name: HumanEval_103_rounded_avg
language: rkt
prompt: "#lang racket\n\n;; You are given two positive integers n and m, and your\
  \ task is to compute the\n;; average of the integers from n through m (including\
  \ n and m). \n;; Round the answer to the nearest integer and convert that to binary.\n\
  ;; If n is greater than m, return -1.\n;; Example:\n;; >>> (rounded_avg 1 5)\n;;\
  \ \"0b11\"\n;; >>> (rounded_avg 7 5)\n;; -1\n;; >>> (rounded_avg 10 20)\n;; \"0b1111\"\
  \n;; >>> (rounded_avg 20 33)\n;; \"0b11010\"\n(define (rounded_avg n m)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rounded_avg))\n\
  \    (check-equal? (candidate 1 5) \"0b11\")\n    (check-equal? (candidate 7 13)\
  \ \"0b1010\")\n    (check-equal? (candidate 964 977) \"0b1111001010\")\n    (check-equal?\
  \ (candidate 996 997) \"0b1111100100\")\n    (check-equal? (candidate 560 851) \"\
  0b1011000010\")\n    (check-equal? (candidate 185 546) \"0b101101110\")\n    (check-equal?\
  \ (candidate 362 496) \"0b110101101\")\n    (check-equal? (candidate 350 902) \"\
  0b1001110010\")\n    (check-equal? (candidate 197 233) \"0b11010111\")\n    (check-equal?\
  \ (candidate 7 5) -1)\n    (check-equal? (candidate 5 1) -1)\n    (check-equal?\
  \ (candidate 5 5) \"0b101\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(> n m) -1]\n    [else (bin (round (/ (+ n m) 2)))]))\n",
  "  (define (sum a b)\n    (if (> a b)\n        -1\n        (+ a (sum (+ a 1) b))))\n\
    \  (let ((div (round (/ (sum n m) (- (+ m 1) n)))))\n    (format \"0b~b\" div)))\n",
  "  (cond\n    [(> n m) -1]\n    [else (define (sum n m) (+ n (if (= n m) 0 (sum\
    \ (+ n 1) m))))\n          (define (average n m) (/ (sum n m) (- m n 1)))\n  \
    \        (define (round n) (round n))\n          (define (int-&gt;binary n) (exact-&gt;inexact\
    \ (round (log n 2))))\n          (bin-&gt;bytes \"0b\" (int-&gt;binary (round\
    \ (average n m))))]))\n", "  (if (< n m)\n      (rounded_avg n m)\n      (binary\
    \ (round (/ (+ n m) 2)))))", "  (cond ((< n m) (round-average n m))\n        ((=\
    \ n m) (round-average n m))\n        (else -1)))\n", "  (if (< n m)\n      (integer->binary\
    \ (round (/ (+ n m) 2)))\n      -1))\n", "  (if (> n m)\n      -1\n      (string->number\
    \ (number->string (round (/ (+ n m) 2.0))) 2)))\n", "  ;; Start with the easy\
    \ cases:\n  (cond ((> n m) -1)\n        ((= n m) (integer->binary n))\n      \
    \  (else\n         ;; else calculate the average and convert that to binary\n\
    \         (let ((avg (/ (+ n m) 2)))\n           (integer->binary avg)))))\n",
  "  (if (< n m)\n      (integer->binary (round (/ (+ n m) 2)))\n      -1))\n", " \
    \ (local ((define (average n m)\n            (if (< n m)\n                (average\
    \ (add1 n) m)\n                n)))\n    (if (> n m)\n        -1\n        (integer->binary\
    \ (round (average n m))))))\n", "  (cond\n    [(> n m) -1]\n    [else (string->number\
    \ (format \"0b~a\" (round (exact->inexact (/ (+ n m) 2)))))]))", "  (cond ((>\
    \ n m) -1)\n        (else (string->number\n               (number->string (round\
    \ (/ (+ n m) 2.0)))\n               2))))", "  ; Your code here\n  )\n", "  (cond\n\
    \    [(> n m) -1]\n    [else\n     (define total (for/sum ([n (in-range n (add1\
    \ m))]) n))\n     (define avg (round (/ total (- (add1 m) n))))\n     (string->symbol\
    \ (string-append \"0b\" (number->string (integer->binary avg))))]))\n", "  (define\
    \ (sum n m)\n    (if (< n m) (add1 (+ n (sum (add1 n) m))) 0))\n  (define (helper\
    \ n m)\n    (if (<= n m) (add1 (helper (add1 n) m)) 0))\n  (if (> n m) -1 (integer->binary\
    \ (round (/ (sum n m) (helper n m))))))\n", "  (if (&gt; n m)\n      -1\n    \
    \  (integer-&gt;string (round (/ (+ n m) 2)) 2)))\n</code>\nI have tested the\
    \ <code>rounded_avg</code> function using the given tests.\nPasting my solution\
    \ into the validation box gives me a 403.\n\n\nA:\n\nI have submitted a solution\
    \ to the kata that passes their validation tests.\n", "  (define (sum n m)\n \
    \   (if (&gt; n m)\n        -1\n        (+ n (sum (+ n 1) m))))\n  (define (avg\
    \ n m)\n    (if (= 0 (modulo (+ n m) 2))\n        (/ (+ n m) 2)\n        (/ (+\
    \ n m) 2)))\n  (cond ((&gt; n m) -1)\n        ((= n m) (integer-&gt;binary n))\n\
    \        (else (integer-&gt;binary (avg n m)))))\n</code>\nI got the following\
    \ results:\n<code>&gt; (rounded_avg 1 5)\n\"0b11\"\n&gt; (rounded_avg 7 5)\n-1\n\
    &gt; (rounded_avg 10 20)\n\"0b1111\"\n&gt; (rounded_avg 20 33)\n\"0b11010\"\n\
    </code>\n", "  (if (> n m)\n      -1\n      (bitwise-arithmetic-shift (round (/\
    \ (+ n m) 2.0)) 1)))", "  (display (integer->binary (round (/ (+ n m) 2))))\n\
    \  )\n", "  (integer->binary (round (average n m))))\n", "  (define (rounded_avg-helper\
    \ n m count sum)\n    (cond\n      [(> n m) -1]\n      [(= n m) (string->number\
    \ (number->string (string->number (number->string sum \"2\") 10)) 2)]\n      [else\
    \ (rounded_avg-helper (+ n 1) m (+ count 1) (+ sum n))]))\n  (define (integer->binary\
    \ n)\n    (cond\n      [(= n 0) \"0b0\"]\n      [else (integer->binary (/ n 2))]))\n\
    \  (string-append (integer->binary (rounded_avg-helper n m 0 0)) (number->string\
    \ (modulo (rounded_avg-helper n m 0 0) 2))))\n", "  (if (> n m)\n      -1\n  \
    \    (inexact->exact (round (/ (+ n m) 2.0)))\n  )\n)\n", "  (let ((n (integer->char\
    \ n))\n        (m (integer->char m)))\n    (char->string n)))\n```\n\n```racket",
  "  (if (< n m)\n      (rounded_avg m n)\n      (if (> n m)\n          -1\n     \
    \     (number->string (average n m 2)))))\n", "    (define (sum lst)\n       \
    \ (if (null? lst)\n            0\n            (+ (car lst) (sum (cdr lst)))))\n\
    \    (define (avg lst)\n        (cond [(< n m) (// (sum lst) (length lst))]\n\
    \              [else -1]))\n    (define (binary n)\n        (cond [(= n 0) \"\
    0b0\"]\n              [(even? n) (string-append (binary (/ n 2)) \"0\")]\n   \
    \           [else (string-append (binary (/ n 2)) \"1\")]))\n    (binary (avg\
    \ (build-list (- m n) add1 n))))\n", "  (cond [(> n m) -1]\n        [else (define\
    \ average (/ (+ n m) 2))\n              (define binary (number->string (string->number\
    \ (integer->binary average)) 2))\n              (string-append \"0b\" binary)]))",
  "  (if (< n m)\n      (integer->binary (round (/ (+ n m) 2)))\n      -1))\n", " \
    \ (define (sum n m)\n    (if (= n m)\n        m\n        (+ n (sum (+ n 1) m))))\n\
    \  (define (average n m)\n    (if (= n m)\n        m\n        (/ (sum n m) (length\
    \ n m))))\n  (define (length n m)\n    (if (= n m)\n        1\n        (+ 1 (length\
    \ (+ n 1) m))))\n  (if (&gt; n m)\n      -1\n      (define (to_binary n)\n   \
    \     (if (= n 0)\n            #\"\"\n            (string-append (if (= (remainder\
    \ n 2) 0)\n                               #\"0\"\n                           \
    \    #\"1\")\n                           (to_binary (quotient n 2)))))\n     \
    \ (string-append \"0b\" (to_binary (round (average n m))))))\n</code>\nI am not\
    \ sure why I am getting the errors, however. Any help would be appreciated.\n\
    <code>Checking rounded_avg...\nrounded_avg: test '1-1' failed\nExpected:\n\"0b0\"\
    \nGot:\n\"0b1\"\nrounded_avg: test '1-2' failed\nExpected:\n\"0b1\"\nGot:\n\"\
    0b11\"\nrounded_avg: test '1-3' failed\nExpected:\n\"0b1\"\nGot:\n\"0b11\"\nrounded_avg:\
    \ test '1-4' failed\nExpected:\n\"0b10\"\nGot:\n\"0b11\"\nrounded_avg: test '1-5'\
    \ failed\nExpected:\n\"0b11\"\nGot:\n\"0b11\"\nrounded_avg: test '1-6' failed\n\
    Expected:\n\"0b11\"\nGot:\n\"0b11\"\nrounded_avg: test '1-7' failed\nExpected:\n\
    \"0b11\"\nGot:\n\"0b11\"\nrounded_avg: test '1-8' failed\nExpected:\n\"0b11\"\n\
    Got:\n\"0b11\"\nrounded_avg: test '1-9' failed\nExpected:\n\"", "  (if (&gt; n\
    \ m)\n      -1\n      (let* ([n-m (+ n m)]\n             [n-m-m n-m]\n       \
    \      [n-m-m-m n-m-m]\n             [n-m-m-m-m n-m-m-m]\n             [n-m-m-m-m-m\
    \ n-m-m-m-m]\n             [n-m-m-m-m-m-m n-m-m-m-m-m]\n             [n-m-m-m-m-m-m-m\
    \ n-m-m-m-m-m-m]\n             [n-m-m-m-m-m-m-m-m n-m-m-m-m-m-m-m]\n         \
    \    [n-m-m-m-m-m-m-m-m-m n-m-m-m-m-m-m-m-m]\n             [n-m-m-m-m-m-m-m-m-m-m\
    \ n-m-m-m-m-m-m-m-m-m]\n             [n-m-m-m-m-m-m-m-m-m-m-m n-m-m-m-m-m-m-m-m-m-m]\n\
    \             [n-m-m-m-m-m-m-m-m-m-m-m-m n-m-m-m-m-m-m-m-m-m-m-m]\n          \
    \   [n-m-m-m-m-m-m-m-m-m-m-m-m-m n-m-m-m-m-m-m-m-m-m-m-m-m]\n             [n-m-m-m-m-m-m-m-m-m-m-m-m-m-m\
    \ n-m-m-m-m-m-m-m-m-m-m-m-m-m]\n             [n-m-m-m-m-m-m-", "  (define total\
    \ 0)\n  (define count 0)\n  (for ([i n])\n        (when (<= i m)\n          (set!\
    \ total (+ total i))\n          (set! count (+ count 1))))\n  (define average\
    \ (quotient total count))\n  (if (< n m)\n      (string->symbol (string-append\
    \ \"0b\" (number->string (exact->inexact (round average)) 2)))\n      -1))\n",
  "  (cond ((> n m) -1)\n        (else (number->string (round (/ (+ n m) 2.0)) 2))))\n",
  "  (cond\n    [(> n m) -1]\n    [else (integer->binary (round (/ (+ n m) 2)))]))\n",
  "  (if (> n m)\n      -1\n      (integer->binary (round (/ (+ n m) 2)))))", "  (cond\
    \ ((> n m) -1)\n        (else (binary-decode\n               (round-to-nearest-integer\n\
    \                (/ (apply + (build-list (+ 1 (- m n)) (lambda (i) (+ n i))))\n\
    \                   (- m n)))))))\n", "  (define sum 0)\n  (define cnt 0)\n  (for\
    \ ((i n)\n        (j m))\n    (if (<= i j)\n        (begin\n          (set! sum\
    \ (+ sum i))\n          (set! cnt (+ cnt 1))\n          (set! i (+ i 1)))))\n\
    \  (if (= cnt 0)\n      -1\n      (string->number (substring (number->string (round\
    \ (/ sum cnt))) 2))))", "  (cond\n    [(> n m) -1]\n    [else (binary-string (round\
    \ (/ (+ n m) 2)))]))\n", "  (if (&gt; n m)\n      -1\n      (integer-&gt;binary\
    \ (round (/ (+ n m) 2)))))\n</code>\n", "  (if (< n m)\n      (if (zero? (modulo\
    \ (+ n m) 2))\n          (number->string (+ n m) 2)\n          (number->string\
    \ (add1 (+ n m)) 2))\n      -1))\n", "  (cond\n    [(> n m) -1]\n    [else (binary_string\
    \ (round (/ (+ n m) 2)))]))\n", "  (cond\n    [(> n m) -1]\n    [else (integer->binary\
    \ (round (/ (+ n m) 2)))]))\n```\n\n# Language setup\n\n1. Install [Racket](https://download.racket-lang.org/)\n\
    2. Run `raco pkg install typed-racket`", "  (if (< n m)\n      (cond\n       \
    \ [(= n m) (number->string (+ n m) 2)]\n        [else (number->string (round (/\
    \ (+ n m) 2)) 2)])\n      (number->string -1 2)))\n", "  (round (/ (+ n m) 2)))\n",
  "  (if (> n m)\n      -1\n      (integer->binary (round (/ (+ n m) 2)))))\n", " \
    \ (cond\n    [(> n m) -1]\n    [else (display (binary (round (average n m))))]))\n",
  '  (display ((/ (apply + (range n m)) (- m n)))))', "  (if (< n m) \n      (let\
    \ ([sum (+ n m)]) \n        (string->symbol \n         (printf \"0b~a\" \n   \
    \              (integer->binary (quotient (round (* 2 sum)) 2)))))\n      -1))",
  "  (round-to-nearst-binary (average-from-n-to-m n m)))\n", "  (if (> n m)\n    \
    \  -1\n      (integer->binary (round (/ (+ n m) 2)))))\n", "  (cond [(> n m) -1]\n\
    \        [else (string->number (format \"0b~a\"\n                            \
    \          (integer->binary (round (/ (+ n m) 2)))))]))\n", "  (define (avg lst)\n\
    \    (define (add a b)\n      (+ a b))\n    (cond ((= (length lst) 1) (car lst))\n\
    \          (else (round (/ (foldl add 0 lst) (length lst))))))\n  (cond ((< n\
    \ m) (string->symbol (string-append \"0b\" (number->string (integer->binary (avg\
    \ (range n m)))))))\n        (else -1)))\n```\n\n## 7. Grains\n\nThere once was\
    \ a wise servant who saved the life of a prince. The king promised to pay whatever\
    \ the servant could dream up. Knowing that the king loved chess, the servant told\
    \ the king he would like to have grains of wheat. One grain on the first square\
    \ of a chess board. Two grains on the next. Four on the third, and so on.\n\n\
    There are 64 squares on a chessboard.\n\nWrite code that shows:\n- how many grains\
    \ were on each square, and\n- the total number of grains\n\nLink: [Grains](https://github.com/dwyl/learn-regex/blob/master/exercises/grains.js)\n\
    \n```racket\n#lang racket\n", "  (define (sum n m)\n    (if (= n m)\n        n\n\
    \        (+ n (sum (+ n 1) m))))\n  (if (> n m)\n      -1\n      (integer->binary\n\
    \       (round (/ (sum n m) (number-of-integers n m))))))\n", "  (define (avg\
    \ n m)\n    (/ (+ n m) 2))\n  (define (avg_rounded n m)\n    (round (avg n m)))\n\
    \  (cond\n    [(> n m)\n     -1]\n    [else\n     (number->string (avg_rounded\
    \ n m) 2)]))", "  (define (avg n m)\n    (if (> n m)\n        -1\n        (/ (+\
    \ n m) 2.0)))\n  (integer->binary (round (avg n m))))\n", "  (define average (/\
    \ (+ n m) 2))\n  (cond ((> n m)\n         (-1))\n        (else\n         (printf\
    \ \"~a\\n\" average)\n         (number->string (integer->char average)))))\n",
  "  (cond\n    [(> n m)\n     -1]\n    [else\n     (define sum (apply + (range n\
    \ m)))\n     (define mean (/ sum (- m n)))\n     (format \"0b~a\" (integer->binary\
    \ mean))]))\n", "  (if (&gt; n m)\n      -1\n      (binary-&gt;string (round (average\
    \ (range n m))))))\n", "  (if (> n m)\n      -1\n      (define sum (+ m (+ (*\
    \ (- m n) (- m n 1)) 2)))\n      (define quotient (quotient sum 2))\n      (define\
    \ remainder (remainder sum 2))\n      (if (= remainder 1)\n          (define rounded\
    \ (add1 quotient))\n          (define rounded quotient))\n      (format \"0b~b\"\
    \ rounded)))", "  (if (> n m)\n      -1\n      (let* ([i m]\n             [total\
    \ 0])\n        (do ([i n (+ i 1)])\n            ((> i m) (/ total (- m n 1)))\n\
    \          (set! total (+ total i))))))\n", "  (cond [(> n m) -1]\n        [else\
    \ (bytes->bstring \n               (integer->bytes (round (/ (+ n m) 2.0))))]))",
  "  (if (< n m)\n      (floor->binary\n       (integer-round\n        (/ (apply +\
    \ (range n m)) (number->string (- m n 1)))))\n      -1))\n", "  (cond\n    [(>\
    \ n m) -1]\n    [else\n     (define-values (q r) (quotient-and-remainder\n   \
    \                        (+ n m)\n                           2))\n     (define\
    \ result (integer->binary q))\n     (if (= r 0)\n         result\n         (string-append\
    \ result \"1\"))]))\n", "  (define (avg_helper n m sum)\n    (if (= n m)\n   \
    \     (round (/ (+ n sum) 2))\n        (avg_helper (+ n 1) m (+ n sum))))\n  (if\
    \ (> n m)\n      -1\n      (binary->string (decimal->binary (avg_helper n m 0)))))\n\
    ```\n\n[Back to Index](../README.md)", "  (define (sum-from-to n m)\n    (cond\
    \ ((> n m) -1)\n          ((= n m) m)\n          (else (+ n (sum-from-to (+ n\
    \ 1) m)))))\n  (define (float->bin n)\n    (cond ((< n 0) -1)\n          ((= n\
    \ 0) \"0b0\")\n          ((= n 1) \"0b1\")\n          (else (string-append (float->bin\
    \ (quotient n 2))\n                               (number->string (remainder n\
    \ 2))))))\n  (define (avg n m)\n    (float->bin (/ (sum-from-to n m)\n       \
    \            (+ 1 (- m n)))))\n  (avg n m))", "    (define x (/ (+ n m) 2))\n\
    \    (cond ((< n m) (number->string (round x) 2))\n          (else -1)))\n", " \
    \ (define (calc-avg n m) (/ (+ n m) 2))\n  (define (bin-avg n m)\n    (if (> n\
    \ m)\n      -1\n      (number->string (calc-avg n m) 2)))\n  (bin-avg n m))\n",
  "  (if (> n m)\n      -1\n      (if (= n m)\n          (integer->binary n)\n   \
    \       (integer->binary (round (/ (+ n m) 2.0))))))\n", "  (define (sum n m)\n\
    \    (if (> n m)\n        0\n        (+ n (sum (+ n 1) m))))\n  (define (avg x\
    \ y)\n    (quotient (sum x y) (- (+ x y) (- x y))))\n  (define (average-to-bin\
    \ x)\n    (define (bin-help x)\n      (cond ((= x 0) (list 0))\n            ((=\
    \ x 1) (list 1))\n            (else (append (bin-help (quotient x 2)) (list (remainder\
    \ x 2))))))\n    (cond ((&gt; n m)\n           -1)\n          ((&lt; n m)\n  \
    \         (string-append \"0b\" (bytes-&gt;string/utf-8 (list-&gt;bytes (bin-help\
    \ x))))))))\n", "  (cond\n    [(> n m) -1]\n    [else\n     (define sum (+ n m))\n\
    \     (define div (quotient sum 2))\n     (if (odd? sum)\n         (string->symbol\
    \ (string-append \"#b\" (number->string (quotient (1+ div) 2))))\n         (string->symbol\
    \ (string-append \"#b\" (number->string div))))]))\n", "  (if (&gt; n m)\n   \
    \   -1\n      (bitwise-or (bitwise-arithmetic-shift-left 1 (quotient (+ n m) 2))\n\
    \                  (bitwise-bit-set? (remainder (+ n m) 2) 0))))\n</code>\n",
  "  (if (> n m)\n      -1\n      (number->string (fxround (/ (+ n m) 2)) 2)))", " \
    \ (if (< n m)\n      (define avgnm (/ (+ n m) 2))\n      avgnm\n      (define\
    \ avgnm -1))\n  (number->string (inexact->exact (round avgnm)) 2))\n", "  (define\
    \ (sum n m)\n    (if (> n m)\n        0\n        (+ n (sum (+ n 1) m))))\n  (define\
    \ (ceil_by_2 n)\n    (if (= 1 (remainder n 2))\n        n\n        (+ n 1)))\n\
    \  (define (floor_by_2 n)\n    (if (= 1 (remainder n 2))\n        (- n 1)\n  \
    \      n))\n  (define (rounded_avg_helper n m)\n    (if (> n m)\n        -1\n\
    \        (let ((sum (+ n m)))\n          (binary (ceil_by_2 (/ sum 2))))))\n \
    \ (rounded_avg_helper n m))\n", "  (cond\n    [(> n m) -1]\n    [else (string->number\
    \ (number->string (integer->char (round (/ (+ n m) 2)))) 2)]))\n", "  (if (< n\
    \ m)\n      (build-bit-vector \n       (average\n        (map (lambda (x) (exact->inexact\
    \ (string->number x 2)))\n             (range n m))))\n      -1))\n", "  (cond\n\
    \    [(> n m) -1]\n    [else\n     (string->symbol (format \"0b~a\" (integer->binary\
    \ (round (/ (+ n m) 2)))))]))", "  (display (binary (round (average n m))))\n\
    \  )\n", "  (if (> n m)\n      -1\n      (let ([avg (/ (+ n m) 2.0)])\n      \
    \  (string->number (string-append \"0b\" (number->string (round avg)))))))\n",
  "  (define (avg n m)\n    (cond ((> n m) (-1))\n          (else (/ (+ n m) 2.0))))\n\
    \  (define (avg-str x)\n    (if (= x -1)\n        -1\n        (let ([bin-str (bytes->string/utf-8\
    \ (integer->bytes (floor x) #:big-endian? #t))])\n          (string-append \"\
    0b\" bin-str))))\n  (avg-str (avg n m)))\n```\n\nor with Racket's `exact->inexact`\
    \ function:\n\n```racket\n#lang racket\n", "  (cond\n    [(> n m) -1]\n    [else\
    \ (number->string (round (/ (+ n m) 2)) 2)]))\n", "  (cond ((> n m) -1)\n    \
    \    (else (integer->binary (inexact->exact (round (/ (+ n m) 2)))))))\n", " \
    \ (cond\n    [(> n m) -1]\n    [else\n     (format \"0b~a\" (number->string (round\
    \ (/ (+ n m) 2)) 2))]))\n", "  (if (&gt; n m)\n      -1\n      (define sum 0)\n\
    \      (for ([i (in-range n (+ m 1))])\n        (set! sum (+ sum i)))\n      (integer-&gt;binary\
    \ (round (/ sum (- m n 1))))))\n</code>\nIs there a more elegant way to get the\
    \ average value of the range? <code>sum</code> is unnecessary but I couldn't figure\
    \ out how to do <code>(+ i ...)</code> without it.\nIs there a better way to get\
    \ the number of elements in the range? I know there's <code>length</code> but\
    \ <code>length</code> is only for lists.\nIs there a more idiomatic way to get\
    \ the binary representation of an integer? I found <code>integer-&gt;binary</code>\
    \ after a while of searching, but I had to use <code>round</code> because <code>integer-&gt;binary</code>\
    \ wanted an integer, not a floating point.\n\n\nA:\n\nThere's no reason to compute\
    \ the whole sum if you only need the average. You could write:\n<code>(define\
    \ (rounded-avg n m)\n  (if (&gt; n m)\n      -1\n      (integer-&gt;binary (round\
    \ (/ (+ n m) 2)))))\n</code>\nIf you need the number of elements in a range, the\
    \ easy way is to use <code>for/sum</code>:\n<code>(for/sum ([i (in-range n (+\
    \ m 1))]) 1)\n</code>\nBut there's an easier way: it's just <code>m - n + 1</code>.\
    \ So you could also write:\n<code>(define (rounded-avg n m)\n  (if (&gt; n m)\n\
    \      -1\n      (integer-&gt;binary (round (/ (+ n m) (1+ (- m n)))))))\n</code>\n\
    As for the average, you could do something like:\n<code>(define (rounded-avg n\
    \ m)\n  (if (&gt; n m)\n      -1\n      (integer-&gt;binary (round (/ (for/sum\
    \ ([i (in-range n (+ m 1))]) i) (1+ (- m", "  (cond\n    [(> n m) -1]\n    [else\n\
    \     (define sum 0)\n     (for ([i (in-range n m)])\n       (set! sum (+ sum\
    \ i)))\n     (format \"0b~a\" (inexact->exact (round (/ sum (- m n 1)))))\n  \
    \   ]))\n", "  (define (avg-loop total count)\n    (cond [(> n m) (quotient (round\
    \ (/ total count)) 2)]\n          [else (avg-loop (+ total n) (+ count 1))]))\n\
    \  (avg-loop (+ n m) 2))\n", "  (define (avg list)\n    (if (null? list)\n   \
    \   0\n      (/ (apply + list) (length list))))\n  (define (dec2bin x)\n    (if\
    \ (= x 0)\n      \"\"\n      (string-append (dec2bin (quotient x 2)) (number->string\
    \ (remainder x 2)))))\n  (define (results n m)\n    (if (and (and (integer? n)\
    \ (integer? m))\n             (and (> n 0) (> m 0))\n             (>= n m))\n\
    \      (begin\n        (round (avg (build-list m (+ 1 n) (lambda (x) x))))\n \
    \       (dec2bin (round (avg (build-list m (+ 1 n) (lambda (x) x))))))\n     \
    \ -1))\n  (results n m))", "  (let ([sum (exact->inexact (+ n m))])\n    (cond\
    \ [(< n m) (string->number (number->string (+ n m 2) 2))]\n          [else -1])))",
  "  (if (< n m)\n      (let ([avg (round (/ (+ n m) 2.0))])\n        (format \"0b~a\"\
    \ avg))\n      -1))\n", "  (when (and (number? n) (number? m))\n    (let* ((sum\
    \ (+ n m))\n           (avg (quotient sum 2)))\n      (cond ((> n m) -1)\n   \
    \         ((odd? sum) (string-append #\"0b\" (number->string (round avg))))\n\
    \            (else (string-append #\"0b\" (number->string avg)))))))", "  (define\
    \ (rounded_avg_iter x a m)\n    (if (&gt; x m)\n        (display (inexact-&gt;exact\
    \ (/ a (- x m))))\n        (rounded_avg_iter (+ x 1) (+ a x) m)))\n  (if (&gt;\
    \ n m)\n      -1\n      (rounded_avg_iter n n m)))\n", "  (cond\n    [(> n m)\
    \ -1]\n    [else (average-to-bin n m)]))\n", "  (if (&gt; n m)\n      -1\n   \
    \   (integer-&gt;binary (round (/ (+ n m) 2)))))\n</code>\nTest:\n<code>#lang\
    \ racket\n", "  (display (binary (avg_rounded n m)))\n  \"0b\"\n  (display (binary\
    \ (avg_rounded n m)))\n)\n", "  (if (< n m)\n      (integer->binary (inexact->exact\
    \ (round (/ (+ n m) 2))))\n      -1))\n", "  (cond\n    [(> n m) -1]\n    [else\
    \ (format \"0b~a\" (string->number\n                         (number->string\n\
    \                          (round (/ (+ n m) 2))\n                          2)))]))\n",
  "  (if (< n m)\n      (number->string (round (/ (+ n m) 2)) 2)\n      -1))\n", " \
    \ (cond\n    [(> n m) -1]\n    [else (vector->string (integer->binary-string (round\
    \ (/ (+ n m) 2))))]))\n", "  (cond\n    [(< n m) (integer->binary (round (/ (+\
    \ n m) 2.0)))]\n    [else -1]))\n", "  ;; your code here\n  )\n  ```\n  - Approach\
    \ 1:\n    1. (define (rounded_avg n m)\n        (cond [(> n m) -1]\n         \
    \     [else (number->string (round (/ (+ n m) 2)) 2)]))\n    2. (define (rounded_avg\
    \ n m)\n        (cond [(> n m) -1]\n              [else (number->string (round\
    \ (/ (+ n m) 2)) 2)]))\n    3. (define (rounded_avg n m)\n        (cond [(> n\
    \ m) -1]\n              [else (number->string (round (/ (+ n m) 2)) 2)]))\n  -\
    \ Approach 2:\n    1. (define (rounded_avg n m)\n        (cond [(> n m) -1]\n\
    \              [else (format \"0b~a\" (string->number (number->string (round (/\
    \ (+ n m) 2)) 2)))]))\n    2. (define (rounded_avg n m)\n        (cond [(> n m)\
    \ -1]\n              [else (format \"0b~a\" (string->number (number->string (round\
    \ (/ (+ n m) 2)) 2)))]))\n    3. (define (rounded_avg n m)\n        (cond [(>\
    \ n m) -1]\n              [else (format \"0b~a\" (string->number (number->string\
    \ (round (/ (+ n m) 2)) 2)))]))\n  - Approach 3:\n    1. (define (rounded_avg\
    \ n m)\n        (cond [(> n m) -1]\n              [else (format \"0b~a\" (string->number\
    \ (number->string (round (/ (+ n m) 2)) 2)))]))\n    2. (define (rounded_avg n\
    \ m)\n        (cond [(> n m) -1]\n              [else (format \"0b~a\" (string->number\
    \ (number->string (round (/ (+ n m) 2)) 2)))]))\n    3. (define (rounded_avg n\
    \ m)\n        (cond [(> n m) -1]\n              [else (format \"0b~a\" (string->number\
    \ (number->string (round", "  (if (&gt; n m)\n      -1\n      (bitwise-arithmetic-shift\
    \ (round (/ (+ n m) 2.0))\n                                -1)))\n</code>\n",
  "  (if (> n m)\n      -1\n      (let ((average (/ (+ n m) 2)))\n        (string->symbol\
    \ (string-append \"0b\" (number->string (integer->binary average)))))))\n", " \
    \ (let\n    ([avg (round (/ (+ n m) 2.0))])\n    (if (> m n)\n      (format \"\
    0b~x\" avg)\n      -1)))\n", "  (define sum 0)\n  (define count 0)\n  (for ([i\
    \ n])\n    (when (<= i m)\n      (set! sum (+ sum i))\n      (set! count (+ count\
    \ 1))))\n  (cond [(< n m)\n          (string->symbol (format \"0b~a\" (number->string\
    \ (inexact->exact (round (/ sum count))))))]\n        [else -1]))", "  (define\
    \ (sum n m)\n    (if (> n m)\n        0\n        (+ n (sum (+ n 1) m))))\n  (define\
    \ (average n m)\n    (round (/ (sum n m) (- m n))))\n  (if (> n m)\n      -1\n\
    \      (integer->string (average n m) 2)))\n", "  (if (< n m)\n      (number->string\
    \ (round (/ (+ n m) 2.0)) 2)\n      -1))\n", "  (if (> n m) -1\n      (string->number\
    \ (number->string (average n m)) 2)))\n", "  (let ([total 0]\n        [count 0])\n\
    \    (for ([i (in-range n m)]\n          #:when (even? i))\n      (set! total\
    \ (+ total i))\n      (set! count (+ count 1)))\n    (if (= count 0)\n       \
    \ -1\n        (define res (floor (/ total count)))\n        (bytes->string/utf-8\
    \ (integer->bytes res #:radix 2)))))", "  (if (&gt; n m) -1\n      (string-&gt;number\
    \ (string-append \"#b\"\n                                      (number-&gt;string\n\
    \                                       (round (apply + (map (\u03BB (x) x) (range\
    \ n (+ m 1))))\n                                              (/ (length (range\
    \ n (+ m 1))) 2)))))))\n</code>\nIt seems to me that it is quite slow, about 4\
    \ seconds for the average number <code>n=1000000, m=2000000</code>. It is clear\
    \ that I just didn't get how to use <code>range</code> properly. \nI tried the\
    \ following way, but it returns a wrong answer:\n<code>(define (rounded_avg n\
    \ m)\n  (if (&gt; n m) -1\n      (string-&gt;number (string-append \"#b\"\n  \
    \                                    (number-&gt;string\n                    \
    \                   (round (apply + (map (\u03BB (x) x) (range n (+ m 1))))\n\
    \                                              (/ (length (range n (+ m 1))) 2)))))))\n\
    </code>\nThe second one seems to be more naive approach. How can I do it better?\n\
    \n\nA:\n\nYou can make this a bit faster by using the <code>exact-integer-sqrt</code>\
    \ procedure from <code>math/number-theory</code> to compute the average without\
    \ computing the sum of the values first. You can also make it run faster by replacing\
    \ the use of <code>range</code> by the <code>iota</code> procedure. You can also\
    \ remove the call to <code>map</code> since <code>iota</code> will return a list\
    \ of integers so the <code>lambda</code> is not doing anything. Finally, the call\
    \ to <code>length</code> can be replaced by just subtracting <code>n</code> from\
    \ <code>m</code> (this will also be faster because <code>length</code> has to\
    \ traverse the list).\n<code>(require math/number-theory)\n", "  (cond\n    [(>\
    \ n m) -1]\n    [else (binary-decode (round (/ (+ n m) 2)))]))\n", "  (define\
    \ (rounded_avg_iter sum n m)\n    (if (&gt; n m) sum (rounded_avg_iter (+ sum\
    \ n) (+ n 1) m)))\n  (cond ((&gt; n m) -1)\n        (else (string-append \"0b\"\
    \ (number-&gt;string (round (rounded_avg_iter 0 n m) (/ (+ m n) 2)))))))\n</code>\n\
    The problem is <code>(/ (+ m n) 2)</code> is not in most cases the average of\
    \ two numbers, because it is not floored. I know I could use <code>(floor (/ (+\
    \ m n) 2))</code> but I want to round.\n\n\nA:\n\nThe problem is that <code>/</code>\
    \ returns a rational number, not a real number. To round a rational number, you\
    \ should use <code>round/</code>.\n", "  ;; round down and round up\n  (define\
    \ n-str (number->string (floor (/ (+ n m) 2))))\n  (define m-str (number->string\
    \ (ceiling (/ (+ n m) 2))))\n  (cond\n    [(> n m) \"BAD_INPUT\"]\n    [(not (=\
    \ (string-length n-str) (string-length m-str))) \"BAD_INPUT\"]\n    [else (string->number\
    \ (string-append \"0b\" n-str) 2)]))\n", "  (if (&gt; n m)\n      -1\n      (number-&gt;string\
    \ (inexact-&gt;exact (round (/ (+ n m) 2.0))) 2)))\n</code>\nThe solution works,\
    \ but I feel like there are probably better ways to do this. Any thoughts on how\
    \ I could improve the solution?\n\n\nA:\n\nYour solution is correct, but I would\
    \ have written it differently.\nI'd have used a local <code>define</code> to define\
    \ the <code>average</code> procedure, and moved the check that <code>n</code>\
    \ is less than or equal to <code>m</code> inside of it, since it's a <code>require</code>\
    \ that <code>average</code> checks. That would make the procedure more general,\
    \ e.g. the caller could use <code>average</code> to return <code>#f</code> when\
    \ <code>n</code> is greater than <code>m</code> and a real answer otherwise.\n\
    <code>(define (rounded_avg n m)\n  (define (average n m)\n    (unless (&lt;= n\
    \ m) (error \"n must be less than or equal to m\"))\n    (round (/ (+ n m) 2.0)))\n\
    \  (if (&gt; n m)\n      -1\n      (number-&gt;string (inexact-&gt;exact (average\
    \ n m)) 2)))\n</code>\nI would also check that the arguments are integers, and\
    \ perhaps check that they are positive as well. Otherwise, you'll get <code>number-&gt;string:\
    \ no exact representation for 0b10.5</code> or similar.\n<code>(define (rounded_avg\
    \ n m)\n  (define (check-int n)\n    (unless (integer? n) (error \"must be an\
    \ integer\" n)))\n  (define (average n m)\n    (check-int n)\n    (check-int m)\n\
    \    (unless (&lt;= n m) (error \"n must be less than or equal to m\"))\n    (round\
    \ (/ (+ n m) 2.0)))\n  (if (&gt; n m)\n      -1\n      (number-&gt;string (",
  "  ;;;;;;;;;; YOUR CODE GOES HERE\n)\n", "  (if (&gt; n m) -1\n      (byte-&gt;string\
    \ (round (average (list-&gt;set (range n m)))))))\n", "  (if (&gt; n m)\n    \
    \  -1\n      (integer-&gt;binary (round (/ (+ n m) 2)))))\n", "  (define (avg\
    \ x y)\n    (if (&gt; x y)\n        -1\n        (/ (+ x y) 2)))\n  (define (round\
    \ n)\n    (if (equal? (floor n) n)\n        n\n        (ceiling n)))\n  (define\
    \ (to_binary n)\n    (if (equal? n 0)\n        \"\"\n        (to_binary (quotient\
    \ n 2))\n        (integer-&gt;char (+ #x30 (remainder n 2)))))\n  (string-append\
    \ \"0b\" (to_binary (round (avg n m)))))\n</code>\nWhen running this I get the\
    \ error \"expects type <code>&lt;procedure&gt;</code> as 1st argument, given:\
    \ #; in: 1\"\n\n\nA:\n\nThe problem is that for some reason you have written a\
    \ badly indented piece of code, where the <code>if</code> expression is incomplete,\
    \ and the <code>to_binary</code> expression is executed with a wrong number of\
    \ arguments. All the errors you have mentioned are caused by this mistake.\nYou\
    \ have the following:\n<code>(define (to_binary n)\n  (if (equal? n 0)\n     \
    \ \"\"\n      (to_binary (quotient n 2))\n      (integer-&gt;char (+ #x30 (remainder\
    \ n 2)))))\n</code>\nBut it should be:\n<code>(define (to_binary n)\n  (if (equal?\
    \ n 0)\n      \"\"\n      (string-append (to_binary (quotient n 2))\n        \
    \             (integer-&gt;char (+ #x30 (remainder n 2))))))\n</code>\nNotice\
    \ that the <code>string-append</code> expression is part of the <code>if</code>'s\
    \ <code>else</code> branch.\nNow the program works and produces the expected results:\n\
    <code>(rounded_avg 1 5)\n=&gt; \"0b11\"", "  (define (sum n m)\n    (if (= n m)\n\
    \        m\n        (+ n (sum (+ n 1) m))))\n  (define (sum-to-m n m)\n    (cond\n\
    \      [(> n m) \"0b-1\"]\n      [(= n m) (number->string (integer->char '0b')\
    \ (number->string (int-to-fixnum (sum n m)) (number->string (integer->char '/')\
    \ (number->string (int-to-fixnum (abs (- m n))) \"\"))))]\n      [else (number->string\
    \ (integer->char '0b') (number->string (int-to-fixnum (sum n m)) (number->string\
    \ (integer->char '/') (number->string (int-to-fixnum (abs (- m n))) \"\"))))]))\n\
    \  (sum-to-m n m))", "  (cond ((< n m) (format \"0b~a\" (decimal->binary (round\
    \ (/ (+ n m) 2)))))\n        (else -1)))\n```\n\n### Snail sort\n\n```#lang racket\n",
  "  (cond\n    [(> n m) -1]\n    [else\n     (define sum (+ n m))\n     (cond\n \
    \      [(= sum 2) 1]\n       [else (define sum (+ sum (rounded_avg (+ n 1) (-\
    \ m 1))))]\n       )\n     (display (number->string (quotient sum 2)))\n     (display\
    \ \"b\")\n     (display (integer->binary (quotient sum 2)))\n     ]\n    )\n \
    \ )\n", "  (cond\n    [(> n m) -1]\n    [else\n     (let* ([sum (+ n m)]\n   \
    \         [sum-n (integer->binary (/ sum 2))])\n       (if (= (remainder sum 2)\
    \ 0)\n           sum-n\n           (string-append sum-n \"1\")))]))", "  (if (&gt;\
    \ n m)\n      -1\n      (let* ([arr (range n m)]\n             [avg (/ (apply\
    \ + arr) (length arr))]\n             [binary (number-&gt;string (round avg) 2)])\n\
    \        (string-append \"0b\" binary))))\n</code>\n\n<code>#lang racket\n", " \
    \ (if (< n m) \n      (define average (/ (+ n m) 2))\n      (display \"ERROR!\
    \ The first number must be less than the second number\")\n      -1)\n  (integer->binary\
    \ average))\n", "    (cond [(< n m) (list->string (append (list #\\0 #\\b) (integer->binary\
    \ (round (/ (+ n m) 2))))) ]\n          [else -1]))", "  (if (> n m) -1\n    \
    \  (let ((sum (+ n m))\n            (count 2))\n        (if (and (even? n) (even?\
    \ m))\n            (for ([i (in-range (+ n 2) (- m 2) 2)])\n              (set!\
    \ sum (+ sum i))\n              (set! count (+ count 1)))\n            (for ([i\
    \ (in-range (+ n 3) (- m 3) 2)])\n              (set! sum (+ sum i))\n       \
    \       (set! count (+ count 1))))\n        (integer->binary (round (/ sum count))))))\n",
  "  (cond [(> n m) -1]\n        [else\n         (define sum (/ (+ n m) 2))\n    \
    \     (string->number (string-append \"0b\" (number->string sum)))\n         ]))\n",
  "  (if (> n m) -1\n      (integer->binary\n       (round (real-part (/ (+ n m) 2))))))\n",
  "  (if (&gt; n m) -1\n      (number-&gt;string (round (average-round (list n m))))))\n",
  "  (define (average n m)\n    (if (= n m)\n        n\n        (/ (+ n m) 2)))\n\
    \  (if (< n m)\n      (integer->binary (round (average n m)))\n      -1))", " \
    \ (cond\n    [(> n m) -1]\n    [else (number->string (round (/ (+ n m) 2)) 2)]))\n",
  "  (if (> n m)\n      -1\n      (string->number (number->string (round (/ (+ n m)\
    \ 2))) 2)))\n", "  (if (> n m)\n      -1\n      (integer->binary \n       (round\
    \ (/ (+ n m) 2.0)))))\n", "  (if (&gt; n m)\n      -1\n      (let ([x (if (even?\
    \ (+ n m))\n                   (quotient (+ n m) 2)\n                   (quotient\
    \ (+ 1 (+ n m)) 2))])\n        (string-append \"0b\" (integer-&gt;binary x)))))\n\
    </code>\n", "  (if (> n m)\n      -1\n      (let ([sum (+ n m)])\n        (string->symbol\
    \ (string-append \"0b\" (number->string (round (/ sum 2))))))))\n", "  (if (&gt;\
    \ n m) -1\n      (string-&gt;number (number-&gt;string (round (/ (+ n m) 2.0)))\
    \ 2)))\n</code>\n", "  (if (< n m)\n      (let ([sum (for/sum ([i (in-range n\
    \ (add1 m))]) i)])\n        (integer->binary (round (/ sum (- (add1 m) n)))))\n\
    \      -1))\n", "  (if (> n m)\n      -1\n      (integer->binary (round (/ (+\
    \ n m) 2)))))", "  (if (< n m)\n      (integer->binary (round (/ (+ n m) 2)))\n\
    \      -1))\n", "  (let ((total (+ n m))\n        (length 2))\n    (if (> n m)\
    \ -1\n        (cond ((even? total) (number->string (/ total length) 2))\n    \
    \          (else (number->string (/ (+ total 1) length) 2))))))\n", "  (if (<\
    \ n m)\n      (if (odd? (/ (+ n m) 2))\n          (number->string (+ n m) 2)\n\
    \          (number->string (+ n m 1) 2))\n      -1))\n", "  (unless (or (not (integer?\
    \ n)) (not (integer? m)))\n    (integer->binary (round (/ (+ n m) 2.0)))))\n```\n\
    \n## Check Sum of Consecutive Prime Numbers\n``` #lang racket\n", "  (cond ((&gt;\
    \ n m) -1)\n        (else (binary-&gt;number (number-&gt;string (round (/ (+ n\
    \ m) 2)) 2)))))\n", "  (cond\n    [(> n m) -1]\n    [else\n     (define sum 0)\n\
    \     (for ([i (in-range n m)])\n       (set! sum (+ sum i)))\n     (bin->string\
    \ (round (/ sum (- m n))))]))\n", "  (define (avg n m)\n    (quotient (+ n m)\
    \ 2))\n  (if (> n m)\n      -1\n      (integer->binary (round (avg n m)))))\n",
  "  ;(round (/ (+ n m) 2))\n  (let ((sum 0))\n    (for ([i (in-range n (+ m 1))])\n\
    \      (set! sum (+ sum i)))\n    (define avg (round (/ sum (- (+ m 1) n))))\n\
    \    (define avg-string (string->list (number->string avg)))\n    (list->string\
    \ (cons #\\0 (cons #\\b (cons (char->integer (first avg-string)) '())))))\n  )\n",
  "  (let ((sum 0)\n        (avg 0))\n    (cond\n      [(> n m) -1]\n      [else (for/sum\
    \ ([i (- n m)])\n              (add1 sum i))])))\n</code>\nI'm sure I'm missing\
    \ something simple and stupid, but I can't see what.\n\n\nA:\n\nYou're not using\
    \ <code>for/sum</code> correctly. The first argument to <code>for/sum</code> is\
    \ supposed to be a binding spec. You have <code>- n m</code> instead, which is\
    \ an expression.\nYou should change that to <code>[i (in-range n (add1 m))]</code>.\
    \ This uses the <code>range</code> function to create a sequence of numbers, and\
    \ the <code>in-range</code> form to create a binding spec that binds <code>i</code>\
    \ to each number in the sequence.\n\nAlso, it's not clear why you're using <code>for/sum</code>\
    \ at all. It's only necessary if you're actually trying to sum up a bunch of terms,\
    \ which you're not doing.\nIf you want to just iterate over a range of numbers,\
    \ then I would use <code>for/sum</code>, but I would use the <code>collect</code>\
    \ transformation:\n<code>(for/sum ([i (in-range n (add1 m))]) i)\n</code>\nThis\
    \ has the advantage of making the loop body (the part after <code>-&gt;</code>)\
    \ simpler to read.\n", "  (define (sum_range n m)\n    (if (> n m)\n        (-1)\n\
    \        (+ n (sum_range (+ n 1) m))))\n  (define (int->bin x)\n    (cond [(zero?\
    \ x) \"0b0\"]\n          [(= x 1) \"0b1\"]\n          [else (cons #\\1 (int->bin\
    \ (sub1 x)))]))\n  (define (avg n m)\n    (let ((sum (sum_range n m)))\n     \
    \ (if (= sum -1)\n          -1\n          (int->bin (/ sum (- m n))))))\n  (avg\
    \ n m))\n", "  (cond\n    [(> n m) -1]\n    [else (bitwise-arithmetic-shift (round\
    \ (/ (+ n m) 2)) -1)]))", "  (if (&gt; n m)\n      -1\n      (let ([total 0]\n\
    \            [cnt 0])\n        (for ([i (in-range n (+ m 1))])\n          (set!\
    \ total (+ total i))\n          (set! cnt (+ cnt 1)))\n        (define (to-binary\
    \ n)\n          (cond \n            [(= n 0) \"\"]\n            [(= (remainder\
    \ n 2) 0) (string-append (to-binary (/ n 2)) \"0\")]\n            [else (string-append\
    \ (to-binary (/ n 2)) \"1\")]))\n        (string-append \"0b\" (to-binary (round\
    \ (/ total cnt)))))))\n", "  (let ([sum (+ n m)])\n    (if (> n m)\n        -1\n\
    \        (string->number (number->string (/ sum 2)) 2))))\n", "  (cond [(> n m)\
    \ -1]\n        [else (build-bits (byte-to-bits (quotient (+ n m) 2)))]))\n", " \
    \ (if (> n m) -1\n    (define (binary num) (integer->binary (round num)))\n  \
    \  (binary (/ (+ n m) 2))))", "  (if (&gt; n m)\n      -1\n      (number-&gt;string\n\
    \       (round (/ (apply + (build-list (- m n) (lambda (x) (+ n x)))) (- m n 1)))\n\
    \       2)))\n</code>\nIt works for the first 3 examples, but fails for the last\
    \ one.\nExample:\n<code>&gt; (rounded_avg 20 33)\n\"0b11011\"\n</code>\nThe answer\
    \ should be \"0b11010\".\n\nWhat is wrong?\nHow can I fix it?\n\n\n\nA:\n\nThe\
    \ problem is that the rounding is being done in decimal.  (Rounding is a function\
    \ of the base, so it should be done in the base being used.  If you round in decimal,\
    \ some numbers have multiple possibilities for the binary result.)\nSince the\
    \ base is specified in the call to <code>number-&gt;string</code>, the rounding\
    \ should be done in binary.  From the docs:\n<blockquote>\n<p>If <code>&lt;code&gt;radix&lt;/code&gt;</code>\
    \ is given, then <code>&lt;code&gt;x&lt;/code&gt;</code> is interpreted in base\
    \ <code>&lt;code&gt;radix&lt;/code&gt;</code>, which must be an integer between\
    \ 2 and 36, inclusive.  The result is a string whose characters are digits from\
    \ 0 to 9 and lowercase letters from a to z.</p>\n</blockquote>\nTo round in binary,\
    \ first, calculate the average as in the original problem, then check whether\
    \ the number after the decimal point is >= 1/2.  (This is the same as checking\
    \ whether the truncated average is even.)  If it is, add 1.  If it isn't, don't\
    \ add anything.\n<code>(define (rounded_avg n m)\n  (if (&gt; n m)\n      -1\n\
    \      (let* ([avg (/ (apply + (build-list (- m n) (lambda (x) (+ n x)))) (- m\
    \ n 1))]\n             [avg-truncated (truncate avg)])\n        (if (even? avg-truncated)\n\
    \            (", "  (define (avg a b)\n    (/ (+ a b) 2))\n  (define (rounded-avg\
    \ a b)\n    (round (avg a b)))\n  (define (int-to-bin n)\n    (define (inner n\
    \ acc)\n      (if (= n 0)\n          acc\n          (inner (quotient n 2) (cons\
    \ (remainder n 2) acc))))\n    (string-append \"0b\" (list->string (reverse (inner\
    \ n '())))))\n  (if (> n m)\n      -1\n      (int-to-bin (rounded-avg n m))))",
  "  (if (&gt; n m) -1\n      (byte-&gt;bin (round (/ (+ n m) 2.0)))))\n</code>\n\
    Racket also offers a way to make this a little prettier by having you define a\
    \ function for the desired precision.\n<code>#lang racket\n", "  (cond\n    [(>\
    \ n m) -1]\n    [else (-> n m \n\t      (range)\n\t      (apply +)\n\t      (/\
    \ (count n m))\n\t      (round)\n\t      (integer->binary))]))\n", "  (if (> n\
    \ m)\n      -1\n      (integer->binary (round (/ (+ n m) 2)))))\n", "  (if (&gt;\
    \ n m)\n      -1\n      (integer-&gt;binary (round (/ (+ n m) 2)))))\n</code>\n\
    I'm using a 3rd party function integer->binary which converts an integer to a\
    \ binary string.\n\n\nA:\n\nCode format\nHere's a fairly minor thing, but I think\
    \ you should be consistent with your use of whitespace. You have a space after\
    \ your <code>if</code> and the parentheses around the condition, but there's none\
    \ before the opening parenthesis of the <code>if</code> body. I would go with:\n\
    <code>(if (&gt; n m)\n    -1\n    (integer-&gt;binary (round (/ (+ n m) 2))))\n\
    </code>\nor\n<code>(if (&gt; n m)\n    -1\n    (integer-&gt;binary (round (/ (+\
    \ n m) 2))))\n</code>\nor similar, rather than mixing the styles.\nUse appropriate\
    \ procedures\nThis function only does arithmetic, so I would make the <code>integer-&gt;binary</code>\
    \ call inside the <code>if</code> body optional. If the user doesn't want it,\
    \ he can call <code>rounded-avg</code> and omit the <code>integer-&gt;binary</code>\
    \ call. If he needs it, he can write it himself.\n<code>(define (rounded-avg n\
    \ m)\n  (if (&gt; n m)\n      -1\n      (round (/ (+ n m) 2))))\n</code>\nAccuracy\n\
    The <code>/</code> function in Racket returns a floating point number.\n<code>(/\
    \ 9 2)", "  (if (&gt; n m)\n      -1\n      (number-&gt;string (inexact-&gt;exact\
    \ (/ (+ n m) 2)) 2)))\n", "  (if (> n m)\n      -1\n      (define (sum a b) (+\
    \ a b))\n      (string->number (number->string (round (/ (foldr sum 0 (range n\
    \ m))\n                                               (- m n))))\n           \
    \           2)))", "  (define (aux n m acc)\n    (if (> n m)\n        (-1)\n \
    \       (if (= n m)\n            (exact->inexact (round (quotient (+ n acc) (+\
    \ 1 acc))))\n            (aux (+ n 1) m (+ n acc)))))\n  (let ([result (aux n\
    \ m 0)])\n    (if (= result -1)\n        result\n        (string->symbol (string-append\
    \ \"0b\" (number->string (inexact->exact (round result))))))))\n", "  (if (&gt;\
    \ n m)\n      -1\n      (bitwise-or (bitwise-shift-left 1 (quotient (+ (- n 1)\
    \ m) 2)))))\n</code>\nTest:\n<code>&gt; (rounded_avg 1 5)\n\"0b11\"\n&gt; (rounded_avg\
    \ 7 5)\n-1\n&gt; (rounded_avg 10 20)\n\"0b1111\"\n&gt; (rounded_avg 20 33)\n\"\
    0b11010\"\n</code>\n", "  (if (&gt; n m)\n      -1\n      (number-&gt;string (inexact-&gt;exact\
    \ (round (/ (+ n m) 2.0))) 2)))\n</code>\nI hope that gives you a good start on\
    \ your own solution.\n", "  (cond ((> n m) -1)\n        (else (exact->inexact\
    \ (/ (+ n m) 2)))))", "  (cond [(> n m) -1]\n        [else \n         (let* ([sum\
    \ (+ n m)] \n                [avg (/ sum 2)]\n                [bin (number->string\
    \ (inexact->exact (floor (/ sum 2))) 2)])\n           (string-append \"0b\" bin))]))",
  "  (define (sum-ints n m)\n    (if (> n m) 0\n        (+ n (sum-ints (+ n 1) m))))\n\
    \  (define (average n m)\n    (integer->char (round (/ (sum-ints n m) (- m n)))))\n\
    \  (cond [(> n m) -1]\n        [else (format \"0b~a\" (average n m))]))\n", " \
    \ (if (> n m)\n      -1\n      (let* ([avg (/ (+ n m) 2)]\n             [avg-rounded\
    \ (round avg)]\n             [avg-binary (number->string avg-rounded 2)])\n  \
    \      (string-append \"0b\" avg-binary))))", "  (define (helper n m)\n    (cond\
    \ ((<= n m) (cons n (helper (+ n 1) m)))\n          (else '())))\n  (define (average\
    \ xs) (/ (apply + xs) (length xs)))\n  (define (round x) (if (< x 0) (- (floor\
    \ (/ x -1))) (floor x)))\n  (define (to_binary x) (number->string x 2))\n  (cond\
    \ ((> n m) -1)\n        (else (to_binary (round (average (helper n m)))))))\n",
  "  (if (> n m) -1\n      (let* ((sum 0)\n             (count 0)\n             (i\
    \ n))\n        (while (<= i m)\n          (set! sum (+ sum i))\n          (set!\
    \ count (+ count 1))\n          (set! i (+ i 1)))\n        (let ((avg (/ sum count)))\n\
    \          (string-append \"0b\" (number->string (integer-valued-expr (round avg))))))))",
  "    (cond \n        [(> n m) -1]\n        [else (let ([sum 0])\n              \
    \  (for/sum ([i (in-range n (+ m 1))])\n                    (set! sum (+ sum i)))\n\
    \                (let ([sum-int (/ sum (- m n))])\n                    (printf\
    \ \"~b~n\" sum-int)))]))", "  (define (sum i)\n    (if (&gt; i m)\n        0\n\
    \        (+ i (sum (+ i 1)))))\n  (define (avg i)\n    (if (= i m)\n        (/\
    \ (sum i) i)\n        (avg (+ i 1))))\n  (if (&gt; n m)\n      -1\n      (integer-&gt;binary\
    \ (round (avg n)))))\n", "  (cond\n    [(> n m) -1]\n    [else (let ([average\
    \ (/ (+ n m) 2)])\n            (number->string average 2))]))", "  (define (rounded_avg-iter\
    \ n m sum)\n    (cond\n      ((<= n m) (rounded_avg-iter (+ n 1) m (+ sum n)))\n\
    \      (else (/ (round (/ sum (- m n)))\n               2))))\n  (cond\n    ((>\
    \ n m) -1)\n    (else (integer->binary (rounded_avg-iter n m 0)))))\n", "  (let*\
    \ ([nums (for/list ([i (in-range n m)]) i)]\n         [avg (round (/ (apply +\
    \ nums) (length nums)))])\n    (cond\n      [(> n m) -1]\n      [else (number->string\
    \ avg 2)])))\n", "  (define (count_bits num)\n    (cond [(zero? num) 0]\n    \
    \      [else (+ 1 (count_bits (quotient num 2)))]))\n  (cond [(> n m) -1]\n  \
    \      [else\n         (define avg (+ n m))\n         (define rounded-avg (quotient\
    \ (+ avg (/ avg 2)) 2))\n         (cond [(zero? rounded-avg) \"0b0\"]\n      \
    \         [else (string-append \"0b\" (number->string (count_bits rounded-avg)))]\n\
    \               )]))\n\n```\n\n```\nRACKET_VERSION='^Racket v7.0' racket round_average.rkt\n\
    ```\n\n### [Combinations](https://www.codewars.com/kata/59e66e48fc3c499ec5000103)\n\
    \nIn this Kata, you will be given two integers n and k and your task is to create\n\
    a list consisting of all the combinations of k distinct elements from the\ninterval\
    \ [1..n].\n\n- n will be always greater than k.\n- Elements in a combination must\
    \ be sorted.\n- Lists of combinations must be sorted in lexicographical order.\n\
    \nExample: n = 5, k = 3\n```\ncombinations(5, 3) -- [[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3,4,5]]\n\
    ```\n\n```racket\n#lang racket\n", "  (define (average x y)\n    (quotient (+\
    \ x y) 2))\n  (cond\n    [(> n m) -1]\n    [else\n     (define sum 0)\n     (for\
    \ ([i (in-range n m)])\n       (set! sum (+ sum i)))\n     (integer->binary-string\
    \ (average sum (+ n m)))]))\n", "  (if (> n m)\n      -1\n      (integer->binary\
    \ (round (/ (+ n m) 2)))))", "  (if (> n m)\n      -1\n      (list->string\n \
    \      (int->list\n        (round\n         (/ (+ n m) 2.0)) 2))))\n", "  (cond\n\
    \    [(> n m) -1]\n    [else\n     (define sum (+ n m))\n     (display (string->number\
    \ (number->string (round (float (/ sum 2)))) 2))]))\n", "  (define (avg n m) (/\
    \ (+ n m) 2))\n  (define (average n m)\n    (integer->binary (round (avg n m))))\n\
    \  (if (> n m) -1 (average n m)))", "  (define (helper sum count)\n    (if (=\
    \ n m)\n        (binary (round (/ (+ n sum) (+ count 1))))\n        (helper (+\
    \ sum n) (+ count 1))\n        )\n    )\n  (if (< n m)\n      (helper 0 0)\n \
    \     -1\n      )\n  )\n", "  (define (average n m)\n    (let loop ([n n] [m m]\
    \ [acc 0])\n      (if (= n m)\n          (quotient (+ acc n) 2)\n          (loop\
    \ (+ n 1) m (+ acc n)))))\n  (if (< n m)\n      (if (= (remainder (average n m)\
    \ 1) 0)\n          (integer->binary (average n m))\n          (integer->binary\
    \ (add1 (average n m))))\n      -1))\n```\n\n```racket\n#lang racket\n", "  (cond\n\
    \    [(< n m) (number->string (integer-round (/ (+ n m) 2)) 2)]\n    [else -1]))",
  "  (cond\n    [(> n m) -1]\n    [else\n     (string->number\n      (number->string\
    \ (round (/ (+ n m) 2.0)))\n      2)]))\n", "  (cond\n    [(> n m)\n     -1]\n\
    \    [else\n     (string->symbol\n      (string-append \"0b\"\n              \
    \       (number->string\n                      (integer-length\n             \
    \          (quotient\n                        (+ n m)\n                      \
    \  2)))))]))\n", "    (if (> n m)\n        -1\n        (define sum (+ n m))\n\
    \        (define average (/ sum 2))\n        (format \"0b~b\" (round average))))\n",
  "  (if (< n m)\n      (number->string (inexact->exact (round (/ (+ n m) 2))) 2)\n\
    \      -1))\n", "    (local ((define (avg_helper running-total count)\n      \
    \           (cond\n                  [(> n m) -1]\n                  [(= count\
    \ (- m n)) running-total]\n                  [else (avg_helper (+ running-total\
    \ n) (+ count 1))])))\n        (define r (avg_helper 0 0))\n        (if (equal?\
    \ r -1)\n            r\n            (binary->string (inexact->exact (round (/\
    \ r (- m n)))) 2))))\n", "  (if (> n m)\n      -1\n      (bitwise-or\n       (quotient\
    \ (bitwise-and\n                  (lsh (lsh 1 32) -1)\n                  (+ n\
    \ m))\n                 2)\n       0)))\n", "  (if (< n m)\n      (binary-decimal-string\
    \ (/ (+ n m) 2))\n      -1))\n", "  (if (<= n m)\n      (string->symbol (string-append\
    \ \"0b\" (number->string (round (/ (+ n m) 2)))))\n      -1))\n", "  (if (< n\
    \ m)\n      (inexact->exact (round (/ (+ n m) 2)))\n      -1))\n", "  (let ([diff\
    \ (- m n)])\n    (if (&lt; n m)\n        (if (zero? (remainder diff 2))\n    \
    \        (number-&gt;string (bitwise-ior \n                              (+ n\
    \ (/ diff 2))\n                              (ash 1 (/ (- diff 1) 2))))\n    \
    \        (number-&gt;string (bitwise-ior \n                              (+ n\
    \ (/ diff 2))\n                              (ash 1 (/ diff 2)))))\n        -1)))\n\
    </code>\n\nI know there's an easier way than using <code>bitwise-ior</code> and\
    \ <code>ash</code>, but I\nthink I was trying to do some kind of binary add without\
    \ carry. I just need\nto actually figure out how to code it.\nI wouldn't call\
    \ <code>if</code> a primitive, but you're right, it's not a \"built-in\".\nI still\
    \ think that's better than \"local\".\nI'm not sure what you mean about <code>diff</code>\
    \ being \"perhaps not the best name\".\nWhat would be better?\n\n\n\nA:\n\nTo\
    \ implement a divide-and-conquer algorithm, one needs to find a way to break a\
    \ given problem into smaller and smaller sub-problems until the sub-problems are\
    \ easy to solve.\nIn the case of finding the average, we can split a range <code>[n,\
    \ m]</code> into two ranges: <code>[n, (n+m)/2]</code> and <code>[(n+m)/2+1, m]</code>.\
    \ The average of the first half and the average of the second half are both less\
    \ than the average of the entire range. So, to compute the average of the entire\
    \ range, we first have to compute the average of the halves, then the average\
    \ of the halves of those halves and so on.\nSo the algorithm will be:\n\nIf <code>n\
    \ &gt; m</code>, return <code>-1</code>.\nOtherwise, return the average of <code>[n,\
    \ m]</code>.\n\nTo compute the average of a range:\n\nIf <code>n == m</code>,\
    \ return <code>n</code>.\nIf <code>n &lt; m</code>, return the average of <code>[n,",
  "  (if (> n m)\n      -1\n      (let* ([len (- m n)]\n             [avg (round (/\
    \ (+ n m) 2.0))]\n             [bin (if (<= avg 2)\n                      (format\
    \ \"0b~a\" avg)\n                      (binary avg))])\n        bin)))", "  (if\
    \ (&gt; n m)\n      -1\n      (let* ([avg (round (/ (+ n m) 2.0))]\n         \
    \    [bin (number-&gt;string avg 2)])\n        (string-append \"0b\" bin))))\n\
    </code>\nMy solution is in Racket, as it's what I'm more familiar with at the\
    \ moment.  I was wondering if there was a better/more functional way to do this?\n\
    I got the idea for the unboxing from this answer.\n\n\nA:\n\nI'm going to have\
    \ to defer to others on the functional aspects of this solution.  I'll focus on\
    \ style.\n\nI wouldn't bother with <code>let*</code> here.  I'd use <code>let</code>.\
    \  Given that we're in\nRacket, that actually buys us some powerful style improvements.\n\
    \n<code>(define (rounded_avg n m)\n  (cond [(&gt; n m) -1]\n        [else    (string-append\
    \ \"0b\" (number-&gt;string (round (/ (+ n m) 2.0)) 2))]))\n</code>\n<code>(define\
    \ (rounded_avg n m)\n  (if (&gt; n m)\n      -1\n      (string-append \"0b\" (number-&gt;string\
    \ (round (/ (+ n m) 2.0)) 2))))\n</code>\n<code>(define (rounded_avg n m)\n  (if\
    \ (&gt; n m)\n      -1\n      (let ([avg (round (/ (+ n m) 2.0))])\n        (string-append\
    \ \"0b\" (number-&gt;string avg 2)))))\n</code>\n<code>(define (rounded_avg n\
    \ m)\n  (if (&gt; n m)\n      -1\n      (let ([avg (round (/ (+ n m) 2.0))])\n\
    \        (string-append \"0b\"\n                       (number-&gt;string avg\
    \ 2)))))\n</code>\n<code>(define (rounded_avg n m)\n  (if (&gt; n m)\n      -1\n\
    \      (let ([avg (round (/ (+ n m) 2.0))])\n", "  (cond\n    [(> n m) -1]\n \
    \   [else\n     (define sum (+ n m))\n     (define avg (/ sum 2))\n     (define\
    \ b-avg (exact->inexact (string->number (number->string avg) 2)))\n     (define\
    \ rounded-b-avg (round b-avg))\n     (inexact->exact (string->number (number->string\
    \ rounded-b-avg) 2))]))\n", "  (if (< n m)\n      (binary-round (avg (range n\
    \ m)))\n      -1))\n", "  (cond\n    [(> n m) -1]\n    [else (byte->string (round\
    \ (/ (+ n m) 2)) 2)]))", "  (cond [(> n m) #\"-1\"]\n        [else     (number->string\
    \ (inexact->exact (round (average n m))) 2)]))\n", "  (if (> n m)\n      -1\n\
    \      (integer->binary (round (/ (+ n m) 2)))))\n", "  (define (get-avg n m)\n\
    \    (if (&gt; n m)\n        '-1\n        (let ((avg (/ (+ n m) 2)))\n       \
    \   (cond [(even? avg) avg]\n                [else (round avg)]))))\n  (integer-&gt;string\
    \ (get-avg n m) 2))\n</code>\n", "  (if (&gt; n m) -1\n      (define sum 0)\n\
    \      (define count 0)\n      (for ([i (in-range n (+ m 1))])\n        (set!\
    \ sum (+ sum i))\n        (set! count (+ count 1)))\n      (define rounded (round\
    \ (/ sum count)))\n      (string-append \"0b\" (number-&gt;string (integer-&gt;binary\
    \ rounded)))))\n</code>\nI have added comments on each line, but if anything is\
    \ unclear, please comment and I will happily explain.\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
