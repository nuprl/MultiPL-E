name: HumanEval_70_strange_sort_list
language: rkt
prompt: "#lang racket\n\n;; Given list of integers, return list in strange order.\n\
  ;; Strange sorting, is when you start with the minimum value,\n;; then maximum of\
  \ the remaining integers, then minimum and so on.\n;; Examples:\n;; >>> (strange_sort_list\
  \ (list 1 2 3 4))\n;; (list 1 4 2 3)\n;; >>> (strange_sort_list (list 5 5 5 5))\n\
  ;; (list 5 5 5 5)\n;; >>> (strange_sort_list (list ))\n;; (list )\n(define (strange_sort_list\
  \ lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strange_sort_list))\n\
  \    (check-equal? (candidate (list 1 2 3 4)) (list 1 4 2 3))\n    (check-equal?\
  \ (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7))\n    (check-equal? (candidate (list\
  \ 1 2 3 4 5)) (list 1 5 2 4 3))\n    (check-equal? (candidate (list 5 6 7 8 9 1))\
  \ (list 1 9 5 8 6 7))\n    (check-equal? (candidate (list 5 5 5 5)) (list 5 5 5\
  \ 5))\n    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate\
  \ (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5))\n    (check-equal? (candidate\
  \ (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2))\n    (check-equal? (candidate\
  \ (list 111111)) (list 111111))\n))\n\n(test-humaneval)"
completions: ["  (strange_sort_lst lst (list (car lst)))\n  )\n", "  (if (null? lst)\n\
    \      (list)\n      (define min (apply min lst))\n      (define max (apply max\
    \ lst))\n      (cons min (cons max (strange_sort_list (remove min (remove max\
    \ lst)))))))\n", "  (if (null? lst) lst\n      (append (list (min (min lst (max\
    \ lst)) (max lst)))\n              (strange_sort_list (list (max (min lst (max\
    \ lst)) (max lst)))))))", "  (let loop ([min (min lst)]\n             [max (max\
    \ lst)]\n             [lst (remove min lst)]\n             [rem-list '()])\n \
    \   (cond [(empty? lst) '()]\n          [(= max min) lst]\n          [else (loop\
    \ max min (remove max lst) (append rem-list (list min max)))])))\n", "  (cond\n\
    \    [(empty? lst) empty]\n    [else\n     (append\n      (list (min-remaining\
    \ lst))\n      (list (max-remaining lst))\n      (strange_sort_list (remove-element-by-value\
    \ (min-remaining lst) (remove-element-by-value (max-remaining lst) lst))))]))\n",
  "  (define (min_aux lst mn)\n    (cond\n      [(empty? lst) mn]\n      [(< mn (first\
    \ lst)) (min_aux (rest lst) mn)]\n      [else (min_aux (rest lst) (first lst))]))\n\
    \  (define (min lst)\n    (min_aux lst (first lst)))\n  (define (max_aux lst mx)\n\
    \    (cond\n      [(empty? lst) mx]\n      [(> mx (first lst)) (max_aux (rest\
    \ lst) mx)]\n      [else (max_aux (rest lst) (first lst))]))\n  (define (max lst)\n\
    \    (max_aux lst (first lst)))\n  (define (min_index lst)\n    (let ([f (first\
    \ lst)])\n      (if (empty? lst)\n          -1\n          (if (= f (min lst))\n\
    \              0\n              (+ 1 (min_index (rest lst)))))))\n  (define (max_index\
    \ lst)\n    (let ([f (first lst)])\n      (if (empty? lst)\n          -1\n   \
    \       (if (= f (max lst))\n              0\n              (+ 1 (max_index (rest\
    \ lst)))))))\n  (define (rem-min lst)\n    (if (= 0 (min_index lst))\n       \
    \ (rest lst)\n        (append (list (first lst)) (rem-min (rest lst)))))\n  (define\
    \ (rem-max lst)\n    (if (= 0 (max_index lst))\n        (rest lst)\n        (append\
    \ (list (first lst)) (rem-max (rest lst)))))\n  (define (strange_sort_aux mn mx\
    \ lst)\n    (cond\n      [(empty? lst) (list mn mx)]\n      [(= 1 (length lst))\
    \ (list mn (first lst))]\n      [else (append (list mn mx) (strange_sort_aux (min\
    \ (rem-min lst)) (max (rem-max", "  (if (= (length lst) 0)\n      '()\n      (append\
    \ (list (min lst))\n              (list (max (delete (min lst) lst)))\n      \
    \        (strange_sort_list (delete (max (delete (min lst) lst)) lst)))))\n",
  "  (if (null? lst)\n      '()\n      (let ([min (apply min lst)]\n            [max\
    \ (apply max lst)])\n        (if (= min max)\n            lst\n            (append\
    \ (list min max)\n                    (strange_sort_list (remove min (remove max\
    \ lst))))))))\n", "  (if (null? lst)\n      null\n      (let* ([min-value (apply\
    \ min lst)]\n             [max-value (apply max lst)]\n             [min-index\
    \ (list-index min-value lst)]\n             [max-index (list-index max-value lst)]\n\
    \             [rest (delete* min-value (delete* max-value lst))])\n        (if\
    \ (empty? rest)\n            (list min-value max-value)\n            (append (list\
    \ min-value max-value)\n                    (strange_sort_list rest))))))\n",
  "  (match lst\n    ['() '()]\n    [(list x) (list x)]\n    [(list x y) (list x y)]\n\
    \    [(list x y . rest) (append (list x (max-list rest) y (min-list rest))\n \
    \                              (strange_sort_list (remove (max-list rest) (remove\
    \ (min-list rest) lst))))]))\n\n", "  (cond [(empty? lst) empty]\n        [else\n\
    \         (append (list (apply min lst))\n                 (list (apply max (sub1\
    \ (length lst)) lst))\n                 (strange_sort_list (sub2 (length lst)\
    \ lst)))]))\n", "  (if (null? lst)\n      null\n      (cons (min lst)\n      \
    \      (cons (max lst)\n                  (cons (min (remove (min lst) lst))\n\
    \                        (cons (max (remove (max lst) lst))\n                \
    \              (strange_sort_list (remove (min lst) (remove (max lst) lst)))))))))\n",
  "  (define (process-list lst acc)\n    (cond [(empty? lst) acc]\n          [(= (count\
    \ lst) 1) (append acc lst)]\n          [else (process-list (rest lst) (append\
    \ acc (list (min lst) (max lst))))]))\n  (process-list lst '()))\n```\n\n```scheme\n\
    #lang racket\n", "  (cond [(empty? lst) lst]\n        [else\n         (let-values\
    \ ([(min-v max-v rst)\n                       (values (apply min lst)\n      \
    \                         (apply max lst)\n                               (remove*\
    \ (min lst) lst))])\n           (cons min-v (cons max-v (strange_sort_list rst))))]))\n",
  "  (if (empty? lst)\n      lst\n      (cons (min-element lst)\n            (cons\
    \ (max-element lst)\n                  (strange_sort_list (remove (min-element\
    \ lst)\n                                             (remove (max-element lst)\n\
    \                                                     lst)))))))", "  (if (null?\
    \ lst)\n      '()\n      (cons (apply min lst)\n            (cons (apply max lst)\n\
    \                  (strange_sort_list (remove (min lst)\n                    \
    \                         (remove (max lst)\n                                \
    \                     lst)))))))\n```\n\n```racket\n#lang racket\n", "  (match\
    \ lst\n    ['() '()]\n    [(list x) (list x)]\n    [(list x xs ...)\n     (cons\
    \ (min lst)\n           (if (= x (max lst))\n               (list x)\n       \
    \        (cons (max lst)\n                     (if (= x (min lst))\n         \
    \                (list x)\n                         (cons (min lst) (if (= x (max\
    \ (cdr lst)))\n                                             (list x)\n       \
    \                                      (cons (max (cdr lst)) (if (= x (min (cdr\
    \ lst)))\n                                                                   \
    \     (list x)\n                                                             \
    \           (cons (min (cdr lst))\n                                          \
    \                                    (if (= x (max (cddr lst)))\n            \
    \                                                                      (list x)\n\
    \                                                                            \
    \      (cons (max (cddr lst))\n                                              \
    \                                          (if (= x (min (cddr lst)))\n      \
    \                                                                            \
    \          (list x)\n                                                        \
    \                                    (cons (min (cddr lst))\n                \
    \                                                                            \
    \      (if (= x (max (cdddr lst)))\n                                         \
    \                                                             (list x)\n     \
    \                                                                            \
    \                     (cons (max (cdddr lst))\n                              \
    \                                                                            \
    \  (if (= x (min (cdddr lst)))\n                                             \
    \                                                                   (list x)\n\
    \                                                                            \
    \                                    (cons (min (cdddr lst))\n               \
    \                                                                            \
    \                           (if (= x (max (cddddr lst)))\n                   \
    \                                                                            \
    \                           (list x)\n                                       \
    \                                                                            \
    \       (cons (max (cddddr lst))\n                                           \
    \                                                                            \
    \         (if (= x (min (cddddr lst)))\n                                     \
    \                                                                            \
    \                   (list x)\n                                               \
    \                                                                            \
    \         (cons (min (cddddr lst))\n                                         \
    \                                                                            \
    \                     (if (= x (max (cdddddr lst)))\n                        \
    \                                                                            \
    \                                          (list x)\n                        \
    \        ", "  (if (empty? lst)\n      '()\n      (append (list (min lst) (max\
    \ lst))\n              (strange_sort_list (remove (min lst) (remove (max lst)\
    \ lst))))))\n", "  (cond\n    [(empty? lst) empty]\n    [else\n     (define min_val\
    \ (apply min lst))\n     (define max_val (apply max lst))\n     (define min_pos\
    \ (position min_val lst))\n     (define max_pos (position max_val lst))\n    \
    \ (define next_lst (list-copy lst))\n     (cond\n       [(= min_pos max_pos)\n\
    \        (cons min_val (strange_sort_list (remove min_val next_lst)))]\n     \
    \  [else\n        (define min_val (apply min lst))\n        (define max_val (apply\
    \ max lst))\n        (define next_lst (list-copy lst))\n        (list-set! next_lst\
    \ min_pos max_val)\n        (list-set! next_lst max_pos min_val)\n        (cons\
    \ min_val (strange_sort_list (remove min_val next_lst)))])])\n\n    )\n</code>\n\
    So I would like to know if there is a way to find the position of an element and\
    \ then remove it in a single function.\n\n\nA:\n\nA simple way to move from an\
    \ index to a list is a forward reference, and vice versa.\n<code>(define (i2l\
    \ i n . ls)\n  (if (= i n)\n      (list n)\n      (cons n (i2l i (+ n 1) ls))))\n",
  "  (if (null? lst)\n      (list)\n      (let ([min (apply min lst)]\n          \
    \  [max (apply max lst)])\n        (list min max)\n        (strange_sort_list\
    \ (list (apply - lst (list min max)))))))\n", "  (define sorted (sort lst #&lt;))\n\
    \  (for/fold ([result '()]) ([elt sorted])\n    (if (null? result)\n        (cons\
    \ elt result)\n        (cons (car (append (reverse result) (cdr result))) result))))\n\
    </code>\nSample run:\n<code>&gt; (strange_sort_list (list 1 2 3 4))\n'(1 4 2 3)\n\
    </code>\n", "  (if (= (length lst) 0)\n      (list)\n      (if (= (length lst)\
    \ 1)\n          (list (car lst))\n          (let ([min (apply min lst)]\n    \
    \            [max (apply max lst)]\n                [new-lst (remove min lst)])\n\
    \            (if (null? new-lst)\n                (list min)\n               \
    \ (cons min (cons max (strange_sort_list (remove max new-lst)))))))))\n", "  (cond\
    \ [(null? lst) null]\n        [else (append (list (min lst) (max lst))\n     \
    \                 (strange_sort_list (remove (min lst) (remove (max lst) lst))))]))\n",
  "  (strange_sort_iter lst (sort lst <)))\n", "  (letrec ([strange-sort-helper\n\
    \             (lambda (sorted lst)\n               (if (empty? lst)\n        \
    \           sorted\n                   (let ([min (min lst)]\n               \
    \          [max (max lst)])\n                     (strange-sort-helper (append\
    \ sorted (list min max))\n                                          (remove min\
    \ (remove max lst))))))])\n    (strange-sort-helper '() lst)))", "  (if (null?\
    \ lst)\n      lst\n      (append (list (min lst) (max lst))\n              (strange_sort_list\
    \ (remove (min lst) (remove (max lst) lst))))))\n", "  (define (min-of-rest lst)\n\
    \    (cond [(empty? lst) (error \"Empty list\")]\n          [(null? (rest lst))\
    \ (first lst)]\n          [else (min (first lst) (min-of-rest (rest lst)))]))\n\
    \  (define (max-of-rest lst)\n    (cond [(empty? lst) (error \"Empty list\")]\n\
    \          [(null? (rest lst)) (first lst)]\n          [else (max (first lst)\
    \ (max-of-rest (rest lst)))]))\n  (define (min-max-of-rest lst)\n    (cond [(empty?\
    \ lst) (error \"Empty list\")]\n          [(null? (rest lst)) (list (first lst)\
    \ (first lst))]\n          [else (list (min (first lst) (first (min-max-of-rest\
    \ (rest lst))))\n                      (max (first lst) (first (min-max-of-rest\
    \ (rest lst)))))]))\n  (define (max-min-of-rest lst)\n    (cond [(empty? lst)\
    \ (error \"Empty list\")]\n          [(null? (rest lst)) (list (first lst) (first\
    \ lst))]\n          [else (list (max (first lst) (first (max-min-of-rest (rest\
    \ lst))))\n                      (min (first lst) (first (max-min-of-rest (rest\
    \ lst)))))]))\n  (define (strange-sort lst)\n    (cond [(empty? lst) (list)]\n\
    \          [(null? (rest lst)) (list (first lst))]\n          [else (append (list\
    \ (min-of-rest lst))\n                        (list (max-of-rest lst))\n     \
    \                   (strange-sort (remove (min-of-rest lst) (remove (max-of-rest\
    \ lst) lst))))]))\n  (define (strange-sort-2 lst)\n    (cond [(empty? lst) (list)]\n\
    \          [(null? (rest lst)) (list (first lst))]\n          [else", "  (let\
    \ loop ([lst lst] [prev -1000] [acc '()])\n    (cond\n      [(and (empty? lst)\
    \ (not= prev -1000)) (reverse acc)]\n      [(empty? lst) acc]\n      [(and (and\
    \ (and (and (and (= prev -1000)\n                                (not (empty?\
    \ lst)))\n                          (or (min-element lst) #f))\n             \
    \         (not (member (min-element lst) lst)))\n                  (not (member\
    \ (max-element lst) lst)))\n              (not (member (min-element lst) lst)))\n\
    \       (loop (list-remove (list-remove (list-remove lst (min-element lst))\n\
    \                                       (max-element lst))\n                 \
    \         (min-element lst))\n             (min-element lst)\n             (cons\
    \ (min-element lst)\n                   (cons (max-element lst)\n            \
    \             (cons (min-element lst) acc))))]\n      [(and (and (and (and (and\
    \ (= prev -1000)\n                                (not (empty? lst)))\n      \
    \                    (or (min-element lst) #f))\n                      (not (member\
    \ (min-element lst) lst)))\n                  (not (member (max-element lst) lst)))\n\
    \              (member (min-element lst) lst))\n       (loop (list-remove (list-remove\
    \ lst (min-element lst))\n                          (max-element lst))\n     \
    \        (min-element lst)\n             (cons (min-element lst)\n           \
    \        (cons (max-element lst) acc)))]\n      [(and (and (and (and (and (= prev\
    \ -1000)\n                                (not (empty? lst)))\n              \
    \            (or (min-element lst) #f))\n                      (not (member (min-element\
    \ lst) lst)))\n                  (member (max-element lst) lst))\n           \
    \   (not (member (min-element lst) lst)))\n       (loop (list-remove (list-remove\
    \ lst (min-element lst))\n                          (max-element lst))\n", " \
    \ (if (null? lst)\n      '()\n      (sort lst\n            (lambda (a b)\n   \
    \           (if (positive? (- a b))\n                  #t\n                  #f)))))\n",
  "  (cond [(empty? lst) empty]\n        [else\n         (define min (apply min lst))\n\
    \         (define max (apply max lst))\n         (cons min (cons max (strange_sort_list\
    \ (remove (lambda (x) (= x min)) (remove (lambda (x) (= x max)) lst)))))]))",
  "  (if (empty? lst)\n      (list)\n      (strange_sort_list_helper lst (list (min-of-list\
    \ lst)))))\n", "  (let/ec return\n    (define (helper lst acc)\n      (cond\n\
    \        [(null? lst) (return (reverse acc))]\n        [(= (length lst) 1) (return\
    \ (reverse (cons (car lst) acc)))]\n        [else\n         (define (first-max\
    \ lst max)\n           (cond\n             [(null? lst) max]\n             [(>\
    \ (car lst) max) (first-max (cdr lst) (car lst))]\n             [else (first-max\
    \ (cdr lst) max)]))\n         (define (first-min lst min)\n           (cond\n\
    \             [(null? lst) min]\n             [(< (car lst) min) (first-min (cdr\
    \ lst) (car lst))]\n             [else (first-min (cdr lst) min)]))\n        \
    \ (define (remove-first-matching lst val)\n           (cond\n             [(null?\
    \ lst) lst]\n             [(equal? (car lst) val) (cdr lst)]\n             [else\
    \ (cons (car lst) (remove-first-matching (cdr lst) val))]))\n         (helper\
    \ (remove-first-matching lst (first-max lst (first-min lst (car lst))))\n    \
    \             (cons (first-max lst (first-min lst (car lst))) acc))]))\n    (helper\
    \ lst '())))\n", "  (define (min_rest lst)\n    (define (min_rest_helper lst min)\n\
    \      (cond\n        [(empty? lst) min]\n        [(< (first lst) min) (min_rest_helper\
    \ (rest lst) (first lst))]\n        [else (min_rest_helper (rest lst) min)]))\n\
    \    (min_rest_helper (rest lst) (first lst)))\n  (define (max_rest lst)\n   \
    \ (define (max_rest_helper lst max)\n      (cond\n        [(empty? lst) max]\n\
    \        [(> (first lst) max) (max_rest_helper (rest lst) (first lst))]\n    \
    \    [else (max_rest_helper (rest lst) max)]))\n    (max_rest_helper (rest lst)\
    \ (first lst)))\n  (define (sort_helper lst min max result)\n    (cond\n     \
    \ [(empty? lst) result]\n      [(< (first lst) min) (sort_helper (rest lst) (first\
    \ lst) max (append result (list (first lst))))]\n      [(> (first lst) max) (sort_helper\
    \ (rest lst) min (first lst) (append result (list (first lst))))]\n      [else\
    \ (sort_helper (rest lst) min max (append result (list (first lst))))]))\n  (sort_helper\
    \ (rest lst) (first lst) (first lst) (list (first lst))))", "  (if (null? lst)\n\
    \      '()\n      (let* ([min (min lst)]\n             [rest (remove min lst)]\n\
    \             [max (max rest)]\n             [rest (remove max rest)])\n     \
    \   (cons min (cons max (strange_sort_list rest))))))\n", "  (define (strange-sort\
    \ lst)\n    (cond\n      [(null? lst) (cons)]\n      [(null? (cdr lst)) (cons\
    \ (car lst))]\n      [else\n       (let ([min (car lst)]\n             [max (car\
    \ lst)])\n         (for-each\n          (lambda (x)\n            (cond\n     \
    \         [(> x max) (set! max x)]\n              [(< x min) (set! min x)]))\n\
    \          lst)\n         (cons min (cons max (strange-sort (remove max (remove\
    \ min lst))))))]))\n  (strange-sort lst))\n", "  (if (null? lst)\n      (list)\n\
    \      (let ([lst-min (min lst)]\n            [lst-max (max lst)]\n          \
    \  [lst-sorted (sort (list-remove lst lst-min) number&lt;?)])\n        (append\
    \ (list lst-min)\n                (list lst-max)\n                (strange_sort_list\
    \ lst-sorted)))))\n", "  (strange_sort_list_iter lst '() '()))\n", "  (cond [(empty?\
    \ lst) empty]\n        [else\n         (sort\n          (cons (min lst) (cons\
    \ (max lst) (strange_sort_list (remove (min lst) (remove (max lst) lst)))))\n\
    \          (\u03BB (x y) (&lt;= x y)))]))\n</code>\n", "  (define (strange_sort_list_iter\
    \ result working_list)\n    (if (null? working_list)\n        result\n       \
    \ (strange_sort_list_iter (append result (list (min working_list) (max working_list)))\
    \ (remove (min working_list) (remove (max working_list) working_list)))))\n  (strange_sort_list_iter\
    \ (list) lst))\n", "  (define (strange_sort_list_itr lst acc)\n    (if (null?\
    \ lst) acc\n      (if (null? (cdr lst)) (cons (car lst) acc)\n        (let* ([first\
    \ (apply min lst)]\n               [rest (remove (lambda (n) (= n first)) lst)]\n\
    \               [last (apply max rest)])\n          (strange_sort_list_itr (remove\
    \ (lambda (n) (= n last)) rest)\n                                 (cons first\
    \ (cons last acc)))))))\n  (reverse (strange_sort_list_itr lst (list))))", " \
    \ (if (null? lst)\n      lst\n      (cons (min lst)\n            (cons (max lst)\n\
    \                  (if (null? (cdr lst))\n                      lst\n        \
    \              (strange_sort_list (cdr lst)))))))", "  (define (strange-sort-helper\
    \ lst greater lesser)\n    (if (null? lst)\n      '()\n      (append (if (even?\
    \ (length lst)) lesser greater)\n              (strange-sort-helper (cdr lst)\
    \ lesser greater))))\n  (strange-sort-helper lst\n                       (sort\
    \ lst <)\n                       (sort lst >)))\n", "  (if (null? lst) lst\n \
    \     (append (list (min lst) (max lst)) (strange_sort_list (remove (max lst)\
    \ (remove (min lst) lst))))))\n", "  (cond\n    [(null? lst) '(list)]\n    [(=\
    \ (length lst) 1) lst]\n    [else\n     (append\n      (list (min lst) (max lst))\n\
    \      (strange_sort_list (list-replace lst (min lst) '())))]))\n", "  (let* ([a\
    \ (remove-duplicates lst)]\n         [b (sort a <)])\n    (let loop ([b b] [a\
    \ (list)])\n      (if (empty? b)\n          a\n          (loop (drop-right b 1)\
    \ (append a (list (car b) (list-ref b (- (length b) 1)))))))))", "  (cond [(empty?\
    \ lst) empty]\n        [else\n         (cond [(= (max lst) (min lst)) lst]\n \
    \              [else\n                (cons (min lst)\n                      (cons\
    \ (max lst)\n                            (strange_sort_list (filter (\u03BB (x)\
    \ (and (not (= x (min lst))) (not (= x (max lst))))) lst))))])]))\n", "  (if (null?\
    \ lst)\n      (list)\n      (append (list (min (car lst) (car (cdr lst))))\n \
    \             (list (max (car lst) (car (cdr lst))))\n              (strange_sort_list\
    \ (list (min (car lst) (car (cdr lst))) (max (car lst) (car (cdr lst)))) (cdr\
    \ (cdr lst))))))\n ", "  (sort lst #:key (\u03BB (x) (if (odd? x) 1 2))))\n",
  "  (if (null? lst)\n      '()\n      (if (= (length lst) 1)\n          lst\n   \
    \       (if (null? (cdr lst))\n              lst\n              (let ((min (min\
    \ (car lst) (cadr lst)))\n                    (max (max (car lst) (cadr lst))))\n\
    \                (append (list min max)\n                        (strange_sort_list\
    \ (remove min (remove max lst)))))))))\n</code>\nThe same algorithm, with a tail-recursive\
    \ helper:\n<code>#lang racket\n", "  (define (strange_sort lst acc)\n    (cond\
    \ [(empty? lst) acc]\n          [(empty? (rest lst)) (cons (first lst) acc)]\n\
    \          [else (strange_sort (remove_first (max_element lst) lst)\n        \
    \                      (cons (min_element lst)\n                             \
    \       (cons (max_element lst) acc)))]))\n  (strange_sort lst (list)))\n", " \
    \ (if (null? lst)\n      lst\n      (append (list (min (first lst) (second lst)))\n\
    \              (list (max (first lst) (second lst)))\n              (strange_sort_list\
    \ (rest (rest lst))))))\n", "  (if (empty? lst)\n      (list)\n      (let ([first-max\
    \ (apply max lst)]\n            [rest (remove first-max lst)]\n            [first-min\
    \ (apply min rest)]\n            [rest2 (remove first-min rest)])\n        (append\
    \ (list first-max first-min)\n                (strange_sort_list rest2)))))\n",
  "  (if (null? lst)\n      (list)\n      (if (null? (cdr lst))\n          (list (car\
    \ lst))\n          (let ([min (min-of-list lst)]\n                [max (max-of-list\
    \ lst)])\n            (append (list min max)\n                    (strange_sort_list\
    \ (remove min (remove max lst))))))))\n", "  (if (empty? lst)\n      '()\n   \
    \   (define lst_sorted (sort lst <))\n      (append (list (car lst_sorted) (last\
    \ lst_sorted))\n              (strange_sort_list (butlast (cdr lst_sorted))))))\n",
  "  (if (null? lst)\n      '()\n      (append (list (apply min lst))\n          \
    \    (list (apply max lst))\n              (strange_sort_list (remove (apply min\
    \ lst) (remove (apply max lst) lst))))))\n", "  (if (null? lst)\n      (list)\n\
    \      (let ((fst-lst (list (apply min lst)))\n            (remaining-lst (remove\
    \ (apply min lst) lst)))\n        (append fst-lst\n                (strange_sort_list\
    \ remaining-lst)))))", "  (cond\n    [(null? lst) lst]\n    [(null? (cdr lst))\
    \ lst]\n    [else (append (list (min lst) (max lst)) (strange_sort_list (list-remove\
    \ (list (min lst) (max lst)) lst)))]))\n", "  (cond\n    [(empty? lst) empty]\n\
    \    [else (append (list (min (remove-min lst)))\n                  (list (max\
    \ (remove-max lst)))\n                  (strange_sort_list (remove-min-max lst)))]))\n",
  "  (define (sorted? lst)\n    (cond ((empty? lst) #t)\n          ((or (null? (cdr\
    \ lst))\n               (and (<= (car lst) (cadr lst))\n                    (sorted?\
    \ (cdr lst))))\n           #t)\n          (else #f)))\n  (define (max-rest lst)\n\
    \    (cond ((empty? lst) (error \"lst should not be empty\"))\n          ((null?\
    \ (cdr lst)) (car lst))\n          (else (max (car lst) (max-rest (cdr lst))))))\n\
    \  (define (min-rest lst)\n    (cond ((empty? lst) (error \"lst should not be\
    \ empty\"))\n          ((null? (cdr lst)) (car lst))\n          (else (min (car\
    \ lst) (min-rest (cdr lst))))))\n  (define (strange-sort lst acc)\n    (cond ((empty?\
    \ lst) acc)\n          ((sorted? lst) (append (reverse acc) lst))\n          (else\
    \ (strange-sort (remove max-rest lst)\n                              (cons max-rest\
    \ (cons min-rest acc))))))\n  (strange-sort lst empty))\n```\n\n```\n#lang racket\n",
  "  (let ([nums (sort lst <)])\n    (if (null? nums)\n        '()\n        (list\
    \ (first nums)\n              (last nums)\n              (strange_sort_list (butlast\
    \ (rest nums)))))))\n", "  (if (= (length lst) 0)\n      (list)\n      (let ([min\
    \ (apply min lst)]\n            [max (apply max lst)])\n        (if (= min max)\n\
    \            (list min)\n            (let ([lst-without-min (remove min lst)]\n\
    \                  [lst-without-max (remove max lst-without-min)])\n         \
    \     (append (list min max)\n                      (strange_sort_list lst-without-max)))))))\n",
  "  (if (null? lst)\n      lst\n      (strange_sort_list (cdr lst))\n      (list\
    \ (max lst) (min lst))\n      )\n  )", "  (if (null? lst)\n      '()\n      (let\
    \ ([min (apply min lst)]\n            [max (apply max lst)])\n        (append\
    \ (list min)\n                (strange_sort_list (remove min lst))\n         \
    \       (list max)\n                (strange_sort_list (remove max lst))))))",
  "  (if (null? lst)\n      lst\n      (strange_sort_list_acc lst (list (min lst)))))\n",
  "  (if (null? lst)\n      '()\n      (cons (min lst) (cons (max lst) (strange_sort_list\
    \ (del lst (min lst) (max lst)))))))\n", "  (if (null? lst)\n      (list)\n  \
    \    (cons (min lst) (cons (max lst) (strange_sort_list (remq (min lst) (remq\
    \ (max lst) lst)))))))\n", "  (if (null? lst)\n      lst\n      (reverse (cons\
    \ (min (reverse lst))\n                     (cons (max (reverse lst))\n      \
    \                     (strange_sort_list (remove-min-max (reverse lst))))))))",
  "  (if (null? lst)\n      (list)\n      (reverse (strange_sort_list_help (reverse\
    \ lst)))))\n", "  (if (empty? lst)\n      lst\n      (let* ([all-but-max (remove\
    \ (apply max lst) lst)]\n             [all-but-min (remove (apply min lst) all-but-max)])\n\
    \        (list (apply min lst)\n              (apply max lst)\n              (strange_sort_list\
    \ all-but-min)))))\n", "  (define (accumulate acc lst)\n    (if (null? lst) acc\n\
    \      (define min  (list-ref lst (list-min (list->set lst))))\n      (define\
    \ max  (list-ref lst (list-max (list->set lst))))\n      (define lst1 (list-remove\
    \ lst min))\n      (define lst2 (list-remove lst1 max))\n      (accumulate (append\
    \ acc (list min max)) lst2)))\n  (accumulate (list) lst))\n", "  (cond\n    [(empty?\
    \ lst) empty]\n    [else\n     (define temp (sort lst <))\n     (append (list\
    \ (first temp))\n             (reverse (rest temp)))]))\n", "  (if (or (empty?\
    \ lst) (null? lst))\n      lst\n      (append (list (min (car lst) (cadr lst)))\n\
    \              (list (max (car lst) (cadr lst)))\n              (strange_sort_list\
    \ (cddr lst)))))\n", "  (if (equal? lst '())\n      '()\n      (append (list (min-lst\
    \ lst))\n              (list (max-lst lst))\n              (strange_sort_list\
    \ (remove (min-lst lst) (remove (max-lst lst) lst))))))\n", "  (define (aux lst\
    \ acc)\n    (if (null? lst)\n        acc\n        (let ([min-val (apply min lst)]\n\
    \              [max-val (apply max lst)])\n          (if (null? (cdr lst))\n \
    \             (append acc (list min-val))\n              (append acc (list min-val)\
    \ (list max-val))))))\n  (aux lst (list)))\n", "  (cond\n    [(empty? lst) empty]\n\
    \    [else (cons (min lst) (append (reverse (cdr (min-max lst))) (cons (max lst)\
    \ empty)))]))\n", "  (define (min lst)\n    (cond\n      [(null? lst) '()]\n \
    \     [(null? (cdr lst)) (car lst)]\n      [else (cond\n              [(< (car\
    \ lst) (min (cdr lst))) (car lst)]\n              [else (min (cdr lst))])]))\n\
    \  (define (max lst)\n    (cond\n      [(null? lst) '()]\n      [(null? (cdr lst))\
    \ (car lst)]\n      [else (cond\n              [(> (car lst) (max (cdr lst)))\
    \ (car lst)]\n              [else (max (cdr lst))])]))\n  (define (max-remaining\
    \ lst max)\n    (if (null? lst)\n        '()\n        (if (null? (cdr lst))\n\
    \            '()\n            (if (= (car lst) max)\n                (max-remaining\
    \ (cdr lst) max)\n                (if (> (car lst) (max-remaining (cdr lst) max))\n\
    \                    (car lst)\n                    (max-remaining (cdr lst) max))))))\n\
    \  (define (min-remaining lst min)\n    (if (null? lst)\n        '()\n       \
    \ (if (null? (cdr lst))\n            '()\n            (if (= (car lst) min)\n\
    \                (min-remaining (cdr lst) min)\n                (if (< (car lst)\
    \ (min-remaining (cdr lst) min))\n                    (car lst)\n            \
    \        (min-remaining (cdr lst) min))))))\n  (define (srt lst newlst)\n    (cond\n\
    \      [(null? lst) newlst]\n      [(null? (cdr lst)) (append newlst (list (car\
    \ lst)))]\n      [else (srt (cdr lst) (append newlst (list (car lst))))]))\n \
    \ (if (null? lst)\n      '()\n      (if (null? (cdr lst))\n          (list (",
  "  (define (sorted? lst)\n    (let ([len (length lst)])\n      (let loop ([i 0]\
    \ [last -1])\n        (cond\n          [(= i len) #t]\n          [(< last (list-ref\
    \ lst i))\n           (loop (+ i 1) (list-ref lst i))]\n          [else #f]))))\n\
    \  (cond\n    [(empty? lst) lst]\n    [(sorted? lst) lst]\n    [else\n     (let\
    \ loop ([acc (list)] [items lst])\n       (cond\n         [(empty? items) (reverse\
    \ acc)]\n         [(empty? (rest items)) (reverse (cons (first items) acc))]\n\
    \         [else\n          (let ([min (apply min items)]\n                [max\
    \ (apply max items)])\n            (loop (cons min (cons max acc))\n         \
    \         (append (remove min items) (remove max items))))]))]))\n", "  (define\
    \ (helper lst acc)\n    (if (empty? lst)\n        acc\n        (helper (remove\
    \ (max lst) lst) (append acc (list (max lst))))))\n  (helper lst '()))\n", " \
    \ (cond\n    [(empty? lst) empty]\n    [else\n     (let* ([sorted-lst (sort lst)]\n\
    \            [max-lst (sort (drop-right sorted-lst 1))]\n            [max (first\
    \ (reverse sorted-lst))]\n            [min (first sorted-lst)])\n       (cons\
    \ min (cons max (strange_sort_list max-lst))))]))\n", "  (cond [(empty? lst) (list)]\n\
    \        [(list? lst)\n         (let ([min-val (apply min lst)]\n            \
    \   [lst-wo-min (remove min-val lst)])\n           (cons min-val\n           \
    \      (if (empty? lst-wo-min)\n                     (list)\n                \
    \     (cons (apply max lst-wo-min)\n                           (strange_sort_list\
    \ (remove (apply max lst-wo-min) lst-wo-min))))))]))\n", "  (let loop ([lst lst]\
    \ [result '()])\n    (cond\n      [(null? lst) (reverse result)]\n      [else\
    \ (let ([min-val (apply min lst)]\n                  [max-val (apply max lst)])\n\
    \              (loop (remove min-val lst)\n                    (cons min-val (cons\
    \ max-val result))))])))\n```\n\n```\n#lang racket\n", "  (cond\n    [(empty?\
    \ lst) empty]\n    [else\n     (append\n      (list (min (rest lst) (list (car\
    \ lst))))\n      (list (max (rest lst) (list (car lst))))\n      (strange_sort_list\
    \ (remove (max (rest lst) (list (car lst))) (remove (min (rest lst) (list (car\
    \ lst))) lst))))]))", "  (if (null? lst)\n      lst\n      (sort lst #:key (lambda\
    \ (x) (and (odd? x) x)))))", "  (cond\n    [(empty? lst) lst]\n    [(one? lst)\
    \ lst]\n    [else\n     (define min-item (min lst))\n     (define remaining-items\
    \ (remove min-item lst))\n     (define max-item (max remaining-items))\n     (define\
    \ remaining-items (remove max-item remaining-items))\n     (cons min-item (cons\
    \ max-item (strange_sort_list remaining-items)))]))\n```\n\n## \u0417\u0430\u0434\
    \u0430\u0447\u0430 3 - \u0421\u0443\u043C\u0430\n\n\u0414\u0430 \u0441\u0435 \u043D\
    \u0430\u043F\u0438\u0448\u0435 \u0444\u0443\u043D\u043A\u0446\u0438\u044F `sum`,\
    \ \u043A\u043E\u044F\u0442\u043E \u043F\u0440\u0438\u0435\u043C\u0430 \u0434\u0432\
    \u0430 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u0430 `n` \u0438 `m`,\
    \ \u043A\u044A\u0434\u0435\u0442\u043E `n` \u0438 `m` \u0441\u0430 \u0446\u0435\
    \u043B\u0438 \u0447\u0438\u0441\u043B\u0430, \u0438 \u0432\u0440\u044A\u0449\u0430\
    \ \u0441\u0443\u043C\u0430\u0442\u0430 \u043D\u0430 \u0447\u0438\u0441\u043B\u0430\
    \u0442\u0430 \u043E\u0442 `n` \u0434\u043E `m` \u0432\u043A\u043B\u044E\u0447\u0438\
    \u0442\u0435\u043B\u043D\u043E.\n\n\u041F\u0440\u0438\u043C\u0435\u0440\u0438\
    :\n\n```racket\n>>> (sum 1 10)\n55\n>>> (sum 0 10)\n55\n>>> (sum -3 10)\n62\n\
    >>> (sum -1 -2)\n0\n```\n\n### \u041F\u0440\u0438\u043C\u0435\u0440\u043D\u043E\
    \ \u0440\u0435\u0448\u0435\u043D\u0438\u0435\n\n```racket", "  (define (partition\
    \ lst a b c)\n    (cond [(empty? lst) (values a b c)]\n          [(and (or (empty?\
    \ a) (&lt; (first lst) (car a)))\n                (or (empty? b) (&gt; (first\
    \ lst) (car b))))\n           (partition (rest lst) (cons (first lst) a) b c)]\n\
    \          [(or (empty? a) (= (first lst) (car a)))\n           (partition (rest\
    \ lst) a (cons (first lst) b) c)]\n          [(and (or (empty? b) (&gt; (first\
    \ lst) (car b)))\n                (or (empty? c) (&lt; (first lst) (car c))))\n\
    \           (partition (rest lst) a b (cons (first lst) c))]\n          [(or (empty?\
    \ b) (= (first lst) (car b)))\n           (partition (rest lst) a b (cons (first\
    \ lst) c))]\n          [else (error \"should not happen\")]))\n  (define (strange\
    \ lst a b)\n    (cond [(empty? lst) (values a b)]\n          [(or (empty? a) (=\
    \ (first lst) (car a)))\n           (strange (rest lst) a (cons (first lst) b))]\n\
    \          [(or (empty? b) (= (first lst) (car b)))\n           (strange (rest\
    \ lst) (cons (first lst) a) b)]\n          [else (error \"should not happen\"\
    )]))\n  (let-values ([(a b c) (partition lst (list) (list) (list))]\n        \
    \       [(a b) (strange c a b)])\n    (if (empty? a)\n        b\n        (append\
    \ a (reverse b)))))\n</code>\n", "  (cond\n    ((null? lst) '())\n    ((= (length\
    \ lst) 1) lst)\n    (else\n     (append\n      (list (apply min lst))\n      (list\
    \ (apply max (remove (apply min lst) lst)))\n      (strange_sort_list (remove\
    \ (apply max (remove (apply min lst) lst)) lst))))))", "  (if (null? lst)\n  \
    \    lst\n      (append (list (apply min lst))\n              (strange_sort_list\
    \ (remove (apply min lst) lst)))))\n", "  (cond [(empty? lst) empty]\n       \
    \ [else\n         (cons (min lst)\n               (cons (max (remove (min lst)\
    \ lst))\n                     (strange_sort_list (remove (max (remove (min lst)\
    \ lst)) lst))))]))\n", "  (let loop ((lst lst)\n             (new (list))\n  \
    \           (max lst)\n             (min lst))\n    (cond\n      ((null? lst)\
    \ new)\n      ((null? (cdr lst)) (append (list (car lst)) new))\n      (else\n\
    \       (loop (cdr lst)\n             (append (list (car lst) (car max) (car min))\
    \ new)\n             (cdr max)\n             (cdr min))))))\n</code>\nIf anyone\
    \ has a better solution in terms of performance, please share it.\n\n\nA:\n\n\
    Basic structure of solution\n\nStart by adding the first element from the list\
    \ to the result list.\nAdd the minimum of the remaining elements to the result\
    \ list.\nAdd the maximum of the remaining elements to the result list.\nGoto step\
    \ 1.\n\nRecursive solution\n<code>(define (strange-sort lst)\n  (if (null? lst)\n\
    \      '()\n      (if (null? (cdr lst))\n          lst\n          (append (list\
    \ (car lst)\n                        (apply min (cdr lst))\n                 \
    \       (apply max (cdr lst)))\n                  (strange-sort (cdr lst))))))\n\
    </code>\nIterative solution\n<code>(define (strange-sort lst)\n  (let loop ((lst\
    \ lst)\n             (res '()))\n    (if (null? lst)\n        res\n        (if\
    \ (null? (cdr lst))\n            (append lst res)\n            (loop (cdr lst)\n\
    \                  (append (list (car lst)\n                                (apply\
    \ min (cdr lst))\n                                (apply max (cdr lst)))\n   \
    \                       res))))))\n</code>\n", "  (define (go lst _min _max odd-turn)\n\
    \    (if (null? lst)\n        '()\n        (if odd-turn\n            (cons _min\
    \ (go (remove _min lst) _min _max (not odd-turn)))\n            (cons _max (go\
    \ (remove _max lst) _min _max (not odd-turn))))))\n  (if (null? lst)\n      '()\n\
    \      (let ([min (min lst)]\n            [max (max lst)])\n        (go lst min\
    \ max #t))))\n", "  (cond [(empty? lst) empty]\n        [else (cons (min lst)\n\
    \                    (cons (max (remove min lst))\n                          (strange_sort_list\
    \ (remove max (remove min lst)))))]))\n", "  (let* ([sorted (sort lst <)]\n  \
    \       [min (car sorted)]\n         [max (car (reverse sorted))]\n         [sorted-but-reversed\
    \ (reverse (cdr (reverse (cdr sorted))))])\n    (if (null? sorted)\n        '()\n\
    \        (append (list min max) (strange_sort_list sorted-but-reversed)))))\n\
    ```\n\n```racket\n#lang racket\n", "  (define (strange-sort lst acc)\n    (if\
    \ (null? lst) acc\n        (if (null? (cdr lst)) acc\n            (let ([max (apply\
    \ max lst)]\n                  [min (apply min lst)])\n              (strange-sort\
    \ (remove min (remove max lst))\n                            (append acc (list\
    \ min max)))))))\n  (strange-sort lst '()))\n</code>\nI really appreciate any\
    \ suggestions.\n\n\nA:\n\nIn racket, the most important function for list processing\
    \ is filter, which you might need to import first (note the plural). It's equivalent\
    \ to the <code>remove</code> procedure, but the order of arguments is reversed\
    \ and the predicate returns true if the item must be kept and false if it should\
    \ be removed. For example:\n<code>(filter (lambda (x) (&gt; x 2)) '(1 2 3 4))\n\
    </code>\nreturns <code>(3 4)</code>. Another important function is map, which\
    \ is like <code>filter</code> but generates a new list based on the elements of\
    \ the input list. For example:\n<code>(map (lambda (x) (* x x)) '(1 2 3 4))\n\
    </code>\nreturns <code>(1 4 9 16)</code>. Finally, there is foldl (or reduce),\
    \ which folds the elements of a list into a single value. For example:\n<code>(foldl\
    \ (lambda (x y) (* x y)) 1 '(1 2 3 4))\n</code>\nreturns <code>24</code>.\nNow,\
    \ you can rewrite your code using these functions. However, it's not clear to\
    \ me what is your desired output. If you can provide some example inputs and outputs,\
    \ we can better assist you with this exercise.\n", "  (if (null? lst)\n      lst\n\
    \      (begin\n        (sort lst (lambda (x y) (< x y)))\n        )))\n", "  (cond\
    \ [(empty? lst) empty]\n        [else\n         (cons (min lst)\n            \
    \   (cons (max (rest lst))\n                     (strange_sort_list (remove (min\
    \ lst) (remove (max (rest lst)) lst)))))]))\n", "  (define (min-first lst)\n \
    \   (if (null? lst) lst\n      (define min-value (apply min lst))\n      (cons\
    \ min-value (remove min-value lst))))\n  (define (max-first lst)\n    (if (null?\
    \ lst) lst\n      (define max-value (apply max lst))\n      (cons max-value (remove\
    \ max-value lst))))\n  (define (strange-sort lst)\n    (if (null? lst) lst\n \
    \     (append (min-first lst) (max-first (cdr lst)))))\n  (strange-sort lst))\n",
  "  (match lst\n    ('() '())\n    ((cons min tail)\n     (let loop ([lower min]\
    \ [upper (apply max tail)] [acc (list lower)])\n       (cond\n         [(null?\
    \ tail) (reverse acc)]\n         [(< lower upper) (loop upper (- lower upper)\
    \ (cons lower acc))]\n         [(= lower upper) (loop upper (- lower upper) (cons\
    \ lower acc))]\n         [(> lower upper) (loop lower (- upper lower) (cons upper\
    \ acc))])))))\n", "  (if (null? lst)\n      lst\n      (if (null? (cdr lst))\n\
    \          lst\n          (if (= (car lst) (cadr lst))\n              (cons (car\
    \ lst) (strange_sort_list (cdr lst)))\n              (cons (car lst) (cons (apply\
    \ max (filter (\u03BB (x) (not (= x (car lst)))) lst)) (strange_sort_list (filter\
    \ (\u03BB (x) (not (= x (car lst))) (filter (\u03BB (x) (not (= x (apply max (filter\
    \ (\u03BB (x) (not (= x (car lst)))) lst)))) lst))))))))))\n", "  (map (curry\
    \ list (min-by (lambda (x y)\n                        (< x y)) lst))\n       (range\
    \ 0 (add1 (length lst)) 2)))\n", "  (if (null? lst)\n      '()\n      (let* ([sorted\
    \ (sort < lst)]\n             [min (car sorted)]\n             [min-removed (remove\
    \ min sorted)]\n             [max (car (reverse sorted))]\n             [max-removed\
    \ (remove max min-removed)])\n        (cons min (strange_sort_list (append max-removed\
    \ min-removed))))))\n", "  (define (sort lst i)\n    (if (and (not (= (length\
    \ lst) 0)) (not (= (length lst) i)))\n        (sort (append (list (min lst) (max\
    \ lst)) (remove (min lst) (remove (max lst) lst))) (+ i 2))\n        lst))\n \
    \ (sort lst 0))\n", "  (if (= (length lst) 0)\n      '()\n      (let* ([max (apply\
    \ max lst)]\n             [min (apply min lst)]\n             [filtered-lst (remove\
    \ min (remove max lst))])\n        (cons min (cons max (strange_sort_list filtered-lst))))))\n",
  "  (define (accumulate lst sort odd-cnt even-cnt sort-lst)\n    (cond [(empty? lst)\
    \ sort-lst]\n          [(zero? odd-cnt) (accumulate (rest lst) sort (+ odd-cnt\
    \ 1) even-cnt\n                                       (append sort-lst (list (min\
    \ lst))))]\n          [(zero? even-cnt) (accumulate (rest lst) sort odd-cnt (+\
    \ even-cnt 1)\n                                        (append sort-lst (list\
    \ (max lst))))]\n          [else (accumulate (filter (lambda (n)\n           \
    \                           (not (equal? n (min lst) (max lst)))))\n         \
    \                   sort (+ odd-cnt 1) (- even-cnt 1)\n                      \
    \      (append sort-lst (list (min lst) (max lst))))]))\n  (if (empty? lst)\n\
    \      lst\n      (accumulate lst (sort < lst) 0 0 (list (min lst)))))\n</code>\n\
    I think this is the opposite of tail recursion, but how can I optimize/fix this?\n\
    \n\nA:\n\nI would phrase it more like this:\n<code>(define (accumulate orig odd\
    \ even sort)\n  (cond [(null? orig) sort]\n        [(null? odd) (accumulate orig\n\
    \                                 (list (min orig))\n                        \
    \         even\n                                 sort)]\n        [(null? even)\
    \ (accumulate orig\n                                  odd\n                  \
    \                (list (max orig))\n                                  sort)]\n\
    \        [else (accumulate (filter (lambda (e)\n                             \
    \       (not (or (equal? e (car odd))\n                                      \
    \       (equal? e (car even)))))\n                                  orig)\n  \
    \                     (cdr odd)\n                       (cdr even)\n         \
    \              (append sort (list (car odd) (car even))))]))\n", "  (cond [(empty?\
    \ lst) lst]\n        [else (append (list (min lst) (max lst))\n              \
    \        (strange_sort_list (remove* (min lst) (remove* (max lst) lst))))]))\n",
  "  (if (null? lst)\n      lst\n      (define (proccess lst)\n        (if (null?\
    \ lst)\n            lst\n            (append (list (min lst) (max lst)) (proccess\
    \ (filter (lambda (x) (not (or (= x (min lst)) (= x (max lst))))) lst)))))\n \
    \   (proccess lst)))\n", "  (if (null? lst)\n      '()\n      (strange_sort_list-recursive\
    \ lst '())))\n", "  (cond\n    [(empty? lst) empty]\n    [else (list (min lst)\
    \ (max lst) (strange_sort_list (remove (min lst) (remove (max lst) lst))))]))\n",
  "  (let loop ((lst lst)\n             (new-lst '()))\n    (cond ((null? lst) (reverse\
    \ new-lst))\n          (else\n           (if (null? (cdr lst))\n             \
    \  (loop (cdr lst) (cons (car lst) new-lst))\n               (if (> (car lst)\
    \ (cadr lst))\n                   (loop (append (reverse (cons (car lst) (cdr\
    \ lst))) '())\n                         (cons (car lst) new-lst))\n          \
    \         (loop (cdr lst) (cons (car lst) new-lst))))))))\n", "  (define (iter\
    \ lst mn mx res)\n    (cond\n      [(empty? lst) res]\n      [(< (first lst) mn)\
    \ (iter (rest lst) (first lst) mx res)]\n      [(> (first lst) mx) (iter (rest\
    \ lst) mn (first lst) res)]\n      [else (iter (rest lst) mn mx (append res (list\
    \ (first lst))))]))\n  (if (empty? lst) lst\n      (iter (rest lst) (first lst)\
    \ (first lst) (list (first lst)))))\n```\n\n<details>\n  <summary>\u041F\u0440\
    \u043E\u0432\u0435\u0440\u0438\u0442\u044C \u043A\u043E\u0434</summary>\n  \n\
    \  ```racket\n  (module+ test\n    (require rackunit)\n    (check-equal? (strange_sort_list\
    \ '()) '())\n    (check-equal? (strange_sort_list '(1 2 3 4)) '(1 4 2 3))\n  \
    \  (check-equal? (strange_sort_list '(5 5 5 5)) '(5 5 5 5))\n    (check-equal?\
    \ (strange_sort_list '(1 2 3 4 5)) '(1 5 2 4 3))\n    (check-equal? (strange_sort_list\
    \ '(5 4 3 2 1)) '(1 5 2 4 3))\n    (check-equal? (strange_sort_list '(5 5 5 5\
    \ 2 2 2 2 2)) '(5 5 5 5 2 2 2 2 2))\n    (check-equal? (strange_sort_list '(5\
    \ 4 3 2 1)) '(1 5 2 4 3))\n    (check-equal? (strange_sort_list '(1 3 5 4 2))\
    \ '(1 5 2 4 3))\n    (check-equal? (strange_sort_list '(1 2 3 4 5)) '(1 5 2 4\
    \ 3))\n    (check-equal? (strange_sort_list '(1 2 3 4 5 6)) '(1 6 2 5 3 4))\n\
    \    (check-equal? (strange_sort_list '(1 2 3 4 5 6 7)) '(1 7 2 6 3 5 4))\n  \
    \  (", "  (strange_sort_list_helper (remove-duplicates lst) lst))\n", "  (let\
    \ loop ([lst lst] [res (list)] [mins (list)] [maxs (list)])\n    (if (null? lst)\n\
    \        (if (null? mins)\n            res\n            (loop (if (null? maxs)\
    \ lst maxs) res (cdr mins) (list)))\n        (loop (cdr lst) (cons (car lst) res)\
    \ (cons (car lst) mins) (cons (car lst) maxs)))))\n</code>\nQuestion\n\nWhat do\
    \ you think of this approach?\nCan the implementation be improved?\n\n\n\nA:\n\
    \nI'm not sure what's the expected output for this, but I'm assuming that the\
    \ input list is sorted, and you want to get a 'strange-sorted' version of it,\
    \ by starting from the minimum and the maximum, etc.\n<code>(define (strange-sort\
    \ ls)\n  (define (next ls)\n    (define (remove-last ls)\n      (reverse (cdr\
    \ (reverse ls))))\n    (define (remove-first ls)\n      (cdr ls))\n    (let ([min\
    \ (apply min ls)])\n      (let ([max (apply max ls)])\n        (list min max (remove-last\
    \ (remove max ls)))\n        (remove-first (remove min ls))))))\n</code>\nPlease\
    \ have a look at Racket list API to find more useful functions: https://docs.racket-lang.org/reference/pairs.html\n",
  "  (cond ((null? lst) lst)\n        ((null? (cdr lst)) lst)\n        (else (append\
    \ (list (min-rem lst) (max-rem lst)) (strange_sort_list (lst-rem lst))))))\n",
  "  (cond ((empty? lst) empty)\n        ((and (rest lst) (rest (rest lst)))\n   \
    \      (cons (first lst)\n               (cons (last lst)\n                  \
    \   (strange_sort_list (rest (butlast lst))))))\n        (else lst)))\n", "  (if\
    \ (null? lst)\n      (list)\n      (append (list (apply min lst))\n          \
    \    (list (apply max lst))\n              (strange_sort_list (for/remove ([num\
    \ lst]\n                                               #:when (and (= num (apply\
    \ min lst))\n                                                           (= num\
    \ (apply max lst))))\n                                  num)))))\n</code>\nI would\
    \ like to know if there is a better solution for this.\n\n\nA:\n\nThere is a very\
    \ simple solution for this:\n<code>(define (strange-sort-list lst)\n  (define\
    \ (strange-sort-list! lst n)\n    (cond\n      [(null? lst) n]\n      [(null?\
    \ (cdr lst)) (reverse n)]\n      [else (strange-sort-list! (cddr lst) (cons (car\
    \ lst) (cons (cadr lst) n)))]))\n  (strange-sort-list! lst '()))\n</code>\nThe\
    \ reason why this works is that the ordered list can be obtained simply by reversing\
    \ the list that we obtain by taking the first, the third, the fifth... element\
    \ and then the second, the fourth, the sixth... element. Then we can use a simple\
    \ function to do this.\nIn the case of a singleton list the procedure just returns\
    \ the list. This is guaranteed by the fact that the <code>reverse</code> procedure\
    \ does nothing if the list has less than two elements.\n", "  (if (empty? lst)\n\
    \      '()\n      (let ([min (apply min lst)]\n            [rest (remove min lst)])\n\
    \        (cons min (strange_sort_list rest)))))\n", "  (cond\n    [(empty? lst)\
    \ empty]\n    [else\n     (cons (min lst)\n           (cons (max (remove (min\
    \ lst) lst))\n                 (strange_sort_list (remove (max (remove (min lst)\
    \ lst))\n                                            (remove (min lst) lst)))))]))\n",
  "  (cond\n    [(empty? lst)\n     empty]\n    [(pair? lst)\n     (append\n     \
    \ (list (max lst) (min lst))\n      (strange_sort_list (list-tail lst 2)))]))",
  "  (define (min lst)\n    (if (null? (cdr lst))\n        (car lst)\n        (if\
    \ (< (car lst) (min (cdr lst)))\n            (car lst)\n            (min (cdr\
    \ lst)))))\n  (define (max lst)\n    (if (null? (cdr lst))\n        (car lst)\n\
    \        (if (> (car lst) (max (cdr lst)))\n            (car lst)\n          \
    \  (max (cdr lst)))))\n  (define (max-lst lst)\n    (if (null? lst)\n        lst\n\
    \        (cons (max lst) (max-lst (remove (max lst) lst)))))\n  (define (min-lst\
    \ lst)\n    (if (null? lst)\n        lst\n        (cons (min lst) (min-lst (remove\
    \ (min lst) lst)))))\n  (define (sorted-lst lst)\n    (if (null? lst)\n      \
    \  lst\n        (append (cons (min (car lst)) (max-lst (cdr lst)))\n         \
    \       (sorted-lst (remove (min (car lst)) (cdr lst))))))\n  (sorted-lst lst))\n",
  "  (define (min-max-pair lst mm)\n    (cond ((null? lst) (values (car mm) (cdr mm)))\n\
    \          ((< (car lst) (car mm)) (min-max-pair (cdr lst) (cons (car lst) (cdr\
    \ mm))))\n          ((> (car lst) (cdr mm)) (min-max-pair (cdr lst) (cons (car\
    \ mm) (car lst))))\n          (else (min-max-pair (cdr lst) mm))))\n  (define\
    \ (next-min-max lst mm)\n    (if (= (length lst) 0)\n        (values '() '())\n\
    \        (let ((min (car mm))\n              (max (cdr mm)))\n          (values\
    \ (remove (lambda (x) (or (= x min) (= x max))) lst)\n                  (if (<\
    \ min max) (values min max) (values max min))))))\n  (let loop ((lst lst)\n  \
    \           (acc '()))\n    (if (null? lst)\n        acc\n        (let ((mm (min-max-pair\
    \ lst (cons (car lst) (car lst)))))\n          (let ((next-pair (next-min-max\
    \ lst mm)))\n            (loop (car next-pair)\n                  (append acc\
    \ (list (car mm) (cdr mm)))))))))\n", "  (cond [(null? lst) '()]\n        [else\
    \ (append (list (min lst) (max lst))\n                      (strange_sort_list\
    \ (remove (min lst) (remove (max lst) lst))))]))\n", "  (if (null? lst)\n    \
    \  '()\n      (append (list (min lst) (max lst)) (strange_sort_list (remove (min\
    \ lst) (remove (max lst) lst))))))\n", "  (define (sort_one lst asc)\n    (cond\
    \ ((null? lst) '())\n          ((null? (cdr lst)) lst)\n          (else\n    \
    \       (let* ((h (car lst))\n                  (t (cdr lst))\n              \
    \    (m (if asc (apply min t) (apply max t)))\n                  (i (if asc (index\
    \ m t) (reverse-index m t)))\n                  (a (append (take lst i) (drop\
    \ lst (+ i 1)))))\n             (cons m (sort_one a (not asc)))))))\n  (sort_one\
    \ lst #t))\n```\n\n## Solution 2:\n\n```racket\n#lang racket\n", "  (cond\n  \
    \  [(empty? lst) '()]\n    [(empty? (rest lst)) lst]\n    [else (cons (min (car\
    \ lst) (second lst))\n                 (cons (max (car lst) (second lst))\n  \
    \                     (strange_sort_list (rest (rest lst)))))]))\n", "  (if (null?\
    \ lst)\n      lst\n      (strange_sort_list_iter lst (length lst) (sort lst <)\
    \ (sort lst >))))\n", "  (cond\n    [(empty? lst) empty]\n    [else (cons (min\
    \ lst) (cons (max lst) (strange_sort_list (remove (min lst) (remove (max lst)\
    \ lst)))))]))\n", "  (if (null? lst)\n      (list)\n      (let ([lo (min lst)]\n\
    \            [hi (max lst)])\n        (cond [(= hi lo) (list hi)]\n          \
    \    [else (append (list lo hi)\n                            (strange_sort_list\
    \ (remove lo (remove hi lst))))]))))\n", "  (cond ((null? lst) '())\n        ((null?\
    \ (cdr lst)) lst)\n        (else (cons (min lst)\n                    (cons (max\
    \ (remove (min lst) lst))\n                          (strange_sort_list (remove\
    \ (max (remove (min lst) lst)) (remove (min lst) lst))))))))\n</code>\nI was sure\
    \ that the solution is not optimal. It is good when the length of list is even,\
    \ but when it is odd it makes one more loop. So I rewrote it:\n<code>#lang racket",
  "  (if (empty? lst)\n      lst\n      (if (empty? (rest lst))\n          lst\n \
    \         (strange_sort_list (list (min-list lst) (max-list (rest lst)) (strange_sort_list\
    \ (rest (remove (min-list lst) lst))))))))\n", "  (cond\n    [(empty? lst) empty]\n\
    \    [else\n     (define _min (apply min lst))\n     (define _rest (remove _min\
    \ lst))\n     (define _max (apply max _rest))\n     (append (list _min _max) (strange_sort_list\
    \ _rest))]))", "  (cond [(empty? lst) empty]\n        [else (cons (min lst)\n\
    \                    (cons (max (remove (min lst) lst))\n                    \
    \      (strange_sort_list (remove (max (remove (min lst) lst))\n             \
    \                                          (remove (min lst) lst)))))]))\n", " \
    \ (define (strange_sort_helper lst max_remaining min_remaining)\n    (cond ((null?\
    \ lst) '())\n          ((null? max_remaining) (cons min_remaining (strange_sort_helper\
    \ lst min_remaining (min-remaining min_remaining lst))))\n          ((null? min_remaining)\
    \ (cons max_remaining (strange_sort_helper lst (max-remaining max_remaining lst)\
    \ max_remaining)))\n          (else (cons min_remaining (cons max_remaining (strange_sort_helper\
    \ lst (max-remaining max_remaining lst) (min-remaining min_remaining lst)))))))\n\
    \  (strange_sort_helper lst '() '()))\n", "  (cond\n    [(empty? lst) empty]\n\
    \    [else\n     (let*\n         ([min-val (apply min lst)]\n          [max-val\
    \ (apply max lst)]\n          [rest (filter (lambda (x) (not (= x min-val)))(filter\
    \ (lambda (x) (not (= x max-val))) lst))])\n       (list min-val max-val (strange_sort_list\
    \ rest)))]))\n\n", "  (let loop ((lst lst)\n             (result (list)))\n  \
    \  (cond\n      [(empty? lst) (reverse result)]\n      [else\n       (let ((min\
    \ (min (first lst) (last lst)))\n             (max (max (first lst) (last lst))))\n\
    \         (loop (remove min (remove max lst))\n               (append result (list\
    \ min max))))])))\n", "  (strange_sort_helper lst '()))\n", "  (cond [(empty?\
    \ lst) empty]\n        [else\n         (let* ([min (apply min lst)]\n        \
    \        [remaining (remove min lst)]\n                [max (apply max remaining)]\n\
    \                [remaining2 (remove max remaining)])\n           (append (list\
    \ min max) (strange_sort_list remaining2)))]))\n", "  (cond [(empty? lst) empty]\n\
    \        [else (cons (min lst) (cons (max lst) (strange_sort_list (remove (min\
    \ lst) (remove (max lst) lst)))))]))\n", "  (reverse (sort lst <)))\n", "  (if\
    \ (null? lst)\n      (list)\n      (let loop ((lst lst)\n                 (sorted-lst\
    \ (list))\n                 (is-min? #t))\n        (if (null? lst)\n         \
    \   (reverse sorted-lst)\n            (let* ((lst-sorted (sort lst <))\n     \
    \              (min-max (if is-min? (car lst-sorted) (car (reverse lst-sorted)))))\n\
    \              (loop (remove min-max lst)\n                    (cons min-max sorted-lst)\n\
    \                    (not is-min?)))))))\n", "  (define (aux lst acc)\n    (cond\
    \ ((empty? lst) acc)\n          ((empty? (rest lst)) (cons (first lst) acc))\n\
    \          (else (aux (rest lst) (cons (first lst) (cons (first (reverse lst))\
    \ acc))))))\n  (if (empty? lst) lst (aux (rest lst) (list (first lst)))))\n",
  "  (if (null? lst)\n      '()\n      (append (list (min lst) (max lst))\n      \
    \        (strange_sort_list (remove (min lst)\n                              \
    \           (remove (max lst) lst))))))\n", "  (if (null? lst)\n      lst\n  \
    \    (cond\n       ((= (length lst) 1) lst)\n       ((= (length lst) 2) (list\
    \ (min lst) (max lst)))\n       (else\n        (append (list (min lst) (max lst))\n\
    \                (strange_sort_list (remove (min lst) (remove (max lst) lst))))))))\n",
  "  (cond\n    [(empty? lst) empty]\n    [else\n     (append\n      (list (min lst)\
    \ (max lst))\n      (strange_sort_list (remove (min lst) (remove (max lst) lst))))]))\n\
    ```\n\n```\n#lang racket\n", "  (if (null? lst)\n      (list)\n      (let loop\
    \ ([lst lst] [max (apply max lst)] [min (apply min lst)] [new-lst '()])\n    \
    \    (if (null? lst)\n            (reverse new-lst)\n            (loop (remove-first\
    \ max lst)\n                  (apply max lst)\n                  (apply min lst)\n\
    \                  (cons max (cons min new-lst))))))", "  (if (empty? lst)\n \
    \     (list)\n      (strange_sort_list' lst (list) (max lst) (min lst))))\n",
  "  (if (null? lst)\n      (list)\n      (if (null? (cdr lst))\n          (list (car\
    \ lst))\n          (let ([min-val (apply min lst)]\n                [max-val (apply\
    \ max lst)]\n                [remain (remove min-val (remove max-val lst))])\n\
    \            (cons min-val (cons max-val (strange_sort_list remain)))))))\n",
  "  (if (null? lst)\n      '()\n      (let ([sorted (sort lst <)])\n        (let\
    \ loop ([cur-idx 0] [acc '()])\n          (if (= cur-idx (length sorted))\n  \
    \            (reverse acc)\n              (let ([idx (+ cur-idx (if (even? cur-idx)\
    \ 1 -1))])\n                (loop (+ cur-idx 1) (cons (list-ref sorted idx) acc))))))))\n",
  "  (cond\n    [(null? lst) lst]\n    [(= (length lst) 1) lst]\n    [else\n     (let\
    \ ([min (apply min lst)]\n           [max (apply max lst)]\n           [others\
    \ (filter (lambda (x) (not (or (= x min) (= x max)))) lst)])\n       (cons min\
    \ (cons max (strange_sort_list others))))]))\n", "  (if (null? lst)\n      (list)\n\
    \      (sort (lambda (x y)\n              (if (odd? (- x y)) #t #f))\n       \
    \     lst)))", "  (define (min-max lst)\n    (let ((min (car lst))\n         \
    \ (max (car lst)))\n      (for ([item lst])\n        (if (&lt; item min)\n   \
    \         (set! min item))\n        (if (&gt; item max)\n            (set! max\
    \ item)))\n      (list min max)))\n  (if (empty? lst)\n      (list)\n      (append\
    \ (min-max lst)\n              (strange_sort_list (remove (min-max lst) lst)))))\n\
    </code>\n", "  (define (odd? n)\n    (= (remainder n 2) 1))\n  (define (make-pair)\n\
    \    (cons (apply min lst) (apply max lst)))\n  (define (iter new-lst pair)\n\
    \    (if (null? lst)\n        new-lst\n        (begin\n          (set! lst (remove\
    \ (car pair) lst))\n          (set! new-lst (append new-lst (list (car pair))))\n\
    \          (set! pair (make-pair))\n          (if (odd? (length new-lst))\n  \
    \            (set! pair (reverse pair))\n              #f)\n          (iter new-lst\
    \ pair))))\n  (iter (list) (make-pair)))\n```\n\n* [RacketGuile](RacketGuile.rkt)\n\
    \n```racket\n#lang racket\n", "  (cond\n    [(empty? lst) empty]\n    [else (cons\
    \ (min lst) (cons (max lst)\n                                (strange_sort_list\
    \ (remove (min lst) (remove (max lst) lst)))))]))\n", "  (cond ((null? lst) (list))\n\
    \        ((empty? lst) (list))\n        (else (append (list (min (filter (curry\
    \ eq? (min lst)) lst))\n                            (max (filter (curry eq? (max\
    \ lst)) lst)))\n                      (strange_sort_list (filter (curry not (curry\
    \ eq? (min lst)))\n                                                 (filter (curry\
    \ not (curry eq? (max lst))) lst)))))))", "  (define (loop lst out)\n    (cond\
    \ [(empty? lst) out]\n          [(<= (count lst) 2) (append out lst)]\n      \
    \    [else\n           (loop (append (list (min lst))\n                      \
    \   (list (max lst))\n                         (rest (rest lst)))\n          \
    \       (append out (list (min lst) (max lst))))]))\n  (loop lst empty))\n", " \
    \ (cond [(empty? lst) lst]\n        [else (append (list (min lst) (max lst))\n\
    \                      (strange_sort_list (filter (lambda (x) (and (not (= x (min\
    \ lst))) (not (= x (max lst))))) lst)))]))\n", "  (if (null? lst)\n      lst\n\
    \      (append (list (min lst) (max lst)) (strange_sort_list (remove (min lst)\
    \ (remove (max lst) lst))))))\n", "  (if (empty? lst)\n      lst\n      (strange_sort_list\
    \ (append (list (minimum lst) (maximum lst)) (remove (maximum lst) (remove (minimum\
    \ lst) lst))))))\n", "  (cond [(empty? lst) lst]\n        [else\n         (define\
    \ (partition lst mx mn)\n           (cond [(empty? lst) (list mx mn)]\n      \
    \           [(< (first lst) mn) (partition (rest lst) mx (first lst))]\n     \
    \            [(> (first lst) mx) (partition (rest lst) (first lst) mn)]\n    \
    \             [else (partition (rest lst) mx mn)]))\n         (define (build lst\
    \ result)\n           (cond [(empty? lst) result]\n                 [(empty? (rest\
    \ lst)) (append result lst)]\n                 [else (build (rest (rest lst))\
    \ (append result (list (first lst) (second lst))))]))\n         (define (min-max\
    \ lst)\n           (cond [(empty? lst) (error \"lst is empty\")]\n           \
    \      [(empty? (rest lst)) (list (first lst) (first lst))]\n                \
    \ [else (partition (rest lst) (first lst) (first lst))]))\n         (define (strange_sort\
    \ lst)\n           (cond [(empty? lst) empty]\n                 [else (build lst\
    \ (min-max lst))]))\n         (strange_sort lst)]))\n", "  (define (unzip lst\
    \ step)\n    (cond ((null? lst) (list null null))\n          ((= step 0) (list\
    \ (list (car lst)) (cdr lst)))\n          ((= step 1) (list (cdr lst) (list (car\
    \ lst))))\n          (else (error \"unreachable\"))))\n  (define (zip x y)\n \
    \   (cond ((null? x) y)\n          ((null? y) x)\n          (else (cons (car x)\
    \ (cons (car y) (zip (cdr x) (cdr y)))))))\n  (define (strange-help lst acc step)\n\
    \    (cond ((null? lst) (reverse acc))\n          (else (let* ((u (unzip lst step))\n\
    \                       (x (car u))\n                       (y (cdr u)))\n   \
    \               (strange-help y (zip x acc) (+ step 1))))))\n  (strange-help lst\
    \ null 0))", "  (define (strange_sort_list_helper lst rlst)\n    (if (empty? lst)\n\
    \        rlst\n        (let ([min_val (apply min lst)]\n              [max_val\
    \ (apply max lst)])\n          (strange_sort_list_helper (remove min_val lst)\n\
    \                                    (append rlst (list min_val max_val))))))\n\
    \  (strange_sort_list_helper lst '()))\n", "  (cond ((null? lst) '())\n      \
    \  ((= (length lst) 1) lst)\n        (else (cons (min lst)\n                 \
    \   (cons (max lst)\n                          (strange_sort_list (filter (lambda\
    \ (x) (not (or (= x (min lst)) (= x (max lst))))) lst)))))))\n</code>\nCan this\
    \ code be improved?\n\n\nA:\n\nSince your algorithm uses the <code>min</code>\
    \ and <code>max</code> procedures, the result will depend on the order of the\
    \ elements of the input list. I doubt it's what you want.\nAlso, to improve readability\
    \ you should avoid using an underscore in function names.\nHere's a more concise\
    \ version:\n<code>(define (strange-sort lst)\n  (cond\n    [(null? lst) '()]\n\
    \    [(= (length lst) 1) lst]\n    [else\n     (let* ([min-elt (min lst)]\n  \
    \          [max-elt (max lst)]\n            [rest (remove min-elt (remove max-elt\
    \ lst))])\n       (append (list min-elt max-elt) (strange-sort rest)))]))\n</code>\n",
  "  (let loop ((lst lst)\n             (res '()))\n    (if (null? lst)\n        res\n\
    \        (let ((minimum (apply min lst))\n              (maximum (apply max lst)))\n\
    \          (loop (remove (lambda (x) (= x minimum)) lst)\n                (append\
    \ res (list minimum)))))))\n", "  (define (maybe-append lst el)\n    (if (null?\
    \ lst)\n        lst\n        (cons el lst)))\n  (define (strange-sort lst)\n \
    \   (if (null? lst)\n        lst\n        (maybe-append (maybe-append (strange-sort\
    \ (cdr lst)) (car lst)) (apply max (cdr lst)))))\n  (strange-sort lst))\n", " \
    \ (cond\n    [(empty? lst) empty]\n    [else\n     (cons (min lst)\n         \
    \  (append (reverse (remove (min lst) lst))\n                   (remove (max lst)\
    \ (remove (min lst) lst))))]))\n</code>\nIt works fine, but I suspect it could\
    \ be done much more prettier. Please help make it more pretty.\n\n\nA:\n\nHere\
    \ is a one-liner:\n<code>(define (strange-sort-list lst)\n  (if (null? lst) lst\n\
    \      (cons (apply min lst) (strange-sort-list (remove (apply min lst) lst)))))\n\
    </code>\nI think you'll find that this is much prettier than what you have.  The\
    \ functions are the same, but the names are consistent and there is less noise.\n",
  "  (if (null? lst)\n      lst\n      (list (min lst) (max lst) (strange_sort_list\
    \ (remove (min lst) (remove (max lst) lst))))))", "  (if (empty? lst) lst\n  \
    \    (if (= (length lst) 1) lst\n          (cons (min lst) (cons (max lst) (strange_sort_list\
    \ (delete (min lst) (delete (max lst) lst))))))))\n", "  (if (null? lst)\n   \
    \   '()\n      (cond\n       [(empty? (rest lst))\n        lst]\n       [(empty?\
    \ (rest (rest lst)))\n        (append (list (minimum lst)) (list (maximum lst)))]\n\
    \       [else\n        (append (list (minimum lst))\n                (strange_sort_list\
    \ (remove (minimum lst) lst)))])))\n", "  (define (strange_sort lst res)\n   \
    \ (cond\n      [(empty? lst) res]\n      [(empty? (rest lst)) (append res lst)]\n\
    \      [else\n       (define minimum (apply min lst))\n       (define minimum-index\
    \ (index-of minimum lst))\n       (define maximum (apply max (remove minimum lst)))\n\
    \       (define maximum-index (index-of maximum (remove minimum lst)))\n     \
    \  (strange_sort (remove-ith minimum-index lst)\n                     (append\
    \ res (list minimum maximum)))]))\n  (strange_sort lst empty))\n", "  (strange_sort_list_iter\
    \ lst '()))\n", "  (cond ((or (null? lst) (null? (cdr lst))) lst)\n        (else\n\
    \         (let ([fst (min lst)]\n               [snd (max (remove fst lst))])\n\
    \           (list fst snd (strange_sort_list (remove snd (remove fst lst))))))))\n",
  "  (if (null? lst)\n      (list)\n      (append (list (min lst) (max lst))\n   \
    \           (strange_sort_list (filter (lambda (x) (not (or (= x (min lst)) (=\
    \ x (max lst))))) lst)))))\n", "  (if (null? lst)\n      '()\n      (append (list\
    \ (min lst) (max lst))\n              (strange_sort_list (remove (min lst) (remove\
    \ (max lst) lst))))))\n</code>\n", "  (define (sort_list lst min)\n    (define\
    \ (inner-sort-list lst)\n      (cond [(empty? lst) lst]\n            [(= (length\
    \ lst) 1) lst]\n            [else\n             (append (list min)\n         \
    \            (inner-sort-list (remove min lst)))]))\n    (inner-sort-list lst))\n\
    \  (define (sorted-list-with-min lst)\n    (let* ([min (apply min lst)]\n    \
    \       [sorted-list (sort_list lst min)])\n      sorted-list))\n  (define (sorted-list-with-max\
    \ lst)\n    (let* ([max (apply max lst)]\n           [sorted-list (sort_list lst\
    \ max)])\n      sorted-list))\n  (define (is-min-first lst)\n    (let* ([min (apply\
    \ min lst)]\n           [first (first lst)])\n      (= min first)))\n  (define\
    \ (strange-sort lst)\n    (cond [(empty? lst) lst]\n          [(= (length lst)\
    \ 1) lst]\n          [(is-min-first lst)\n           (append (list (first lst))\n\
    \                   (strange-sort (rest lst)))]\n          [else\n           (append\
    \ (list (first lst))\n                   (strange-sort (list (apply max (rest\
    \ lst))))\n                   (strange-sort (remove (apply max (rest lst)) (rest\
    \ lst))))]))\n  (strange-sort lst))\n", "  (define (min-max-helper lst acc)\n\
    \    (if (empty? lst)\n        acc\n        (let* ([min (argmin lst)]\n      \
    \         [max (argmax lst)]\n               [min-val (list-ref lst min)]\n  \
    \             [max-val (list-ref lst max)])\n          (min-max-helper (remove\
    \ lst min max) (append acc (list min-val max-val))))))\n  (min-max-helper lst\
    \ empty))\n", "  (cond\n    [(empty? lst) '()]\n    [else\n     (if (null? (cdr\
    \ lst))\n         lst\n         (append (list (apply min lst))\n             \
    \    (list (apply max lst))\n                 (strange_sort_list (remove (apply\
    \ min lst) (remove (apply max lst) lst)))))]))\n", "  (cond\n    [(empty? lst)\
    \ lst]\n    [(= (count lst) 1) lst]\n    [else\n     (append\n      (list (min\
    \ lst) (max lst))\n      (strange_sort_list (remove (min lst) (remove (max lst)\
    \ lst))))]))\n", "  (if (empty? lst)\n      (list)\n      (let ([min (apply min\
    \ lst)]\n            [max (apply max lst)]\n            [rem (remove min (remove\
    \ max lst))])\n        (append (list min max) (strange_sort_list rem)))))\n",
  "  (cond\n    [(null? lst) '()]\n    [(= (length lst) 1) lst]\n    [else (strange_sort_list\n\
    \            (cons (car lst)\n                  (append (list (list-ref lst (sub1\
    \ (length lst))))\n                          (strange_sort_list (list-tail lst\
    \ 1)))))]))\n", "  (if (equal? (length lst) 0)\n      empty\n      (let ((ordered-list\
    \ (sort lst <)))\n        (list (first ordered-list)\n              (last ordered-list)\n\
    \              (strange_sort_list (rest (butlast ordered-list)))))))\n", "  (cond\n\
    \    [(null? lst) (list)]\n    [(= (length lst) 1) lst]\n    [else\n     (let*\
    \ ([lst1 (sort (list) > (list-ref lst 0))]\n            [lst2 (sort (list) < (sublist\
    \ lst 1))])\n       (append lst1 lst2))]))\n", "  (define (sort_it l s r)\n  \
    \  (cond ((null? l) r)\n          ((null? s) (sort_it (cdr l) (cdr s) (cons (car\
    \ l) r)))\n          (else (sort_it (cdr l) (cdr s) (cons (car s) (cons (car l)\
    \ r))))))\n  (define (strange_sort lst)\n    (cond ((null? lst) '())\n       \
    \   ((null? (cdr lst)) lst)\n          (else (sort_it (cdr lst) (cdr lst) (list\
    \ (car lst))))))\n  (reverse (strange_sort (reverse lst))))\n", "  (cond ((null?\
    \ lst) '())\n        ((or (null? (cdr lst))\n             (null? (cddr lst)))\
    \ lst)\n        (else (strange_sort_lst_helper (sort lst <) '()))))\n", "  (if\
    \ (null? lst)\n      '()\n      (list (min (list (car lst) (cadr lst)))\n    \
    \        (max (list (car lst) (cadr lst)))\n            (min (list (cadr lst)\
    \ (caddr lst)))\n            (max (list (cadr lst) (caddr lst)))\n           \
    \ (min (list (caddr lst) (cadddr lst)))\n            (max (list (caddr lst) (cadddr\
    \ lst)))\n            (min (list (cadddr lst) (caddddr lst)))\n            (max\
    \ (list (cadddr lst) (caddddr lst)))\n            (min (list (caddddr lst) (cadddddr\
    \ lst)))\n            (max (list (caddddr lst) (cadddddr lst)))\n            (min\
    \ (list (cadddddr lst) (caddddddr lst)))\n            (max (list (cadddddr lst)\
    \ (caddddddr lst)))\n            (min (list (caddddddr lst) (cadddddddr lst)))\n\
    \            (max (list (caddddddr lst) (cadddddddr lst)))\n            (min (list\
    \ (cadddddddr lst) (caddddddddr lst)))\n            (max (list (cadddddddr lst)\
    \ (caddddddddr lst)))\n            (min (list (caddddddddr lst) (cadddddddddr\
    \ lst)))\n            (max (list (caddddddddr lst) (cadddddddddr lst)))\n    \
    \        (min (list (cadddddddddr lst) (caddddddddddr lst)))\n            (max\
    \ (list (cadddddddddr lst) (caddddddddddr lst)))\n            (min (list (caddddddddddr\
    \ lst) (cadddddddddddr lst)))\n            (max (list (", "  (letrec\n      ((new-lst\
    \ (list))\n       (help (lambda (lst new-lst)\n               (if (null? lst)\
    \ new-lst\n                   (begin\n                     (set! new-lst (append\
    \ new-lst (list (min lst) (max lst))))\n                     (help (remove (min\
    \ lst) (remove (max lst) lst)) new-lst))))))\n    (help lst new-lst)))\n", " \
    \ (cond [(empty? lst) empty]\n        [else (cons (min lst)\n                \
    \    (cons (max (remove (min lst) lst))\n                          (strange_sort_list\
    \ (remove (max (remove (min lst) lst)) lst))))]))\n", "  (if (null? lst)\n   \
    \   '()\n      (begin\n        (display \"Hello\")\n        (display lst)\n  \
    \      (newline)\n        '())))\n", "  (cond ((null? lst) lst)\n        ((= (length\
    \ lst) 1) lst)\n        (else (cond ((and (null? (cdr lst))\n                \
    \         (= (car lst) (cadr lst))) lst)\n                    ((or (= (car lst)\
    \ (cadr lst))\n                         (and (null? (cddr lst))\n            \
    \                  (= (car lst) (caddr lst)))) (cons (car lst) (strange_sort_list\
    \ (cdr lst))))\n                    (else (cons (car lst) (cons (cadr (reverse\
    \ lst)) (strange_sort_list (cddr lst)))))))))\n\n", "  (if (null? lst)\n     \
    \ lst\n      (if (null? (cdr lst))\n          lst\n          (let ([min (apply\
    \ min lst)]\n                [max (apply max lst)])\n            (list min max\
    \ (strange_sort_list (filter (lambda (x) (and (&lt; x max) (&gt; x min))) lst)))))))\n\
    </code>\nI realize that I could use <code>sort</code> but I want to do it manually.\
    \ \n\n\nA:\n\nI suggest you this:\n<code>(define (strange-sort-list lst)\n  (if\
    \ (null? lst)\n      '()\n      (if (null? (cdr lst))\n          lst\n       \
    \   (append (list (apply min lst) (apply max lst))\n                  (strange-sort-list\
    \ (remove (lambda (x) (or (equal? x (apply min lst))\n                       \
    \                                      (equal? x (apply max lst))))\n        \
    \                                       lst))))))\n</code>\nIt works as follows:\n\
    <code>(strange-sort-list '(1 2 3 4))\n=&gt; '(1 4 2 3)\n", "  (if (null? lst)\n\
    \      '()\n      (let* ([min-val (apply min lst)]\n             [max-val (apply\
    \ max lst)]\n             [new-lst (remove min-val lst)]\n             [new-lst\
    \ (remove max-val new-lst)])\n        (cons min-val (cons max-val (strange_sort_list\
    \ new-lst))))))\n", "  (cond\n    [(null? lst) '()]\n    [(null? (cdr lst)) lst]\n\
    \    [else (append (list (min lst) (max lst)) (strange_sort_list (remove (min\
    \ lst) (remove (max lst) lst))))]))\n```\n\n```scheme\n#lang racket\n", "  (cond\
    \ [(null? lst) lst]\n        [else (cond [(= (length lst) 1) lst]\n          \
    \          [else (let ([sorted (sort lst >)])\n                            (cond\
    \ [(even? (length sorted))\n                                   (even_sort sorted)]\n\
    \                                  [else (odd_sort sorted)]))])]))\n", "  (if\
    \ (null? lst)\n      null\n      (append (list (min lst) (max lst))\n        \
    \      (strange_sort_list (for/list ([x lst] #:when (not (or (= x (min lst)) (=\
    \ x (max lst)))) ) x)))))\n", "  (if (null? lst)\n      '()\n      (if (null?\
    \ (cdr lst))\n          (list (car lst))\n          (let* ([min (apply min lst)]\n\
    \                 [max (apply max lst)]\n                 [rest (remv min (remv\
    \ max lst))])\n            (append (list min max) (strange_sort_list rest))))))\n",
  "  (if (null? lst)\n      lst\n      (append (list (min lst) (max lst))\n      \
    \        (strange_sort_list (remove (min lst) (remove (max lst) lst))))))\n",
  "  (if (null? lst)\n      (list)\n      (append (list (min lst) (max lst))\n   \
    \           (strange_sort_list (list-remove (min lst) (list-remove (max lst) lst))))))\n",
  "  (let ([lst-sorted (sort lst <)])\n    (cond\n      [(&gt; (length lst-sorted)\
    \ 1)\n       (append\n        (list (first lst-sorted) (last lst-sorted))\n  \
    \      (strange_sort_list (remove (first lst-sorted) (remove (last lst-sorted)\
    \ lst-sorted))))]\n      [else lst-sorted])))\n</code>\n", "  (cond\n    [(= (length\
    \ lst) 0) (list)]\n    [(= (length lst) 1) lst]\n    [else\n     (cond\n     \
    \  [(= (length lst) 2) (cons (min lst) (list (max lst)))]\n       [else\n    \
    \    (cons (min lst) (cons (max lst) (strange_sort_list (sublist lst (min lst)\
    \ (max lst))))])]))\n", "  (if (null? lst)\n      (list)\n      (append (list\
    \ (apply min lst))\n              (list (apply max lst))\n              (strange_sort_list\
    \ (remove (apply min lst) (remove (apply max lst) lst))))))\n", "  (cond [(empty?\
    \ lst) empty]\n        [else (cons (min lst)\n                    (cons (max (remove\
    \ (min lst) lst))\n                          (strange_sort_list (remove (max (remove\
    \ (min lst) lst))\n                                                       (remove\
    \ (min lst) lst)))))]))\n", "  (if (= (length lst) 0)\n      lst\n      (append\
    \ (list (apply min lst))\n              (list (apply max lst))\n             \
    \ (strange_sort_list (remove (apply min lst) (remove (apply max lst) lst))))))\n\
    ```\n</details>\n\n## Copy List\n<details>\n<summary>View solution</summary>\n\
    \n```racket\n#lang racket\n", "  (cond [(empty? lst) empty]\n        [else\n \
    \        (let ([min (min-list lst)]\n               [max (max-list lst)])\n  \
    \         (cond [(and (empty? (remove min lst))\n                       (empty?\
    \ (remove max lst)))\n                  (list min max)]\n                 [else\n\
    \                  (append (list min max)\n                          (strange_sort_list\
    \ (remove (list min max) lst)))]))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
