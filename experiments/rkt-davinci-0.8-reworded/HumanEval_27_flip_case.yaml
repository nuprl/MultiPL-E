name: HumanEval_27_flip_case
language: rkt
prompt: "#lang racket\n\n;; For a given string, flip lowercase characters to uppercase\
  \ and uppercase to lowercase.\n;; >>> (flip_case \"Hello\")\n;; \"hELLO\"\n(define\
  \ (flip_case string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"Hello!\"\
  ) \"hELLO!\")\n    (check-equal? (candidate \"These violent delights have violent\
  \ ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n))\n\n(test-humaneval)"
completions: ["  (string-map (lambda (c)\n                (if (char-lower-case? c)\n\
    \                    (char-upcase c)\n                    (char-downcase c)))\n\
    \              string))\n", "  (map (\u03BB (c)\n         (if (char-ci&gt;=? c\
    \ #\\a)\n             (char-upcase c)\n             (char-downcase c)))\n    \
    \   string))\n</code>\nThis might be considered \"clever\", but it's definitely\
    \ not idiomatic Racket.\n<code>#lang racket\n", "  (string-&gt;list string))\n",
  "  (for/list ([c (in-string string)])\n    (cond\n      [(char-upcase? c) (char-downcase\
    \ c)]\n      [(char-lowercase? c) (char-upcase c)]\n      [else c])))\n", "  (map\
    \ (lambda (ch)\n         (if (char-downcase? ch)\n             (char-upcase ch)\n\
    \             (char-downcase ch)))\n       string))\n", "  (let loop ([chars (string->list\
    \ string)]\n             [result '()])\n    (if (null? chars)\n        (list->string\
    \ (reverse result))\n        (let ([char (car chars)])\n          (if (char-alphabetic?\
    \ char)\n              (if (char-lower-case? char)\n                  (loop (cdr\
    \ chars) (cons (char-upcase char) result))\n                  (loop (cdr chars)\
    \ (cons (char-downcase char) result)))\n              (loop (cdr chars) (cons\
    \ char result)))))))\n```\n\n```racket\n#lang racket\n", "  (list->string (map\
    \ (lambda (x) (if (char-upcase? x) (char-downcase x) (char-upcase x)))\n     \
    \                (string->list string))))\n", "  (regexp-replace* #rx\"[a-z]\"\
    \ string (lambda (substring) (string-upcase substring))))\n", "  (string-map (\u03BB\
    \ (s) (if (char-upper-case? s) (char-downcase s) (char-upcase s))) string))\n",
  "  (for/list ([ch (in-string string)])\n    (if (char-alphabetic? ch)\n        (if\
    \ (char-lower-case? ch)\n            (char-upcase ch)\n            (char-downcase\
    \ ch))\n        ch)))\n", "  (string-map \n   (lambda (x)\n     (if (char-lower-case?\
    \ x)\n         (char-upcase x)\n         (char-downcase x)))\n   string))\n",
  "  (regexp-replace* #rx\"[a-z]\" string\n                   (lambda (a)\n      \
    \               (string-upcase a))\n                   #:case-sensitive? #f))\n",
  "  (string-append (string-map (\u03BB (c) (if (char-lower-case? c) (char-upcase\
    \ c) (char-downcase c))) string)))", "  (map char-upcase string))\n", "  (string-append\n\
    \   (string-map (\u03BB (ch)\n                 (cond\n                   [(and\
    \ (char-alphabetic? ch) (char-lower-case? ch)) (char-upcase ch)]\n           \
    \        [(and (char-alphabetic? ch) (char-upper-case? ch)) (char-downcase ch)]\n\
    \                   [else ch]))\n               string)))\n", "  (string-map (\u03BB\
    \ (c)\n                (if (char-upcase? c)\n                    (char-downcase\
    \ c)\n                    (char-upcase c)))\n              string))\n", "  (apply\
    \ string-append\n    (map\n      (lambda (c)\n        (cond\n          [(char-lower-case?\
    \ c) (char-upcase c)]\n          [(char-upper-case? c) (char-downcase c)]\n  \
    \        [else c]))\n      string)))\n", "  (string-map (\u03BB (c)\n    (if (char-ci=?\
    \ c #\\A) #\\a\n    (if (char-ci=? c #\\B) #\\b\n    (if (char-ci=? c #\\C) #\\\
    c\n    (if (char-ci=? c #\\D) #\\d\n    (if (char-ci=? c #\\E) #\\e\n    (if (char-ci=?\
    \ c #\\F) #\\f\n    (if (char-ci=? c #\\G) #\\g\n    (if (char-ci=? c #\\H) #\\\
    h\n    (if (char-ci=? c #\\I) #\\i\n    (if (char-ci=? c #\\J) #\\j\n    (if (char-ci=?\
    \ c #\\K) #\\k\n    (if (char-ci=? c #\\L) #\\l\n    (if (char-ci=? c #\\M) #\\\
    m\n    (if (char-ci=? c #\\N) #\\n\n    (if (char-ci=? c #\\O) #\\o\n    (if (char-ci=?\
    \ c #\\P) #\\p\n    (if (char-ci=? c #\\Q) #\\q\n    (if (char-ci=? c #\\R) #\\\
    r\n    (if (char-ci=? c #\\S) #\\s\n    (if (char-ci=? c #\\T) #\\t\n    (if (char-ci=?\
    \ c #\\U) #\\u\n    (if (char-ci=? c #\\V) #\\v\n    (if (char-ci=? c #\\W) #\\\
    w\n    (if (char-ci=? c #\\X) #\\x\n    (if (char-ci=? c #\\Y) #\\y\n    (if (char-ci=?\
    \ c #\\Z) #\\z\n    (if (char-ci=? c #\\a) #\\A\n    (if (char-ci=? c #\\b)",
  "  (build-string (string-length string)\n                (lambda (i)\n         \
    \         (if (char-lower-case? (string-ref string i))\n                     \
    \ (char-upcase (string-ref string i))\n                      (char-downcase (string-ref\
    \ string i))))))\n", "  (for/list ([c (in-string string)])\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
