name: HumanEval_27_flip_case
language: rkt
prompt: "#lang racket\n\n;; For a given string, flip lowercase characters to uppercase\
  \ and uppercase to lowercase.\n;; >>> (flip_case \"Hello\")\n;; \"hELLO\"\n(define\
  \ (flip_case string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"Hello!\"\
  ) \"hELLO!\")\n    (check-equal? (candidate \"These violent delights have violent\
  \ ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n))\n\n(test-humaneval)"
completions: ["  (string-map (lambda (c)\n                (if (char-lower-case? c)\n\
    \                    (char-upcase c)\n                    (char-downcase c)))\n\
    \              string))\n", "  (map (\u03BB (c)\n         (if (char-ci&gt;=? c\
    \ #\\a)\n             (char-upcase c)\n             (char-downcase c)))\n    \
    \   string))\n</code>\nThis might be considered \"clever\", but it's definitely\
    \ not idiomatic Racket.\n<code>#lang racket\n", "  (string-&gt;list string))\n",
  "  (for/list ([c (in-string string)])\n    (cond\n      [(char-upcase? c) (char-downcase\
    \ c)]\n      [(char-lowercase? c) (char-upcase c)]\n      [else c])))\n", "  (map\
    \ (lambda (ch)\n         (if (char-downcase? ch)\n             (char-upcase ch)\n\
    \             (char-downcase ch)))\n       string))\n", "  (let loop ([chars (string->list\
    \ string)]\n             [result '()])\n    (if (null? chars)\n        (list->string\
    \ (reverse result))\n        (let ([char (car chars)])\n          (if (char-alphabetic?\
    \ char)\n              (if (char-lower-case? char)\n                  (loop (cdr\
    \ chars) (cons (char-upcase char) result))\n                  (loop (cdr chars)\
    \ (cons (char-downcase char) result)))\n              (loop (cdr chars) (cons\
    \ char result)))))))\n```\n\n```racket\n#lang racket\n", "  (list->string (map\
    \ (lambda (x) (if (char-upcase? x) (char-downcase x) (char-upcase x)))\n     \
    \                (string->list string))))\n", "  (regexp-replace* #rx\"[a-z]\"\
    \ string (lambda (substring) (string-upcase substring))))\n", "  (string-map (\u03BB\
    \ (s) (if (char-upper-case? s) (char-downcase s) (char-upcase s))) string))\n",
  "  (for/list ([ch (in-string string)])\n    (if (char-alphabetic? ch)\n        (if\
    \ (char-lower-case? ch)\n            (char-upcase ch)\n            (char-downcase\
    \ ch))\n        ch)))\n", "  (string-map \n   (lambda (x)\n     (if (char-lower-case?\
    \ x)\n         (char-upcase x)\n         (char-downcase x)))\n   string))\n",
  "  (regexp-replace* #rx\"[a-z]\" string\n                   (lambda (a)\n      \
    \               (string-upcase a))\n                   #:case-sensitive? #f))\n",
  "  (string-append (string-map (\u03BB (c) (if (char-lower-case? c) (char-upcase\
    \ c) (char-downcase c))) string)))", "  (map char-upcase string))\n", "  (string-append\n\
    \   (string-map (\u03BB (ch)\n                 (cond\n                   [(and\
    \ (char-alphabetic? ch) (char-lower-case? ch)) (char-upcase ch)]\n           \
    \        [(and (char-alphabetic? ch) (char-upper-case? ch)) (char-downcase ch)]\n\
    \                   [else ch]))\n               string)))\n", "  (string-map (\u03BB\
    \ (c)\n                (if (char-upcase? c)\n                    (char-downcase\
    \ c)\n                    (char-upcase c)))\n              string))\n", "  (apply\
    \ string-append\n    (map\n      (lambda (c)\n        (cond\n          [(char-lower-case?\
    \ c) (char-upcase c)]\n          [(char-upper-case? c) (char-downcase c)]\n  \
    \        [else c]))\n      string)))\n", "  (string-map (\u03BB (c)\n    (if (char-ci=?\
    \ c #\\A) #\\a\n    (if (char-ci=? c #\\B) #\\b\n    (if (char-ci=? c #\\C) #\\\
    c\n    (if (char-ci=? c #\\D) #\\d\n    (if (char-ci=? c #\\E) #\\e\n    (if (char-ci=?\
    \ c #\\F) #\\f\n    (if (char-ci=? c #\\G) #\\g\n    (if (char-ci=? c #\\H) #\\\
    h\n    (if (char-ci=? c #\\I) #\\i\n    (if (char-ci=? c #\\J) #\\j\n    (if (char-ci=?\
    \ c #\\K) #\\k\n    (if (char-ci=? c #\\L) #\\l\n    (if (char-ci=? c #\\M) #\\\
    m\n    (if (char-ci=? c #\\N) #\\n\n    (if (char-ci=? c #\\O) #\\o\n    (if (char-ci=?\
    \ c #\\P) #\\p\n    (if (char-ci=? c #\\Q) #\\q\n    (if (char-ci=? c #\\R) #\\\
    r\n    (if (char-ci=? c #\\S) #\\s\n    (if (char-ci=? c #\\T) #\\t\n    (if (char-ci=?\
    \ c #\\U) #\\u\n    (if (char-ci=? c #\\V) #\\v\n    (if (char-ci=? c #\\W) #\\\
    w\n    (if (char-ci=? c #\\X) #\\x\n    (if (char-ci=? c #\\Y) #\\y\n    (if (char-ci=?\
    \ c #\\Z) #\\z\n    (if (char-ci=? c #\\a) #\\A\n    (if (char-ci=? c #\\b)",
  "  (build-string (string-length string)\n                (lambda (i)\n         \
    \         (if (char-lower-case? (string-ref string i))\n                     \
    \ (char-upcase (string-ref string i))\n                      (char-downcase (string-ref\
    \ string i))))))\n", "  (for/list ([c (in-string string)])\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c)))\n", "  (string-append \n   (map (lambda\
    \ (c) (char-upcase c)) (regexp-match-all \"[a-z]+\" string))\n   (map (lambda\
    \ (c) (char-downcase c)) (regexp-match-all \"[A-Z]+\" string))))\n", "  (string-map\n\
    \   (lambda (ch)\n     (cond\n       [(char-lower-case? ch) (char-upcase ch)]\n\
    \       [(char-upper-case? ch) (char-downcase ch)]\n       [else ch]))\n   string))\n\
    </code>\n", "  (string-map\n   (lambda (ch)\n     (cond\n       [(char-alphabetic?\
    \ ch)\n        (if (char-lower-case? ch)\n            (char-upcase ch)\n     \
    \       (char-downcase ch))]\n       [else ch]))\n   string))\n", "  (for/list\
    \ ([ch (in-string string)])\n    (if (char-upcase? ch)\n        (char-downcase\
    \ ch)\n        (char-upcase ch))))\n", "  (let loop ([i 0] [flipped #f])\n   \
    \ (cond\n      [(string=? string flipped) flipped]\n      [(string=? (string-ref\
    \ string i) (string-downcase (string-ref string i)))\n       (loop (+ i 1) (string-append\
    \ flipped (string-upcase (string-ref string i))))]\n      [(string=? (string-ref\
    \ string i) (string-upcase (string-ref string i)))\n       (loop (+ i 1) (string-append\
    \ flipped (string-downcase (string-ref string i))))]\n      [else (loop (+ i 1)\
    \ (string-append flipped (string-ref string i)))])))\n", "  (string-&gt;list string))\n",
  "  (define (flip_case-iter string result)\n    (cond\n      [(empty? string) result]\n\
    \      [(char-lower-case? (first string))\n       (flip_case-iter (rest string)\
    \ (string-append result (string-upcase (first string))))]\n      [(char-upper-case?\
    \ (first string))\n       (flip_case-iter (rest string) (string-append result\
    \ (string-downcase (first string))))]\n      [else (flip_case-iter (rest string)\
    \ (string-append result (first string)))]))\n  (flip_case-iter string \"\"))\n",
  "  (string-join (map (\u03BB (c) (if (char-lower-case? c) (char-upcase c) (char-downcase\
    \ c))) (string->list string))))\n", "  (string-map (lambda (c)\n             \
    \   (if (char-lower-case? c)\n                    (char-upcase c)\n          \
    \          (char-downcase c)))\n              string))\n", "  (build-string (string-length\
    \ string)\n                (lambda (i)\n                  (if (char-upper-case?\
    \ (string-ref string i))\n                      (char-downcase (string-ref string\
    \ i))\n                      (char-upcase (string-ref string i))))))\n", "  (string-map\n\
    \   (lambda (x)\n     (if (char-lower-case? x)\n         (char-upcase x)\n   \
    \      (char-downcase x)))\n   string))\n```\n\n```scheme\n#lang racket\n", " \
    \ (string-map (\u03BB (c) (string-downcase (string-upcase c))) string))\n", " \
    \ (string-map (\u03BB (c)\n\t\t(if (char-lower-case? c)\n\t\t    (char-upcase\
    \ c)\n\t\t    (char-downcase c)))\n\t      string))\n", "  (string-map #\\uppercase?\n\
    \              (string-map #\\lowercase?\n                          string)))\n\
    ```\n\n```racket", "  (string-map\n   (\u03BB (c)\n     (cond\n       [(char-lower-case?\
    \ c) (char-upcase c)]\n       [(char-upper-case? c) (char-downcase c)]\n     \
    \  [else c]))\n   string))\n", "  (string-map\n   (lambda (ch)\n     (if (char-upper-case?\
    \ ch)\n         (char-downcase ch)\n         (char-upcase ch)))\n   string))\n",
  "  (string-&gt;list string))\n</code>\nThis is my attempt, which works but I know\
    \ there is a better way.\n<code>#lang racket\n", "  (string-map (lambda (char)\
    \ (if (char-lower-case? char) (char-upcase char) (char-downcase char))) string))\n",
  "  (string-join (map (lambda (c) (if (char-upcase? c) (char-downcase c) (char-upcase\
    \ c))) string)))\n", "  (cond\n    [(= (string-length string) 0)\n     \"\"\n\
    \     ]\n    [else\n     (string-append\n      (cond\n        [(char-downcase?\
    \ (string-ref string 0))\n         (string-upcase (string-ref string 0))\n   \
    \      ]\n        [else\n         (string-downcase (string-ref string 0))\n  \
    \       ]\n        )\n      (flip_case (substring string 1))\n      )\n     ]\n\
    \    )\n  )\n", "  (string-map (lambda (char)\n                (if (char-alphabetic?\
    \ char)\n                    (if (char-lower-case? char)\n                   \
    \     (char-upcase char)\n                        (char-downcase char))\n    \
    \                char))\n              string))\n", "  (list->string (map (lambda\
    \ (x) (if (char-alphabetic? x)\n                                      (if (char-lower-case?\
    \ x)\n                                          (char-upcase x)\n            \
    \                              (char-downcase x))\n                          \
    \            x))\n                      (string->list string))))\n", "  (string-map\
    \ (lambda (c)\n                (if (char-lower-case? c)\n                    (char-upcase\
    \ c)\n                    (char-downcase c)))\n              string))\n", "  (foldl\
    \ (lambda (x acc)\n           (if (char-alphabetic? x)\n               (string-append\
    \ acc (string-map char-downcase (string-map char-upcase (string x))))\n      \
    \         (string-append acc (string x))))\n         \"\"\n         string))\n",
  "  (string-upcase (string-downcase string)))\n", "  (local ((define (up-case? char)\n\
    \            (char-upper-case? char)))\n    (map\n     (\u03BB (char)\n      \
    \ (if (up-case? char)\n           (char-downcase char)\n           (char-upcase\
    \ char)))\n     string)))\n", "  (for/string ([char (in-string string)])\n   \
    \ (if (char-alphabetic? char)\n        (if (char-lower-case? char)\n         \
    \   (char-upcase char)\n            (char-downcase char))\n        char)))\n",
  "  (string-flip-case string))\n", "  (map (lambda (character)\n         (if (char-lower-case?\
    \ character)\n             (char-upcase character)\n             (char-downcase\
    \ character)))\n       string))\n", "  (string-map\n   (\u03BB (x)\n     (if (char-numeric?\
    \ x) x\n         (if (char-lower-case? x) (char-upcase x) (char-downcase x))))\n\
    \   string))\n", "  (string-append (map (lambda (ch)\n                       \
    \ (if (char-lower-case? ch)\n                            (char-upcase ch)\n  \
    \                          (char-downcase ch)))\n                      string)))\n",
  "  (define len (string-length string))\n  (define (flip-loop i)\n    (if (= i len)\n\
    \        \"\"\n        (let* ([ch (string-ref string i)]\n               [upper?\
    \ (char-upcase? ch)]\n               [lower? (char-lowercase? ch)])\n        \
    \  (string-append\n           (if upper?\n               (string-downcase (string\
    \ ch))\n               (if lower?\n                   (string-upcase (string ch))\n\
    \                   (string ch)))\n           (flip-loop (+ i 1))))))\n  (flip-loop\
    \ 0))\n", '  (string-upcase (string-downcase string)))', "  (regexp-replace* #rx\"\
    [A-Z]\" string\n                   (lambda (match)\n                     (string-upcase\
    \ (string-downcase match)))))", "  (define (check-case ch)\n    (cond\n      [(char-lower-case?\
    \ ch) (char-upcase ch)]\n      [(char-upper-case? ch) (char-downcase ch)]\n  \
    \    [else ch]))\n  (list->string (map check-case (string->list string))))\n",
  "  (define (flip_letter c)\n    (if (char-ci&gt;=? c #\\a)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (string-&gt;list (string-map flip_letter\
    \ string)))\n", "  (string-downcase (string-upcase string)))\n```\n\n```scheme\n\
    #lang racket\n", "  (let loop ([i 0] [result '()])\n    (cond [(= i (string-length\
    \ string)) (list->string (reverse result))]\n          [(char-alphabetic? (string-ref\
    \ string i))\n           (let ([ch (string-ref string i)])\n             (if (char-lower-case?\
    \ ch)\n                 (loop (+ i 1) (cons (char-upcase ch) result))\n      \
    \           (loop (+ i 1) (cons (char-lower-case ch) result))))]\n          [else\
    \ (loop (+ i 1) (cons (string-ref string i) result))])))\n", "  (string-map\n\
    \   (lambda (character)\n     (cond\n       ((char-lower-case? character) (char-upcase\
    \ character))\n       ((char-upper-case? character) (char-downcase character))\n\
    \       (else character)))\n   string))\n", "  (map (\u03BB (x)\n         (if\
    \ (char-alphabetic? x)\n             (if (char-lower-case? x)\n              \
    \   (char-upcase x)\n                 (char-downcase x))\n             x))\n \
    \      string))\n", "  (string-downcase (string-upcase string)))\n", "  (for/list\
    \ ([char (in-string string)])\n    (if (char-numeric? char)\n        char\n  \
    \      (if (char-lower-case? char)\n            (char-upcase char)\n         \
    \   (char-downcase char)))))\n", "  (string-&gt;list string))\n</code>\nI'm still\
    \ learning racket and would appreciate any feedback/answers!\n", "  (string-copy\n\
    \   string\n   string\n   (lambda (s i)\n     (if (char-lower-case? s)\n     \
    \    (char-upcase s)\n         (char-downcase s)))))\n```\n\n```racket\n#lang\
    \ racket\n", "  (string-upcase (string-downcase string)))\n", "  (map (lambda\
    \ (char)\n         (cond\n           [(char-alphabetic? char)\n            (if\
    \ (char-lower-case? char)\n                (char-upcase char)\n              \
    \  (char-downcase char))]\n           [else char]))\n       string))\n", "  (regexp-replace*\
    \ #rx\".\" string (lambda (m) (string-upcase (string-downcase m)))))\n", "  (string-&gt;list\
    \ string))\n</code>\nWhen I run this in Racket, it gives me the error:\n<code>string-&gt;list:\
    \ expects argument of type &lt;string&gt;; given \"Hello\"\n</code>\nWhy is this\
    \ not a string?\nEDIT:\nI finally ended up with this solution:\n<code>#lang racket\n",
  "  (map char-upcase string))\n", "  (apply string-append (map (lambda (ch)\n   \
    \                           (if (char-lower-case? ch)\n                      \
    \            (char-upcase ch)\n                                  (char-downcase\
    \ ch)))\n                            string)))\n", "  (map\n   (lambda (char)\n\
    \     (if (char-lower-case? char)\n         (char-upcase char)\n         (char-downcase\
    \ char)))\n   string))\n", "  (list->string (map (lambda (c) (if (char-ci&gt;=?\
    \ c #\\a) (char-upcase c) (char-downcase c))) (string-&gt;list string))))\n",
  "  (string-&gt;list string))\n</code>\nI get this error:\n<code>#lang racket", " \
    \ (string-map char-downcase/upcase string))\n", "  (string-map\n   (lambda (char)\n\
    \     (if (or (char-lower-case? char) (char-numeric? char))\n         (char-upcase\
    \ char)\n         (char-downcase char)))\n   string))\n", "    (string-map #(cond\
    \ [(char-upper-case? %) (char-downcase %)]\n                          [(char-lower-case?\
    \ %) (char-upcase %)]\n                          [else %])\n                 \
    \           string))\n", "  (define (flip_char c)\n    (if (char-upcase? c)\n\
    \        (char-downcase c)\n        (char-upcase c)))\n  (define (flip_chars lst)\n\
    \    (cond [(empty? lst) empty]\n          [else (cons (flip_char (first lst))\
    \ (flip_chars (rest lst)))]))\n  (list->string (flip_chars (string->list string))))\n\
    ```\n\nLet's `(flip_case \"Hello\")`\n\n```", "  (regexp-replace* #rx\"[a-zA-Z]\"\
    \ string\n                   (lambda (chars)\n                     (string-map\
    \ (lambda (char)\n                                   (if (char-alphabetic? char)\n\
    \                                       (char-upcase char)\n                 \
    \                      (char-downcase char)))\n                              \
    \   chars))))\n```\n\n```scheme\n#lang racket\n", "  (map symbol->string\n   \
    \    (map\n        (lambda (x)\n          (if (char-lower-case? x)\n         \
    \     (char-upcase x)\n              (char-downcase x)))\n        (string->list\
    \ string))))\n", "  (for/string ([c string])\n    (if (char-lower-case? c)\n \
    \       (char-upcase c)\n        (char-downcase c))))\n", "  (string-map\n   (lambda\
    \ (ch)\n     (if (char-lower-case? ch)\n         (char-upcase ch)\n         (char-downcase\
    \ ch)))\n   string))\n", "  (string-&gt;list string))\n</code>\nI'm not sure how\
    \ to proceed with this. The original Python code uses the string library, and\
    \ my understanding is that Racket doesn't have string libraries. Am I misunderstanding\
    \ something?\nHere's the Python code:\n<code>def flip_case(string):\n    return\
    \ ''.join([char.upper() if char.islower() else char.lower() for char in string])\n\
    </code>\n\n\nA:\n\nIn Racket, strings are immutable and can't be changed. If you\
    \ want to change the contents of a string, you'll need to convert it to a list\
    \ of characters and then convert it back to a string.\nSince you're new to Racket,\
    \ let's first take a look at how to use map and string->list to change a string.\n\
    <code>(map #\\A \"Hello\")\n</code>\nwill return <code>\"AAAAA\"</code>.\n<code>(string-&gt;list\
    \ \"Hello\")\n</code>\nwill return <code>'(#\\H #\\e #\\l #\\l #\\o)</code>.\n\
    Your function will need to return the string you want. \nYou'll need to use the\
    \ first expression above for each character in the list to replace each character\
    \ in the list with another character. \n<code>(string-&gt;list \"Hello\")</code>\
    \ will return a list of characters. \nYou'll need to use the second expression\
    \ above to convert the list back to a string.\n", "  (if (null? string)\n    \
    \  '()\n      (cons (if (char-alphabetic? (car string))\n                (if (char-upper-case?\
    \ (car string))\n                    (char-downcase (car string))\n          \
    \          (char-upcase (car string)))\n                (car string))\n      \
    \      (flip_case (cdr string)))))\n", "  (cond\n    [(empty? string)\n      \"\
    \"]\n    [(char-lower-case? (first string))\n      (string-append (string-upcase\
    \ (string (first string))) (flip_case (rest string)))]\n    [(char-upper-case?\
    \ (first string))\n      (string-append (string-downcase (string (first string)))\
    \ (flip_case (rest string)))]\n    [else\n      (string-append (string (first\
    \ string)) (flip_case (rest string)))]))\n", "  (regexp-replace* #rx\"[a-z]\"\
    \ string\n                   (lambda (m) (string-downcase (string-upcase (match:substring\
    \ m))))))\n", "  (string-map char-upcase/downcase string))\n", "  (for/list ([char\
    \ (in-string string)])\n    (cond [(char-lower-case? char) (char-upcase char)]\n\
    \          [(char-upper-case? char) (char-downcase char)]\n          [else char])))\n",
  "  (define (flip-case-helper string-list)\n    (cond\n      [(null? string-list)\
    \ '()]\n      [(char-lower-case? (car string-list))\n       (cons (char-upcase\
    \ (car string-list)) (flip-case-helper (cdr string-list)))]\n      [(char-upper-case?\
    \ (car string-list))\n       (cons (char-lower-case (car string-list)) (flip-case-helper\
    \ (cdr string-list)))]\n      [else (cons (car string-list) (flip-case-helper\
    \ (cdr string-list)))]))\n  (flip-case-helper (string->list string)))\n", "  (string-map\
    \ char-upcase (string-map char-downcase string)))\n</code>\n", "  (cond [(empty?\
    \ string)\n         string]\n        [(char-lower-case? (car string))\n      \
    \   (string-append (string-downcase (car string)) (flip_case (cdr string)))]\n\
    \        [(char-upper-case? (car string))\n         (string-append (string-upcase\
    \ (car string)) (flip_case (cdr string)))]\n        [else\n         (string-append\
    \ (car string) (flip_case (cdr string)))]))\n", "  (list->string (map (\u03BB\
    \ (x) (cond [(char-upper-case? x) (char-downcase x)]\n                       \
    \              [(char-lower-case? x) (char-upcase x)]\n                      \
    \               [else x]))\n                      (string->list string))))\n```\n\
    \n### 5.3.3 Getting the size of a string\n\n```racket\n#lang racket\n", "  (string-map\
    \ (lambda (x)\n                (if (char-upcase? x)\n                    (char-downcase\
    \ x)\n                    (char-upcase x)))\n              string))\n```\n\n#\
    \ 6. Convert to binary\n\n```#lang racket\n", "  (define (flip_case string flipped)\n\
    \    (cond [(empty? string) flipped]\n          [(char-lower-case? (first string))\
    \ (flip_case (rest string) (string-append flipped (string-upcase (first string))))]\n\
    \          [(char-upper-case? (first string)) (flip_case (rest string) (string-append\
    \ flipped (string-downcase (first string))))]\n          [else (flip_case (rest\
    \ string) (string-append flipped (first string)))]))\n  (flip_case string \"\"\
    ))\n", "  (string-&gt;list string))\n</code>\nHowever, this just returns <code>'(#\\\
    H #\\e #\\l #\\l #\\o)</code>. How do I convert a list back to a string?\n\n\n\
    A:\n\nThe <code>string-&gt;list</code> procedure returns a list of characters.\
    \ You can use the <code>list-&gt;string</code> procedure to go back to a string.\n\
    However, you need to flip the case of the characters first.\nYou can use the <code>char-upcase</code>\
    \ and <code>char-downcase</code> procedures to convert characters to upper- and\
    \ lower-case.\n", "  (string-join\n   (map\n    (\u03BB (c)\n      (if (char-ci&lt;=?\
    \ #\\a c #\\z)\n          (char-upcase c)\n          (char-downcase c)))\n   \
    \ (string-&gt;list string))))\n", "  (map (lambda (c) (if (char-alphabetic? c)\
    \ (if (char-lower-case? c) (char-upcase c) (char-downcase c)) c)) string))\n",
  "  (string-map\n   (lambda (c)\n     (if (char-downcase? c)\n         (char-upcase\
    \ c)\n         (char-downcase c)))\n   string))\n", "  (string-flip-case string))\n",
  "  (string-normalize-nfkc (string-downcase string)))\n", "  (string-&gt;list string))\n",
  "  (string-fold case-flip string \"\"))\n", "  (build-string (string-length string)\n\
    \    (lambda (i)\n      (if (char-alphabetic? (string-ref string i))\n       \
    \   (if (char-ci=? (string-ref string i) (char-downcase (string-ref string i)))\n\
    \              (char-upcase (string-ref string i))\n              (char-downcase\
    \ (string-ref string i)))\n          (string-ref string i)))))\n", "  (string-map\n\
    \   (lambda (char)\n     (if (char-lower-case? char)\n         (char-upcase char)\n\
    \         (char-downcase char)))\n   string))\n", "  (foldl (lambda (x y) (if\
    \ (char-lower-case? x) (string-append y (string-upcase (string x))) (string-append\
    \ y (string-downcase (string x))))) \"\" string))\n</code>\nMy solution:\n<code>#lang\
    \ racket\n", "  (string-map (lambda (char)\n                (cond ((char-downcase?\
    \ char) (char-upcase char))\n                      ((char-upcase? char) (char-downcase\
    \ char))\n                      (else char)))\n              string))\n", "  (string-map\
    \ (\u03BB (x) (if (char-lower-case? x) (char-upcase x) (char-downcase x))) string))\n\
    ```\n\n```racket\n#lang racket\n", "  (string-append\n   (map (lambda (ch)\n \
    \         (cond ((char-lower-case? ch) (char-upcase ch))\n                ((char-upper-case?\
    \ ch) (char-downcase ch))\n                (else ch)))\n        string)))\n",
  "  (string-&gt;list string))\n</code>\nI have no idea what I'm doing at all. My\
    \ thinking is to turn the string into a list and then do something to it, but\
    \ I'm not sure.\n\n\nA:\n\nThis looks pretty much like a homework problem. \n\
    Assuming this is Dr. Racket the <code>string-upcase</code> and <code>string-downcase</code>\
    \ functions will be helpful. \nThis looks a lot like your code with a couple of\
    \ changes.  \n\nI've added a <code>cond</code> expression to detect the case of\
    \ each character\nI'm using <code>cond</code> to output the character in the opposite\
    \ case from the input\nI'm using <code>list-&gt;string</code> to turn the result\
    \ into a string for return.\n\n<code>#lang racket\n", "  (string-map (lambda (character)\n\
    \                (if (char-lower-case? character)\n                    (char-upcase\
    \ character)\n                    (char-downcase character)))\n              string))\n",
  "  (string-map\n   (lambda (x)\n     (if (char-lower-case? x)\n         (char-upcase\
    \ x)\n         (char-downcase x)))\n   string))\n", "  (define (case_convert?\
    \ character)\n    (cond ((char-lower-case? character) (char-upcase character))\n\
    \          ((char-upper-case? character) (char-downcase character))\n        \
    \  (else character)))\n  (string-join (map case_convert? (string->list string))))\n",
  "  (string-map\n   (lambda (char)\n     (if (char-lower-case? char)\n         (char-upcase\
    \ char)\n         (char-downcase char)))\n   string))\n", "  (string-map char-upcase\
    \ string))\n", "  (string-append (string-upcase (substring string 0 1))\n    \
    \             (string-downcase (substring string 1))))\n", "  (string-join (map\
    \ (\u03BB (c)\n                      (if (char-lower-case? c)\n              \
    \            (char-upcase c)\n                          (char-downcase c)))\n\
    \                    string)))\n", "  (string-map (lambda (c)\n              \
    \  (if (char-upper-case? c)\n                    (char-downcase c)\n         \
    \           (char-upcase c)))\n              string))\n", "  (map string-upcase\
    \ (map string-downcase string)))\n", "  (string-&gt;list (string-downcase string)))\n",
  "  (let ([chars (string->list string)])\n    (map\n     (lambda (c)\n       (match\
    \ c\n         [(or #\\a #\\e #\\i #\\o #\\u) (char-upcase c)]\n         [(or #\\\
    A #\\E #\\I #\\O #\\U) (char-downcase c)]\n         [else c]))\n     chars)))\n",
  "  (let loop ([i 0] [result '()])\n    (cond [(= i (string-length string)) (list->string\
    \ (reverse result))]\n          [(char-lower-case? (string-ref string i))\n  \
    \         (loop (+ i 1) (cons (char-upcase (string-ref string i)) result))]\n\
    \          [(char-upper-case? (string-ref string i))\n           (loop (+ i 1)\
    \ (cons (char-lower-case (string-ref string i)) result))]\n          [else (loop\
    \ (+ i 1) (cons (string-ref string i) result))])))\n", "  (string-map\n   (lambda\
    \ (x)\n     (if (char-upper-case? x)\n         (char-downcase x)\n         (char-upcase\
    \ x)))\n   string))\n", "  (string-append\n   (for/list ([ch (in-string string)])\n\
    \     (if (char-ci&lt;=? #\\a ch #\\z)\n         (char-upcase ch)\n         (char-downcase\
    \ ch)))))\n", "  (string-map\n   (lambda (c)\n     (if (char-lower-case? c)\n\
    \         (char-upcase c)\n         (char-downcase c)))\n   string))\n", "  (define\
    \ (flip c)\n    (cond\n      [(char-lower-case? c) (char-upcase c)]\n      [(char-upper-case?\
    \ c) (char-downcase c)]\n      [else c]))\n  (string-&gt;list (string-&gt;symbol\
    \ (string-join (map flip (string-&gt;list string))))))\n", "  (string-append\n\
    \   (map (lambda (char)\n          (if (char-alphabetic? char)\n             \
    \ (if (char-lower-case? char)\n                  (char-upcase char)\n        \
    \          (char-downcase char))\n              char))\n        string)))\n",
  "  (string-map\n   (\u03BB (c)\n     (if (char-lower-case? c)\n         (char-upcase\
    \ c)\n         (char-downcase c)))\n   string))\n```\n\n```racket", "  (string-map\
    \ (lambda (x)\n                (cond\n                  [(char-lower-case? x)\
    \ (char-upcase x)]\n                  [(char-upper-case? x) (char-downcase x)]\n\
    \                  [else x]))\n              string))\n```\n\nThe `cond` form\
    \ is the Racket version of the `switch` statement from C-based languages.  The\
    \ macro syntax for `cond` is shown below.  Each line after the macro name is a\
    \ condition-action pair.  The body of the cond is evaluated in order, stopping\
    \ at the first condition that evaluates to a truthy value.  The associated action\
    \ is then executed and the result is returned.  The final `else` form is executed\
    \ if the previous conditions all evaluate to falsy values.\n\n```racket", "  (string-join\
    \ (map (lambda (x)\n                      (if (char-lower-case? x)\n         \
    \                 (char-upcase x)\n                          (char-downcase x)))\n\
    \                    string)))\n", "  (string-upcase (string-downcase string)))\n",
  "  (cond ((string-upcase? string) (string-downcase string))\n        ((string-downcase?\
    \ string) (string-upcase string))\n        (else string)))\n", "  (if (string-empty?\
    \ string)\n      string\n      (string-append\n       (string (char-upcase (string-ref\
    \ string 0)))\n       (flip_case (substring string 1)))))\n", "  (string-map (lambda\
    \ (x) (if (char-ci&gt;=? x #\\a) (char-upcase x) (char-downcase x))) string))\n",
  "  (string-map (lambda (ch) (if (char-lower-case? ch) (char-upcase ch) (char-downcase\
    \ ch))) string))\n", "  (string-map\n   (lambda (c)\n     (if (char-alphabetic?\
    \ c)\n         (if (char-ci&lt;=? #\\a c)\n             (char-upcase c)\n    \
    \         (char-downcase c))\n         c))\n   string))\n", "  (string-append\
    \ (string-map char-downcase (string-map char-upcase string))))\n", "  (for/list\
    \ ([char (in-string string)])\n    (if (char-alphabetic? char)\n        (if (char-lower-case?\
    \ char)\n            (char-upcase char)\n            (char-downcase char))\n \
    \       char)))\n\n", "  (let ([length (string-length string)])\n    (let loop\
    \ ([i 0] [result '()])\n      (if (= i length)\n        (list->string (reverse\
    \ result))\n        (let ([char (string-ref string i)])\n          (loop (+ i\
    \ 1) (cons (flip_char char) result)))))))\n", "  (define (flip_character character)\n\
    \    (cond\n      [(char-lower-case? character) (char-upcase character)]\n   \
    \   [(char-upper-case? character) (char-downcase character)]\n      [else character]))\n\
    \  (string-append (map flip_character (string->list string))))\n", "  (define\
    \ (helper string acc)\n    (if (empty? string)\n        (reverse acc)\n      \
    \  (helper (rest string) (cons (char-upcase (first string)) acc))))\n  (helper\
    \ string '()))\n", "  (string-map char-upcase string))\n", "  (string-map\n  \
    \ (lambda (x)\n     (if (or (char-lower-case? x) (char-numeric? x))\n        \
    \ (char-upcase x)\n         (char-downcase x)))\n   string))\n", "  (string-map\n\
    \   (lambda (char)\n     (if (char-upcase? char)\n         (char-downcase char)\n\
    \         (char-upcase char)))\n   string))\n", "  (string-map (lambda (x) (if\
    \ (char-lower-case? x) (char-upcase x) (char-downcase x))) string))\n", "  (string-downcase\
    \ string))\n", "  (string-map (lambda (char) (if (char-ci&gt;=? char #\\a)\n \
    \                                (char-upcase char)\n                        \
    \         (char-downcase char)))\n              string))\n</code>\nSince I've\
    \ used <code>string-map</code>, this returns a string, which is nice.\n", "  (string-map\
    \ (lambda (c)\n                (if (char-ci&gt;=? c #\\a)\n                  \
    \  (char-upcase c)\n                    (char-downcase c)))\n              string))\n",
  "  (string-map (curryr string-upcase? string-downcase string-upcase) string))\n",
  "  (regexp-replace* #rx\"[a-z]\" string\n                   (lambda (s)\n      \
    \               (if (char-alphabetic? (string-ref s 0))\n                    \
    \     (string-upcase s)\n                         (string-downcase s)))))\n```\n\
    \n```racket\n#lang racket\n", "  (string-append\n   (map (lambda (x)\n       \
    \   (if (char-alphabetic? x)\n              (if (char-lower-case? x)\n       \
    \           (char-upcase x)\n                  (char-downcase x))\n          \
    \    x))\n        string)))\n```\n\n```racket\n#lang racket\n", "  (for/string\
    \ ([c string])\n    (if (char-upcase? c)\n        (char-downcase c)\n        (char-upcase\
    \ c))))\n", "  (map (\u03BB (char)\n         (if (char-lower-case? char)\n   \
    \          (char-upcase char)\n             (char-downcase char)))\n       string))\n",
  "  (string-&gt;list (string-upcase string)))\n", "  (string-map (lambda (c)\n  \
    \              (if (char-lower-case? c)\n                    (char-upcase c)\n\
    \                    (char-downcase c)))\n              string))\n", "  (define\
    \ (flip-case-helper string-reverse string-length)\n    (cond ((= string-length\
    \ 0) (reverse string-reverse))\n          ((char-lower-case? (string-ref string\
    \ (- string-length 1)))\n           (flip-case-helper (string-append string-reverse\
    \ (string-upcase (string-ref string (- string-length 1)))) (- string-length 1)))\n\
    \          ((char-upper-case? (string-ref string (- string-length 1)))\n     \
    \      (flip-case-helper (string-append string-reverse (string-downcase (string-ref\
    \ string (- string-length 1)))) (- string-length 1)))\n          (else (flip-case-helper\
    \ (string-append string-reverse (string-ref string (- string-length 1))) (- string-length\
    \ 1)))))\n  (flip-case-helper \"\" (string-length string)))\n", "  (map (lambda\
    \ (char)\n         (if (char-ci=? char (char-upcase char))\n             (char-downcase\
    \ char)\n             (char-upcase char)))\n       string))\n```\n\n```racket\n\
    #lang racket\n", "  (string-map (lambda (c)\n                (case c\n       \
    \           ((#\\a #\\e #\\i #\\o #\\u) (char-upcase c))\n                  ((#\\\
    A #\\E #\\I #\\O #\\U) (char-downcase c))\n                  (#t c)))\n      \
    \        string))\n", "  (string-map (lambda (char)\n                (if (char-alphabetic?\
    \ char)\n                    (if (char-lower-case? char)\n                   \
    \     (char-upcase char)\n                        (char-downcase char))\n    \
    \                char))\n              string))\n", "  (build-string (string-length\
    \ string) (lambda (n) (char-upcase (string-ref string n)))))\n", "  (regexp-replace*\
    \ #rx\"[a-z]\" string (lambda (match) (string-upcase match))))\n```\n\n```racket\n\
    #lang racket\n", "  (map (\u03BB (x) (if (char-upper-case? x) (char-downcase x)\
    \ (char-upcase x))) string))\n", "  (string-map (lambda (char)\n             \
    \   (if (char-upper-case? char)\n                    (char-downcase char)\n  \
    \                  (char-upcase char)))\n              string))\n", "  (string-upcase\
    \ string))\n", "  (map (lambda (x)\n         (cond\n           [(char-alphabetic?\
    \ x)\n            (if (char-lower-case? x)\n                (char-upcase x)\n\
    \                (char-downcase x))]\n           [else x]))\n       string))\n",
  "  (map symbol->string\n       (map char-upcase/downcase (string->list string))))\n\
    ```\n\n```\n#lang racket\n", "  (string-map (lambda (c)\n                (if (char-ci&gt;=?\
    \ c #\\a)\n                    (char-upcase c)\n                    (char-downcase\
    \ c)))\n              string))\n</code>\n", "  (string-&gt;list string))\n", " \
    \ (apply string-append (map flip string)))\n", "  (define (flip-letter letter)\n\
    \    (if (char-lower-case? letter)\n        (char-upcase letter)\n        (char-downcase\
    \ letter)))\n  (map flip-letter string))\n", "  (string-join (map char-upcase\
    \ (string-split string #\\space))))\n", "  (string-map (lambda (char) (if (char-upper-case?\
    \ char) (char-downcase char) (char-upcase char))) string))\n", "  (string-map\
    \ (\u03BB (c) (if (char-ci=? c #\\a) #\\A #\\a)) string))\n", "  (string-downcase\
    \ (string-upcase string)))\n", "  (string-&gt;list string))\n</code>\nI'm confused\
    \ on how to do that. I have no idea how to do this. Can you guys help me?\n\n\n\
    A:\n\nThe predicate <code>char-alphabetic?</code> returns <code>#t</code> for\
    \ all the letters of the alphabet, and the functions <code>char-upcase</code>\
    \ and <code>char-downcase</code> can be used to transform the alphabetic characters\
    \ into their case-alternatives.\n<code>(define (flip-case string)\n  (string-&gt;list\
    \ string))\n</code>\nwill convert the string into a list of characters, but you're\
    \ not using that list anywhere. A function that takes a string and returns a string\
    \ can be implemented this way:\n<code>(define (flip-case string)\n  (string-&gt;list\
    \ string))\n</code>\nNow your task is to find a way to transform each of the characters\
    \ in the list, so that the process of converting the string into a list, processing\
    \ the characters and then converting the list into a string can be done by a single\
    \ call to <code>map</code>.\n<code>(define (flip-case string)\n  (string-&gt;list\
    \ string))\n</code>\nIf you need more help than this, please include an attempt\
    \ at a solution in your question.\n", "  (string-append (string-upcase (string-downcase\
    \ string))))\n", "  (define (flip_char char)\n    (if (char-lower-case? char)\n\
    \        (char-upcase char)\n        (char-downcase char)))\n  (string-&gt;list\
    \ (map flip_char (string-&gt;list string))))\n</code>\nThis works but it seems\
    \ very roundabout, as I need to convert the string to a list of characters, convert\
    \ that list of characters to a list of the flipped characters, and then convert\
    \ the list of flipped characters back to a string.\nWhat is the preferred way\
    \ to do this in Racket?\n\n\nA:\n\nIf you want to do it using <code>map</code>,\
    \ the simplest way would be to use <code>string-map</code>, which takes a one-argument\
    \ function and a string, then maps that function over the string, resulting in\
    \ a new string:\n<code>(define (flip_case string)\n  (string-map (lambda (c)\n\
    \                (if (char-lower-case? c)\n                    (char-upcase c)\n\
    \                    (char-downcase c)))\n              string))\n</code>\nYou\
    \ could also just write a for loop for it, but if you want to use higher-order\
    \ functions, then <code>string-map</code> is the way to go.\n", "  (string-map\
    \ (\u03BB (ch)\n                (if (char-lower-case? ch)\n                  \
    \  (char-upcase ch)\n                    (char-downcase ch)))\n              string))\n",
  "  (string-map (lambda (ch) (if (char-ci=? ch (char-upcase ch)) (char-downcase ch)\
    \ (char-upcase ch))) string))\n</code>\nHowever, I can't find any information\
    \ on why this isn't working.  I suspect the problem is the predicate that I'm\
    \ using, but I can't figure out how to fix it.  I've also tried to use <code>char-upper-case?</code>\
    \ and <code>char-lower-case?</code>, but those don't seem to be working either.\
    \  Any ideas?\n\n\nA:\n\n<code>string-map</code> takes a procedure that takes\
    \ 2 arguments, the first argument being the string, the second the character.\n\
    <code>(define (flip_case string)\n  (string-map (lambda (string ch) (if (char-ci=?\
    \ ch (char-upcase ch)) (char-downcase ch) (char-upcase ch))) string))\n</code>\n",
  "  (build-string (string-length string)\n                (lambda (i)\n         \
    \         (let ((char (string-ref string i)))\n                    (if (char-lower-case?\
    \ char)\n                        (char-upcase char)\n                        (char-downcase\
    \ char))))))\n", "  (string-map\n   (lambda (char)\n     (if (char-alphabetic?\
    \ char)\n         (if (char-lower-case? char)\n             (char-upcase char)\n\
    \             (char-downcase char))\n         char))\n   string))\n```\n\n## Ruby\n\
    \n```ruby\n# flip_case.rb\n\ndef flip_case(string)\n  string.chars.map do |char|\n\
    \    if char =~ /[a-z]/\n      char.upcase\n    elsif char =~ /[A-Z]/\n      char.downcase\n\
    \    else\n      char\n    end\n  end.join\nend\n```\n\n## Rust\n\n```rust\n//\
    \ flip_case.rs\n\nfn flip_case(string: &str) -> String {\n    string.chars().map(|c|\
    \ {\n        if c.is_alphabetic() {\n            c.is_uppercase()\n          \
    \      .then_some(c.to_lowercase().next().unwrap())\n                .or_else(||\
    \ c.to_uppercase().next())\n                .unwrap()\n        } else {\n    \
    \        c\n        }\n    }).collect()\n}\n```", "  (define (helper str)\n  \
    \  (cond\n      [(empty? str) empty]\n      [(char-lower-case? (first str)) (cons\
    \ (char-upcase (first str)) (helper (rest str)))]\n      [(char-upper-case? (first\
    \ str)) (cons (char-downcase (first str)) (helper (rest str)))]\n      [else (cons\
    \ (first str) (helper (rest str)))]))\n  (helper string))\n", "  (map (lambda\
    \ (char)\n         (if (char-lower-case? char)\n             (char-upcase char)\n\
    \             (char-downcase char)))\n       string))\n", "  (cond\n    [(not\
    \ (string? string)) #f]\n    [(empty? string) \"\"]\n    [else\n     (cond\n \
    \      [(char-lower-case? (string-ref string 0))\n        (string-append (string-upcase\
    \ (string-ref string 0)) (flip_case (substring string 1)))]\n       [(char-upper-case?\
    \ (string-ref string 0))\n        (string-append (string-downcase (string-ref\
    \ string 0)) (flip_case (substring string 1)))]\n       [else\n        (string-append\
    \ (string-ref string 0) (flip_case (substring string 1)))])]))\n", "  (cond [(string-ci=?\
    \ string \"abcd\") \"ABCD\"]\n        [(string-ci=? string \"AbCd\") \"aBcD\"\
    ]\n        [(string-ci=? string \"aBcD\") \"AbCd\"]\n        [(string-ci=? string\
    \ \"ABCD\") \"abcd\"]\n        [(string-ci=? string \"Abcd\") \"aBCD\"]\n    \
    \    [(string-ci=? string \"aBCD\") \"Abcd\"]\n        [(string-ci=? string \"\
    ABCd\") \"abCD\"]\n        [(string-ci=? string \"AbCd\") \"aBcD\"]\n        [(string-ci=?\
    \ string \"aBcD\") \"AbCd\"]\n        [(string-ci=? string \"abCD\") \"ABCd\"\
    ]\n        [(string-ci=? string \"abcd efgh\") \"ABCD EFGH\"]\n        [(string-ci=?\
    \ string \"AbCd EfGh\") \"aBcD eFgH\"]\n        [(string-ci=? string \"aBcD eFgH\"\
    ) \"AbCd EfGh\"]\n        [(string-ci=? string \"ABCD EFGH\") \"abcd efgh\"]\n\
    \        [(string-ci=? string \"Abcd Efgh\") \"aBCD eFGH\"]\n        [(string-ci=?\
    \ string \"aBCD eFGH\") \"Abcd Efgh\"]\n        [(string-ci=? string \"ABCd EfGh\"\
    ) \"abCD eFgH\"]\n        [(string-ci=? string \"AbCd eFgH\") \"aBcD EfGh\"]\n\
    \        [(string-ci=? string \"aBcD EfGh\") \"AbCd eFgH\"]\n        [(string-ci=?\
    \ string \"abCD eFgH\") \"ABCd EfGh\"]\n        [(string-ci=? string \"AbCd EfGh\
    \ iJkL\") \"aBcD eFgH IjKl\"]\n        [(string-ci=? string \"aBcD eFgH IjKl\"\
    ) \"AbCd EfGh iJkL\"]\n        [(string-ci=?", "  (string-map (lambda (c)\n  \
    \              (cond ((char-numeric? c)\n                       c)\n         \
    \             ((char-lower-case? c)\n                       (char-upcase c))\n\
    \                      ((char-upper-case? c)\n                       (char-downcase\
    \ c))\n                      (else\n                       c)))\n            \
    \  string))\n", "  (string-map\n   (lambda (character)\n     (if (char-lower-case?\
    \ character)\n         (char-upcase character)\n         (char-downcase character)))\n\
    \   string))\n```\n\n```python\n#lang python\n\n# For a given string, flip lowercase\
    \ characters to uppercase and uppercase to lowercase.\n# >>> flip_case(\"Hello\"\
    )\n# \"hELLO\"\ndef flip_case(string):\n    return \"\".join(\n        [\n   \
    \         character.upper() if character.islower() else character.lower()\n  \
    \          for character in string\n        ]\n    )\n```\n\n#### 7. Reverse a\
    \ string.\n\n```racket\n#lang racket\n", "  (for/list ([char (in-string string)])\n\
    \    (cond\n      [(char-alphabetic? char)\n       (if (char-lower-case? char)\n\
    \           (char-upcase char)\n           (char-downcase char))]\n      [else\
    \ char])))\n", "  (string-map (\u03BB (c) (if (char-lower-case? c) (char-upcase\
    \ c) (char-downcase c))) string))\n</code>\nAnd here's the timings:\n<code>#lang\
    \ racket\n", "  (string-map (lambda (c)\n                (if (char-lower-case?\
    \ c)\n                    (char-upcase c)\n                    (char-downcase\
    \ c)))\n              string))\n", "  (string-join (map (lambda (char)\n     \
    \                 (cond\n                        [(char-alphabetic? char)\n  \
    \                       (if (char-lower-case? char)\n                        \
    \     (char-upcase char)\n                             (char-downcase char))]\n\
    \                        [else char]))\n                    (string->list string))))\n",
  "  (for/list ([char (in-string string)])\n    (if (char-upper-case? char)\n    \
    \    (char-downcase char)\n        (char-upcase char))))\n", "  (string-map\n\
    \   (lambda (char)\n     (if (char-lower-case? char)\n         (char-upcase char)\n\
    \         (char-downcase char)))\n   string))\n", "  (string-normalize-spaces\n\
    \   (for/fold ([new_string \"\"]\n              [previous-char \"\"])\n      \
    \ ([x (in-string string)])\n     (cond [(char-alphabetic? x)\n            (if\
    \ (char-alphabetic? previous-char)\n                (string-append new_string\
    \ (string-upcase (string x)))\n                (string-append new_string (string\
    \ x)))]\n           [else (string-append new_string (string x))]))))\n", "  (string-join\
    \ (map (lambda (x)\n                      (if (char-alphabetic? x)\n         \
    \                 (if (char-lower-case? x)\n                              (char-upcase\
    \ x)\n                              (char-downcase x))\n                     \
    \     x))\n                    (string->list string))))\n", "  (for/list ([char\
    \ (in-string string)])\n    (if (char-lower-case? char)\n        (char-upcase\
    \ char)\n        (char-downcase char))))\n", "  (string-map (\u03BB (c) (if (char-ci=?\
    \ c #\\a) #\\A #\\a)) string))\n", "  (map\n   (lambda (c)\n     (cond\n     \
    \  [(char-alphabetic? c)\n        (if (char-lower-case? c)\n            (char-upcase\
    \ c)\n            (char-downcase c))]\n       [else c]))\n   string))", "  (string-map\
    \ (lambda (c)\n                (if (char-lower-case? c)\n                    (char-upcase\
    \ c)\n                    (char-downcase c)))\n              string))\n</code>\n\
    This is not a smart solution as there could be non-alphabetic characters in the\
    \ input string. In that case, the character should be left unchanged. The below\
    \ function is a smart solution for this.\n<code>#lang racket\n", "  (regexp-replace*\
    \ #rx\"[A-Z]\" string (\u03BB (x) (string-downcase x)))\n  (regexp-replace* #rx\"\
    [a-z]\" string (\u03BB (x) (string-upcase x))))\n", "  (map (lambda (char)\n \
    \        (cond\n           [(char-lower-case? char) (char-upcase char)]\n    \
    \       [(char-upper-case? char) (char-downcase char)]\n           [else char]))\n\
    \       string))\n", "  (for/list ([i (in-range (string-length string))])\n  \
    \  (string-replace #\\H #\\h (string-replace #\\h #\\H (string-ref string i)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
