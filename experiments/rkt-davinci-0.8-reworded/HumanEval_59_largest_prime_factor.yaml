name: HumanEval_59_largest_prime_factor
language: rkt
prompt: "#lang racket\n\n;; Return the largest prime factor of n. Assume n > 1 and\
  \ is not a prime.\n;; >>> (largest_prime_factor 13195)\n;; 29\n;; >>> (largest_prime_factor\
  \ 2048)\n;; 2\n(define (largest_prime_factor n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n\
  \    (check-equal? (candidate 15) 5)\n    (check-equal? (candidate 27) 3)\n    (check-equal?\
  \ (candidate 63) 7)\n    (check-equal? (candidate 330) 11)\n    (check-equal? (candidate\
  \ 13195) 29)\n))\n\n(test-humaneval)"
completions: ["  (if (prime? n)\n      n\n      (largest_prime_factor (next-largest-prime-factor\
    \ n))))\n", "  (largest_prime_factor_iter 2 n))\n", "  (define (largest_prime_factor-iter\
    \ n i)\n    (if (= n i)\n        (largest_prime_factor-iter (- n 1) 2)\n     \
    \   (if (and (= (remainder n i) 0)\n                 (is_prime? i))\n        \
    \    i\n            (largest_prime_factor-iter n (+ i 1)))))\n  (largest_prime_factor-iter\
    \ n 2))\n", "  (largest_prime_factor_iter n 2))\n", "  (define (factor n d)\n\
    \    (if (= n d)\n        n\n        (if (even? n)\n            (factor (/ n 2)\
    \ 2)\n            (if (zero? (modulo n d))\n                (factor (/ n d) d)\n\
    \                (factor n (+ d 1))))))\n  (factor n 2))", "  (define (find-prime-factor\
    \ n)\n    (if (even? n) (find-prime-factor (/ n 2))\n        (for/first ([p (in-range\
    \ 2 (ceiling (sqrt n)))])\n          (if (divides? p n)\n              p))))\n\
    \  (find-prime-factor n))\n", "  (cond\n    [(>= (sqrt n) (car (factorize n)))\n\
    \     (largest_prime_factor (round (sqrt n)))]\n    [else (car (factorize n))]))\n",
  "  (define (find-prime-factor i)\n    (if (and (integer? (/ n i)) (prime? i))\n\
    \        i\n        (find-prime-factor (+ i 1))))\n  (find-prime-factor 2))\n",
  "  (define (iter n m)\n    (if (= n 1)\n        (if (prime? m) m\n            (iter\
    \ 1 (next-prime m)))\n        (if (divisible? n m)\n            (iter (/ n m)\
    \ m)\n            (iter n (next-prime m)))))\n  (iter n (next-prime n)))\n", " \
    \ (define (largest_prime_factor-aux n i)\n    (cond [(= i n) n]\n          [(integer?\
    \ (/ n i))\n           (largest_prime_factor-aux (/ n i) i)]\n          [else\
    \ (largest_prime_factor-aux n (+ i 1))]))\n  (largest_prime_factor-aux n 2))",
  "  (define (helper i)\n    (if (prime? i)\n        (if (= (modulo n i) 0)\n    \
    \        i\n            (helper (- i 1)))\n        (helper (- i 1))))\n  (helper\
    \ (integer-sqrt n)))\n", "  (let loop ([n n] [p 2])\n    (cond [(prime? n) n]\n\
    \          [(zero? (modulo n p)) (loop (/ n p) p)]\n          [else (loop n (+\
    \ p 1))])))\n", "  (define (helper n (i 2))\n    (cond ((&gt; (* i i) n) n)\n\
    \          ((= (remainder n i) 0) (helper (/ n i) i))\n          (else (helper\
    \ n (+ i 1)))))\n  (helper n 2))\n", "  (define prime?\n    (make-is-prime))\n\
    \  (define (lpf n acc)\n    (if (= n acc)\n        (error \"n must not be a prime\"\
    )\n        (if (integer? (/ n acc))\n            (lpf (/ n acc) acc)\n       \
    \     (lpf n (+ acc 1)))))\n  (lpf n 2))\n```\n\n```racket", "  (let loop ([n\
    \ n] [k 2])\n    (if (= 1 n)\n        0\n        (if (integer? (/ n k))\n    \
    \        (loop (/ n k) k)\n            (loop n (+ k 1))))))\n```\n\n```scheme\n\
    #lang racket\n", "  (next-prime-factor n 2))\n", "  (define (helper n i)\n   \
    \ (cond\n      [(> (expt i 2) n) n]\n      [(and (divides? n i) (prime? i)) (helper\
    \ (quotient n i) i)]\n      [else (helper n (+ i 1))]))\n  (helper n 2))\n", " \
    \ (let loop ([n n] [i 2])\n    (cond [(and (zero? (modulo n i)) (&lt; i n)) (loop\
    \ (/ n i) i)]\n          [(&lt;= i n) (loop n (+ i 1))]\n          [else i])))\n\
    </code>\nI'm not a Racket programmer and didn't think it would work without a\
    \ <code>recur</code>, but it does.\n<code>;; Return the largest prime factor of\
    \ n. Assume n &gt; 1 and is not a prime.", "  (define (largest_prime_factor* n)\n\
    \    (define (is_prime? n)\n      (define (is_prime?* n i)\n        (if (> i (sqrt\
    \ n))\n            #t\n            (if (zero? (modulo n i))\n                #f\n\
    \                (is_prime?* n (+ i 1)))))\n      (is_prime?* n 2))\n    (define\
    \ (divisors n)\n      (define (divisors* n i)\n        (if (= i n)\n         \
    \   (list n)\n            (if (zero? (modulo n i))\n                (cons i (divisors*\
    \ n (+ i 1)))\n                (divisors* n (+ i 1)))))\n      (divisors* n 2))\n\
    \    (define (filter-primes ns)\n      (if (null? ns)\n          (list)\n    \
    \      (if (is_prime? (car ns))\n              (cons (car ns) (filter-primes (cdr\
    \ ns)))\n              (filter-primes (cdr ns)))))\n    (if (is_prime? n)\n  \
    \      n\n        (apply max (filter-primes (divisors n)))))\n  (largest_prime_factor*\
    \ n))\n```\n\n```racket\n#lang racket\n", "  (cond [(is_prime n) n]\n        [else\
    \ (largest_prime_factor (next_prime (truncate (sqrt n))))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
