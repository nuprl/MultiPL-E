name: HumanEval_43_pairs_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; pairs_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns #t if there are two distinct elements in the list that\n;; sum to\
  \ zero, and #f otherwise.\n;; >>> (pairs_sum_to_zero (list 1 3 5 0))\n;; #f\n;;\
  \ >>> (pairs_sum_to_zero (list 1 3 -2 1))\n;; #f\n;; >>> (pairs_sum_to_zero (list\
  \ 1 2 3 7))\n;; #f\n;; >>> (pairs_sum_to_zero (list 2 4 -5 3 5 7))\n;; #t\n;; >>>\
  \ (pairs_sum_to_zero (list 1))\n;; #f\n(define (pairs_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 -2 1)) #f)\n    (check-equal? (candidate (list 1 2 3 7)) #f)\n    (check-equal?\
  \ (candidate (list 2 4 -5 3 5 7)) #t)\n    (check-equal? (candidate (list 1)) #f)\n\
  \    (check-equal? (candidate (list -3 9 -1 3 2 30)) #t)\n    (check-equal? (candidate\
  \ (list -3 9 -1 3 2 31)) #t)\n    (check-equal? (candidate (list -3 9 -1 4 2 30))\
  \ #f)\n    (check-equal? (candidate (list -3 9 -1 4 2 31)) #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? l) false]\n    [(empty? (rest l)) false]\n  \
    \  [(member (- (first l) (second l)) (rest (rest l)))\n     true]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n\
    \    [(= 0 (+ (first l) (first (rest l)))) #t]\n    [else (pairs_sum_to_zero (rest\
    \ l))]))\n", "  (if (null? l)\n      #f\n      (or (zero? (car l))\n         \
    \ (pair_sum_to_zero (cdr l) (car l)))))\n", "  (cond\n    [(empty? l) #f]\n  \
    \  [(empty? (rest l)) #f]\n    [(positive? (sum l)) (pairs_sum_to_zero (rest l))]\n\
    \    [(zero? (sum l)) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\
    \ [(null? l) #f]\n        [(and (member (car l) (cdr l)) (not (zero? (car l))))\
    \ #t]\n        [else (pairs_sum_to_zero (cdr l))]))\n", "  (let loop ([l l] [check\
    \ (range 0 (sub1 (length l)))])\n    (cond\n      [(empty? l) #f]\n      [(member\
    \ (sub1 (sub1 (length l))) check) #f]\n      [(member (sub1 (sub1 (length l)))\
    \ (map (\u03BB (x) (sub1 (- x (sub1 (sub1 (length l)))))) check)) #f]\n      [(not\
    \ (empty? (filter (\u03BB (x) (= x 0)) l))) #t]\n      [(not (empty? (filter (\u03BB\
    \ (x) (= (sub1 (- (sub1 (sub1 (length l))) x)) (sub1 (sub1 (length l)))) (map\
    \ (\u03BB (x) (sub1 (- x (sub1 (sub1 (length l)))))) check))) check))) #t]\n \
    \     [else (loop (sub1 l) (map (\u03BB (x) (sub1 x)) check))])))\n", "  (if (null?\
    \ l) #f\n      (if (member (car l) (cdr l)) #t\n          (pairs_sum_to_zero (cdr\
    \ l)))))\n", "  (cond [(null? l) false]\n        [(and (member 0 l) (member 0\
    \ (cdr l))) true]\n        [(member (0 - (car l)) (cdr l)) true]\n        [else\
    \ (pairs_sum_to_zero (cdr l))]))\n```\n\n```scheme\n#lang racket\n", "  (cond\n\
    \    [(null? l) (error \"Empty List\")]\n    [(or (= 0 (car l)) (pairs_sum_to_zero\
    \ (cdr l)))]\n    [(member (- (car l)) (cdr l)) #t]\n    [else (pairs_sum_to_zero\
    \ (cdr l))]))", "  (cond\n    [(empty? l) false]\n    [(number? (first l))\n \
    \    (or (pairs_sum_to_zero (rest l))\n         (exists-pair? l - (first l)))]\n\
    \    [else (pairs_sum_to_zero (first l))]))\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(empty? (rest l)) #f]\n    [(zero? (+ (first l) (second l))) #t]\n    [else\
    \ (pairs_sum_to_zero (rest l))]))\n", "  (cond [(empty? l) #f]\n        [(zero?\
    \ (length l)) #f]\n        [(zero? (length (cdr l))) #f]\n        [(let ([x (car\
    \ l)]\n               [y (car (cdr l))])\n           (cond [(= (+ x y) 0) #t]\n\
    \                 [else (pairs_sum_to_zero (cdr l))]))]))\n```\n---\n# More on\
    \ Recursion\n\n``` #lang racket\n", "  (define (helper l acc)\n    (cond ((null?\
    \ l) acc)\n          ((member (list-ref l 0) acc) (helper (cdr l) acc))\n    \
    \      (else (helper (cdr l) (cons (list-ref l 0) acc)))))\n  (define (sum_to_zero?\
    \ n l)\n    (cond ((null? l) #f)\n          ((= (- n (list-ref l 0)) (list-ref\
    \ l 0)) #t)\n          (else (sum_to_zero? n (cdr l)))))\n  (cond ((null? l) #f)\n\
    \        ((null? (cdr l)) #f)\n        ((sum_to_zero? (list-ref l 0) (helper (cdr\
    \ l) '())) #t)\n        (else (pairs_sum_to_zero (cdr l)))))\n", "  (cond [(empty?\
    \ l) #f]\n        [(empty? (rest l)) #f]\n        [(zero? (+ (first l) (first\
    \ (rest l)))) #t]\n        [else (pairs_sum_to_zero (rest l))]))\n", "  ;; if\
    \ the list is empty, then there are no pairs of elements\n  ;; that sum to zero.\n\
    \  (if (null? l)\n      #f\n      ;; otherwise, the list is non-empty.\n     \
    \ ;; we'll need to compare the first element of the list to\n      ;; every other\
    \ element of the list.\n      ;; if the first element of the list is equal to\
    \ the negative\n      ;; of any other element of the list, then we know that\n\
    \      ;; there is a pair of elements that sum to zero.\n      ;; so we check.\n\
    \      (if (null? (member (- (car l) 0) (cdr l)))\n          ;; if we get here,\
    \ it means that no other element of the\n          ;; list is equal to the negative\
    \ of the first element.\n          ;; we recurse on the tail of the list, i.e.\
    \ the list\n          ;; without the first element.\n          (pairs_sum_to_zero\
    \ (cdr l))\n          ;; but if we get here, it means that the first element\n\
    \          ;; does sum to zero with some other element of the list.\n        \
    \  #t)))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(member\
    \ (sub1 (first l) (first (rest l))) (rest (rest l))) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n```\n\n- [pairs_sum_to_zero](pairs_sum_to_zero.rkt)\n\n- [pairs_sum_to_zero_tests](pairs_sum_to_zero_tests.rkt)",
  "    ;; Sum of distinct elements that add to zero\n    (define (elements_sum_to_zero\
    \ el1 el2)\n        (cond [(equal? el1 el2) #f]\n              [(= (add1 el1 el2)\
    \ 0) #t]\n              [else #f]))\n    \n    ;; Sum of different pairs in a\
    \ list\n    (define (sum_list l)\n        (if (empty? l)\n            #f\n   \
    \         (or (elements_sum_to_zero (first l) (second l))\n                (sum_list\
    \ (rest l)))))\n    \n    (sum_list l))\n", "  (let ((found_item (list-set l 0)))\n\
    \    (cond ((eq? found_item #f) #f)\n          ((null? l) #f)\n          (else\n\
    \           (let ((found_other (list-set (remove found_item l) (- 0 found_item))))\n\
    \             (if (eq? found_other #f)\n                 (pairs_sum_to_zero (remove\
    \ found_item l))\n                 #t))))))\n```\n\n```scheme\n#lang racket\n",
  "  (cond\n    [(empty? l) false]\n    [(empty? (rest l)) false]\n    [(member (-\
    \ (first l) (first (rest l))) (rest (rest l))) true]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond [(empty? l) #f]\n        [(and (empty? (rest l)) #f)\
    \ #f]\n        [(empty? (rest l)) #f]\n        [else (cond [(= (apply + (first\
    \ l) (first (rest l))) 0) #t]\n                    [else (pairs_sum_to_zero (rest\
    \ l))])]))\n", "  (cond [(empty? l) #f]\n        [(empty? (rest l)) #f]\n    \
    \    [(or (= (abs (first l)) (abs (second l)))\n             (pairs_sum_to_zero\
    \ (rest l))) #t]\n        [else #f]))\n", "  (let ((n (length l)))\n    (cond\n\
    \      [(= n 0) #f]\n      [(= n 1) #f]\n      [(= n 2) (= (+ (car l) (cadr l))\
    \ 0)]\n      [else (or (pairs_sum_to_zero (cons (car l) (cdr l)))\n          \
    \      (pairs_sum_to_zero (cdr l)))])))\n", "  (cond ((zero? (length l)) #f)\n\
    \        ((and (member (car l) (cdr l)) (member 0 (cdr l))) #t)\n        (else\
    \ (pairs_sum_to_zero (cdr l)))))\n", "  (cond\n    ((empty? l) #f)\n    ((zero?\
    \ (remainder (car l) 2)) #f) ;; Not sure\n    ((= (car l) (cadr l)) #f) ;; Not\
    \ sure\n    ((= (+ (car l) (cadr l)) 0) #t)\n    (else (pairs_sum_to_zero (cdr\
    \ l)))))\n\n\n", "  ;; check parameters\n  (cond\n    [(not (list? l)) (error\
    \ \"wrong type, expected a list\")]\n    [(not (map (lambda (x) (number? x)) l))\
    \ (error \"wrong type, expected a list of numbers\")]\n    [else (pairs_sum_to_zero\
    \ l)]))\n  (define (pair-exists l)\n    (cond\n      [(null? l) #f]\n      [(member\
    \ (0 - (car l)) (cdr l)) #t]\n      [else (pair-exists (cdr l))]))\n  (pair-exists\
    \ l))\n", "  (cond\n    [(and (empty? l)\n          (empty? (cdr l)))\n     #f]\n\
    \    [(member (car l) (cdr l))\n     #t]\n    [else\n     (pairs_sum_to_zero (cdr\
    \ l))]))\n", "  ;; use a local function to avoid passing around the accumulator\n\
    \  (let sum_to_zero ([l l] [acc (list)])\n    (cond [(null? l) (not (null? acc))]\n\
    \          [else (if (member (car l) acc)\n                   (sum_to_zero (cdr\
    \ l) acc)\n                   (sum_to_zero (cdr l) (cons (- (car l)) acc)))])))\n",
  "  (cond\n    [(empty? l) #f]\n    [(and\n       (zero? (modulo (first l) 2))\n\
    \       (member (sub1 (first l)) (rest l)))\n     #t]\n    [(and\n       (zero?\
    \ (modulo (first l) 2))\n       (member (add1 (first l)) (rest l)))\n     #t]\n\
    \    [else (pairs_sum_to_zero (rest l))]))\n", "  (define (inner l)\n    (cond\n\
    \      [(empty? l) #f]\n      [(find (first l) (rest l)) #t]\n      [else (inner\
    \ (rest l))]))\n  (inner l))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest\
    \ l)) #f]\n    [(zero? (abs (sum (first l) (first (rest l))))) #t]\n    [else\
    \ (or (pairs_sum_to_zero (rest l))\n              (pairs_sum_to_zero (rest (rest\
    \ l))))]))\n", "  (cond ((< (length l) 2) #f)\n        ((= (length l) 2) (= (car\
    \ l) (- (cadr l))))\n        (else (or (= (car l) (- (cadr l)))\n            \
    \     (pairs_sum_to_zero (cdr l))))))\n", "   ;; your code here\n  )\n", "  (cond\
    \ ((empty? l) #f)\n        ((pair? (car l))\n         (or (pairs_sum_to_zero (car\
    \ l))\n             (pairs_sum_to_zero (cdr l))))\n        ((empty? (cdr l)) #f)\n\
    \        ((zero? (plus (car l) (cadr l))) #t)\n        (else (pairs_sum_to_zero\
    \ (cdr l)))))\n", "  (and (has_zero_sum? l) (has_distinct_zeros? l)))\n", "  (cond\n\
    \    [(= (length l) 1) #f]\n    [(= (length l) 2) (or (= (car l) (car (cdr l)))\n\
    \                          (= (- (car l) (car (cdr l))) 0))]\n    [else (or (pairs_sum_to_zero\
    \ (cdr l))\n              (pairs_sum_to_zero (list (car l) (car (cdr l))))\n \
    \             (pairs_sum_to_zero (list (car l) (car (cdr (cdr l))))))]))\n", " \
    \ (and (not (empty? l))\n       (or (pairs_sum_to_zero_rec (set l))\n        \
    \   (pairs_sum_to_zero (cdr l)))))\n", "  (define (sum? x y)\n    (= x (- 0 y)))\n\
    \  (for/or ([a l]\n           [b l])\n    (sum? a b)))\n", "  (cond [(empty? l)\
    \ #f]\n        [(empty? (rest l)) #f]\n        [(zero? (+ (first l) (second l)))\
    \ #t]\n        [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n    [(empty?\
    \ l) #f]\n    [(null? (member (- (first l)) (rest l))) (pairs_sum_to_zero (rest\
    \ l))]\n    [else #t]))\n", "  (or (zero? (length l)) (and (not (zero? (modulo\
    \ (length l) 2))) (not (zero? (remainder l (list (sum (quotient l 2)) (remainder\
    \ l (quotient l 2))))))))\n)\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest\
    \ l)) #f]\n    [(or (and (= (- (first l) (second l)) 0) #t)\n         (pairs_sum_to_zero\
    \ (rest l))) #t]\n    [else #f]))\n", "  (cond\n    [empty? l] #f\n    [(zero?\
    \ (apply + l))] #t\n    [else (and\n            (pairs_sum_to_zero (cdr l))\n\
    \            (pairs_sum_to_zero (cdr (cdr l))))]))\n", "  (cond\n    [(empty?\
    \ l) #f]\n    [(empty? (rest l)) #f]\n    [(= (sum (first l) (first (rest l)))\
    \ 0) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (if (or (empty? l)\
    \ (null? (cdr l)))\n      #f\n      (let ([head (car l)]\n            [tail (cdr\
    \ l)])\n        (if (member (sub1 head) tail)\n            #t\n            (pairs_sum_to_zero\
    \ tail)))))\n", "  (cond [(empty? l) false]\n        [(= (length l) 1) false]\n\
    \        [else (if (member (subtract 0 (first l)) (rest l)) true false)]))\n",
  "    ;;; YOUR CODE HERE!\n    #f)\n", "  (or (null? l) (and (member (car l) (cdr\
    \ l)) (not (member (- (car l) (car l)) (cdr l))))))\n", "  (cond ((null? l) #f)\n\
    \        ((and (member (car l) (cdr l)) (equal? (car l) 0)) #t)\n        ((pairs_sum_to_zero\
    \ (cdr l)) #t)\n        (else #f)))\n", "  (cond\n    [(empty? l) #f]\n    [(empty?\
    \ (rest l)) #f]\n    [(number-in-list? (- (first l) (first (rest l))) (rest (rest\
    \ l))) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (and (not (null?\
    \ l))\n       (or (pair_sum_to_zero l)\n           (pairs_sum_to_zero (cdr l)))))\n",
  "  (cond\n    [; FILL ME IN]\n    [; FILL ME IN]\n    [; FILL ME IN]\n    ))\n",
  "  (cond [(empty? l) false]\n        [(cond [(or (= (first l) 0) (= (first l) (*\
    \ -1 (first l)))) (remove (first l) l)]\n               [else (remove (first l)\
    \ l)])\n         (and (member? 0 (remove (first l) l)) (not (member? (first l)\
    \ (remove 0 (remove (first l) l)))))\n         ]\n        [else (pairs_sum_to_zero\
    \ (remove (first l) l))]))\n", "  (if (null? l)\n      #f\n      (or\n       (member\
    \ (- (car l) (car (cdr l))) (cdr (cdr l)))\n       (pairs_sum_to_zero (cdr l)))))\n",
  "  (cond [(empty? l) #f]\n        [(= 0 (list-ref l 0)) (pairs_sum_to_zero (rest\
    \ l))]\n        [(member (- (list-ref l 0)) (rest l)) #t]\n        [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "    (cond\n      [(empty? l) #f]\n      [(member (- (first\
    \ l)) (rest l)) #t]\n      [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(not (eq? (first l) 0))\n     (or (pairs_sum_to_zero\
    \ (rest l))\n         (pair_sum_to_zero_helper (first l) (rest l)))]\n    [else\
    \ #t]))", "    (define (helper left right)\n        (cond [(null? left) #f]\n\
    \              [(member (car left) right) #t]\n              [else (helper (cdr\
    \ left) (cons (car left) right))]))\n    (helper l '()))\n", "  ;; YOUR CODE HERE\n\
    \  (cond [(null? l) #f]\n        [(= (car l) (make-polar 0)) #t]\n        [(member\
    \ (make-polar (car l)) (cdr l)) #t]\n        [else (pairs_sum_to_zero (cdr l))]))\n\
    ```\n\n## Problem 2\n\nThis question deals with [queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle).\n\
    \nYou can use the function `list-queens` and test whether the result is\ncorrect\
    \ by using the function `test-queens`.\n\n```racket\n#lang racket\n", "  (define\
    \ (helper l neg lst)\n    (cond ((null? l) #f)\n          ((member (abs (car l))\
    \ neg) #t)\n          (else (helper (cdr l) (cons (abs (car l)) neg) (cons (car\
    \ l) lst)))))\n  (helper l '() '()))\n", "  (if (&lt;= (length l) 1)\n      #f\n\
    \      (if (= (car l) (car (cdr l)))\n          (pairs_sum_to_zero (cdr l))\n\
    \          (if (= (+ (car l) (car (cdr l))) 0)\n              #t\n           \
    \   (pairs_sum_to_zero (cdr l))))))\n</code>\nI'd appreciate any guidance to improve\
    \ my code.\n\n\nA:\n\nThere's no need to recurse on the whole list: once you've\
    \ found that two elements in the list sum to zero, you can return immediately.\n\
    <code>(define (pairs-sum-to-zero lst)\n  (or (null? lst)\n      (let ((car (car\
    \ lst))\n            (cdr (cdr lst)))\n        (or (memq car cdr)\n          \
    \  (pairs-sum-to-zero cdr)))))\n</code>\nThis is, admittedly, a little esoteric.\
    \  A more conventional way to do it would be to process the list one element at\
    \ a time, using <code>for/or</code>:\n<code>(define (pairs-sum-to-zero lst)\n\
    \  (for/or ([x lst])\n    (any (lambda (y) (= y (- x))) lst)))\n</code>\n", " \
    \ (cond\n    [(null? l) #f]\n    [(or (member 0 l)\n\t (and (not (member 0 l))\n\
    \t      (pairs_sum_to_zero (sort (lambda (a b) (< a b)) l))\n\t      (pairs_sum_to_zero\
    \ (list (list-ref l (sub1 (length l)))\n\t\t\t\t       (list-ref l 0)))))]\n \
    \   [else #f]))\n", "  (define (sum l1 l2)\n    (if (null? l1)\n        #f\n \
    \       (or (equal? (car l1) (car l2))\n            (sum (cdr l1) l2))))\n  (if\
    \ (null? l)\n      #f\n      (or (sum l (map (lambda (x) (- 0 x)) l))\n      \
    \    (pairs_sum_to_zero (cdr l)))))\n", "  (define (has_zero? l)\n    (cond [(null?\
    \ l) #f]\n          [(= 0 (car l)) #t]\n          [else (has_zero? (cdr l))]))\n\
    \  (define (pairs_sum_to_zero? l)\n    (cond [(null? l) #f]\n          [(null?\
    \ (cdr l)) #f]\n          [(zero? (+ (car l) (car (cdr l)))) #t]\n          [else\
    \ (pairs_sum_to_zero? (cdr l))]))\n  (if (has_zero? l)\n      (pairs_sum_to_zero?\
    \ l)\n      #f))\n", "  (or\n   (and (equal? (length l) 2) (equal? (apply + l)\
    \ 0))\n   (and (not (null? (cdr l)))\n        (or (pairs_sum_to_zero (cons (car\
    \ l) (cddr l)))\n            (pairs_sum_to_zero (cdr l))))))\n", "  (cond\n  \
    \  [(null? l) #f]\n    [(eq? (null? (cdr l)) #t) #f]\n    [(eq? (null? (cddr l))\
    \ #t) #f]\n    [(eq? (- (car l) (cadr l)) 0) #t]\n    [(eq? (- (car l) (caddr\
    \ l)) 0) #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n", "  (cond ((null? l)\
    \ #f)\n        ((zero? (length l)) #f)\n        ((and (member (car l) (cdr l))\
    \ (not (zero? (car l)))) #t)\n        (else (pairs_sum_to_zero (cdr l)))))\n",
  "  (cond\n    [(null? l) #f]\n    [(member (car l) (cdr l)) #t]\n    [else (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  ;; first part of the body\n  (and (equal? (length l) 0) #f)\n\
    \  (or (pairs_sum_to_zero_helper (cdr l) (car l))\n      (pairs_sum_to_zero (cdr\
    \ l))))\n", "  (cond [(empty? l) #f]\n        [(member (sum (head l) (head (tail\
    \ l))) (tail (tail l))) #t]\n        [else (pairs_sum_to_zero (tail l))]))\n",
  "  ;; helper function that takes two arguments: an accumulator list, and\n  ;; the\
    \ remaining list to be traversed. it returns #t if the accumulator\n  ;; list\
    \ has a pair of integers that sum to zero, and #f otherwise.\n  (define (helper\
    \ accum remaining)\n    (cond\n      [(empty? remaining) #f]\n      [(contains?\
    \ accum (car remaining)) #t]\n      [else (helper (cons (car remaining) accum)\
    \ (cdr remaining))]))\n  (helper '() l))\n", "  (define (contains l a)\n    (cond\
    \ ((null? l) #f)\n          ((equal? (car l) a) #t)\n          (else (contains\
    \ (cdr l) a))))\n  (cond ((or (null? l) (null? (cdr l))) #f)\n        ((contains\
    \ (cdr l) (- (car l))) #t)\n        (else (pairs_sum_to_zero (cdr l)))))\n", " \
    \ (and (not (empty? l)) (not (empty? (cdr l)))\n       (or (zero? (+ (car l) (cadr\
    \ l)))\n           (pairs_sum_to_zero (cdr l)))))", "  (cond ((empty? l) #f)\n\
    \        ((= (car l) 0) #t)\n        ((zero? (length l)) #f)\n        ((member\
    \ (car l) (cdr l)) #t)\n        (else (pairs_sum_to_zero (cdr l)))))\n", "  (define\
    \ (helper l b s)\n    (cond\n      [(empty? l) #f]\n      [(zero? s) #t]\n   \
    \   [(and (member (car l) b) (not (member (- (car l)) b))) #t]\n      [else (helper\
    \ (cdr l) (cons (car l) b) (+ s (car l)))]))\n  (helper l '() 0))\n", "  (cond\
    \ [(null? l) #f]\n        [(equal? 0 (car l)) #t]\n        [(equal? 0 (cadr l))\
    \ #t]\n        [(pairs_sum_to_zero (cdr l)) #t]\n        [else #f]))\n", "  (local\
    \ [(define (helper l)\n            (if (or (empty? l) (empty? (rest l)))\n   \
    \             #f\n                (if (= (abs (first l)) (abs (first (rest l))))\n\
    \                    #t\n                    (helper (rest l)))))\n          ]\n\
    \    (helper l)))\n```\n\n### Question 3\n\n```racket\n#lang racket\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(null? (cdr l)) #f]\n    [(empty? (cdr l)) #f]\n  \
    \  [(empty? (cddr l)) #f]\n    [(= (car l) (* -1 (cadr l))) #t]\n    [(= (car\
    \ l) (* -1 (caddr l))) #t]\n    [(= (cadr l) (* -1 (caddr l))) #t]\n    [else\
    \ (pairs_sum_to_zero (cdr l))]))\n", "  (cond [(or (empty? l) (null? (cdr l)))\
    \ #f]\n        [else (or (= 0 (+ (car l) (cadr l)))\n                  (pairs_sum_to_zero\
    \ (cdr l)))]))\n", "  (cond\n    [(null? l) #f]\n    [(= (car l) 0) #t]\n    [(member\
    \ (car l) (cdr l)) #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n", "  (if (empty?\
    \ l)\n      #f\n      (or (sumToZero? l)\n          (pairs_sum_to_zero (cdr l)))))\n",
  "  (cond\n    [(null? l) #f]\n    [(member (- (car l)) (cdr l)) #t]\n    [else (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (define (helper l1 l2)\n    (cond\n      [(empty? l1) false]\n\
    \      [(memq (- (first l1) (first l2)) (rest l2)) true]\n      [else (helper\
    \ (rest l1) (rest l2))]))\n  (helper l (rest l)))\n", "  (cond [(empty? l) #f]\n\
    \        [(member? (sum_pairs 0 l) (rest l)) #t]\n        [else (pairs_sum_to_zero\
    \ (rest l))]))", "  (cond\n    [(empty? l) #f]\n    [(not (empty? (sub1 (sub1\
    \ l))))\n     (pairs_sum_to_zero (sub1 l))]\n    [(= 0 (sum l)) #t]\n    [else\
    \ #f]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(zero?\
    \ (+ (first l) (first (rest l)))) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n",
  "  (cond ((null? l) #f)\n        ((null? (cdr l)) #f)\n        ((= 0 (+ (car l)\
    \ (car (cdr l)))) #t)\n        (else (pairs_sum_to_zero (cdr l)))))\n", "  (cond\
    \ ((null? l) #f)\n        ((and (member (car l) (cdr l))\n              (= (car\
    \ l) 0))\n         #t)\n        ((member (car l) (cdr l))\n         (or (pairs_sum_to_zero\
    \ (cdr l))\n             (pairs_sum_to_zero (remove (car l) (cdr l)))))\n    \
    \    (else (pairs_sum_to_zero (cdr l)))))\n", "  (cond [(empty? l) #f]\n     \
    \   [(or (member (- (first l) (second l)) (rest (rest l)))\n             (member\
    \ (- (second l) (first l)) (rest (rest l)))) #t]\n        [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (if (empty? l)\n      #f\n      (or (pairs_sum_to_zero (rest\
    \ l))\n          (if (not (empty? (rest l)))\n              (cond [(= (abs (first\
    \ l)) (abs (first (rest l))))\n                     #t]\n                    [else\n\
    \                     #f])\n              #f))))\n", "  (or (member 0 l)\n   \
    \   (not (null? (remove-duplicates (flatmap (lambda (x) (list (- x) x)) l))))))\n",
  "  (cond\n    [ (empty? l) #f ]\n    [ (&gt;= (length l) 2)\n      (or\n       \
    \ (if (= (sum (first l) (second l)) 0) #t)\n        (pairs_sum_to_zero (rest l)))\
    \ ]\n    [ else #f ]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l))\
    \ #f]\n    [(= (abs (first l)) (abs (first (rest l))))\n     (or (pairs_sum_to_zero\
    \ (rest l)) #t)]\n    [else (pairs_sum_to_zero (rest l))]))\n", "    (cond\n \
    \       [(= (length l) 0) #f]\n        [(= (length l) 1) #f]\n        [(= (length\
    \ l) 2) (if (= (abs (car l)) (car (cdr l))) #t #f)]\n        [else\n        (define\
    \ (is_zero? a b)\n            (cond\n                [(> a 0)\n              \
    \  (if (= (- a b) 0) #t #f)]\n                [(< a 0)\n                (if (=\
    \ (+ a b) 0) #t #f)]\n                [else #f]))\n        (define (get_num_to_check\
    \ n)\n            (cond\n                [(> n 0) (- n)]\n                [(<\
    \ n 0) (+ n)]\n                [else 0]))\n        (define (recur_list_test rest_of_list)\n\
    \            (cond\n                [(= (length rest_of_list) 1) #f]\n       \
    \         [(= (length rest_of_list) 2) (is_zero? (car rest_of_list) (car (cdr\
    \ rest_of_list)))]\n                [else\n                (define rest_rest_of_list\
    \ (cdr rest_of_list))\n                (cond\n                    [(is_zero? (car\
    \ rest_of_list) (car rest_rest_of_list)) #t]\n                    [else (recur_list_test\
    \ rest_rest_of_list)])]))\n        (define (recur_negative_check l)\n        \
    \    (cond\n                [(= (length l) 0) #f]\n                [(= (length\
    \ l) 1) #f]\n                [(= (length l) 2) #f]\n                [else\n  \
    \              (define (is_negative? n)\n                    (cond\n         \
    \               [(< n 0) #t]\n                        [else #f]))\n          \
    \      (define (recur_list_test rest_of_list)\n                    (cond\n   \
    \                     [(= (length rest_of_list) 1) #f]\n                     \
    \   [(= (length rest_of_list) 2) #f]\n                        [else\n        \
    \                (define rest_rest_of_list (cdr rest_of_list))\n             \
    \           (cond\n", "  (let ([len (length l)])\n    (cond\n      [(<= len 1)\n\
    \       #f]\n      [(and (member 0 l)\n            (member (opp (car l)) (cdr\
    \ l)))\n       #t]\n      [else\n       (pairs_sum_to_zero (cdr l))])))\n", " \
    \ (define (pair? l1 l2)\n    (equal? (add l1 l2) 0))\n  (define (sum? l)\n   \
    \ (or (pair? (car l) (cadr l))\n        (sum? (cdr l))))\n  (cond ((null? l) #f)\n\
    \        ((null? (cdr l)) #f)\n        ((= (length l) 2) (pair? (car l) (cadr\
    \ l)))\n        (else (sum? l))))", "  (cond\n    [(null? l) #f]\n    [(integer?\
    \ (first l))\n     (or (pairs_sum_to_zero (rest l))\n         (memv (- (first\
    \ l)) (rest l)))]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n  \
    \  [(empty? l) #f]\n    [(member -(first l) (rest l)) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(or (null? l) (null? (cdr l))) #f]\n    [(=\
    \ 0 (+ (car l) (car (cdr l)))) #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n",
  "  (cond ((null? l) #f)\n        ((null? (cdr l)) #f)\n        ((= (+ (car l) (car\
    \ (cdr l))) 0) #t)\n        (else (pairs_sum_to_zero (cdr l)))))\n", "  (if (empty?\
    \ l)\n      #f\n      (if (null? (cdr l))\n          #f\n          (or (zero?\
    \ (+ (car l) (cadr l)))\n              (pairs_sum_to_zero (cdr l))))))\n", " \
    \ (cond\n    [(null? l) #f]\n    [(member (- (car l)) (cdr l)) #t]\n    [else\
    \ (pairs_sum_to_zero (cdr l))]))\n", "  ;; check to see if there are at least\
    \ two elements in the list\n  (if (or (null? l) (null? (cdr l)))\n      #f\n \
    \     ;; check to see if there is an element for which (0 - x) is in the list\n\
    \      (if (member (- 0 (car l)) (cdr l))\n          #t\n          ;; otherwise\
    \ recurse over the rest of the list\n          (pairs_sum_to_zero (cdr l)))))\n",
  "  (let ([len (length l)])\n    (cond [(or (= 0 len) (= 1 len)) #f]\n          [else\
    \ (or (and (< 0 (car l))\n                         (pairs_sum_to_zero (cdr l)))\n\
    \                    (and (< 0 (cadr l))\n                         (pairs_sum_to_zero\
    \ (cdr l)))\n                    (and (= 0 (car l)) (mem (cadr l) (cdr l)))\n\
    \                    (and (= 0 (cadr l)) (mem (car l) (cdr l)))\n            \
    \        (pairs_sum_to_zero (cdr l)))])))\n", "  (cond\n    [ (= (length l) 1)\
    \ #f]\n    [ (= (length l) 2) (= (+ (car l) (cadr l)) 0)]\n    [ else (or (= (+\
    \ (car l) (cadr l)) 0)\n               (pairs_sum_to_zero (cdr l)))]))\n", " \
    \ (cond\n    [(empty? l) #f]\n    [(zero? (length l)) #f]\n    [(empty? (cdr l))\
    \ #f]\n    [(zero? (+ (car l) (cadr l))) #t]\n    [else (or (pairs_sum_to_zero\
    \ (cdr l))\n              (pairs_sum_to_zero (cddr l)))]))\n", "  (cond\n    [(null?\
    \ l) #f]\n    [(number? (car l))\n     (let ([xs (cdr l)])\n       (or (member\
    \ (- (car l)) xs)\n           (pairs_sum_to_zero xs)))]\n    [else (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n\
    \    [(= 0 (+ (first l) (second l))) #t]\n    [else (or (pairs_sum_to_zero (rest\
    \ l)) (pairs_sum_to_zero (rest (rest l))))]))\n", "  (define (helper l1 l2)\n\
    \    (cond\n      [(empty? l1) #f]\n      [(member? (first l1) l2) #t]\n     \
    \ [else (helper (rest l1) (append l2 (list (first l1))))]))\n  (helper l (list)))\n",
  "  (cond [(empty? l) #f]\n        [(equal? (car l) 0) #t]\n        [(member? (-\
    \ (car l)) (cdr l)) #t]\n        [else (pairs_sum_to_zero (cdr l))]))\n", "  (if\
    \ (null? l)\n      #f\n      (let ([x (car l)])\n        (if (pairs_sum_to_zero\
    \ (cdr l))\n            #t\n            (if (member (sub1 0 x) (cdr l))\n    \
    \            #t\n                #f)))))\n", "  (if (null? l)\n      #f\n    \
    \  (or (case (list-ref l 0)\n            ((0) #t)\n            ((x) (member -x\
    \ (cdr l))))\n          (pairs_sum_to_zero (cdr l)))))\n", "  (cond\n    [(empty?\
    \ l) #f]\n    [(and (member (car l) (cdr l))\n          (not (member (car l) (remove\
    \ (car l) (cdr l))))) #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n", "  (cond\
    \ [(empty? l) #f]\n        [(empty? (rest l)) #f]\n        [(define (f l)\n  \
    \         (cond [(empty? l) #f]\n                 [(define (g l)\n           \
    \         (cond [(empty? l) #f]\n                          [(= (+ (first l) (first\
    \ (rest l))) 0) #t]\n                          [else (g (rest l))]))\n       \
    \           (g l)]\n                 [else (f (rest l))]))\n         (f l)]))\n",
  "  (define (helper l acc)\n    (cond [(empty? l) #f]\n          [(in? (first l)\
    \ acc) (helper (rest l) acc)]\n          [(in? (- (first l)) acc) #t]\n      \
    \    [else (helper (rest l) (cons (first l) acc))]))\n  (helper l (list)))\n```\n\
    \n## Problem 2\n\n```racket\n#lang racket\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(empty? (rest l)) #f]\n    [(or (= 0 (list-ref l 0)) (= 0 (list-ref l 1)))\
    \ #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (local ((define (r l)\n\
    \            (cond\n              [(null? l) #f]\n              [(null? (cdr l))\
    \ #f]\n              [(= (car l) (car (cdr l))) (r (cdr l))]\n              [(=\
    \ 0 (car l)) #t]\n              [(= 0 (car (cdr l))) #t]\n              [(= (car\
    \ l) (abs (car (cdr l)))) #t]\n              [(= (car (cdr l)) (abs (car l)))\
    \ #t]\n              [else (r (cdr l))])))\n    (r l)))\n\n", "  (cond [(empty?\
    \ l) #f]\n        [(pair? (member (car l) (cdr l))) #t]\n        [else (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (cond\n    [(null? l) #f]\n    [(pair_sum_to_zero? (first\
    \ l) (rest l)) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond ((null?\
    \ l) #f)\n        ((pair_sum_to_zero (car l) (cdr l)) #t)\n        (else (pairs_sum_to_zero\
    \ (cdr l)))))\n", "  (cond\n    [(= (length l) 1) #f]\n    [(member (first l)\
    \ (rest l)) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (define (helper\
    \ l)\n    (cond [(empty? l) empty]\n          [(empty? (rest l)) empty]\n    \
    \      [else (cons (list (first l) (first (rest l)))\n                      (helper\
    \ (rest l)))]))\n  (define (is-contained l1 l2)\n    (cond [(empty? l1) #f]\n\
    \          [(empty? l2) #f]\n          [(or (equal? (first l1) (first l2))\n \
    \              (equal? (first l1) (rest l2))\n               (equal? (rest l1)\
    \ (first l2))\n               (equal? (rest l1) (rest l2))) #t]\n          [else\
    \ (is-contained l1 (rest l2))]))\n  (cond [(empty? l) #f]\n        [(is-contained\
    \ (list 0 0) (helper l)) #t]\n        [else (pairs_sum_to_zero (rest l))]))\n",
  "  (define (pairs_sum_to_zero_iter l total)\n    (cond\n      [(null? l) total]\n\
    \      [(and\n          (memq - (car l) l)\n          (not (memq - (car l) (cdr\
    \ l)))) #t]\n      [else (pairs_sum_to_zero_iter (cdr l) total)]))\n  (pairs_sum_to_zero_iter\
    \ l #f))\n", "  (cond\n    [(or (empty? l) (empty? (rest l))) #f]\n    [(zero?\
    \ (add1 (apply + (map abs l)))) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n",
  "  (define (pairs_sum_to_zero_helper l new-list)\n    (cond\n      [(and (not (null?\
    \ l)) (not (null? new-list)))\n       (if (or (member (car l) new-list) (member\
    \ (- (car l)) new-list))\n           #t\n           (pairs_sum_to_zero_helper\
    \ (cdr l) (cons (car l) new-list)))]\n      [else #f]))\n  (pairs_sum_to_zero_helper\
    \ l null))\n```\n\n```racket", "  (cond\n    [(empty? l) (error \"input list is\
    \ empty\")]\n    [(null? (cdr l)) #f]\n    [(equal? 0 (+ (car l) (car (cdr l))))\
    \ #t]\n    [else (or (pairs_sum_to_zero (cdr l))\n              (pairs_sum_to_zero\
    \ (cdr (cdr l))))]))\n\n", "  (cond [(empty? l) false]\n        [(empty? (rest\
    \ l)) false]\n        [(member (sub1 (first l) (second l)) (rest (rest l))) true]\n\
    \        [else (pairs_sum_to_zero (rest l))]))\n", "  (if (or (empty? l) (empty?\
    \ (rest l)))\n      #f\n      (if (and (member (sub1 (first l)) (rest l))\n  \
    \             (member (sub1 (first l)) (rest l)))\n          #t\n          (pairs_sum_to_zero\
    \ (rest l)))))\n", "  (if (empty? l) #f\n      (let ((x (first l))\n         \
    \   (xs (rest l)))\n        (or (member 0 xs)\n            (or (member (zero?\
    \ (- x)) xs)\n                (pairs_sum_to_zero xs))))))\n", "  (cond\n    [(empty?\
    \ l) #f]\n    [(= (length l) 1) #f]\n    [else (or (pairs_sum_to_zero (rest l))\n\
    \              (reduce + (rest l)))]))\n", "  (cond [(null? l) #f]\n        [(empty?\
    \ (rest l)) #f]\n        [(zero? (apply + (map (lambda (i) (if (member i (rest\
    \ l)) i 0)) l))) #t]\n        [else (pairs_sum_to_zero (rest l))]))\n", "  ;;\
    \ check if two numbers in the list sum to zero\n  (define (check-next num l)\n\
    \    (cond\n      [(empty? l) #f] ; base case - end of list\n      [(equal? (\
    \ + num (first l)) 0) #t] ; match found\n      [else (check-next num (rest l))]))\
    \ ; recur on list\n  ;; do the check on the first element of the list, recur on\
    \ list\n  (cond\n    [(empty? l) #f] ; base case - empty list\n    [(empty? (rest\
    \ l)) #f] ; base case - one element in list\n    [(check-next (first l) (rest\
    \ l)) #t] ; check the first element\n    [else (pairs_sum_to_zero (rest l))]))\
    \ ; recur on the list\n", "  (define (split-list l)\n    (cond\n      [(empty?\
    \ l) (values (list) (list))]\n      [else (let-values ([(first-part rest-part)\
    \ (split-list (rest l))])\n                (values (cons (first l) first-part)\n\
    \                        rest-part))]))\n  (define (is-pairs-sum-to-zero? l)\n\
    \    (cond\n      [(empty? l) #f]\n      [(empty? (rest l)) #f]\n      [else (let-values\
    \ ([(first first-part rest-part) (split-list l)])\n              (or (= (apply\
    \ + first) 0)\n                  (is-pairs-sum-to-zero? rest-part)))]))\n  (is-pairs-sum-to-zero?\
    \ l))\n", "  (cond [(empty? l) #f]\n        [(empty? (rest l)) #f]\n        [(=\
    \ (first l) (zero? (first l))) #t]\n        [(= (- (first l) (first (rest l)))\
    \ 0) #t]\n        [else (pairs_sum_to_zero (rest l))]))\n```\n\n```scheme\n#lang\
    \ racket\n", "  (for/or ([n1 l]\n           [n2 l])\n    (and (not (= n1 n2))\n\
    \         (= (+ n1 n2) 0))))\n", "  (define (aux l ll out)\n    (cond ((null?\
    \ l) #f)\n          ((member (- (car l) (car ll)) out) #t)\n          (else (aux\
    \ (cdr l) ll (cons (car l) out)))))\n  (aux (cdr l) (cdr l) (list (car l))))\n",
  "  (cond\n    [(empty? l) #f]\n    [(or (member (second l) (rest (rest l)))\n  \
    \       (member (second l) (rest (rest (rest l))))) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n```\n\n## Exercise 6.1\n\n```#lang racket\n", "  (define (in_list\
    \ val l)\n    (cond\n      [(null? l) #f]\n      [(equal? val (car l)) #t]\n \
    \     [else (in_list val (cdr l))]))\n  (define (loop l)\n    (cond\n      [(null?\
    \ l) #f]\n      [(in_list (* -1 (car l)) (cdr l)) #t]\n      [else (loop (cdr\
    \ l))]))\n  (loop l))\n", "  (cond [(empty? l)\n         #f]\n        [(= (length\
    \ l) 1)\n         #f]\n        [(and (not (= 0 (car l))) (not (= 0 (car (cdr l))))\n\
    \              (pairs_sum_to_zero (cdr l)))\n         #t]\n        [(or (= 0 (car\
    \ l)) (= 0 (car (cdr l))))\n         #t]\n        [else\n         (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (cond\n    ((null? l) #f)\n    ((null? (cdr l)) #f)\n   \
    \ ((zero? (zero? (sum_to_zero? l 0))) #t)\n    (else (pairs_sum_to_zero (cdr l)))))\n",
  "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(member (- (first\
    \ l) (first (rest l))) (rest (rest l))) #t]\n    [else (pairs_sum_to_zero (rest\
    \ l))]))\n", "  (cond\n    [(or (empty? l) (empty? (rest l)))\n     #f]\n    [(or\
    \ (member (abs (first l)) (rest l))\n         (pairs_sum_to_zero (rest l)))\n\
    \     #t]\n    [else\n     #f]))\n```\n\n### Part 3:\n\n```\n#lang racket\n",
  "  (cond ((null? l) #f)\n        ((null? (cdr l)) #f)\n        ((and (memq (car\
    \ l) (cdr l)) (not (= (car l) 0))) #t)\n        (else (pairs_sum_to_zero (cdr\
    \ l)))))\n", "  (cond\n    [(empty? l) #f]\n    [(cons? (cdr l)) (or (zero? (+\
    \ (car l) (cadr l))) (pairs_sum_to_zero (cdr l)))]\n    [else #f]))\n", "   (cond\n\
    \      [(empty? l) #f]\n      [(empty? (rest l)) #f]\n      [(member (abs (first\
    \ l)) l) #t]\n      [else (pairs_sum_to_zero (rest l))]))\n```\n\n```scheme\n\
    #lang racket\n", "  (cond\n    [(null? l) #f]\n    [(and (null? (cdr l)) (zero?\
    \ (car l))) #t]\n    [(and (null? (cdr l)) (not (zero? (car l)))) #f]\n    [(find\
    \ (car l) (cdr l)) #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n", "  (define\
    \ (helper-pairs-sum-to-zero l)\n    (cond [(empty? l) #f]\n          [(and (member?\
    \ (car l) (cdr l))\n                (zero? (+ (car l) (car (cdr l))))) #t]\n \
    \         [else (helper-pairs-sum-to_zero (cdr l))]))\n  (helper-pairs-sum-to-zero\
    \ (sort l <)))\n```\n\n```racket\n#lang racket\n", "  (let ([s (in-set l)])\n\
    \    (cond [(empty? s) #f]\n          [(zero? (length s)) #f]\n          [(member\
    \ (opposite (first s)) (rest s)) #t]\n          [else (pairs_sum_to_zero (rest\
    \ s))])))\n", "  (define (recur l seen)\n    (cond ((null? l) #f)\n          ((assoc\
    \ (car l) seen) #t)\n          (else (recur (cdr l) (cons (cons (car l) (car l))\
    \ seen)))))\n  (recur l '()))\n", "  (cond\n    [(empty? l) #f]\n    [(member?\
    \ (- (first l)) (rest l)) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n```\n\
    \n```racket\n#lang racket\n", "  (cond\n    [(null? l) #f]\n    [(null? (cdr l))\
    \ #f]\n    [(= (apply + (car l) (cadr l)) 0) #t]\n    [else (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (define (split l idx)\n    (if (and (not (= idx 0)) (= (modulo\
    \ idx 2) 0))\n        (cons (list-ref l idx) (split l (- idx 1)))\n        (split\
    \ l (- idx 1))))\n  (define (is_in_list e l)\n    (cond ((null? l) #f)\n     \
    \     ((= e (car l)) #t)\n          (else (is_in_list e (cdr l)))))\n  (define\
    \ (pairs_sum_to_zero_iter pairs)\n    (cond ((null? pairs) #f)\n          ((is_in_list\
    \ (- (car pairs)) (cdr pairs)) #t)\n          (else (pairs_sum_to_zero_iter (cdr\
    \ pairs)))))\n  (pairs_sum_to_zero_iter (split l (- (length l) 1))))\n", "  (if\
    \ (empty? l) #f\n      (for/or ([x (in-list l)]\n               [y (in-list l)])\n\
    \        (and (not (eq? x y)) (= x (- y))))))\n", "  (or (member 0 l)\n      (not\
    \ (empty? (member* (filter (lambda (n) (member (- n) l)) l) l)))))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(member (rest l) (first\
    \ l)) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (define (member elem\
    \ l)\n    (cond\n      [(empty? l) #f]\n      [(equal? elem (first l)) #t]\n \
    \     [else (member elem (rest l))]))\n  (cond\n    [(empty? l) #f]\n    [(member\
    \ (- (first l)) (rest l)) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", " \
    \ (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(zero? (add1 (remainder\
    \ (first l) (first (rest l))))) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n",
  "  (define (pair_to_zero l)\n    (cond [(null? l) #f]\n          [(null? (cdr l))\
    \ #f]\n          [(= (car l) (- (car (cdr l)))) #t]\n          [else (pair_to_zero\
    \ (cdr l))]))\n  (pair_to_zero l))\n", "  (list? l))\n```\n\n```#lang racket\n",
  "  (if (<= (length l) 1)\n      #f\n      (if (member (- (car l) (cadr l)) (cddr\
    \ l))\n          #t\n          (pairs_sum_to_zero (cdr l)))))\n", "  (cond\n \
    \   [(empty? l) #f]\n    [(null? (cdr l)) #f]\n    [(= (+ (car l) (cadr l)) 0)\
    \ #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n```\n\n```\n#lang racket\n",
  "  (cond [(empty? l) false]\n        [(zero? (remainder (- (first l) (second l))))\
    \ true]\n        [else (pairs_sum_to_zero (rest l))]))\n", "  (if (empty? l)\n\
    \      #f\n      (let loop((lst l) (sum 0))\n        (if (empty? lst)\n      \
    \      (if (zero? sum)\n                #t\n                #f)\n            (loop\
    \ (cdr lst) (+ sum (car lst)))))))", "  (cond ((empty? l) #f)\n        ((empty?\
    \ (rest l)) #f)\n        ((= (first l) 0) #t)\n        ((member (- (first l) (first\
    \ (rest l))) (rest (rest l))) #t)\n        (else (pairs_sum_to_zero (rest l)))))\n",
  "  (if (null? l)\n      #f\n      (not (not (sum-to-zero-help l)))))\n", "  ;; YOUR\
    \ CODE HERE\n  )\n", "    ;; post: return #t if there are two distinct elements\
    \ in l that sum to zero,\n    ;; otherwise #f\n    (let loop ([l l])\n      (if\
    \ (null? l) #f\n          (if (member (- (car l)) (cdr l)) #t\n              (loop\
    \ (cdr l))))))\n", "  (match l\n    [(and (? pair? (? equal? 0)) _) #t]\n    [(and\
    \ (? pair? _) (? pair? _)) (or (pairs_sum_to_zero (cdr l))\n                 \
    \                      (pairs_sum_to_zero (cons 0 (cdr l))))]\n    [_ #f]))\n",
  "  (define lastlist empty)\n  (cond ((empty? l) #f)\n        ((and (empty? (cdr\
    \ l)) (or (= 0 (car l)) (member (car l) lastlist))) #f)\n        ((and (empty?\
    \ (cdr l)) (and (not (member (car l) lastlist)) (member (- 0 (car l)) lastlist)))\
    \ #t)\n        ((member (- 0 (car l)) lastlist) #t)\n        (else (set! lastlist\
    \ (cons (car l) lastlist)) (pairs_sum_to_zero (cdr l)))\n  )\n)\n", "  (define\
    \ (pairs_sum_to_zero-helper l k)\n    (cond [(empty? l) #f]\n          [(equal?\
    \ 0 (remainder (first l) 2))\n           (pairs_sum_to_zero-helper (rest l) (cons\
    \ (first l) k))]\n          [(member (first l) k) #t]\n          [else (pairs_sum_to_zero-helper\
    \ (rest l) (cons (first l) k))]))\n  (pairs_sum_to_zero-helper l (list)))\n",
  "  (cond [(empty? l) #f]\n        [(> (length l) 1) (or (member (zero? (- (first\
    \ l) (second l))) #t)\n                              (pairs_sum_to_zero (rest\
    \ l)))]\n        [else #f]))\n", "  (cond ((null? l) #f) ;; base case: empty list\n\
    \        ((null? (cdr l)) #f) ;; base case: singleton list\n        ((equal? 0\
    \ (+ (car l) (car (cdr l)))) #t) ;; recursive case: found (car l) and (car (cdr\
    \ l)) that sum to zero\n        (else (pairs_sum_to_zero (cdr l))))) ;; recursive\
    \ case: continue recursing with the tail\n", "  (cond [(empty? l) #f]\n      \
    \  [(= (count_zero l) 2) #t]\n        [else (pairs_sum_to_zero (cdr l))]))\n",
  "  (cond [(empty? l) false]\n        [(empty? (rest l)) false]\n        [(= (+ (first\
    \ l) (second l)) 0) true]\n        [else (pairs_sum_to_zero (rest l))]))\n", " \
    \ (define (helper s l)\n    (cond ((null? l) false)\n          ((= 0 (list-ref\
    \ l 0)) (or true (helper s (cdr l))))\n          ((member (list-ref l 0) s) (helper\
    \ s (cdr l)))\n          (else (or (member (- (list-ref l 0)) s) (helper (cons\
    \ (list-ref l 0) s) (cdr l))))))\n  (helper (list) l))\n", "  (cond\n    [(null?\
    \ l) #f]\n    [(find_pair_in_lst (car l) (cdr l)) #t]\n    [else (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (define (member? x l)\n    (cond\n      [(null? l) #f]\n\
    \      [(equal? x (car l)) #t]\n      [else (member? x (cdr l))]))\n  (define\
    \ (pairs-sum-to-zero? l)\n    (cond\n      [(null? l) #f]\n      [(member? (-\
    \ (car l)) (cdr l)) #t]\n      [else (pairs-sum-to-zero? (cdr l))]))\n  (if (null?\
    \ l)\n      #f\n      (pairs-sum-to-zero? l)))\n", "  (cond\n    [(null? l) (display\
    \ #f)]\n    [(null? (cdr l)) (display #f)]\n    [(= (+ (car l) (car (cdr l)))\
    \ 0) (display #t)]\n    [else (pairs_sum_to_zero (cdr l))]))\n", "  (cond [(=\
    \ (length l) 1) #f]\n        [(= (length l) 2) (or (zero? (apply + l)) #f)]\n\
    \        [else (or (and (zero? (apply + (list (car l) (cadr l))))\n          \
    \             #t)\n                  (pairs_sum_to_zero (cons (car l) (cddr l))))]))\n",
  "  (define (pairs_sum_to_zero-iter l n)\n    (cond ((null? l) #f)\n          ((or\
    \ (zero? n) (member n l #t)) #t)\n          (else (pairs_sum_to_zero-iter (cdr\
    \ l) (- n (car l))))))\n  (if (null? l)\n      #f\n      (pairs_sum_to_zero-iter\
    \ (cdr l) (- (car l)))))\n```\n\n<hr>\n\n#### Lists - Concise\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(null? l) #f]\n    [(member (abs (car l)) (cdr l))\
    \ #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n```\n\n#### Question 2.5\n\n\
    ###### [5 points]\n\nThe function `combinations` consumes a positive integer n\
    \ and a list of elements. It returns a list of all possible (non-repeating) combinations\
    \ of size n from the given list of elements. In this case, a combination is a\
    \ sequence of n elements, with the requirement that no element can be used more\
    \ than once. Combinations are ordered only with respect to the order of their\
    \ elements, not the order in which they appear in the list.\n\nFor example, the\
    \ list returned by `(combinations 3 (list 0 1 2 3))` is:\n\n```racket\n'((0 1\
    \ 2) (0 1 3) (0 2 3) (1 2 3))\n```\n\nNote that the orders of (1 2 3) and (1 3\
    \ 2) are different, and hence they are both included in the result.\n\n```racket\n\
    #lang racket\n", "  ;; we need to keep track of whether we've found a number\n\
    \  ;; that would sum to zero with something in l\n  (define (pairs_sum_to_zero/seen\
    \ l seen)\n    (cond [(empty? l) #f]\n          [else\n           (cond [(member\
    \ (first l) seen)\n                  (pairs_sum_to_zero/seen (rest l) seen)]\n\
    \                 [else\n                  (let* ([seen (cons (first l) seen)]\n\
    \                         [seen (if (member (- (first l)) seen) #t seen)])\n \
    \                   (if seen\n                        #t\n                   \
    \     (pairs_sum_to_zero/seen (rest l) seen)))])]))\n  (pairs_sum_to_zero/seen\
    \ l (list)))\n", "  (cond\n    [(null? l) false]\n    [(= (length l) 1) false]\n\
    \    [else\n     (let ([first (car l)]\n           [rest (cdr l)])\n       (cond\n\
    \         [(member (- first) rest) true]\n         [else (pairs_sum_to_zero rest)]))]))\n",
  "  (cond ((null? l) #f)\n        ((null? (cdr l)) #f)\n        ((= (car l) (car\
    \ (cdr l))) #f)\n        ((= (car l) 0) #t)\n        ((zero? (modulo (car l) (car\
    \ (cdr l)))) #t)\n        (else #f)))\n```\n\n```scheme\n#lang racket\n", "  (define\
    \ (pairs_sum_to_zero_pairs l)\n    (cond\n      [(empty? l) (list)]\n      [(empty?\
    \ (rest l)) (list)]\n      [else (cons (+ (first l) (first (rest l)))\n      \
    \            (pairs_sum_to_zero_pairs (rest l)))]))\n  (cond\n    [(empty? l)\
    \ #f]\n    [(member 0 (pairs_sum_to_zero_pairs l)) #t]\n    [else #f]))\n```\n\
    \n### Problem 5 (5 Points)\n\nWrite the function `lengths` that takes as input\
    \ a list of non-empty lists of integers and returns a list of their lengths.\n\
    ```\n#lang racket\n", "  (define (helper l s)\n    (if (null? l)\n        #f\n\
    \        (if (assoc (car l) s)\n            #t\n            (helper (cdr l) (cons\
    \ (cons (car l) #t) s)))))\n  (helper l (list)))\n", "  (cond [(empty? l) false]\n\
    \        [(= (count l) 1) false]\n        [else (or (zero? (add1 (count (filter\
    \ (lambda (v) (= v (- (first l)) )) (rest l)))))\n                  (pairs_sum_to_zero\
    \ (rest l)))]))", "  (cond ((null? l) #f)\n        ((null? (cdr l)) #f)\n    \
    \    ((= 0 (+ (car l) (car (cdr l)))) #t)\n        (else (pairs_sum_to_zero (cdr\
    \ l)))))\n", "  (cond\n    [(empty? l) #f]\n    [(= (length l) 1) #f]\n    [else\
    \ (if (or (member 0 l) (member-b (car l) (cdr l))) #t (pairs_sum_to_zero (cdr\
    \ l)))]))\n", "  ;; your code here.\n  (cond\n    [(or (empty? l) (= (length l)\
    \ 1)) #f]\n    [(member (list (car l) 0) (pair_sum_list l)) #t]\n    [else (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (define (trav l)\n    (cond\n      [(empty? l) #f]\n    \
    \  [(memq (car l) (cdr l)) #t]\n      [else (trav (cdr l))]))\n  (trav l))\n",
  "  (cond\n    [(= (length l) 0) #f]\n    [(or (zero? (car l)) (zero? (cadr l)))\
    \ #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n", "  (cond ((null? l) #f)\n\
    \        ((= (length l) 1) #f)\n        ((elem-in-list? (car l) (cdr l)) #t)\n\
    \        (else (pairs_sum_to_zero (cdr l)))))\n", "  (let ((n (length l)))\n \
    \   (cond\n      [(or (= n 0) (= n 1)) #f]\n      [(or (= (first l) 0) (= (first\
    \ l) (second l))) #t]\n      [else (pairs_sum_to_zero (rest l))])))\n", "  (let\
    \ loop ([nums l] [i 0])\n    (if (< i (length nums))\n        (or (member (expt\
    \ (- (list-ref nums i) 0) 2) nums)\n            (loop nums (+ i 1)))\n       \
    \ #f)))\n", "  (cond\n    [(null? l) #f]\n    [(number? (car l))\n     (if (member\
    \ (- (car l)) (cdr l))\n         #t\n         (pairs_sum_to_zero (cdr l)))]\n\
    \    [else (pairs_sum_to_zero (cdr l))]))\n\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(empty? (rest l)) #f]\n    [(equal? 0 (+ (first l) (first (rest l)))) #t]\n\
    \    [else (pairs_sum_to_zero (rest l))]))\n```\n\n# Solution\n\nThe time complexity\
    \ for this solution is O(n), because it runs through the list once.\n\n```racket",
  "  ;; helper function to filter out 0s\n  (define (no-zeros l)\n    (cond ((null?\
    \ l) '())\n          ((= (car l) 0) (no-zeros (cdr l)))\n          (else (cons\
    \ (car l) (no-zeros (cdr l))))))\n  ;; helper function to see if a pair of numbers\
    \ in the list sum to zero\n  (define (sum-to-zero? l)\n    (cond ((null? l) #f)\n\
    \          ((member (- (car l)) (cdr l)) #t)\n          (else (sum-to-zero? (cdr\
    \ l)))))\n  (sum-to-zero? (no-zeros l)))\n", "  ;; set up function that takes\
    \ a list and a value and returns #t\n  ;; if the value is in the list, otherwise\
    \ #f\n  (define (in-list l v)\n    (cond ((null? l) #f)\n          ((= (car l)\
    \ v) #t)\n          (else (in-list (cdr l) v))))\n  ;; loop over list, checking\
    \ each element with the in-list function\n  (define (loop l)\n    (cond ((null?\
    \ l) #f)\n          ((in-list (cdr l) (* -1 (car l))) #t)\n          (else (loop\
    \ (cdr l)))))\n  (loop l))\n", "  (define (pairs_helper l first)\n    (cond\n\
    \      ((null? l) #f)\n      ((member (- first (car l)) (cdr l)) #t)\n      (else\
    \ (pairs_helper (cdr l) first))))\n  (cond\n    ((null? l) #f)\n    ((null? (cdr\
    \ l)) #f)\n    (else (or (pairs_helper (cdr l) (car l))\n              (pairs_sum_to_zero\
    \ (cdr l))))))\n", "  (if (empty? l)\n      #f\n      (let ((pair? (for/or ([i\
    \ (in-list l)]\n                           [j (in-list l)])\n                \
    \    (and (not (= i j))\n                         (= i (- 0 j))))))\n        (if\
    \ pair?\n            #t\n            #f))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
