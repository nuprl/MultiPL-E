name: HumanEval_43_pairs_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; pairs_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns #t if there are two distinct elements in the list that\n;; sum to\
  \ zero, and #f otherwise.\n;; >>> (pairs_sum_to_zero (list 1 3 5 0))\n;; #f\n;;\
  \ >>> (pairs_sum_to_zero (list 1 3 -2 1))\n;; #f\n;; >>> (pairs_sum_to_zero (list\
  \ 1 2 3 7))\n;; #f\n;; >>> (pairs_sum_to_zero (list 2 4 -5 3 5 7))\n;; #t\n;; >>>\
  \ (pairs_sum_to_zero (list 1))\n;; #f\n(define (pairs_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 -2 1)) #f)\n    (check-equal? (candidate (list 1 2 3 7)) #f)\n    (check-equal?\
  \ (candidate (list 2 4 -5 3 5 7)) #t)\n    (check-equal? (candidate (list 1)) #f)\n\
  \    (check-equal? (candidate (list -3 9 -1 3 2 30)) #t)\n    (check-equal? (candidate\
  \ (list -3 9 -1 3 2 31)) #t)\n    (check-equal? (candidate (list -3 9 -1 4 2 30))\
  \ #f)\n    (check-equal? (candidate (list -3 9 -1 4 2 31)) #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? l) false]\n    [(empty? (rest l)) false]\n  \
    \  [(member (- (first l) (second l)) (rest (rest l)))\n     true]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n\
    \    [(= 0 (+ (first l) (first (rest l)))) #t]\n    [else (pairs_sum_to_zero (rest\
    \ l))]))\n", "  (if (null? l)\n      #f\n      (or (zero? (car l))\n         \
    \ (pair_sum_to_zero (cdr l) (car l)))))\n", "  (cond\n    [(empty? l) #f]\n  \
    \  [(empty? (rest l)) #f]\n    [(positive? (sum l)) (pairs_sum_to_zero (rest l))]\n\
    \    [(zero? (sum l)) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\
    \ [(null? l) #f]\n        [(and (member (car l) (cdr l)) (not (zero? (car l))))\
    \ #t]\n        [else (pairs_sum_to_zero (cdr l))]))\n", "  (let loop ([l l] [check\
    \ (range 0 (sub1 (length l)))])\n    (cond\n      [(empty? l) #f]\n      [(member\
    \ (sub1 (sub1 (length l))) check) #f]\n      [(member (sub1 (sub1 (length l)))\
    \ (map (\u03BB (x) (sub1 (- x (sub1 (sub1 (length l)))))) check)) #f]\n      [(not\
    \ (empty? (filter (\u03BB (x) (= x 0)) l))) #t]\n      [(not (empty? (filter (\u03BB\
    \ (x) (= (sub1 (- (sub1 (sub1 (length l))) x)) (sub1 (sub1 (length l)))) (map\
    \ (\u03BB (x) (sub1 (- x (sub1 (sub1 (length l)))))) check))) check))) #t]\n \
    \     [else (loop (sub1 l) (map (\u03BB (x) (sub1 x)) check))])))\n", "  (if (null?\
    \ l) #f\n      (if (member (car l) (cdr l)) #t\n          (pairs_sum_to_zero (cdr\
    \ l)))))\n", "  (cond [(null? l) false]\n        [(and (member 0 l) (member 0\
    \ (cdr l))) true]\n        [(member (0 - (car l)) (cdr l)) true]\n        [else\
    \ (pairs_sum_to_zero (cdr l))]))\n```\n\n```scheme\n#lang racket\n", "  (cond\n\
    \    [(null? l) (error \"Empty List\")]\n    [(or (= 0 (car l)) (pairs_sum_to_zero\
    \ (cdr l)))]\n    [(member (- (car l)) (cdr l)) #t]\n    [else (pairs_sum_to_zero\
    \ (cdr l))]))", "  (cond\n    [(empty? l) false]\n    [(number? (first l))\n \
    \    (or (pairs_sum_to_zero (rest l))\n         (exists-pair? l - (first l)))]\n\
    \    [else (pairs_sum_to_zero (first l))]))\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(empty? (rest l)) #f]\n    [(zero? (+ (first l) (second l))) #t]\n    [else\
    \ (pairs_sum_to_zero (rest l))]))\n", "  (cond [(empty? l) #f]\n        [(zero?\
    \ (length l)) #f]\n        [(zero? (length (cdr l))) #f]\n        [(let ([x (car\
    \ l)]\n               [y (car (cdr l))])\n           (cond [(= (+ x y) 0) #t]\n\
    \                 [else (pairs_sum_to_zero (cdr l))]))]))\n```\n---\n# More on\
    \ Recursion\n\n``` #lang racket\n", "  (define (helper l acc)\n    (cond ((null?\
    \ l) acc)\n          ((member (list-ref l 0) acc) (helper (cdr l) acc))\n    \
    \      (else (helper (cdr l) (cons (list-ref l 0) acc)))))\n  (define (sum_to_zero?\
    \ n l)\n    (cond ((null? l) #f)\n          ((= (- n (list-ref l 0)) (list-ref\
    \ l 0)) #t)\n          (else (sum_to_zero? n (cdr l)))))\n  (cond ((null? l) #f)\n\
    \        ((null? (cdr l)) #f)\n        ((sum_to_zero? (list-ref l 0) (helper (cdr\
    \ l) '())) #t)\n        (else (pairs_sum_to_zero (cdr l)))))\n", "  (cond [(empty?\
    \ l) #f]\n        [(empty? (rest l)) #f]\n        [(zero? (+ (first l) (first\
    \ (rest l)))) #t]\n        [else (pairs_sum_to_zero (rest l))]))\n", "  ;; if\
    \ the list is empty, then there are no pairs of elements\n  ;; that sum to zero.\n\
    \  (if (null? l)\n      #f\n      ;; otherwise, the list is non-empty.\n     \
    \ ;; we'll need to compare the first element of the list to\n      ;; every other\
    \ element of the list.\n      ;; if the first element of the list is equal to\
    \ the negative\n      ;; of any other element of the list, then we know that\n\
    \      ;; there is a pair of elements that sum to zero.\n      ;; so we check.\n\
    \      (if (null? (member (- (car l) 0) (cdr l)))\n          ;; if we get here,\
    \ it means that no other element of the\n          ;; list is equal to the negative\
    \ of the first element.\n          ;; we recurse on the tail of the list, i.e.\
    \ the list\n          ;; without the first element.\n          (pairs_sum_to_zero\
    \ (cdr l))\n          ;; but if we get here, it means that the first element\n\
    \          ;; does sum to zero with some other element of the list.\n        \
    \  #t)))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(member\
    \ (sub1 (first l) (first (rest l))) (rest (rest l))) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n```\n\n- [pairs_sum_to_zero](pairs_sum_to_zero.rkt)\n\n- [pairs_sum_to_zero_tests](pairs_sum_to_zero_tests.rkt)",
  "    ;; Sum of distinct elements that add to zero\n    (define (elements_sum_to_zero\
    \ el1 el2)\n        (cond [(equal? el1 el2) #f]\n              [(= (add1 el1 el2)\
    \ 0) #t]\n              [else #f]))\n    \n    ;; Sum of different pairs in a\
    \ list\n    (define (sum_list l)\n        (if (empty? l)\n            #f\n   \
    \         (or (elements_sum_to_zero (first l) (second l))\n                (sum_list\
    \ (rest l)))))\n    \n    (sum_list l))\n", "  (let ((found_item (list-set l 0)))\n\
    \    (cond ((eq? found_item #f) #f)\n          ((null? l) #f)\n          (else\n\
    \           (let ((found_other (list-set (remove found_item l) (- 0 found_item))))\n\
    \             (if (eq? found_other #f)\n                 (pairs_sum_to_zero (remove\
    \ found_item l))\n                 #t))))))\n```\n\n```scheme\n#lang racket\n",
  "  (cond\n    [(empty? l) false]\n    [(empty? (rest l)) false]\n    [(member (-\
    \ (first l) (first (rest l))) (rest (rest l))) true]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond [(empty? l) #f]\n        [(and (empty? (rest l)) #f)\
    \ #f]\n        [(empty? (rest l)) #f]\n        [else (cond [(= (apply + (first\
    \ l) (first (rest l))) 0) #t]\n                    [else (pairs_sum_to_zero (rest\
    \ l))])]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
