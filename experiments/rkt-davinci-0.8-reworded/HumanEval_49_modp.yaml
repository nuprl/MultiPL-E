name: HumanEval_49_modp
language: rkt
prompt: "#lang racket\n\n;; Return 2^n modulo p (be aware of numerics).\n;; >>> (modp\
  \ 3 5)\n;; 3\n;; >>> (modp 1101 101)\n;; 2\n;; >>> (modp 0 101)\n;; 1\n;; >>> (modp\
  \ 3 11)\n;; 8\n;; >>> (modp 100 101)\n;; 1\n(define (modp n p)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n\
  \    (check-equal? (candidate 3 5) 3)\n    (check-equal? (candidate 1101 101) 2)\n\
  \    (check-equal? (candidate 0 101) 1)\n    (check-equal? (candidate 3 11) 8)\n\
  \    (check-equal? (candidate 100 101) 1)\n    (check-equal? (candidate 30 5) 4)\n\
  \    (check-equal? (candidate 31 5) 3)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 0)\n      1\n      (* (modp (quotient n 2) p)\n        \
    \ (if (= (remainder n 2) 0)\n             1\n             (modp (quotient n 2)\
    \ p)))))\n", "  (cond\n    [(= n 0) 1]\n    [(= (remainder n 2) 0)\n     (let*\
    \ ([d (modp (/ n 2) p)]\n            [result (* d d)])\n       (remainder result\
    \ p))]\n    [else\n     (let* ([d (modp (/ n 2) p)]\n            [result (* d\
    \ d)])\n       (remainder (* result 2) p))]))\n\n", "  (cond [(= n 0) 1]\n   \
    \     [(even? n)\n         (define v (/ n 2))\n         (define v2 (modp v p))\n\
    \         (define v2sqr (* v2 v2))\n         (define r (modulo v2sqr p))\n   \
    \      r]\n        [else\n         (define v (/ (- n 1) 2))\n         (define\
    \ v2 (modp v p))\n         (define v2sqr (* v2 v2))\n         (define r (* 2 (modulo\
    \ v2sqr p)))\n         (define r2 (modulo r p))\n         r2]))\n", "  (let ([result\
    \ 1])\n    (for ([x (in-range n)])\n      (set! result (* result 2)\n      (set!\
    \ result (modulo result p))))\n    result))\n</code>\nThe problem appears to be\
    \ in the modulo procedure: it should return the modulo of result with p, but it\
    \ returns the modulo of x with p.\n<code>#lang racket\n", "  (modulo (expt 2 n)\
    \ p))\n", "  (modulo (expt 2 n) p))\n", "  (define (mp n p result)\n    (cond\
    \ [(= n 0) 1]\n          [(= (remainder n 2) 0) (mp (/ n 2) p (* result result))]\n\
    \          [else (mp (/ (- n 1) 2) p (* result result result))]))\n  (cond [(=\
    \ n 0) 1]\n        [(= p 1) 1]\n        [(= p 0) 0]\n        [else (remainder\
    \ (mp n p 1) p)]))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n        \
    \  (let* ([temp (modp (/ n 2) p)])\n            (* temp temp))\n          (mod\
    \ n p))))\n", "  (if (= n 0)\n      1\n      (* (expt 2 (modulo n p)) (modp (quotient\
    \ n p) p))))\n</code>\nOn my laptop the following code:\n<code>#lang racket\n",
  "  (modulo (expt 2 n) p))\n", "  (let loop ([n n] [k 0])\n    (if (&lt; n 0)\n \
    \       (loop (- n p) (add1 k))\n        (if (= n 0)\n            (expt 2 k)\n\
    \            (if (= (remainder n 2) 0)\n                (loop (/ n 2) (add1 k))\n\
    \                (loop (- n 1) (add1 k)))))))\n</code>\n", "  (cond\n    [(zero?\
    \ n) 1]\n    [(even? n) (modulo (square (modp (/ n 2) p)) p)]\n    [else (modulo\
    \ (* (modp (- n 1) p) 2) p)]))\n", "  (cond\n    [(= n 0) 1]\n    [(= (remainder\
    \ n 2) 0)\n     (let ((tmp (* (modp (/ n 2) p) (modp (/ n 2) p))))\n       (if\
    \ (&gt; tmp p) (- tmp p) tmp))]\n    [else\n     (let ((tmp (* n (modp (/ n 2)\
    \ p) (modp (/ n 2) p))))\n       (if (&gt; tmp p) (- tmp p) tmp))]))\n</code>\n\
    Ok, now the messy, modular numbers.\n<code>#lang racket\n", "  (if (= n 0)\n \
    \     1\n      (if (odd? n)\n          (if (= n 1)\n              1\n        \
    \      (* (modp (/ n 2) p) (modp (/ n 2) p) p))\n          (if (= n 2)\n     \
    \         1\n              (* (modp (/ n 2) p) (modp (/ n 2) p) p)))))\n", " \
    \ (cond ((= n 0) 1)\n        ((even? n) (modulo (square (modp (/ n 2) p)) p))\n\
    \        (else (modulo (* (modp (- n 1) p) 2) p))))\n", "  (if (= n 0)\n     \
    \ 1\n      (* (expt 2 (modulo n p)) (modp (quotient n p) p))))\n</code>\nAnd here's\
    \ the Rust implementation. I'm actually sure this is correctly calculating modular\
    \ powers, but it doesn't seem to pass all the tests:\n<code>fn modp(n: usize,\
    \ p: usize) -&gt; usize {\n    if n == 0 {\n        1\n    } else {\n        2usize.pow(n\
    \ % p) * modp(n / p, p)\n    }\n}\n</code>\nAnd the test cases:\n<code>fn main()\
    \ {\n    assert_eq!(modp(3, 5), 3);\n    assert_eq!(modp(1101, 101), 2);\n   \
    \ assert_eq!(modp(0, 101), 1);\n    assert_eq!(modp(3, 11), 8);\n    assert_eq!(modp(100,\
    \ 101), 1);\n}\n</code>\nThe tests that work fine are <code>modp(3, 5)</code>\
    \ and <code>modp(1101, 101)</code>. The tests that don't work are <code>modp(0,\
    \ 101)</code>, <code>modp(3, 11)</code>, and <code>modp(100, 101)</code>. The\
    \ first two fail because of overflows, the last one I don't understand why it\
    \ fails. I've tried this solution in Python, which produces the same output as\
    \ Racket, so I'm sure I'm doing something wrong.\nWhat am I doing wrong? Is there\
    \ a better way to calculate modular powers?\n\n\nA:\n\nYour implementation is\
    \ close, but you can easily run into overflow if <code>n</code> is too large,\
    \ which is what appears to be happening. The trick is to multiply with the modulus\
    \ whenever the result is too large, because <code>a * b mod p = (a mod p) * (b\
    \ mod p) mod p</code>.\nSo here is a corrected implementation:\n<code>fn modp(n:\
    \ usize, p: usize) -&gt; usize {\n    if n == 0 {\n        1\n    } else {", " \
    \ (if (zero? n)\n      1\n      (if (even? n)\n          (modulo (* (modp (/ n\
    \ 2) p) (modp (/ n 2) p)) p)\n          (modulo (* (modp (/ n 2) p) (modp (/ n\
    \ 2) p) 2) p))))\n</code>\nI wrote this in racket, but it's just a mathematical\
    \ function so it should be easy to convert to any language.\n", "  (if (zero?\
    \ n)\n      1\n      (if (even? n)\n          (let ([n-1 (/ n 2)])\n         \
    \   (if (even? n-1)\n                (mod (* (modp n-1 p) (modp n-1 p)) p)\n \
    \               (mod (* (modp n-1 p) (modp (1+ n-1) p)) p)))\n          (mod (*\
    \ 2 (modp (- n 1) p)) p))))\n", "  (cond [(= n 0) 1]\n        [(= n 1) n]\n  \
    \      [(even? n) (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n        [else\
    \ (modulo (* (modp (- n 1) p) 2) p)]))\n", "  (cond\n    [(= n 0) 1]\n    [(modulo\
    \ n 2) (modulo (* 2 (modp (quotient n 2) p)) p)]\n    [else (modulo (* p (modp\
    \ (quotient n 2) p)) p)]))\n", "  (define (iter-modp n p m)\n    (cond ((= n 0)\
    \ m)\n          ((even? n) (iter-modp (/ n 2) p (* m m p)))\n          (else (iter-modp\
    \ (- n 1) p (* n m p)))))\n  (iter-modp n p 1))\n", "  (let ([r 1])\n    (for\
    \ ([i (in-range n)])\n      (set! r (modulo (* r 2) p)))\n    r))\n", "  (cond\
    \ [(= n 0) 1]\n        [(= (modulo n 2) 0)\n         (modulo (* (modp (/ n 2)\
    \ p) (modp (/ n 2) p)) p)]\n        [else\n         (modulo (* 2 (modp (- n 1)\
    \ p)) p)]))\n", "  (if (= n 0)\n      1\n      (let ((x (modp (quotient n 2) p)))\n\
    \t(if (even? n)\n\t    (modulo (* x x) p)\n\t    (modulo (* p x x) p)))))\n```\n\
    \n```racket", "  (if (zero? n)\n      1\n      (modulo (* 2 (modp (sub1 n) p))\
    \ p)))\n", "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n        [(= n 2) 2]\n  \
    \      [(= n 3) 3]\n        [(= n 4) 6]\n        [(= n 5) 1]\n        [(= n 6)\
    \ 2]\n        [(= n 7) 1]\n        [(= n 8) 8]\n        [(= n 9) 9]\n        [(=\
    \ n 10) 1]\n        [(= n 11) 1]\n        [(= n 12) 1]\n        [(= n 13) 1]\n\
    \        [(= n 14) 1]\n        [(= n 15) 1]\n        [(= n 16) 1]\n        [(=\
    \ n 17) 1]\n        [(= n 18) 1]\n        [(= n 19) 1]\n        [(= n 20) 1]\n\
    \        [(= n 21) 1]\n        [(= n 22) 1]\n        [(= n 23) 1]\n        [(=\
    \ n 24) 1]\n        [(= n 25) 1]\n        [(= n 26) 1]\n        [(= n 27) 1]\n\
    \        [(= n 28) 1]\n        [(= n 29) 1]\n        [(= n 30) 1]\n        [(=\
    \ n 31) 1]\n        [(= n 32) 1]\n        [(= n 33) 1]\n        [(= n 34) 1]\n\
    \        [(= n 35) 1]\n        [(= n 36) 1]\n        [(= n 37) 1]\n        [(=\
    \ n 38) 1]\n        [(= n 39) 1]\n        [(= n 40) 1]\n        [(= n 41) 1]\n\
    \        [(= n 42) 1]\n        [(= n 43) 1]\n        [(= n 44) 1]\n        [(=\
    \ n 45) 1]\n        [(= n 46) 1]\n        [(= n 47) 1]\n        [(= n 48) 1]\n\
    \        [(= n 49) 1]\n        [(= n 50) 1]\n        [(= n 51) 1]\n        [(=\
    \ n 52) 1]\n        [(= n 53) 1]\n        [(= n 54) 1]\n        [(= n 55) 1]\n\
    \        [(= n 56", "  (let loop ([exp (* 2 n)] [mod (* 3 n)])\n    (cond [(&gt;=\
    \ exp p)\n           mod]\n          [else\n           (loop (+ exp n) (* exp\
    \ mod))])))\n</code>\nI am getting this error:\n<code>c:/Users/abc/myname/myname/myname.rkt:7:6:\
    \ .exp: undefined;\n cannot reference an identifier before its definition\n  in\
    \ module: top-level\n</code>\nThis is not making sense to me. Any help? Thanks!\n\
    \n\nA:\n\n<code>exp</code> is a syntax keyword. So don't use it as an identifier.\n",
  "  (define (modp-iter n p n-tot n-tot-tot)\n    (if (zero? n)\n        n-tot-tot\n\
    \        (modp-iter (quotient n 2)\n                   p\n                   (if\
    \ (odd? n)\n                       (modulo (* n-tot n-tot) p)\n              \
    \         n-tot)\n                   (if (odd? n)\n                       (modulo\
    \ (* n-tot n-tot-tot) p)\n                       n-tot-tot))))\n  (modp-iter n\
    \ p 1 1))\n", "  (cond [(<= n 0) 1]\n        [(zero? (remainder n 2))\n      \
    \   (modulo (modp (/ n 2) p) p)]\n        [else\n         (modulo (* 2 (modp (-\
    \ n 1) p)) p)]))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n          (modulo\
    \ (* (modp (/ n 2) p) (modp (/ n 2) p)) p)\n          (modulo (* n (modp (- n\
    \ 1) p)) p))))\n```\n\n---\n\n### NCM\n\n```racket\n#lang racket\n", "  (if (zero?\
    \ n)\n      1\n      (if (even? n)\n          (modulo (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p)) p)\n          (modulo (* (modp (/ n 2) p) (modp (/ n 2) p) n) p))))\n",
  "  (if (= n 0)\n      1\n      (let ((y (modp (/ n 2) p)))\n        (if (= (remainder\
    \ n 2) 0)\n            (modulo (* y y) p)\n            (modulo (* y y n) p)))))\n",
  "  (if (zero? n)\n      1\n      (modulo (* 2 (modp (sub1 n) p)) p)))\n</code>\n\
    Now the task is to convert this function to Python. Unfortunately I don't know\
    \ Racket, so I just copied the text and tried to apply the conversion rules I\
    \ know (as I understand, in Racket function definitions and ifs are structured\
    \ differently than in Python). What I got is this:\n<code>#lang racket\n", " \
    \ (cond [(= n 0) 1]\n        [(even? n)\n         (let [(p-1 (modp (/ n 2) p))]\n\
    \           (modulo (* p-1 p-1) p))]\n        [else\n         (modulo (* n (modp\
    \ (- n 1) p)) p)]))\n", "  (cond [(= n 0) 1]\n        [(even? n) (modulo (modp\
    \ (/ n 2) p) p)]\n        [else (modulo (* (modp (/ (- n 1) 2) p) 2) p)]))\n",
  "  (modulo (* 2 (modp (- n 1) p)) p))\n", "  (if (zero? n)\n      1\n      (if (even?\
    \ n)\n          ;; trick to avoid intermediate products of huge size\n       \
    \   (square (modp (/ n 2) p))\n          (remainder (* n (modp (- n 1) p)) p))))\n",
  "  (define (iter prod x p)\n    (cond\n      [(> x 0) (iter (* prod 2) (- x 1) p)]\n\
    \      [(= x 0) prod]))\n  (modulo (iter 1 n p) p))\n", "  (cond ((= n 0) 1)\n\
    \        ((= (remainder n 2) 0) (remainder (square (modp (quotient n 2) p)) p))\n\
    \        (else (remainder (* (modp (quotient n 2) p) (modp (quotient n 2) p) p)\
    \ p))))\n", "  (let ((a (modulo (* 2 (modp (sub1 n) p)) p)))\n    (if (or (zero?\
    \ n) (= a 0))\n        1\n        a)))\n", "  (if (= 0 n)\n      1\n      (* (modp\
    \ (quotient n 2) p)\n         (if (= 1 (remainder n 2))\n             2\n    \
    \         (let ((q (modulo (+ 1 (* 2 p)) p)))\n               (if (= 0 q)\n  \
    \                 0\n                   (+ 1 (* 2 q))))))))\n", "  (cond\n   \
    \ [(= n 0) 1]\n    [(zero? (modulo n 2)) (modulo (* (modp (/ n 2) p) (modp (/\
    \ n 2) p)) p)]\n    [else (modulo (* 2 (modp (- n 1) p)) p)]))\n", "  (cond ((or\
    \ (equal? p 0)\n             (equal? n 0))\n         1)\n        ((equal? n 1)\n\
    \         1)\n        ((even? n)\n         (modulo (square (modp (/ n 2) p)) p))\n\
    \        (else\n         (modulo (* n (modp (- n 1) p)) p))))\n", "  (if (= n\
    \ 0)\n      1\n      (let ([p_minus_1 (- p 1)])\n        (cond\n         [(= (remainder\
    \ n 2) 0)\n          (modulo (expt (modp (/ n 2) p) 2) p)]\n         [else\n \
    \         (modulo (* (modp (1- n) p) 2) p)]))))", "  (cond\n    [(zero? n) 1]\n\
    \    [(even? n) (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo\
    \ (* (modp (- n 1) p) 2) p)]))\n", "  (if (= 0 n)\n      1\n      (let ((n1 (modulo\
    \ n p)))\n        (if (= 0 n1)\n            1\n            (let ((val (modp (quotient\
    \ n p) p)))\n              (let ((val2 (* n1 val)))\n                (modulo val2\
    \ p)))))))\n```\n\n``` #lang racket\n", "  (define (powmod n p acc)\n    (cond\
    \ [(= n 0) acc]\n          [(even? n) (powmod (/ n 2) p (* acc acc p))]\n    \
    \      [else (powmod (- n 1) p (* acc n p))]))\n  (powmod n p 1))\n", "  (cond\n\
    \    [(= n 0) 1]\n    [(even? n) (modulo (expt 2 (quotient n 2)) p)]\n    [else\
    \ (modulo (* 2 (modp (- n 1) p)) p)]))\n```\n\nWhich leaves us with a problem:\
    \ numbers are unbounded and we're dealing with\na finite amount of memory. In\
    \ many languages we'd do this by using a big\nnumber library, but racket supports\
    \ infinite numbers out of the box. A quick\nlook at the docs:\n\nhttp://docs.racket-lang.org/reference/numbers.html#%28part._bignum%29\n\
    \nTells us that our infinite numbers are also modular and that we can do exact\n\
    modular arithmetic with them. The docs also tell us how to turn a native number\n\
    into a big number.\n\nWe already know that the problem is easy to solve, so we\
    \ start by writing the\neasiest thing that could possibly work.\n\n```racket",
  "  (remainder (expt 2 n) p))\n", "  (define (mod2k x)\n    (cond [(= 1 x) 1]\n \
    \         [(= p x) p]\n          [(even? x) (mod2k (/ x 2))]\n          [else\
    \ (* (mod2k (/ x 2)) (mod2k (/ x 2)))])\n  )\n  (cond [(= 0 n) 1]\n        [(=\
    \ 1 n) 1]\n        [(= p n) p]\n        [(even? n) (mod2k n)]\n        [else (*\
    \ (mod2k n) (mod2k n))]))\n", "  (define (modp-iter n p r)\n    (cond\n      [(even?\
    \ n) (modp-iter (/ n 2) p (* r r p))]\n      [(= 1 n) r]\n      [else (modp-iter\
    \ (- n 1) p (* r r p))]))\n  (modp-iter n p 1))\n```\n\n```", "  (cond\n    ((zero?\
    \ n) 1)\n    ((odd? n) (modulo (* 2 (modp (sub1 n) p)) p))\n    (else (modulo\
    \ (square (modp (quotient n 2) p)) p))))\n", "  (cond\n    [(= n 0) 1]\n    [(=\
    \ (remainder n 2) 0) (modulo (square (modp (/ n 2) p)) p)]\n    [else (modulo\
    \ (* n (modp (- n 1) p)) p)]))\n", "  (cond\n    [(= n 0) 1]\n    [(= (remainder\
    \ n 2) 0) (mod (expt 2 (/ n 2)) p)]\n    [else (mod (* (modp (- n 1) p) 2) p)]))\n\
    \n", "  (cond\n    [(<= n 1) 1]\n    [(even? n) (modulo (square (modp (/ n 2)\
    \ p)) p)]\n    [else (modulo (* (modp (- n 1) p) 2) p)]))", "  (if (= n 0)\n \
    \     1\n      (* (expt 2 (modulo n p)) (modp (quotient n p) p))))\n", "  (cond\n\
    \    [(zero? n)\n     1]\n    [(even? n)\n     (modulo (modp (quotient n 2) p)\n\
    \             (* 2 (modp (quotient n 2) p))\n             p)]\n    [else\n   \
    \  (modulo (* 2 (modp (quotient (- n 1) 2) p))\n             (modp (quotient (-\
    \ n 1) 2) p)\n             p)]))", "  (define (modp-iter n curr-power)\n    (if\
    \ (= n 0)\n        1\n        (let ((next-power (* curr-power 2)))\n         \
    \ (if (> next-power n)\n              (if (= curr-power 1)\n                 \
    \ 1\n                  (modulo next-power p))\n              (modp-iter (- n curr-power)\
    \ next-power)))))\n  (modp-iter n 1))\n</code>\n", "  (modulo (expt 2 n) p))\n",
  "  (define (power x y)\n    (if (= y 0)\n        1\n        (* x (power x (- y 1)))))\n\
    \  (modulo (power 2 n) p))\n", "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n   \
    \     [(even? n) (modulo (square (modp (/ n 2) p)) p)]\n        [else\n      \
    \   (modulo (* (modp (- n 1) p) 2) p)]))\n", "  (let loop ([n n] [acc 1])\n  \
    \  (cond\n      [(= n 0) acc]\n      [(even? n) (loop (/ n 2) (* acc acc p))]\n\
    \      [else (* acc (loop (sub1 n) (* acc acc p)) p)])))\n", "  (remainder (*\
    \ 2 n) p))\n", "  (cond [(= n 0) 1]\n        [(even? n) (modulo (square (modp\
    \ (/ n 2) p)) p)]\n        [else (modulo (* (modp (- n 1) p) 2) p)]))\n", "  (cond\
    \ [(= n 0) 1]\n        [(even? n) (modulo (expt 2 (/ n 2)) p)]\n        [else\
    \ (modulo (* 3 (modp (- n 1) p)) p)]))\n", "  (if (= p 0)\n      1\n      (if\
    \ (= n 0)\n          1\n          (modulo (* (modp (- n 1) p) 2) p))))\n</code>\n\
    <code>;; Return 2^n modulo p (be aware of numerics).", "  (if (= n 0)\n      1\n\
    \      (if (even? n)\n          (let ((acc (* (modp (/ n 2) p) (modp (/ n 2) p))))\n\
    \            (if (> acc p)\n                (- acc p)\n                acc))\n\
    \          (let ((acc (* (modp (- n 1) p) 2)))\n            (if (> acc p)\n  \
    \              (- acc p)\n                acc)))))\n```\n\n# Explanation\n\nLet's\
    \ assume for simplicity that the number to be exponentiated is `2`.\n\nWe are\
    \ using two different methods:\n* a linear method in the case of odd numbers\n\
    * an efficient method in the case of even numbers\n\n## Case of even numbers\n\
    \nWe can do the following:\n\n* for `n = 0`, the result is `1`\n* for `n = 2k`,\
    \ the result is `(modp k p)^2`\n\nThis is equivalent to\n\n* for `n = 0`, the\
    \ result is `1`\n* for `n = 2k`, the result is `(modp (k/2) p)^2`\n\n## Case of\
    \ odd numbers\n\nWe can do the following:\n\n* for `n = 1`, the result is `2`\n\
    * for `n = 2k + 1`, the result is `2 * (modp k p)^2`\n\nThis is equivalent to\n\
    \n* for `n = 1`, the result is `2`\n* for `n = 2k + 1`, the result is `2 * (modp\
    \ (k/2) p)^2`\n\n## Conclusion\n\nThe two methods above can be seen as a generic\
    \ method for all `n`:\n\n* for `n = 0`, the result is `1`\n* for `n = 2k`, the\
    \ result is `(modp (k/2) p)^2`\n* for `n = 2k + 1`, the result is `2 * (modp (k/2)\
    \ p)^2`\n\n# Conclusion\n\nIn this article, we have seen how to raise a number\
    \ to a power modulo `p` using two different methods.\n\nThe even case is really\
    \ efficient, but the odd case is linear.\n\nThe result is a combination of", " \
    \ (define-values (q r) (exact-integer-sqrt (integer-sqrt p)))\n  (define Q (make-vector\
    \ (add1 q) 0))\n  (define R (make-vector (add1 r) 0))\n  (for ([i (in-range (vector-length\
    \ Q))])\n    (vector-set! Q i (expt 2 (add1 i))))\n  (for ([i (in-range (vector-length\
    \ R))])\n    (vector-set! R i (modulo (add1 i) p)))\n  (define result 1)\n  (define\
    \ i 0)\n  (define m (- n p))\n  (while (not (negative? m))\n    (if (positive?\
    \ (modulo m (vector-ref Q i)))\n        (begin\n          (set! result (modulo\
    \ (* result (vector-ref R i)) p))\n          (set! m (- m (vector-ref Q i)))))\n\
    \    (set! i (add1 i)))\n  result)\n", "  (define (square x) (* x x))\n  (cond\
    \ ((= n 0) 1)\n        ((= n 1) n)\n        ((even? n) (modulo (square (modp (/\
    \ n 2) p)) p))\n        (else (modulo (* n (modp (- n 1) p)) p))))\n</code>\n",
  "  (cond [(= n 0) 1]\n        [(= (modulo n 2) 0) (modulo (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p)) p)]\n        [else (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)\
    \ (modp (- n 1) p)) p)]))\n", "  (define (square x) (* x x))\n  (define (modp-iter\
    \ x i)\n    (cond ((= n 0) 1)\n          ((odd? n) (modulo (* x (modp-iter x (-\
    \ i 1))) p))\n          (else (modp-iter (square x) (* 2 i)))))\n  (modp-iter\
    \ 2 n))\n", "  (cond\n    [(zero? n) 1]\n    [(zero? (remainder n 2)) (* (modp\
    \ (/ n 2) p) (modp (/ n 2) p))]\n    [else (* (modp (- n 1) p) (modp (/ n 2) p)\
    \ (modp (/ n 2) p))]))\n", "  (cond [(= n 0) 1]\n        [(and (= n 1) (&gt; p\
    \ 0)) 1]\n        [(odd? n)\n         (modulo (* (modp (/ n 2) p) (modp (/ n 2)\
    \ p) p) p)]\n        [else\n         (modulo (* (modp (/ n 2) p) (modp (/ n 2)\
    \ p) (* 2 p)) p)]))\n</code>\nI have already tried the following (mostly for practice),\
    \ but I couldn't spot any pattern that would make me think that I can write a\
    \ loop that solves my problem.\nAny help is appreciated. Thanks in advance!\n\n\
    \nA:\n\nStep 1:\nWhat you're asking for is the <code>n</code>th power of an element\
    \ in the field of integers modulo <code>p</code>.  Since you're using Racket,\
    \ we might as well make this a procedure that returns a procedure that takes <code>n</code>\
    \ and returns the <code>n</code>th power of a given element in the field of integers\
    \ modulo <code>p</code>.\n<code>(define (int-fld p)\n  (lambda (n)\n    ...))\n\
    </code>\nStep 2:\nSince all you're doing is exponentiation, we'll just use repeated\
    \ squaring.\n<code>(define (int-fld p)\n  (lambda (n)\n    (let loop ((k n) (x\
    \ 1))\n      (cond ((zero? k) x)\n            ((even? k) (loop (quotient k 2)\
    \ (modulo (* x x) p)))\n            (else        (loop (quotient k 2) (modulo\
    \ (* x x x) p)))))))\n</code>\nStep 3:\nWe can be clever about handling the case\
    \ where <code>n</code> is negative.  If <code>n</code> is negative, we'll just\
    \ use the inverse of the power function for positive <code>n</code>.\n<code>(define\
    \ (int-fld p)\n  (let ((int-fld-pos (lambda (n)\n                       (let loop\
    \ ((k n) (x 1))\n                         (cond ((zero? k) x)\n              \
    \                 ((even? k) (loop (", "  (let loop ([n n] [p p] [acc 1])\n  \
    \  (if (= n 0)\n        acc\n        (loop (quotient n 2) p\n              (if\
    \ (odd? n)\n                  (modulo (* acc (modulo (* acc acc) p)) p)\n    \
    \              (modulo (* acc acc) p))))))\n", "  (require math)\n  (remainder\
    \ (expt 2 n) p))\n", "  (let ([l (list 1)])\n    (for ([i (in-range n)])\n   \
    \   (set! l (list (* (first l) 2) (cdr l))))\n    (modulo (first l) p)))\n", " \
    \ (modulo (expt 2 n) p))\n```\n\n### [Problem 8](https://github.com/k-bradley/racket-exercises/blob/master/README.md#problem-8)\n\
    \n``` #lang racket\n", "  (let loop ([n n] [p p] [r 1])\n    (cond\n      [(zero?\
    \ n) r]\n      [(even? n) (loop (quotient n 2) (expt p 2) r)]\n      [else (loop\
    \ (sub1 n) p (* r p))])))\n", "  (cond\n    [(zero? n) 1]\n    [(even? n)\n  \
    \   (if (= (remainder n 2) 0) 1 (multiply (square (modp (quotient n 2) p)) n p))]\n\
    \    [else\n     (multiply (square (modp (quotient n 2) p)) n p)]))\n", "  (define\
    \ (it acc i)\n    (if (< i n)\n        (it (modulo (* acc 2) p) (+ i 1))\n   \
    \     acc))\n  (it 1 0))\n", "  (let loop ([n n] [m 1])\n    (cond\n      [(zero?\
    \ n) m]\n      [(even? n) (loop (quotient n 2) (modulo (* m m) p))]\n      [else\
    \      (loop (quotient n 2) (modulo (* m (modulo (* m 2) p)) p))])))\n", "  (define\
    \ (modp-impl res exp)\n    (if (&gt; exp 0)\n        (modp-impl (modulo (* 2 res)\
    \ p) (- exp 1))\n        res))\n  (modp-impl 1 n))\n", "  (if (zero? n)\n    \
    \  1\n      (if (even? n)\n          (modulo (square (modp (quotient n 2) p))\
    \ p)\n          (modulo (* (modp (quotient n 2) p) (modp (quotient (add1 n) 2)\
    \ p)) p))))\n", "  (if (= 0 n)\n      1\n      (if (odd? n)\n          (modulo\
    \ (* (modp (- n 1) p) 2) p)\n          (modulo (square (modp (/ n 2) p)) p))))\n",
  "  (cond ((zero? n) 1)\n        ((even? n) (modulo (square (modp (quotient n 2)\
    \ p)) p))\n        (else (modulo (* (modp (quotient (- n 1) 2) p) 2) p))))\n",
  "  (let ([product 1])\n    (for ([i (in-range n)])\n      (set! product (* product\
    \ 2))\n      (set! product (modulo product p)))\n    product))\n", "  (define\
    \ (modp n p)\n    (cond\n      [(= n 0) 1]\n      [(= n 1) (remainder 1 p)]\n\
    \      [(even? n) (modulo (square (modp (/ n 2) p)) p)]\n      [else (modulo (*\
    \ 2 (modp (- n 1) p)) p)]))\n  (modp (remainder n p) p))\n", "  (let loop ([t\
    \ 2] [n n])\n    (cond [(zero? n) 1]\n          [(zero? (remainder n 2)) (loop\
    \ (remainder (* t t) p) (/ n 2))]\n          [else (remainder (* t (loop (remainder\
    \ (* t t) p) (/ n 2))) p)])))\n", "  (if (equal? n 0)\n      1\n      (remainder\
    \ (* (modp (quotient n 2) p) (modp (quotient n 2) p)) p)))\n", "  (if (zero? n)\n\
    \      1\n      (if (even? n)\n          (modulo (expt 2 (/ n 2)) p)\n       \
    \   (modulo (* (expt 2 (quotient n 2)) 2) p))))\n", "  (if (zero? n)\n      1\n\
    \      (let ([z (modp (quotient n 2) p)])\n        (remainder (* z z) p))))\n",
  "  (let loop ([n n] [acc 1])\n    (if (= n 0)\n        acc\n        (loop (quotient\
    \ n 2)\n              (if (odd? n)\n                  (modulo (* acc 2) p)\n \
    \                 (modulo acc p))))))\n", "  (let loop ([n n] [acc 1])\n    (if\
    \ (= n 0)\n        acc\n        (let ([c (modulo n 2)])\n          (if (= c 0)\n\
    \              (loop (floor (/ n 2)) (modulo (* acc acc) p))\n              (loop\
    \ (floor (/ n 2)) (modulo (* acc acc acc) p)))))))\n", "  (if (= n 0)\n      1\n\
    \      (modulo (* (modp (- n 1) p) 2) p)))\n", "  (modulo (* (modulo (expt 2 n)\
    \ 1000000007) (modulo n 1000000007)) 1000000007))\n", "  (define (mp b e)\n  \
    \  (cond\n      [(zero? e) 1]\n      [(even? e) (mp (modulo (* b b) p) (/ e 2))]\n\
    \      [else (modulo (* b (mp b (- e 1))) p)]))\n  (mp n p))\n", "  (cond\n  \
    \  [(zero? n) 1]\n    [(even? n) (modulo (expt 2 (quotient n 2)) p)]\n    [else\
    \ (modulo (* (expt 2 (quotient (- n 1) 2)) 3) p)]))\n", "  (if (zero? n)\n   \
    \   1\n      (remainder (* (modp (sub1 n) p) 2) p)))\n", "  (cond\n    [(= n 0)\
    \ 1]\n    [(odd? n)\n     (* (modp (quotient (- n 1) 2) p)\n        (modp (quotient\
    \ (- n 1) 2) p)\n        (modp (remainder n 2) p))]\n    [else\n     (* (modp\
    \ (quotient n 2) p)\n        (modp (quotient n 2) p))]))\n</code>\n\n<code>#lang\
    \ racket\n", "  (cond\n    [(and (zero? n) (not (zero? p))) 1]\n    [(and (zero?\
    \ n) (zero? p)) 0]\n    [(and (zero? n) (negative? p)) p]\n    [(and (zero? n)\
    \ (positive? p)) 0]\n    [(and (negative? n) (not (zero? p))) (- (modp (- n) p))]\n\
    \    [(and (negative? n) (zero? p)) -n]\n    [(and (negative? n) (negative? p))\
    \ (- (modp (- n) (- p)))]\n    [(and (negative? n) (positive? p)) (- (modp (-\
    \ n) p))]\n    [(and (positive? n) (not (zero? p))) (cond\n                  \
    \                          [(odd? n) (modulo (* (modp (quotient n 2) p) (modp\
    \ (quotient n 2) p)) p)]\n                                            [(even?\
    \ n) (modulo (* (modp (quotient n 2) p) (modp (quotient n 2) p) 2) p)])]\n   \
    \ [(and (positive? n) (zero? p)) n]\n    [(and (positive? n) (negative? p)) (-\
    \ (modp n (- p)))]\n    [(and (positive? n) (positive? p)) (cond\n           \
    \                              [(odd? n) (modulo (* (modp (quotient n 2) p) (modp\
    \ (quotient n 2) p)) p)]\n                                         [(even? n)\
    \ (modulo (* (modp (quotient n 2) p) (modp (quotient n 2) p) 2) p)])]))\n", " \
    \ (cond\n    [(= n 0) 1]\n    [(even? n) (modulo (* (modp (/ n 2) p) (modp (/\
    \ n 2) p)) p)]\n    [else (modulo (* (modp (- n 1) p) 2) p)]))\n", "  (if (zero?\
    \ n)\n      1\n      (if (even? n)\n          (remainder (square (modp (quotient\
    \ n 2) p)) p)\n          (remainder (* n (modp (quotient (sub1 n) 2) p)) p))))\n",
  "  (cond\n    [(= 0 n) 1]\n    [(even? n)\n     (let* ([n/2 (integer-quotient n\
    \ 2)]\n            [modp-n/2 (modp n/2 p)])\n       (modulo (* modp-n/2 modp-n/2)\
    \ p))]\n    [else\n     (let* ([n-1 (- n 1)]\n            [modp-n-1 (modp n-1\
    \ p)])\n       (modulo (* 2 modp-n-1) p))]))\n```\n\n## Problem 20\n", "  (cond\
    \ [(zero? n) 1]\n        [(zero? (remainder n 2)) (modulo (square (modp (quotient\
    \ n 2) p)) p)]\n        [else (modulo (* (modp (quotient n 2) p) 3) p)]))\n",
  "  (cond [(= n 0) 1]\n        [(= (remainder n 2) 0) (remainder (* (modp (/ n 2)\
    \ p) (modp (/ n 2) p)) p)]\n        [else (remainder (* n (modp (- n 1) p)) p)]))\n",
  "  (cond [(or (= n 0) (= p 1)) 1]\n        [(even? n) (modulo (expt 2 (/ n 2)) p)]\n\
    \        [else (modulo (* (expt 2 (- n 1)) 2) p)]))\n```\n\n# The Language\nThere\
    \ are two basic things you can do with the language. The first is\nto import packages,\
    \ the second is to define functions.\n\n## Importing Packages\nRacket is an extensible\
    \ language, it's easy to write packages for it,\nand because of this you often\
    \ want to import a package. Packages are\nimported using the `import` keyword\
    \ followed by the package name.\nMultiple packages may be imported on the same\
    \ line.\n\nFor example, the `assignment1` package contains useful functions for\n\
    assignment 1:\n\n```racket\n#lang racket\n", "  (if (zero? n)\n      1\n     \
    \ (if (even? n)\n          ;; instead of (modulo (* 2 (modp (/ n 2) p)) p)\n \
    \         (modulo (expt 2 (modp (/ n 2) p)) p)\n          (modulo (* (modp (1-\
    \ n) p) 2) p))))\n", "  (define (iter res n)\n    (cond [(zero? n) res]\n    \
    \      [(even? n) (iter res (/ n 2))]\n          [else (iter (* 2 res) (- n 1))]))\n\
    \  (define (fix res)\n    (cond [(> res p) (fix (- res p))]\n          [else res]))\n\
    \  (fix (iter 1 n)))\n", "  (cond [(zero? n) 1]\n        [(even? n) (modulo (modp\
    \ (/ n 2) p) p)]\n        [else (modulo (* 2 (modp (- n 1) p)) p)]))\n", "  (if\
    \ (zero? n)\n      1\n      (if (even? n)\n          (modulo (* (modp (/ n 2)\
    \ p) (modp (/ n 2) p)) p)\n          (modulo (* n (modp (- n 1) p)) p))))\n```\n\
    \n## B.4\n\n```racket\n#lang racket\n", "  (define (modp-it n p v)\n    (cond\n\
    \      [(zero? n) v]\n      [(even? n) (modp-it (/ n 2) p (* v v p))]\n      [else\
    \ (modp-it (- n 1) p (* v 2 v p))]))\n  (modp-it n p 1))\n", "  (cond\n    [(zero?\
    \ n) 1]\n    [(even? n) (modulo (expt 2 (/ n 2)) p)]\n    [else (modulo (* 2 (modp\
    \ (- n 1) p)) p)]))\n</code>\nI don't think Scheme is the right tool for the job\
    \ though, I'd much rather use a language that has arbitrary precision integers.\
    \ Racket and SBCL (for Common Lisp) will work.\n", "  (if (zero? n)\n      1\n\
    \      (let ((np (modulo n p)))\n        (if (zero? np)\n            (modp (/\
    \ n p) p)\n            np))))\n", "  (if (zero? n)\n      1\n      (modulo (*\
    \ 2 (modp (sub1 n) p)) p)))\n\n", "  (if (= n 0)\n      1\n      (if (even? n)\n\
    \          (let ([p2 (modp (/ n 2) p)])\n            (remainder (* p2 p2) p))\n\
    \          (remainder (* n (modp (- n 1) p)) p))))\n```\n\n```\n#lang racket\n",
  "  (cond\n    [(zero? n) 1]\n    [(even? n) (modulo (modp (/ n 2) p) p)]\n    [else\
    \ (modulo (* (modp (/ (- n 1) 2) p) n) p)]))\n", "  (if (zero? n)\n      1\n \
    \     (if (even? n)\n          (modulo (square (modp (quotient n 2) p)) p)\n \
    \         (modulo (* (modp (quotient n 2) p) (modp (sub1 n) p)) p))))\n", "  (cond\n\
    \    [(= n 0) 1]\n    [(= (modulo n 2) 0) (modulo (* (modp (/ n 2) p) (modp (/\
    \ n 2) p)) p)]\n    [else (modulo (* (modp (- n 1) p) 2) p)]))\n```\n\n## 2.4.4\n\
    \n```\n#lang racket\n", "  (if (zero? n)\n      1\n      (if (even? n)\n     \
    \     (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)\n          (modulo (* n\
    \ (modp (- n 1) p)) p))))\n", "  (modulo (expt 2 n) p))\n", "  (cond\n    [(>\
    \ n (expt 2 (integer-length n))) (error \"Exceeds size of fixnum\")]\n    [(>\
    \ n (expt 2 (integer-length n) -1)) (modulo (modulo (expt 2 n) p) p)]\n    [(>\
    \ p 65536) (error \"Too large for optimized modp\")]\n    [else (modp-n n p)]))\n",
  "  (define (modp-iter n pow-of-2 result)\n    (cond ((= n 0) result)\n         \
    \ ((>= pow-of-2 n) (modp-iter (- n pow-of-2) pow-of-2 (* result 2 result)))\n\
    \          (else (modp-iter n (* pow-of-2 2) result))))\n  (modp-iter n 1 2))\n",
  "  (if (= n 0)\n      1\n      (if (even? n)\n          (modulo (* (modp (/ n 2)\
    \ p) (modp (/ n 2) p)) p)\n          (modulo (* n (modp (/ n 2) p) (modp (/ n\
    \ 2) p)) p))))\n", "  (cond [(= n 0) 1]\n        [(even? n) (cond [(= (modulo\
    \ n 2) 0) (modulo (square (modp (/ n 2) p)) p)]\n                          [else\
    \ (modulo (* 2 (modp (/ n 2) p)) p)])]\n        [else (modulo (* 2 (modp (- n\
    \ 1) p)) p)]))\n", "  (letrec ([n (if (zero? n) 1 (* 2 (modp (- n 1) p)))]\n \
    \          [result (modulo n p)])\n    result))\n", "  (define (modp-iter n1 a)\n\
    \    (cond\n      [(zero? n1) a]\n      [(zero? (modulo n1 2)) (modp-iter (/ n1\
    \ 2) (* a a))]\n      [else (modp-iter (- n1 1) (* a a))]))\n  (modp-iter n 1))\n\
    </code>\n", "  (cond\n    [(zero? n) 1]\n    [(even? n) (modulo (square (modp\
    \ (/ n 2) p)) p)]\n    [else (modulo (* n (modp (- n 1) p)) p)]))\n", "  (modulo\
    \ (expt 2 n) p))\n", "  (modulo (string->number (substring (number->string (expt\
    \ 2 n)) 0 p)) p))\n```\n\nTesting:\n\n```racket", "  (define (modp-inner k)\n\
    \    (if (= k 0)\n        1\n        (let ((res (* 2 (modp-inner (- k 1)))))\n\
    \          (cond\n            [(> res p) (- res p)]\n            [else res]))))\n\
    \  (modp-inner n))\n", "  (define (modps n)\n    (cond [(= n 0) 1]\n         \
    \ [(even? n) (modps (/ n 2))]\n          [else (* 2 (modps (- n 1)))]))\n  (define\
    \ (modp1 n p)\n    (cond [(= n 1) 1]\n          [(= n 2) (modulo (modps n) p)]\n\
    \          [else (modulo (* (modp1 (- n 1) p) (modps n)) p)]))\n  (modp1 n p))\n",
  "  (if (zero? n)\n      1\n      (if (even? n)\n          (let ([n (/ n 2)])\n \
    \           (mod (* (modp n p) (modp n p)) p))\n          (mod (* (modp (- n 1)\
    \ p) 2) p))))\n", "  (cond\n    [(= n 0) 1]\n    [(= n 1) n]\n    [(even? n) (square\
    \ (modp (/ n 2) p))]\n    [else (modulo (* n (modp (- n 1) p)) p)]))\n", "  (if\
    \ (zero? n)\n      1\n      (* 2 (modp (sub1 n) p) (mod (sub1 n) p))\n      )\n\
    \  )\n", "  (cond ((= n 0) 1)\n        ((= n 1) 1)\n        ((and (= (modulo n\
    \ 2) 0)\n              (= (modulo (modp (/ n 2) p) p) 0))\n         (modulo (modp\
    \ (/ n 2) p) p))\n        ((and (= (modulo n 2) 0)\n              (= (modulo (modp\
    \ (/ n 2) p) p) 1))\n         (modulo (* 2 (modp (/ n 2) p)) p))\n        ((and\
    \ (= (modulo n 2) 1)\n              (= (modulo (modp (- n 1) p) p) 0))\n     \
    \    (modulo (* 2 (modp (- n 1) p)) p))\n        ((and (= (modulo n 2) 1)\n  \
    \            (= (modulo (modp (- n 1) p) p) 1))\n         (modulo (* 2 (modp (-\
    \ n 1) p) + 1) p))))\n```\n## Question 5\n\n**Give an algorithm in pseudo-code\
    \ to find all odd positive divisors of a positive integer n.**\n\n```racket\n\
    #lang racket\n", "  (let ([n (integer->exact-integer n)])\n    (exact-integer->integer\
    \ (modulo n p))))\n", "  (if (= n 0)\n      1\n      (let ((a (modp (floor (/\
    \ n 2)) p)))\n        (if (= 1 (modulo n 2))\n            (modulo (* a a p) p)\n\
    \            (modulo (* 2 a a) p)))))\n", "  (if (= n 0)\n      1\n      (let\
    \ ((result (* (modp (quotient n 2) p) (modp (quotient n 2) p))))\n        (if\
    \ (= 1 (remainder n 2))\n            (* result 2)\n            result))))\n```\n\
    \n```racket\n#lang racket\n", "  (if (zero? n)\n      1\n      (if (even? n)\n\
    \          (modulo (expt 2 (/ n 2)) p)\n          (modulo (* 2 (modp (- n 1) p))\
    \ p))))", "  (define (modr n p r)\n    (cond [(= n 0) r]\n          [(odd? n)\
    \ (modr (quotient n 2) p (* r p))]\n          [else (modr (quotient n 2) p r)]))\n\
    \  (modr n p 1))\n", "  (cond ((= n 0) 1)\n        ((even? n)\n         (modulo\
    \ (* (modp (/ n 2) p) (modp (/ n 2) p)) p))\n        (else\n         (modulo (*\
    \ (modp (/ (- n 1) 2) p) (modp (/ (- n 1) 2) p) 2) p))))\n", "  (define (fastpow\
    \ a b n)\n    (cond\n      [(< b 0)\n       (fastpow (/ 1 a) (- b) n)]\n     \
    \ [(= b 0)\n       1]\n      [(even? b)\n       (fastpow (* a a) (/ b 2) n)]\n\
    \      [else\n       (* a (fastpow a (- b 1) n))]))\n  (modulo (fastpow 2 n p)\
    \ p))\n", "  (if (= n 0)\n      1\n      (* (modp (quotient n 2) p)\n        \
    \ (if (= (remainder n 2) 0)\n             1\n             (if (= (quotient n 2)\
    \ 0)\n                 2\n                 (* 2 (modp (quotient n 2) p)))))))\n",
  "  (define (c n)\n    (cond\n      [(= n 0) 1]\n      [(= n 1) 2]\n      [else (modulo\
    \ (* 2 (c (- n 1))) p)]))\n  (c n))\n", "  (if (zero? n)\n      1\n      (modulo\
    \ (* (modp (sub1 n) p) 2) p)))\n```\n\nR\xE9ponse : `b`\n\nVoir\n[le code](https://github.com/angavrilov/racket-tasks/blob/master/solution/modp.rkt)\
    \ de\nla r\xE9ponse.\n\n### pf-spy\n\n```racket\n#lang racket\n", "  (if (= n\
    \ 0)\n      1\n      (* (expt 2 (remainder n p)) (modp (quotient n p) p))))\n",
  "  (let* ((b (binary n))\n         (m (modulo (apply * b) p)))\n    m))\n", "  (cond\n\
    \    [(zero? n) 1]\n    [(even? n) (modulo (expt 2 (quotient n 2)) p)]\n    [else\
    \ (modulo (* 2 (modp (sub1 n) p)) p)]))\n```\n\n```racket\n#lang racket\n", " \
    \ (cond\n    [(even? n)\n     (modulo (square (modp (quotient n 2) p)) p)]\n \
    \   [(odd? n)\n     (modulo (* (modp (quotient n 2) p) (modp (quotient (+ n 1)\
    \ 2) p)) p)]\n    [else 1]))\n```\n\nNote that this is [exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)\
    \ for modular arithmetic.\n\n##### `sqrt-modp`\n\n```racket\n#lang racket\n",
  "  (letrec\n      ((modp-inner\n        (lambda (bn res)\n          (cond\n    \
    \        [(empty? bn) res]\n            [(= (first bn) 1)\n             (modp-inner\
    \ (rest bn) (* 2 res))]\n            [else\n             (modp-inner (rest bn)\
    \ (* 2 res))]))))\n    (modp-inner (dec-to-bin n) 1)))\n", "  (remainder (expt\
    \ 2 n) p))\n", "  (if (= p 1)\n      1\n      (if (= n 0)\n          1\n     \
    \     (if (= (modulo n 2) 0)\n              (modulo (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p)) p)\n              (modulo (* (modp (/ n 2) p) (modp (/ n 2) p) (modulo\
    \ n p)) p)))))\n", "  (if (zero? n)\n      1\n      (let ((r (modulo n p)))\n\
    \        (if (and (positive? n) (negative? r))\n            (+ r p)\n        \
    \    r))))\n", "  (define (do-modp n r)\n    (if (zero? n)\n        r\n      \
    \  (do-modp (quotient n 2)\n                 (if (even? n)\n                 \
    \    r\n                     (if (> r 1)\n                         (- r p)\n \
    \                        (if (positive? n)\n                             (- r\
    \ p)\n                             r))))))\n  (do-modp n 1))\n", "  (cond ((=\
    \ n 0) 1)\n        ((even? n)\n         (let ((d (modp (/ n 2) p)))\n        \
    \   (modulo (* d d) p)))\n        (else\n         (modulo (* (modp (- n 1) p)\
    \ 2) p))))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n          (if (=\
    \ (modulo n 2) 0)\n              (remainder (* (modp (/ n 2) p) (modp (/ n 2)\
    \ p)) p)\n              (remainder (* (modp (/ n 2) p) (modp (/ n 2) p) 2) p))\n\
    \          (remainder (* (modp (/ (- n 1) 2) p) (modp (/ (- n 1) 2) p) 2) p))))\n\
    ```\n\n```racket\n#lang racket\n", "  (modulo (expt 2 n) p))\n", "  (if (= 0 n)\n\
    \      1\n      (* 2 (modp (- n 1) p) (mod p) p)))\n", "  (define (modp-iter n\
    \ r)\n    (cond\n      ((= n 0) r)\n      ((even? n) (modp-iter (/ n 2) (modulo\
    \ (* r r) p)))\n      (else (modp-iter (sub1 n) (modulo (* 2 r) p)))))\n  (modp-iter\
    \ n 1))\n", "  (if (zero? n)\n      1\n      (remainder (* 2 (modp (sub1 n) p))\
    \ p)))\n", "  (modulo (expt 2 n) p))\n", "  (cond\n    [(= n 0) 1]\n    [(odd?\
    \ n) (remainder (* (modp (- n 1) p) 2) p)]\n    [else (remainder (square (modp\
    \ (/ n 2) p)) p)]))\n", "  (if (zero? n)\n      1\n      (* 2 (modp (sub1 n) p)\
    \ (modp n p))))\n", "  (if (zero? n)\n      1\n      (* (if (even? n) 1 2) (modp\
    \ (quotient n 2) p))))\n", "  (define (modp-iter pow result)\n    (cond\n    \
    \  [(= pow n)\n       result]\n      [(even? pow)\n       (modp-iter (/ pow 2)\n\
    \                  (remainder (* result result) p))]\n      [else\n       (modp-iter\
    \ (sub1 pow)\n                  (remainder (* result result n) p))]))\n  (modp-iter\
    \ n 1))\n", "  (remainder (expt 2 n) p))\n", "  (define (double x)\n    (if (even?\
    \ x) (quotient x 2) (- (+ p (quotient x 2)))))\n  (define (square x)\n    (modulo\
    \ (* x x) p))\n  (define (bit n b)\n    (if (= n b)\n        1\n        (if (even?\
    \ n)\n            (bit (double n) b)\n            (bit (double n) b)\n       \
    \     (square (bit (double n) b)))))\n  (bit n (bit-count n)))\n", "  (cond [(=\
    \ n 0) 1]\n        [(= n 1) n]\n        [(= n 2)\n         (if (= (modulo p 4)\
    \ 3)\n             (- p 1)\n             1)]\n        [(> n p) (modp (modulo n\
    \ p) p)]\n        [(= (modulo n 2) 0)\n         (modulo (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p)) p)]\n        [else\n         (modulo (* (modp (/ n 2) p) (modp (/\
    \ n 2) p) 2) p)]))\n", "  (define (mul a b)\n    (let ([aa (modulo (* a a) p)]\n\
    \          [ab (modulo (* a b) p)])\n      (if (= 0 b) 0\n      (if (= 0 (modulo\
    \ b 2)) aa\n      ab))))\n  (define (modp-iter i a)\n    (if (= 0 i) a\n    (if\
    \ (= 0 (modulo n i))\n      (modp-iter (/ i 2) (mul a a))\n      (modp-iter (-\
    \ i 1) (mul a a)))))\n  (modp-iter n 1))\n", "  (cond\n    [(= n 0) 1]\n    [(=\
    \ n 1) 1]\n    [(zero? n) (modp (- n 2) p)]\n    [(even? n) (modulo (* (modp (/\
    \ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo (* (modp (- n 1) p) 2) p)]))\n",
  "  (if (zero? n)\n      1\n      (if (zero? (modulo n 2))\n          (modulo (*\
    \ (modp (/ n 2) p) (modp (/ n 2) p)) p)\n          (modulo (* 2 (modp (- n 1)\
    \ p)) p))))\n```\n\n## Code in Ruby\n\n```ruby\n#lang racket\n\n# Ruby code\n\
    # https://en.wikipedia.org/wiki/Exponentiation_by_squaring\ndef modp(base, exp,\
    \ mod)\n  if exp == 0\n    1\n  elsif exp % 2 == 0\n    (modp(base, exp/2, mod)\
    \ ** 2) % mod\n  else\n    (base * modp(base, exp-1, mod)) % mod\n  end\nend\n\
    ```\n\n## Code in JavaScript\n\n```javascript\n// JavaScript code\n\n// https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n\
    function modp(base, exp, mod) {\n  if (exp == 0) {\n    return 1;\n  } else if\
    \ (exp % 2 == 0) {\n    return modp(base, exp/2, mod) ** 2 % mod;\n  } else {\n\
    \    return base * modp(base, exp-1, mod) % mod;\n  }\n}\n```\n\n## Unit Tests\n\
    \n```racket", "  (if (= n 0)\n      1\n      (modulo (* (modp (quotient n 2) p)\
    \ (modp (quotient n 2) p)) p)))\n", "  (cond\n    [(= n 0) 1]\n    [(odd? n) (modulo\
    \ (* 2 (modp (- n 1) p)) p)]\n    [else (modulo (square (modp (/ n 2) p)) p)]))\n",
  "  (if (= n 0)\n      1\n      (modulo (* 2 (modp (- n 1) p)) p)))\n</code>\n",
  "  (if (zero? n)\n      1\n      (if (even? n)\n          (modulo (expt 2 (/ n 2))\
    \ p)\n          (modulo (* (expt 2 (quotient n -2)) n) p))))\n", "  (if (= n 0)\n\
    \      1\n      (let loop ((n n) (n-log2 (modulo n p)) (log2 1))\n        (if\
    \ (even? n)\n            (loop (/ n 2) (+ n-log2 log2) (* 2 log2))\n         \
    \   n-log2))))\n```\n\n```racket\n#lang racket\n", "  (if (zero? n)\n      1\n\
    \      (if (even? n)\n          (modulo (* (modp (/ n 2) p) (modp (/ n 2) p))\
    \ p)\n          (modulo (* (modp (/ n 2) p) (modp (/ n 2) p) n) p))))\n", "  (if\
    \ (= n 0)\n      1\n      (let loop ((n n) (i 1))\n        (if (= n 1)\n     \
    \       i\n            (let ((i (* 2 i)))\n              (if (> i p)\n       \
    \           (loop n (- i p))\n                  (loop n i)))))))\n", "  (let loop\
    \ ([n n] [p p] [ans 1])\n    (if (zero? n)\n        ans\n        (loop (quotient\
    \ n 2)\n              p\n              (if (odd? n)\n                  (modulo\
    \ (* 2 ans) p)\n                  (modulo ans p))))))\n\n", "  (if (zero? n)\n\
    \      1\n      (if (odd? n)\n          (modulo (* (modp (quotient n 2) p) (modp\
    \ (quotient n 2) p) ) p)\n          (modulo (* (modp (quotient n 2) p) (modp (quotient\
    \ n 2) p) ) p)\n      )\n  )\n)\n", "  (cond\n    [(= n 0) 1]\n    [(= (remainder\
    \ n 2) 0)\n     (remainder (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else\n\
    \     (remainder (* n (modp (- n 1) p)) p)]))\n", "  (cond\n    [(= n 0) 1]\n\
    \    [(= n 1) 2]\n    [(even? n) (modulo (modp (/ n 2) p) (expt 2 (/ n 2) p))]\n\
    \    [else (modulo (* (modp (- n 1) p) 2) p)]))\n", "  (define (modp-tr a c)\n\
    \    (cond\n      ((= a 0) 1)\n      ((= a 1) c)\n      ((even? a) (modp-tr (/\
    \ a 2) (modulo (* c c) p)))\n      (else (modp-tr (- a 1) (modulo (* c n) p)))))\n\
    \  (modp-tr n n))\n", "  (cond\n    [(= n 0) 1]\n    [(even? n) (modulo (square\
    \ (modp (/ n 2) p)) p)]\n    [else (modulo (* (modp (sub1 n) p) 2) p)]))\n", " \
    \ (if (even? n)\n      (modulo (square (modp (quotient n 2) p)) p)\n      (if\
    \ (zero? n)\n          1\n          (modulo (* (modp (sub1 n) p) 2) p))))\n",
  "  (if (= 0 n)\n      1\n      (let ([p (fl (remainder n p))])\n        (if (negative?\
    \ p)\n            (add1 (fl (remainder n p)))\n            (fl (remainder n p))))))\n",
  "  (cond ((= n 0) 1)\n        ((= n 1) n)\n        ((even? n)\n         (modulo\
    \ (square (modp (/ n 2) p)) p))\n        (else\n         (modulo (* n (modp (-\
    \ n 1) p)) p))))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n          (if\
    \ (eq? 1 (modulo n 2))\n              (modulo (* 2 (modp (/ n 2) p)) p)\n    \
    \          (modulo (* 2 (modp (/ n 2) p)) p))\n          (modulo (* 2 (modp (/\
    \ n 2) p)) p))))\n", "  (cond\n    [(= n 0) 1]\n    [(= (remainder n 2) 0) (modulo\
    \ (expt 2 (/ n 2)) p)]\n    [else (modulo (* (modp (- n 1) p) 2) p)]))\n", " \
    \ (if (= n 0)\n      1\n      (* (modp (quotient n 2) p) (if (= (remainder n 2)\
    \ 0) 1 (modp (- n 1) p)))))\n", "  (cond\n    ((= n 0) 1)\n    ((= p 2) 1)\n \
    \   ((even? n) (modulo (square (modp (/ n 2) p)) p))\n    (else (modulo (* 2 (modp\
    \ (- n 1) p)) p))))\n", "  (cond\n    [(= n 0) 1]\n    [(even? n) (modulo (* (modp\
    \ (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo (* 2 (modp (- n 1) p)) p)]))\n\
    ```\n\n### Parametric Polymorphism\n`(all? pred lst)`\n\n```scheme\n#lang racket\n",
  "  (modulo (expt 2 n) p))\n", "  (cond\n    [(= n 0) 1]\n    [(= (remainder n 2)\
    \ 0) (modulo (square (modp (/ n 2) p)) p)]\n    [else (modulo (* (modp (- n 1)\
    \ p) 2) p)]))\n", "  (if (= n 0)\n      1\n      (* (if (odd? n)\n           \
    \  2\n             1)\n         (remainder (expt 2 (- n 1)) p))))\n", "  (if (=\
    \ n 0)\n      1\n      (modulo (* (modp (bitwise-shift-right n 1) p)\n       \
    \        (modp (bitwise-shift-left n 1) p))\n             p)))\n</code>\n", " \
    \ (let loop ([b 2] [pow 1])\n    (cond [(= n 0) pow]\n          [(even? n) (loop\
    \ (modulo (* b b) p) pow)]\n          [else (loop (modulo (* b b) p) (modulo (*\
    \ b pow) p))])))\n", "  (if (zero? n)\n      1\n      (if (even? n)\n        \
    \  (let ([n/2 (quotient n 2)])\n            (modulo (* (modp n/2 p) (modp n/2\
    \ p)) p))\n          (modulo (* (modp (- n 1) p) 2) p))))\n", "  (if (zero? n)\n\
    \      1\n      (if (even? n)\n          (modulo (expt 2 (/ n 2)) p)\n       \
    \   (modulo (* 2 (modp (- n 1) p)) p))))\n", "  (cond [(= n 0) 1]\n        [(even?\
    \ n) (modulo (modp (/ n 2) p) p)]\n        [else (modulo (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p)) p)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
