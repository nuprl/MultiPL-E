name: HumanEval_18_how_many_times
language: rkt
prompt: "#lang racket\n\n;; Find how many times a given substring can be found in\
  \ the original string. Count overlaping cases.\n;; >>> (how_many_times \"\" \"a\"\
  )\n;; 0\n;; >>> (how_many_times \"aaa\" \"a\")\n;; 3\n;; >>> (how_many_times \"\
  aaaa\" \"aa\")\n;; 3\n(define (how_many_times string substring)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n\
  \    (check-equal? (candidate \"\" \"x\") 0)\n    (check-equal? (candidate \"xyxyxyx\"\
  \ \"x\") 4)\n    (check-equal? (candidate \"cacacacac\" \"cac\") 4)\n    (check-equal?\
  \ (candidate \"john doe\" \"john\") 1)\n))\n\n(test-humaneval)"
completions: ["  (define (substring? start end)\n    (equal? (substring string start\
    \ end) substring))\n  (define (search? start)\n    (substring? start (+ start\
    \ (string-length substring))))\n  (define (search start count)\n    (cond ((or\
    \ (string-empty? string) (string-empty? substring)) 0)\n          ((search? start)\
    \ (search (+ start 1) (+ count 1)))\n          (else count)))\n  (search 0 0))\n",
  "  (if (string-contains string substring)\n      (+ 1 (how_many_times (substring\
    \ string (+ 1 (string-index string substring))) substring))\n      0))\n", " \
    \ (how_many_times_helper string substring 0))\n", "  (if (empty? string)\n   \
    \   0\n      (if (equal? (substring string 0 (string-length substring)) substring)\n\
    \          (+ 1 (how_many_times (substring string 1) substring))\n          (how_many_times\
    \ (substring string 1) substring))))\n", "  (define (how_many_times-helper string\
    \ substring position)\n    (cond\n      [(empty? string) position]\n      [(empty?\
    \ substring) position]\n      [(and (not (empty? string)) (not (empty? substring))\
    \ (equal? (first string) (first substring))) (how_many_times-helper (rest string)\
    \ (rest substring) (add1 position))]\n      [else (how_many_times-helper (rest\
    \ string) substring position)]))\n  (how_many_times-helper string substring 0))\n",
  "  (cond\n    [(empty? string) 0]\n    [(empty? substring) 0]\n    [(equal? (substring\
    \ string 0 (string-length substring)) substring) (+ 1 (how_many_times (substring\
    \ string 1) substring))]\n    [else (how_many_times (substring string 1) substring)]))\n",
  "  (cond\n    [(equal? string \"\") 0]\n    [(equal? substring \"\") 0]\n    [(equal?\
    \ (substring string 0 (string-length substring)) substring)\n     (+ 1 (how_many_times\
    \ (substring string 1) substring))]\n    [else (how_many_times (substring string\
    \ 1) substring)]))\n", "  (letrec ([len (string-length substring)]\n         \
    \  [count 0]\n           [n (string-length string)]\n           [start 0])\n \
    \   (if (= len 0) 0\n      (if (= start n) count\n        (if (string=? (substring\
    \ string start (+ start len)) substring)\n            (how_many_times string substring\
    \ (+ start 1) (+ count 1))\n            (how_many_times string substring (+ start\
    \ 1) count))))))", "  (cond\n    [(or (empty? string) (empty? substring)) 0]\n\
    \    [(not (string-contains string (string-head substring))) (how_many_times (string-tail\
    \ string) substring)]\n    [else (+ 1 (how_many_times (string-tail string) substring))]))\n",
  "  (cond\n    [(empty? string) 0]\n    [(string-index substring string) (+ 1 (how_many_times\
    \ (substring string (+ 1 (string-index substring string))) substring))]\n    [else\
    \ 0]))\n", "  (define (hmt substring str i len)\n    (cond ((&gt; i (- len (string-length\
    \ substring))) 0)\n          ((string=? substring (substring str i (+ i (string-length\
    \ substring)))) (+ 1 (hmt substring str (+ i 1) len)))\n          (else (hmt substring\
    \ str (+ i 1) len))))\n  (hmt substring string 0 (string-length string)))\n",
  "  (if (string-contains string substring)\n      (+ 1 (how_many_times (substring\
    \ string 1 (string-length string)) substring))\n      0))\n", "  (if (string-length\
    \ string)\n      (if (string-prefix? substring string)\n          (+ 1 (how_many_times\
    \ (substring string (string-length substring)) substring))\n          (how_many_times\
    \ (substring string 1) substring))\n      0))\n", "  (define (count-helper string\
    \ substring start)\n    (cond\n      [(string=? substring (substring string start\
    \ (+ start (string-length substring))))\n       (+ 1 (count-helper string substring\
    \ (+ start 1)))]\n      [else\n       0]))\n  (count-helper string substring 0))\n",
  "  (if (substring=? string substring)\n      1\n      (if (substring=? substring\
    \ \"\")\n          0\n          (if (substring=? string \"\")\n              0\n\
    \              (+ (if (substring=? string (substring substring 0 1))\n       \
    \             (how_many_times (substring string 1) substring)\n              \
    \      0)\n                 (how_many_times (substring string 1) substring))))))",
  "  (if (string-index substring string)\n      (+ 1 (how_many_times (substring string\
    \ (string-index substring string) (+ (string-index substring string) (string-length\
    \ substring))\n) substring))\n      0))", "  (if (string-length string)\n    \
    \  (if (string-length substring)\n          (if (string=? (substring string 0\
    \ (string-length substring)) substring)\n              (+ 1 (how_many_times (substring\
    \ string 1) substring))\n              (how_many_times (substring string 1) substring))\n\
    \          0)\n      0))\n", "  (let loop ([i 0] [n 0])\n    (cond\n      [(null?\
    \ string) n]\n      [(equal? substring (substring string i (+ i (string-length\
    \ substring))))\n       (loop (+ i (string-length substring)) (+ n 1))]\n    \
    \  [else (loop (+ i 1) n)])))\n", "  (define (iter str sub cnt)\n    (if (string-contains\
    \ str sub)\n        (iter (substring str (add1 (string-index str sub))) sub (add1\
    \ cnt))\n        cnt))\n  (iter string substring 0))", "  (if (eq? string \"\"\
    )\n      0\n      (if (string-contains string substring)\n          (+ 1 (how_many_times\
    \ (substring string (+ 1 (string-length substring))) substring))\n          0)))\n",
  "  (cond\n    [(string=? \"\" substring) 0]\n    [(string=? \"\" string) 0]\n  \
    \  [(string=? substring (substring string 0 (string-length substring))) (+ 1 (how_many_times\
    \ (substring string 1) substring))]\n    [else (how_many_times (substring string\
    \ 1) substring)]))\n```\n### Question 9 [1 Point]\n\nWhat is the value of the\
    \ following expression:\n\n```racket", "  (define string-length (string-length\
    \ string))\n  (define substring-length (string-length substring))\n  (define substring-matches\
    \ '())\n  (define (get-locations start)\n    (let ([location (string-index string\
    \ substring start)])\n      (if location\n          (begin\n            (set!\
    \ substring-matches (cons location substring-matches))\n            (get-locations\
    \ (+ location substring-length))))))\n  (get-locations 0)\n  (length substring-matches))\n",
  "  (if (string-contains string substring)\n      (+ 1 (how_many_times (string-replace\
    \ string substring \"\") substring))\n      0))", "  (define len (string-length\
    \ substring))\n  (define (how_many_times_iter i acc)\n    (cond\n      [(equal?\
    \ len (+ i 1)) (+ acc 1)]\n      [(equal? (substring string i (+ i len)) substring)\
    \ (how_many_times_iter (+ i 1) (+ acc 1))]\n      [else (how_many_times_iter (+\
    \ i 1) acc)]))\n  (how_many_times_iter 0 0))\n", "  (let ((substring-length (string-length\
    \ substring))\n        (string-length (string-length string))\n        (count\
    \ 0))\n    (do ((i 0 (+ i 1)))\n        ((< i (- string-length substring-length)))\n\
    \      (if (string=? (substring string i (+ i substring-length)) substring)\n\
    \          (set! count (+ count 1))))\n    count))\n```\n</details>\n\n### [12.\
    \ Reverse a string](https://www.codewars.com/kata/5168bb5dfe9a00b126000018/train/racket)\n\
    <details>\n  <summary>Show solution</summary>\n```racket\n#lang racket\n", " \
    \ (define (aux index times)\n    (cond [(empty? string) times]\n          [(substring=?\
    \ (substring string index (+ index (string-length substring))) substring)\n  \
    \         (aux (+ index 1) (+ times 1))]\n          [else (aux (+ index 1) times)]))\n\
    \  (aux 0 0))\n", "  (define (how_many_times-iter position acc)\n    (let ((new-pos\
    \ (string-index string substring position)))\n      (if new-pos\n          (how_many_times-iter\
    \ (+ new-pos 1) (+ acc 1))\n          acc)))\n  (how_many_times-iter 0 0))\n",
  "  (substring-index string substring))\n", "  (cond\n    [(string=? string substring)\
    \ 1]\n    [(string=? string \"\") 0]\n    [else\n     (if (string-prefix? substring\
    \ string)\n         (+ 1 (how_many_times (substring string 1) substring))\n  \
    \       (how_many_times (substring string 1) substring))]))\n", "  (define (substring-count\
    \ substring s)\n    (if (= (substring s 0 (string-length substring)) substring)\n\
    \        (add1 (substring-count substring (substring s 1)))\n        0))\n  (substring-count\
    \ substring string))\n", "  (letrec ([new-string (string-append substring string)]\n\
    \           [count 0])\n    (cond\n      [(string=? string substring)\n      \
    \ (+ count 1)]\n      [(string=? string \"\")\n       count]\n      [(string=?\
    \ (string-append substring \"a\") new-string)\n       (+ count 1)]\n      [else\n\
    \       (let ([new-count (how_many_times (substring string 1) substring)])\n \
    \        (how_many_times (substring string 1) substring))])))\n", "  (define (loop\
    \ counter at)\n    (let ([there (string-index string substring at)])\n      (if\
    \ there\n          (loop (+ counter 1) (+ there 1))\n          counter)))\n  (loop\
    \ 0 0))\n", "  (define (iter string substring output)\n    (cond\n      [(empty?\
    \ string) output]\n      [(empty? substring) output]\n      [(equal? (first string)\
    \ (first substring))\n       (iter (rest string) (rest substring) (+ output 1))]\n\
    \      [else\n       (iter (rest string) substring output)]))\n  (iter string\
    \ substring 0))\n", "  (define (counter string substring count)\n    (if (string-contains\
    \ string substring)\n        (counter (substring string (+ 1 (string-index string\
    \ substring))) substring (+ 1 count))\n        count))\n  (counter string substring\
    \ 0))\n</code>\nFor the second one you can check it yourself with the documentation.\
    \ But I'll leave it below for the \"sake of completeness\".\n<code>#lang racket\n",
  "  (cond [(empty? string) 0]\n        [(zero? (string-index string substring)) (how_many_times\
    \ (substring string 1) substring)]\n        [else (+ 1 (how_many_times (substring\
    \ string (+ 1 (string-index string substring))) substring))]))\n", "  (if (string-contains\
    \ string substring)\n      (+ 1 (how_many_times (substring string (+ 1 (string-index\
    \ string substring))) substring))\n      0))\n", "  (define (how_many_times-helper\
    \ string substring index)\n    (cond ((< index (substring-length string))\n  \
    \         (if (substring=? string substring index)\n               (+ 1 (how_many_times-helper\
    \ string substring (+ index 1)))\n               (how_many_times-helper string\
    \ substring (+ index 1))))\n          (else 0)))\n  (how_many_times-helper string\
    \ substring 0))\n", "  (cond [(empty? string) 0]\n        [(equal? (take (length\
    \ substring) string) substring)\n         (+ 1 (how_many_times (drop (length substring)\
    \ string) substring))]\n        [else (how_many_times (drop 1 string) substring)]))\n",
  "  (cond\n    [(empty? string) 0]\n    [(empty? substring) (length string)]\n  \
    \  [else (add1\n           (if (equal? string (take (length substring) string))\n\
    \               (how_many_times (drop (length substring) string) substring)\n\
    \               (how_many_times (rest string) substring)))]))\n", "  (define (how_many_times_iter\
    \ string substring count)\n    (if (or (string=? substring \"\") (string=? string\
    \ \"\"))\n        count\n        (if (string-prefix? substring string)\n     \
    \       (how_many_times_iter (substring string 1) substring (+ count 1))\n   \
    \         (how_many_times_iter (substring string 1) substring count))))\n  (how_many_times_iter\
    \ string substring 0))\n", "  (how_many_times_aux string substring 0))\n", " \
    \ (if (string-contains string substring)\n      (+ 1 (how_many_times (substring\
    \ string 1) substring))\n      0))\n", "  (let loop ([current-string string] [substring-string\
    \ substring] [count 0])\n    (match current-string [(substring (substring-pos\
    \ substring-string) (substring-string)) (loop (substring current-string (+ 1 (substring-pos\
    \ substring-string))) substring-string (+ 1 count))]\n                      [else\
    \ count])))\n", "  (define (internal n)\n    (cond ((null? string) n)\n      \
    \    ((string-prefix? substring string) (internal (+ n 1)))\n          (else (internal\
    \ n))))\n  (internal 0))\n", "  (cond\n    [(string=? string substring) 1]\n \
    \   [(null? string) 0]\n    [else\n     (+ (if (string-contains substring (string-take\
    \ string (string-length substring))) 1 0)\n        (how_many_times (string-drop\
    \ string 1) substring))]))\n", "  (define (recur i cnt)\n    (if (= i (string-length\
    \ string))\n        cnt\n        (if (string=? (substring string i (+ 1 i)) substring)\n\
    \            (recur (+ 1 i) (+ 1 cnt))\n            (recur (+ 1 i) cnt))))\n \
    \ (recur 0 0))\n", "  (let ([str (string->list string)]\n        [substr (string->list\
    \ substring)])\n    (how_many_times_rec str substr 0)))\n", "  (define (helper\
    \ tindex sindex)\n    (cond\n      [(= tindex (string-length string)) 0]\n   \
    \   [(= sindex (string-length substring)) 1]\n      [(= (string-ref string tindex)\
    \ (string-ref substring sindex)) (helper (+ tindex 1) (+ sindex 1))]\n      [else\
    \ (+ (helper (+ tindex 1) 0) (helper (+ tindex 1) sindex))]))\n  (helper 0 0))",
  "  (letrec ([count 0]\n           [step-over 0]\n           [current-pos 0]\n  \
    \         [count-helper (lambda (string substring current-pos step-over)\n   \
    \                        (let ([s (string-length string)]\n                  \
    \               [ss (string-length substring)])\n                            \
    \ (cond [(<= (+ current-pos ss) s)\n                                    (cond\
    \ [(string=? (substring string current-pos (+ current-pos ss)) substring)\n  \
    \                                         (set! count (+ count 1))\n         \
    \                                  (set! step-over (+ step-over ss))\n       \
    \                                    (count-helper string substring (+ current-pos\
    \ step-over) step-over)]\n                                          [else (count-helper\
    \ string substring (+ current-pos 1) 0)])]\n                                 \
    \  [else 0])))]\n           [run (lambda ()\n                  (count-helper string\
    \ substring current-pos step-over))])\n    (run)))\n", "  (define (aux_count string\
    \ substring)\n    (if (string-length string)\n        (if (string-prefix? substring\
    \ string)\n            (+ 1 (aux_count (substring string 1) substring))\n    \
    \        (aux_count (substring string 1) substring))\n        0))\n  (if (string-length\
    \ substring)\n      (aux_count string substring)\n      (error \"Substring can't\
    \ be empty\")))\n```\n<br>\n\n### Challenge 2.2 - Anagrams\n\nAn anagram is a\
    \ word or phrase formed by rearranging the letters of a different word or phrase,\
    \ typically using all the original letters exactly once.\n\nFor example:\n\n```\n\
    \"William Shakespeare\" is an anagram of \"I am a weakish speller\".\n\"Madam\
    \ Curie\" is an anagram of \"Radium came\".\n```\n\nWrite a function that checks\
    \ if 2 given strings are anagrams of each other.\n\n```racket\n#lang racket\n",
  "  (define (how_many_times-helper string substring accum)\n    (if (or (string=?\
    \ string \"\") (string=? substring \"\"))\n        accum\n        (if (string-prefix?\
    \ substring string)\n            (how_many_times-helper (substring string 1) substring\
    \ (+ accum 1))\n            (how_many_times-helper (substring string 1) substring\
    \ accum))))\n  (how_many_times-helper string substring 0))\n", "  (let* ([len-string\
    \ (string-length string)]\n         [len-substring (string-length substring)])\n\
    \    (if (string=? \"\" substring)\n        (error \"Substring cannot be empty\"\
    )\n        (let loop ([i 0] [count 0])\n          (if (< i (- len-string len-substring))\n\
    \              (if (string=? (substring string i (+ i len-substring)) substring)\n\
    \                  (loop (+ i 1) (+ count 1))\n                  (loop (+ i 1)\
    \ count))\n              count)))))\n", "  (if (string-contains string substring)\n\
    \      (+ 1 (how_many_times (substring string 1) substring))\n      0))\n", " \
    \ (define (how_many_times-iter string substring times)\n    (cond [(empty? string)\
    \ times]\n          [(string-contains string substring) (how_many_times-iter (rest\
    \ string) substring (+ times 1))]\n          [else (how_many_times-iter (rest\
    \ string) substring times)]))\n  (how_many_times-iter string substring 0))\n",
  "  (cond\n    [(empty? string) 0]\n    [(and (string-index string substring) (=\
    \ (string-length substring) 1))\n     (+ 1 (how_many_times (substring string (+\
    \ 1 (string-index string substring))) substring))]\n    [(string-index string\
    \ substring)\n     (+ 1 (how_many_times (substring string (+ 1 (string-index string\
    \ substring))) substring))]\n    [else 0]))\n", "  (if (empty? string)\n     \
    \ 0\n      (if (equal? (substring substring) (substring string))\n          (+\
    \ 1 (how_many_times (substring string) substring))\n          (how_many_times\
    \ (substring string) substring))))\n", "  (if (string-contains string substring)\n\
    \      (+ 1 (how_many_times (substring string (+ 1 (string-index string substring)))\
    \ substring))\n      0))\n", "  (if (empty? string)\n      0\n      (if (substring?\
    \ string substring)\n          (+ 1 (how_many_times (substring string 1) substring))\n\
    \          (how_many_times (substring string 1) substring))))\n", "  (string-indexes\
    \ string substring))\n", "  (if (string-length string)\n      (if (string-prefix?\
    \ substring string)\n          (+ 1 (how_many_times (substring string (string-length\
    \ substring)) substring))\n          (how_many_times (substring string 1) substring))\n\
    \      0))\n```\n\n```#lang racket\n", "  (define (helper orig sub)\n    (let\
    \ ((start (string-index orig sub 0)))\n      (if (equal? start -1)\n         \
    \ 0\n          (+ 1 (helper (substring orig (add1 start) (string-length orig))\
    \ sub)))))\n  (helper string substring))\n", "  (define (one-beg-end-pos s_b s_e\
    \ s_len)\n    (define (beg-end-pos s_b s_e)\n      (if (equal? (substring string\
    \ s_b s_e) substring)\n          1\n          0))\n    (if (= s_e s_len)\n   \
    \     (beg-end-pos s_b s_e)\n        (+ (beg-end-pos s_b s_e) (one-beg-end-pos\
    \ s_b (+ s_e 1) s_len))))\n  (let ((ss_len (string-length substring))\n      \
    \  (s_len (string-length string)))\n    (if (= ss_len 0)\n        0\n        (one-beg-end-pos\
    \ 0 ss_len s_len))))\n", "  (match string\n    [() 0]\n    [(cons head tail) (if\
    \ (string=? substring (string-append (list head) tail))\n                    \
    \      (+ 1 (how_many_times tail substring))\n                          (how_many_times\
    \ tail substring))]))\n", "  (define (find a b)\n    (if (string=? a b)\n    \
    \    1\n        (if (< (string-length a) (string-length b))\n            0\n \
    \           (+ (find (substring a 1) b)\n               (find (substring a 0 (-\
    \ (string-length a) 1)) b)))))\n  (find string substring))\n", "  (define (count-helper\
    \ string substring count)\n    (cond\n      [(empty? string) count]\n      [(string=?\
    \ (substring string 0 (string-length substring)) substring) (count-helper (substring\
    \ string 1) substring (+ count 1))]\n      [else (count-helper (substring string\
    \ 1) substring count)]))\n  (count-helper string substring 0))\n", "  (if (string-contains\
    \ string substring)\n      (+ 1 (how_many_times (string-drop string (string-length\
    \ substring)) substring))\n      0))\n```\n\n###### Expected Output:\n```\n> (how_many_times\
    \ \"\" \"a\")\n0\n> (how_many_times \"aaa\" \"a\")\n3\n> (how_many_times \"aaaa\"\
    \ \"aa\")\n3\n```\n\n### Challenge 3: Given two strings, how many times is the\
    \ second string found in the first string?\n\n```racket\n#lang racket\n", "  (let\
    \ how_many_times_inner (s1 s2 n)\n    (cond [(empty? s1) n]\n          [(empty?\
    \ s2) (how_many_times_inner (rest s1) substring n)]\n          [(equal? (first\
    \ s1) (first s2)) (how_many_times_inner (rest s1) (rest s2) (+ n 1))]\n      \
    \    [else (how_many_times_inner (rest s1) substring n)])))\n", "  (letrec ([num\
    \ 0]\n           [n 0]\n           [s string]\n           [recur (lambda (s n)\n\
    \                    (cond\n                      [(string=? (substring s n (add1\
    \ n)) substring)\n                       (set! n (add1 n))\n                 \
    \      (set! num (add1 num))\n                       (recur s n)]\n          \
    \            [else 0]))])\n    (recur s n)\n    num))\n", "  (cond\n    [(string=?\
    \ \"\" substring)\n     0]\n    [(string=? \"\" string)\n     0]\n    [(and (string=?\
    \ (string-take string 1) (string-take substring 1))\n\t  (string=? (string-drop\
    \ string 1) (string-drop substring 1)))\n     1]\n    [(string=? (string-take\
    \ string 1) (string-take substring 1))\n     (+ 1 (how_many_times (string-drop\
    \ string 1) (string-drop substring 1)))]\n    [else\n     (how_many_times (string-drop\
    \ string 1) substring)]))\n", "  (if (= (length string) 0)\n      0\n      (if\
    \ (string-index string substring)\n          (+ 1 (how_many_times (substring string\
    \ (+ (string-index string substring) (length substring))) substring))\n      \
    \    0)))", "  (define (iter n)\n    (if (substring string n (+ n (string-length\
    \ substring)))\n        (+ 1 (iter (+ n 1)))\n        0))\n  (iter 0))\n", " \
    \ (define (loop count substr_len string_len)\n    (if (< (+ count 1) string_len)\n\
    \        (if (string=? (substring string count (+ count substr_len)) substring)\n\
    \            (loop (+ count 1) substr_len string_len)\n            (loop (+ count\
    \ 1) substr_len string_len))\n        count))\n  (loop 0 (string-length substring)\
    \ (string-length string)))\n```\n\nIt seems that the exercise is hinting at a\
    \ recursive solution. Using a `loop` here is kind of cheating - I should be able\
    \ to accomplish this without it.", "  (define (iter iter-string substring count)\n\
    \    (cond [(string=? iter-string \"\") count]\n          [(string=? (substring\
    \ iter-string 0 (string-length substring)) substring) (iter (substring iter-string\
    \ 1) substring (+ count 1))]\n          [else (iter (substring iter-string 1)\
    \ substring count)]))\n  (iter string substring 0))\n", "  (cond\n    ((or (string=?\
    \ string \"\") (string=? substring \"\")) 0)\n    ((string-contains string substring)\
    \ (+ 1 (how_many_times (substring string (+ 1 (string-index substring string)))\
    \ substring)))\n    (else 0)))\n</code>\nNow this works well for most cases, but\
    \ as we can see, it is not tail recursive. And it takes a lot of time when we\
    \ try to use string with length greater than 1000. How can I make this tail recursive,\
    \ or maybe you have other ideas how to optimize this function?\n", "  (match substring\n\
    \    [(\"\") 0]\n    [else (if (string-contains string substring)\n          \
    \  (+ 1 (how_many_times (string-drop string 1) substring))\n            (how_many_times\
    \ (string-drop string 1) substring))]))\n", "  (cond ((or (string=? string \"\"\
    ) (string=? substring \"\")) 0)\n        ((> (string-length string) (string-length\
    \ substring))\n         (+ (if (and (string=? (substring string 0 1) (substring\
    \ substring 0 1))\n                   (string=? string substring))\n         \
    \        1\n                 0)\n            (how_many_times (substring string\
    \ 1) substring)))\n        (else (how_many_times (substring string 1) substring))))\n",
  "  (let ((count 0)\n        (end-pos (add1 (string-length substring))))\n    (for\
    \ ([i (in-range (string-length string))])\n      (if (string=? (substring string\
    \ i end-pos) substring)\n          (set! count (add1 count))\n          (set!\
    \ end-pos (add1 end-pos))))\n    count))\n```", "  (cond\n    [(empty? string)\
    \ 0]\n    [(contains? string substring) (+ 1 (how_many_times (tail-string string)\
    \ substring))]\n    [else 0]))\n", "  (define (how_many_times-accumulate counter\
    \ i)\n    (cond ((&gt;= i (string-length string)) counter)\n          ((eq? (substring\
    \ string i (+ i (string-length substring))) substring)\n           (how_many_times-accumulate\
    \ (+ counter 1) (+ i 1)))\n          (else (how_many_times-accumulate counter\
    \ (+ i 1)))))\n  (how_many_times-accumulate 0 0))\n</code>\n", "  (define (helper\
    \ string substring matches)\n    (cond\n      [(empty? string) matches]\n    \
    \  [(string-contains string substring) (helper (substring string 1) substring\
    \ (+ matches 1))]\n      [else (helper (substring string 1) substring matches)]))\n\
    \  (helper string substring 0))\n", "  (let/cc how-many-times\n    (define (search\
    \ s i)\n      (if (= i (string-length s))\n          (how-many-times 0)\n    \
    \      (begin\n            (if (string=? (substring s i (+ i (string-length substring)))\
    \ substring)\n                (search s (+ i 1))\n                (how-many-times\
    \ (+ (how-many-times 0) 1))))))\n    (search string 0)))\n", "  (define (how_many_times-iter\
    \ string substring)\n    (cond\n      [(empty? string) (if (empty? substring)\
    \ 0 0)]\n      [(empty? substring) 1]\n      [(char=? (first string) (first substring))\n\
    \       (+ (how_many_times-iter (rest string) (rest substring))\n          (how_many_times-iter\
    \ (rest string) substring))]\n      [else (how_many_times-iter (rest string) substring)]))\n\
    \  (how_many_times-iter string substring))", "  (if (string-contains string substring)\n\
    \      (+ 1 (how_many_times (substring string 1) substring))\n      0))\n", " \
    \ (if (empty? string)\n      0\n      (if (empty? substring)\n          0\n  \
    \        (if (string=? substring (substring string 0 (string-length substring)))\n\
    \              (+ 1 (how_many_times (substring string 1) substring))\n       \
    \       (how_many_times (substring string 1) substring)))))\n", "  (define (helper\
    \ string substring acc)\n    (cond [(equal? \"\" substring) acc]\n          [(string-index\
    \ substring string)\n           (helper (substring string (+ 1 (string-index substring\
    \ string))) substring (+ 1 acc))]\n          [else acc]))\n  (helper string substring\
    \ 0))\n", "  (define (count-substring-helper str start acc)\n    (if (string-contains\
    \ str substring start)\n        (count-substring-helper str (add1 (string-index\
    \ str substring start)) (add1 acc))\n        acc))\n  (count-substring-helper\
    \ string 0 0))\n", "  (if (string-contains string substring)\n      (+ 1 (how_many_times\
    \ (string-drop string 1) substring))\n      0))", "  (if (not (string=? \"\" substring))\n\
    \      (let loop ((count 0) (chars string))\n        (cond ((not (string-contains?\
    \ chars substring))\n               count)\n              ((string=? \"\" chars)\n\
    \               count)\n              (else\n               (loop (+ count 1)\
    \ (string-drop chars 1)))))\n      0))\n", "  (cond\n    [(empty? string) 0]\n\
    \    [(equal? (substring string 0 (string-length substring)) substring) (+ 1 (how_many_times\
    \ (substring string 1) substring))]\n    [else (how_many_times (substring string\
    \ 1) substring)]))\n", "  (define (substr_counter str sub acc)\n    (cond\n  \
    \    [(string=? sub \"\")\n       acc]\n      [(string=? (substring str 0 (string-length\
    \ sub)) sub)\n       (substr_counter (substring str 1) sub (+ acc 1))]\n     \
    \ [else\n       (substr_counter (substring str 1) sub acc)]))\n  (substr_counter\
    \ string substring 0))\n", "  (cond\n    [(empty? string) 0]\n    [(empty? substring)\
    \ 0]\n    [(and (string=? (first string) (first substring))\n          (string=?\
    \ (rest string) (rest substring))) 1]\n    [else (how_many_times (rest string)\
    \ substring)]))\n\n", "  (cond [(null? string) 0]\n        [(equal? (take string\
    \ (string-length substring)) substring)\n         (+ 1 (how_many_times (drop string\
    \ 1) substring))]\n        [else (how_many_times (drop string 1) substring)]))\n",
  "  (define (occurs xs ys)\n    (cond\n      [(or (empty? xs) (empty? ys)) false]\n\
    \      [(= (first xs) (first ys)) (or (occurs (rest xs) (rest ys)) (occurs (rest\
    \ xs) ys))]\n      [else (occurs xs (rest ys))]))\n  (define (loop count xs ys)\n\
    \    (cond\n      [(empty? xs) count]\n      [(occurs xs ys) (loop (+ count 1)\
    \ (rest xs) ys)]\n      [else (loop count (rest xs) ys)]))\n  (loop 0 string substring))\n",
  "  (if (string-contains string substring)\n      (+ 1 (how_many_times (substring\
    \ string (+ 1 (string-index string substring))) substring))\n      0))\n", " \
    \ (if (string-length string)\n      (if (string-contains string substring)\n \
    \         (+ 1 (how_many_times (string-drop string 1) substring))\n          (how_many_times\
    \ (string-drop string 1) substring))\n      0))\n", "  (let ([substring-length\
    \ (string-length substring)])\n    (define (count-substring-in-string start count)\n\
    \      (let ([substring-start (string-index string substring start)])\n      \
    \  (if (not substring-start)\n            count\n            (count-substring-in-string\
    \ (+ substring-start substring-length) (+ count 1)))))\n    (count-substring-in-string\
    \ 0 0)))\n", "  (cond [(string=? string substring) 1]\n        [(string=? substring\
    \ \"\") 0]\n        [else (+ (how_many_times (substring string 0 (- (string-length\
    \ string) 1)) substring)\n                 (how_many_times (substring string 1)\
    \ substring))]))\n", "  (if (string-contains? string substring)\n      (+ 1 (how_many_times\
    \ (substring string (string-index string substring) (string-length string)) substring))\n\
    \      0))\n", "  (define (strlen s)\n    (if (string=? s \"\")\n        0\n \
    \       (+ 1 (strlen (substring s 1)))))\n  (define (how_many_times_helper i)\n\
    \    (define (s string)\n      (string-append string string))\n    (define (h\
    \ i)\n      (cond\n        [(string=? (substring string i (+ i (strlen substring)))\
    \ substring)\n         (+ i (h (+ i 1)))]\n        [else i]))\n    (h i))\n  (define\
    \ (total_times i acc)\n    (cond\n      [(> i (strlen string)) acc]\n      [else\
    \ (total_times (how_many_times_helper i) (+ acc 1))]))\n  (total_times 0 0))\n",
  "  (local [(define (find-location prefix-string suffix-string index)\n         \
    \   (if (= index 0)\n                (string-length prefix-string)\n         \
    \       (if (string=? (substring prefix-string 0 index) (substring suffix-string\
    \ 0 index))\n                    (find-location prefix-string suffix-string (-\
    \ index 1))\n                    index)))\n          (define (find-occurrences\
    \ suffix-string occurrences)\n            (if (string=? \"\" suffix-string)\n\
    \                occurrences\n                (let ([index (find-location substring\
    \ suffix-string (string-length substring))])\n                  (find-occurrences\
    \ (substring suffix-string index) (+ occurrences 1)))))]\n    (find-occurrences\
    \ string 0)))", "  (if (string-contains string substring)\n      (+ 1 (how_many_times\
    \ (substring string 1) substring))\n      0))\n", "  (let loop ([str string] [acc\
    \ 0])\n    (cond [(empty? str) acc]\n          [(string=? (substring str 0 (string-length\
    \ substring)) substring) (loop (substring str 1) (+ acc 1))]\n          [else\
    \ (loop (substring str 1) acc)])))\n", "  (define (occurrences s sub)\n    (let\
    \ ((last-match-pos (- (string-length s) (string-length sub))))\n      (let loop\
    \ ((i 0) (c 0))\n        (cond ((< i last-match-pos)\n               (if (string=?\
    \ (substring s i (+ i (string-length sub))) sub)\n                   (loop (+\
    \ i 1) (+ c 1))\n                   (loop (+ i 1) c)))\n              (else c)))))\n\
    \  (occurrences string substring))\n", "  (let ([times (gsub (regexp substring)\
    \ string #f)])\n    (length times)))\n```\n### 5. \n```\n#lang racket\n", "  (define\
    \ (sub_helper a-string sub)\n    (if (string-length a-string)\n        (if (and\
    \ (equal? (substring a-string 0 (string-length sub)) sub) (not (null? (substring\
    \ a-string (string-length sub)))))\n            (+ 1 (sub_helper (substring a-string\
    \ (string-length sub)) sub))\n            (sub_helper (substring a-string 1) sub))\n\
    \        0))\n  (sub_helper string substring))\n</code>\n", "  (cond\n    [(equal?\
    \ string \"\") 0]\n    [(string-contains string substring)\n     (+ 1 (how_many_times\
    \ (substring string 1) substring))]\n    [else (how_many_times (substring string\
    \ 1) substring)]))\n", "  (if (empty? substring)\n      0\n      (let* ([sub-len\
    \ (string-length substring)]\n             [occurrences 0])\n        (do ([i 0\
    \ (+ i 1)])\n            ((>= i (- (string-length string) sub-len)) occurrences)\n\
    \          (if (equal? (substring string i (+ i sub-len)) substring)\n       \
    \       (set! occurrences (+ occurrences 1)))))))\n", "  (let loop ([i 0] [count\
    \ 0])\n    (if (string-contains string substring)\n        (let ([index (string-index\
    \ string substring)])\n          (loop (+ index (string-length substring))\n \
    \               (+ count 1)))\n        count)))\n", "  (define (how_many_times-inner\
    \ string substring count)\n    (cond ((string-length string) count)\n        \
    \  ((string-contains (substring string 0 (string-length substring)) substring)\n\
    \           (how_many_times-inner (substring string 1) substring (+ count 1)))\n\
    \          (else (how_many_times-inner (substring string 1) substring count))))\n\
    \  (how_many_times-inner string substring 0))\n", "  (define (count-substrings\
    \ so-far rest)\n    (cond\n      [(empty? rest) so-far]\n      [(string=? (substring\
    \ rest 0 (string-length substring)) substring)\n       (count-substrings (+ so-far\
    \ 1) (substring rest 1))]\n      [else (count-substrings so-far (substring rest\
    \ 1))]))\n  (count-substrings 0 string))\n", "  (if (string-contains string substring)\n\
    \      (+ 1 (how_many_times (substring string (+ 1 (string-index string substring)))\
    \ substring))\n      0))\n", "  (if (string-empty? string)\n      0\n      (if\
    \ (string-prefix? substring string)\n          (+ 1 (how_many_times (substring\
    \ string (string-length substring)) substring))\n          (how_many_times (substring\
    \ string 1) substring))))\n", "  (define (count-helper s sb start)\n    (cond\
    \ ((string-contains sb s) (add1 (count-helper s sb (add1 (string-index sb s)))))\n\
    \          ((>= start (string-length s)) 0)\n          (else (count-helper s sb\
    \ (+ start 1)))))\n  (count-helper string substring 0))\n", "  (count (substrings\
    \ string) substring))\n", "  (if (string-length string)\n      (add1 (how_many_times\
    \ (substring string 1) substring))\n      0))\n", "  (if (string-contains? string\
    \ substring)\n      (+ 1 (how_many_times (substring string (+ 1 (string-index\
    \ substring string))) substring))\n      0))\n", "  ;; If there is no substring,\
    \ return 0.\n  (if (or (null? substring) (eq? (string-length substring) 0))\n\
    \      0\n      ;; If the substring is in the string, increment the count by 1,\
    \ and recurse with the tail of the string to find other occurences.\n      (if\
    \ (substring? string substring)\n          (+ 1 (how_many_times (substring string\
    \ (add1 (string-length substring))) substring))\n          ;; Otherwise just return\
    \ 0.\n          0)))\n", "  (if (equal? string \"\")\n      0\n      (let* ([substr-length\
    \ (string-length substring)]\n             [substr-head (substring string 0 substr-length)]\n\
    \             [str-tail (substring string 1 (string-length string))])\n      \
    \  (if (equal? substr-head substring)\n            (+ 1 (how_many_times str-tail\
    \ substring))\n            (how_many_times str-tail substring)))))\n", "  (if\
    \ (string-contains string substring)\n      (+ 1 (how_many_times (substring string\
    \ (+ 1 (string-index substring string))) substring))\n      0))\n", "  (cond\n\
    \    [(empty? string) 0]\n    [(empty? substring) 0]\n    [(empty? (rest string))\
    \ 0]\n    [(equal? (substring string 0 (string-length substring)) substring)\n\
    \     (+ 1 (how_many_times (rest string) substring))]\n    [else (how_many_times\
    \ (rest string) substring)]))\n", "  (cond\n    [(empty? string) 0]\n    [(empty?\
    \ substring) 0]\n    [(equal? (first string) (first substring)) (+ 1 (how_many_times\
    \ (rest string) (rest substring)))]\n    [else (how_many_times (rest string) substring)]))\n\
    ```\n\nHow does this work? If the string or substring is empty, we're done - there's\
    \ nothing left to compare. If the first character of the string and substring\
    \ are equal, we increment our `how_many_times` count and try again. If they aren't,\
    \ we ignore the character and try again.\n\nThis fails, however, if we have a\
    \ substring that is longer than the string it's in. For example, `(how_many_times\
    \ \"a\" \"aa\")` will end up calling `(rest \"a\")`, which is `'()`. We'll get\
    \ a nice exception:\n\n```\n. . ./w2d2-hw.rkt:15:23: rest: contract violation\n\
    \  expected: pair?\n  given: '()\n```\n\nWe'll take care of this case by returning\
    \ 0 when the substring is longer than the string:\n\n```racket", "  (cond\n  \
    \  [(empty? string) 0]\n    [(empty? substring) (add1 (how_many_times (rest string)\
    \ substring))]\n    [(first string) = (first substring) (add1 (how_many_times\
    \ (rest string) (rest substring)))]\n    [else (how_many_times (rest string) substring)]))\n",
  "  (if (= (string-length substring) 0)\n      0\n      (let ([strlen (string-length\
    \ string)]\n            [substrlen (string-length substring)])\n        (let loop\
    \ ([i (- strlen substrlen)])\n          (cond\n            [(= i (- strlen substrlen))\n\
    \             (if (equal? (substring string i (+ i substrlen)) substring)\n  \
    \               1\n                 0)]\n            [(> i (- strlen substrlen))\n\
    \             (if (equal? (substring string i (+ i substrlen)) substring)\n  \
    \               (+ 1 (loop (- i 1)))\n                 (loop (- i 1)))]\n    \
    \        [else\n             0])))))\n", "  (letrec ((loop ([start 0] [count 0])\n\
    \                (if (string-contains string substring start)\n              \
    \      (loop (string-index string substring (+ start 1)) (+ count 1))\n      \
    \              count)))\n    (loop)))\n", "  (define (count result)\n    (if (string-contains\
    \ string substring)\n        (begin\n          (set! string (substring string\
    \ (add1 (string-index string substring))))\n          (count (add1 result)))\n\
    \        result))\n  (count 0))\n", "  (let ([len (string-length substring)])\n\
    \    (cond [(or (null? string) (null? substring)) 0]\n          [(string=? (substring\
    \ string 0 len) substring)\n           (+ 1 (how_many_times (substring string\
    \ 1) substring))]\n          [else (how_many_times (substring string 1) substring)])))\n",
  "  (cond [(empty? string) 0]\n        [(empty? substring) 0]\n        [(equal? (substring\
    \ string 0 (length substring)) substring)\n         (+ 1 (how_many_times (substring\
    \ string 1) substring))]\n        [else (how_many_times (substring string 1) substring)]))\n",
  "  (if (empty? string)\n      0\n      (if (string-contains string substring)\n\
    \          (+ 1 (how_many_times (string-drop string 1) substring))\n         \
    \ (how_many_times (string-drop string 1) substring))))\n", "  (define (recurse\
    \ str substr count)\n    (cond ((string=? substr str) (+ count 1))\n         \
    \ ((null? str) count)\n          (else (recurse (substring str 1) (substring substr\
    \ 1)\n                         (cond ((string=? (substring str 0 1) (substring\
    \ substr 0 1)) count)\n                               (else (+ count 1)))))))\n\
    \  (recurse string substring 0))\n", "  (if (string-contains string substring)\n\
    \      (+ 1 (how_many_times (string-replace string substring \"\") substring))\n\
    \      0))\n", "  (define (substrings string)\n    (define (substrings-helper\
    \ str1 str2)\n      (cond [(null? str1)\n             (list str2)]\n         \
    \   [(substring=? str1 (substring str2 0 (string-length str1)))\n            \
    \ (substrings-helper str1 (substring str2 (string-length str1)))]\n          \
    \  [else\n             (substrings-helper str1 (substring str2 1))]))\n    (substrings-helper\
    \ substring string))\n  (length (substrings string)))", "  ;; Implement this function\n\
    \  (let ((count 0)\n        (substr-len (string-length substring)))\n    (string-for-each\
    \ (lambda (ch)\n                       (if (equal? (substring string (sub1 count)\
    \ substr-len) substring)\n                           (set! count (add1 count))))\n\
    \                     string)\n    count))\n```\n\n### Find the longest palindrome\n\
    ```\n#lang racket\n", "  (let loop ([string string] [count 0])\n    (cond [(empty?\
    \ string) count]\n          [(number->string (substring string 0 (string-length\
    \ substring)))\n           (loop (substring string 1) (+ count 1))]\n        \
    \  [else (loop (substring string 1) count)])))\n", "  (define (subs substr)\n\
    \    (if (string-contains string substr)\n        (+ 1 (subs (string-append (substring\
    \ substr 0 1) (substring substr 1))))\n        0))\n  (subs substring))\n\n```\n\
    \n```\n>>> (how_many_times \"\" \"a\")\n0\n>>> (how_many_times \"aaa\" \"a\")\n\
    3\n>>> (how_many_times \"aaaa\" \"aa\")\n3\n>>> (how_many_times \"aaaa\" \"aaa\"\
    )\n2\n```\n\n### Quiz\n#### How many times can you find \"aaa\" in \"aaaaaaaaa\"\
    ?\n```\n>>> (how_many_times \"aaaaaaaaa\" \"aaa\")\n8\n```\n\n#### How many times\
    \ can you find \"aaa\" in \"aaaaaaaaaaaaaaa\"?\n```\n>>> (how_many_times \"aaaaaaaaaaaaaaa\"\
    \ \"aaa\")\n13\n```\n\n#### How many times can you find \"aa\" in \"aaaaaaaaaaaaaaa\"\
    ?\n```\n>>> (how_many_times \"aaaaaaaaaaaaaaa\" \"aa\")\n14\n```\n\n#### How many\
    \ times can you find \"aa\" in \"aaaaaaaaaaaaaaaaaa\"?\n```\n>>> (how_many_times\
    \ \"aaaaaaaaaaaaaaaaaa\" \"aa\")\n19\n```\n\n#### How many times can you find\
    \ \"aaa\" in \"aaaaaaaaaaaaaaaa\"?\n```\n>>> (how_many_times \"aaaaaaaaaaaaaaaa\"\
    \ \"aaa\")\n13\n```\n\n#### How many times can you find \"aa\" in \"aaaaaaaaaaaaaaaaaaaa\"\
    ?\n```\n>>> (how_many_times \"aaaaaaaaaaaaaaaaaaaa\" \"aa\")\n21\n```\n\n####\
    \ How many times can you find \"aaa\" in \"aaaaaaaaaaaaaaaaaaaa\"?\n```\n>>> (how_many_times\
    \ \"aaaaaaaaaaaaaaaaaaaa\" \"aaa\")\n19\n```\n\n#### How many times can you find\
    \ \"aaa\" in \"aaaaaaaaaaaaaaaaaaaaaaaa\"?\n```\n>>> (how_many_times \"aaaaaaaaaaaaaaaaaaaaaaaa\"\
    \ \"aaa\")\n20\n```\n\n#### How many times can you find \"aa\" in \"aaaaaaaaaaaaaaaa",
  "  ;; Check to see if the substring is contained in the string, if so then...\n\
    \  (if (string-contains string substring)\n      ;; ...add 1 to the count of the\
    \ number of overlaps and call the function again on the original string, with\
    \ the substring removed\n      (+ 1 (how_many_times (string-replace string substring\
    \ \"\") substring))\n      ;; ...otherwise, there were no overlaps, and the function\
    \ returns 0\n      0))\n", "  (cond\n    [(string=? \"\" substring) 0]\n    [(string=?\
    \ \"\" string) 0]\n    [(string=? substring (substring string 0 (string-length\
    \ substring)))\n     (+ 1 (how_many_times (substring string 1) substring))]\n\
    \    [else (how_many_times (substring string 1) substring)]))\n", "  (cond\n \
    \   [(string= \"\" substring) 0]\n    [(string= \"\" string) 0]\n    [(or (string=\
    \ (substring string 0 1) substring)\n        (string= (substring string 0 (string-length\
    \ substring)) substring)) (+ 1 (how_many_times (substring string 1) substring))]\n\
    \    [else (how_many_times (substring string 1) substring)]))\n", "  (define (count-from-0\
    \ idx)\n    (if (= idx (string-length string))\n        0\n        (if (string=?\
    \ substring (substring string idx (+ idx (string-length substring))))\n      \
    \      (+ 1 (count-from-0 (+ idx 1)))\n            (count-from-0 (+ idx 1)))))\n\
    \  (count-from-0 0))", "  (if (or (string=? string \"\") (string=? substring \"\
    \"))\n      0\n      (if (string-contains string substring)\n          (+ 1 (how_many_times\
    \ (substring string 1) substring))\n          0)))\n", "  (local [(define (helper\
    \ string substring count)\n            (cond [(empty? string) count]\n       \
    \           [(empty? substring) count]\n                  [(equal? (substring\
    \ string 0 (string-length substring)) substring)\n                   (helper (substring\
    \ string 1) substring (+ count 1))]\n                  [else (helper (substring\
    \ string 1) substring count)]))]\n    (helper string substring 0)))\n", "  (letrec\
    \ ([string-l (length string)]\n           [substring-l (length substring)]\n \
    \          [count (let loop ([i 0])\n                    (cond [(>= (+ i substring-l)\
    \ string-l) 0]\n                          [(string=? (substring string i (+ i\
    \ substring-l)) substring)\n                           (+ 1 (loop (+ i 1)))]\n\
    \                          [else (loop (+ i 1))]))])\n    count))\n", "  (define\
    \ (count-substring string substring count)\n    (if (string-contains string substring)\n\
    \        (count-substring (string-tail string (string-length substring)) substring\
    \ (+ count 1))\n        count))\n  (count-substring string substring 0))", " \
    \ (if (equal? substring \"\")\n      0\n      (if (string-contains string substring)\n\
    \          (+ 1 (how_many_times (string-drop string (string-length substring))\
    \ substring))\n          0)))\n", "  (local [(define (h string substring index\
    \ len_s len_sub)\n            (cond [(or (= index len_s) (= len_sub 0)) 0]\n \
    \                 [(and (= (string-ref string index) (string-ref substring 0))\n\
    \                        (= (h string substring (+ index 1) len_s (- len_sub 1))\
    \ (- len_sub 1)))\n                   (+ 1 (h string substring (+ index 1) len_s\
    \ len_sub))]\n                  [else (h string substring (+ index 1) len_s len_sub)]))]\n\
    \    (h string substring 0 (string-length string) (string-length substring))))",
  "  (local [(define (count i counter)\n            (cond [(= i (- (string-length\
    \ string) 1))\n                   (if (string=? (substring string i (+ i (string-length\
    \ substring))) substring)\n                       (+ counter 1)\n            \
    \           counter)]\n                  [(string=? (substring string i (+ i (string-length\
    \ substring))) substring)\n                   (count (+ i 1) (+ counter 1))]\n\
    \                  [else (count (+ i 1) counter)]))]\n    (count 0 0)))\n", " \
    \ (let ([str-len (string-length string)]\n        [substr-len (string-length substring)])\n\
    \    (cond [(< str-len substr-len) 0]\n          [(equal? (substring string 0\
    \ substr-len) substring)\n           (+ 1 (how_many_times (substring string 1\
    \ str-len) substring))]\n          [else (how_many_times (substring string 1 str-len)\
    \ substring)])))\n", "  (how_many_times_iter substring string 0))\n", "  (define\
    \ (has_suffix? string suffix)\n    (string=? suffix (substring string (- (string-length\
    \ string) (string-length suffix)))))\n  (define (count occurences)\n    (if (has_suffix?\
    \ string substring)\n        (count (+ occurences 1))\n        occurences))\n\
    \  (count 0))\n", "  (let loop ([string string] [count 0])\n    (if (empty? string)\n\
    \        count\n        (if (string-prefix? substring string)\n            (loop\
    \ (substring string (add1 (string-length substring))) (add1 count))\n        \
    \    count))))\n```\n\n```python\n#lang python\n\n# Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n# >>>\
    \ how_many_times(\"\", \"a\")\n# 0\n# >>> how_many_times(\"aaa\", \"a\")\n# 3\n\
    # >>> how_many_times(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string, substring):\n\
    \    count = 0\n    while len(string) > 0:\n        if string.startswith(substring):\n\
    \            count += 1\n            string = string[len(substring):]\n      \
    \  else:\n            string = string[1:]\n    return count\n```\n\n```java\n\
    // Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n// >>> howManyTimes(\"\", \"a\")\n// 0\n// >>> howManyTimes(\"\
    aaa\", \"a\")\n// 3\n// >>> howManyTimes(\"aaaa\", \"aa\")\n// 3\npublic class\
    \ HowManyTimes {\n    public static int howManyTimes(String string, String substring)\
    \ {\n        int count = 0;\n        while (string.length() > 0) {\n         \
    \   if (string.startsWith(substring)) {\n                count++;\n          \
    \      string = string.substring(substring.length());\n            } else {\n\
    \                string = string.substring(1);\n            }\n        }\n   \
    \     return count;\n    }\n}\n```\n\n```haskell\n-- Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n-- >>>\
    \ howManyTimes \"\" \"a\"\n-- 0\n-- >>> howManyTimes \"aaa\" \"a\"\n-- 3\n-- >>>\
    \ howManyTimes \"aaaa\" \"aa\"\n-- 3\nhowManyTimes :: String -> String -> Int\n\
    howManyTimes string substring =\n  let loop string count =\n        if null string\n",
  "  (if (not (string=? substring \"\"))\n      (if (string-contains string substring)\n\
    \          (+ 1 (how_many_times (substring string (string-index string substring)\
    \ (string-length string)) substring))\n          0)\n      0))\n", "  (define\
    \ (helper string substring n)\n    (if (empty? string)\n        n\n        (let\
    \ ([substring-length (string-length substring)])\n          (if (string=? (substring\
    \ string 0 substring-length) substring)\n              (helper (substring string\
    \ 1 substring-length) substring (+ n 1))\n              (helper (substring string\
    \ 1) substring n)))))\n  (helper string substring 0))\n", "  (define (string-contains?\
    \ string substr)\n    (regexp-match #rx(string-append \".*\" substr \".*\") string))\n\
    \  (define (count substr str)\n    (if (string-contains? str substr)\n       \
    \ (+ 1 (count substr (substring str 1)))\n        0))\n  (count substring string))\n",
  "  (if (and (not (null? string))\n           (not (null? substring)))\n      (cond\n\
    \        ((and (= (string-length string) (string-length substring))\n        \
    \      (string=? string substring))\n         1)\n        ((and (> (string-length\
    \ string) (string-length substring))\n              (string=? (substring string\
    \ 0 (string-length substring)) substring))\n         (+ 1 (how_many_times (substring\
    \ string 1) substring)))\n        (else\n         (how_many_times (substring string\
    \ 1) substring)))\n      0))\n", "  (cond\n    [(empty? string) 0]\n    [(empty?\
    \ substring) (length string)]\n    [else\n     (let ([string-first-char (first\
    \ string)]\n           [substring-first-char (first substring)])\n       (if (char=?\
    \ string-first-char substring-first-char)\n           (+ 1 (how_many_times (rest\
    \ string) (rest substring)))\n           (how_many_times (rest string) substring)))]))\n",
  "  (let loop ([acc 0] [pos 0])\n    (cond [(string-index string substring pos)\n\
    \           (loop (+ acc 1) (+ pos 1))]\n          [else acc])))\n", "  (cond\n\
    \    [(empty? string) 0]\n    [(empty? substring) 0]\n    [(empty? (regexp-match\
    \ #rx substring string)) 0]\n    [else (+ 1 (how_many_times (substring string\
    \ 1) substring))]))\n", "  (define (count index)\n    (if (= (- (string-length\
    \ string) index) (string-length substring))\n        0\n        (if (string=?\
    \ (substring string index (+ index (string-length substring))) substring)\n  \
    \          (+ 1 (count (+ index 1)))\n            (count (+ index 1)))))\n  (count\
    \ 0))\n", "  (define (how_many_times_rec string substring count)\n    (if (empty?\
    \ string)\n        count\n        (if (or (equal? (substring string 0 (string-length\
    \ substring)) substring)\n                (and (empty? substring) (not (empty?\
    \ string))))\n            (how_many_times_rec (substring string 1) substring (+\
    \ count 1))\n            (how_many_times_rec (substring string 1) substring count))))\n\
    \  (how_many_times_rec string substring 0))", "  (if (string-index string substring)\n\
    \      (+ 1 (how_many_times (substring string (+ 1 (string-index string substring)))\
    \ substring))\n      0))\n", "  (count_substrings string substring 0))\n", " \
    \ (if (string-contains string substring)\n      (+ 1 (how_many_times (substring\
    \ string (+ 1 (string-index string substring))) substring))\n      0))", "  (define\
    \ (count-h string substring)\n    (cond\n      [(empty? string)\n       0]\n \
    \     [(not (empty? substring))\n       (count-h (rest string) (rest substring))]\n\
    \      [else\n       (+ 1 (count-h (rest string) substring))]))\n  (count-h string\
    \ substring))", "  (string-count string substring))\n", "  (let loop ([string\
    \ string] [substring substring] [count 0])\n    (cond [(string=? substring \"\"\
    ) count]\n          [(string=? string \"\") count]\n          [(string=? (substring\
    \ string 0 (string-length substring)) substring)\n           (loop (substring\
    \ string 1) substring (+ count 1))]\n          [else (loop (substring string 1)\
    \ substring count)])))\n", "  (define (count-helper string substring count)\n\
    \    (cond [(empty? string) count]\n          [(or (empty? substring) (eq? (first\
    \ string) (first substring)))\n           (count-helper (rest string) (rest substring)\
    \ (add1 count))]\n          [else (count-helper (rest string) substring count)]))\n\
    \  (count-helper string substring 0))\n\n", "  (define (search-substring s sb)\n\
    \    (if (string-contains s sb)\n        (+ 1 (search-substring (substring s (string-index\
    \ s sb) (add1 (string-length sb))) sb))\n        0))\n  (search-substring string\
    \ substring))\n", "  (how_many_times_aux string substring 0))\n", "  (define (count_times\
    \ string substring acc)\n    (cond\n      [(equal? substring (string-drop string\
    \ 0 (string-length substring))) (add1 acc)]\n      [(null? (string-drop string\
    \ 1)) acc]\n      [else (count_times (string-drop string 1) substring acc)]))\n\
    \  (count_times string substring 0))\n```\n\n```racket\n#lang racket\n", "  (define\
    \ (help string substring count)\n    (if (&lt; (string-length string) (string-length\
    \ substring))\n        count\n        (if (string=? substring (substring string\
    \ 0 (string-length substring)))\n            (help (substring string 1) substring\
    \ (+ count 1))\n            (help (substring string 1) substring count))))\n \
    \ (help string substring 0))\n</code>\nI would appreciate any help.\n\n\nA:\n\n\
    I guess you tried to use <code>string-index</code> but have a little problem.\n\
    <code>(define (how_many_times string substring)\n  (define (help string substring\
    \ count index)\n    (if (&lt; (string-length string) (string-length substring))\n\
    \        count\n        (if (string=? substring (substring string index (string-length\
    \ substring)))\n            (help string substring (+ count 1) (+ index 1))\n\
    \            (help string substring count (+ index 1)))))\n  (help string substring\
    \ 0 0))\n</code>\n", "  (cond\n    [(empty? string) 0]\n    [(equal? substring\
    \ (take (length substring) string)) (+ 1 (how_many_times (drop (length substring)\
    \ string) substring))]\n    [else (how_many_times (drop 1 string) substring)]))\n",
  "  (define (substring? string index)\n    (equal? (substring string index (+ index\
    \ (string-length substring))) substring))\n  (define (substring?-r string index)\n\
    \    (substring? string index))\n  (define (substring?-l string index)\n    (and\
    \ (not (or (negative? index) (= index (string-length string))))\n         (substring?\
    \ string index)))\n  (define (substring?-b string index)\n    (and (not (or (negative?\
    \ index) (= index (string-length string))))\n         (substring? string index)))\n\
    \  (define (substring?-bl string index)\n    (and (not (or (negative? index) (=\
    \ index (string-length string))))\n         (substring? string index)))\n  (define\
    \ (substring?-br string index)\n    (and (not (or (negative? index) (= index (string-length\
    \ string))))\n         (substring? string index)))\n  (define (substring?-t string\
    \ index)\n    (and (not (or (negative? index) (= index (string-length string))))\n\
    \         (substring? string index)))\n  (define (substring?-tr string index)\n\
    \    (and (not (or (negative? index) (= index (string-length string))))\n    \
    \     (substring? string index)))\n  (define (substring?-tl string index)\n  \
    \  (and (not (or (negative? index) (= index (string-length string))))\n      \
    \   (substring? string index)))\n  (define (substring?-bl-tr string index)\n \
    \   (and (not (or (negative? index) (= index (string-length string))))\n     \
    \    (substring? string index)))\n  (define (substring?-br-tl string index)\n\
    \    (and (not (or (negative? index) (= index (string-length string))))\n    \
    \     (substring? string index)))\n  (define (substring?-algorithm algorithm)\n\
    \    (define (how_many-rec string index count)\n      (cond ((= index (string-length\
    \ string)) count)\n            ((algorithm string index) (how_many-rec string\
    \ (+ index 1) (+ count 1)))\n", "  (define (how_many_times_iter str sub)\n   \
    \ (if (eq? (length str) (length sub)) 0\n      (if (string=? sub (substring str\
    \ 0 (length sub)))\n          (+ 1 (how_many_times_iter (substring str 1 (length\
    \ str)) sub))\n          (how_many_times_iter (substring str 1 (length str)) sub))))\n\
    \  (how_many_times_iter string substring))\n", "  (define (how_many_times-helper\
    \ string substring index)\n    (if (= index 0) (how_many_times-helper string substring\
    \ 1)\n        (if (= index (string-length string))\n            0\n          \
    \  (if (string=? (substring string index (add1 index)) substring)\n          \
    \      (add1 (how_many_times-helper string substring (add1 index)))\n        \
    \        (how_many_times-helper string substring (add1 index))))))\n  (how_many_times-helper\
    \ string substring 0))\n", "  (cond [(empty? string) 0]\n        [(empty? substring)\
    \ 0]\n        [(= (string-length substring) 1)\n         (let* ([char (string-ref\
    \ substring 0)]\n                [count (for/sum ([i (in-range (string-length\
    \ string))])\n                         (and (= char (string-ref string i)) 1))])\n\
    \           count)]\n        [else (let* ([count (how_many_times string (string-drop\
    \ substring 1))])\n                 (for/sum ([i (in-range (- (string-length string)\
    \ (string-length substring)))])\n                   (and (= (string-take string\
    \ (string-length substring)) substring) 1)))]))\n", "  (let count_occurrences\
    \ ([remaining_str string] [occurrence_count 0])\n    (cond [(empty? remaining_str)\
    \ occurrence_count]\n          [(has-substring? remaining_str substring)\n   \
    \        (count_occurrences (drop-substring remaining_str) (+ occurrence_count\
    \ 1))]\n          [else\n           (count_occurrences (rest remaining_str) occurrence_count)])))\n",
  "  (if (string-length string)\n      (if (string-suffix? substring string)\n   \
    \       (+ 1 (how_many_times (substring string 0 (sub1 (string-length string)))\
    \ substring))\n          (how_many_times (substring string 0 (sub1 (string-length\
    \ string))) substring))\n      0))\n", "  ;; fill-in your code here\n  )\n", " \
    \ (define (times start-index)\n    (if (eq? (add1 start-index) (string-length\
    \ string)) 0\n        (if (string=? (substring string start-index (add1 start-index))\
    \ (substring substring 0 1)) (+ 1 (times (add1 start-index)))\n            (times\
    \ (add1 start-index)))))\n  (times 0))\n", "  (let ((str_len (string-length string))\n\
    \        (substr_len (string-length substring)))\n    (define (loop counter)\n\
    \      (if (>= counter str_len)\n          0\n          (if (string=? substring\
    \ (substring string counter (+ counter substr_len)))\n              (+ 1 (loop\
    \ (+ counter substr_len)))\n              (loop (+ counter 1)))))\n    (loop 0)))\n\
    </code>\n", "  (let loop ([string string] [substring substring] [count 0])\n \
    \   (cond [(empty? string) count]\n          [(empty? substring) count]\n    \
    \      [(zero? (string-index substring string)) (loop (substring string 1) substring\
    \ (+ count 1))]\n          [else (loop (substring string 1) substring count)])))\n",
  "  (if (string-prefix? substring string)\n      (+ 1 (how_many_times (substring\
    \ string (add1 (string-length substring))) substring))\n      0))\n```\n\n## [Reverse\
    \ a string.][2]\n\n[2]: http://www.practicepython.org/exercise/2014/03/19/07-list-comprehensions.html\
    \ \"Reverse a string.\"\n\n``` #lang racket\n", "  (count (lambda (index)\n  \
    \         (if (string=? (substring string index (+ index (string-length substring)))\
    \ substring)\n               1\n               0))\n         (iota (string-length\
    \ string))))\n", "  (cond [(empty? string) 0]\n        [(empty? substring) 0]\n\
    \        [(string=? (substring string 0 (string-length substring)) substring)\
    \ (+ 1 (how_many_times (substring string 1) substring))]\n        [else (how_many_times\
    \ (substring string 1) substring)]))\n", "  (cond [(equal? string \"\") 0]\n \
    \       [(equal? substring \"\") 0]\n        [(equal? (substring string 0 (string-length\
    \ substring)) substring)\n         (+ 1 (how_many_times (substring string 1) substring))]\n\
    \        [else (how_many_times (substring string 1) substring)]))\n```\n\n## Easy\
    \ #5:\n\n```#lang racket\n", "  (if (equal? (string-length substring) (string-length\
    \ string))\n      (if (equal? string substring)\n          1\n          0)\n \
    \     (if (equal? substring \"\")\n          0\n          (let ([index (string-index\
    \ string substring)])\n            (if index\n                (+ 1 (how_many_times\
    \ (substring string (+ index (string-length substring))) substring))\n       \
    \         0)))))\n", "  (define (recur ss sr)\n    (if (equal? sr substring)\n\
    \        1\n        (if (and (equal? (string-length ss) (string-length sr))\n\
    \                 (equal? (string-length sr) (string-length substring)))\n   \
    \         0\n            (if (string-prefix? substring sr)\n                (+\
    \ 1 (recur (substring ss 1) (substring sr 1)))\n                (recur (substring\
    \ ss 1) (substring sr 1))))))\n  (recur string string))\n", "  (define (split-string\
    \ string regexp)\n    (if (string-length string)\n        (apply string-append\n\
    \               (map (lambda (lst)\n                      (if (string? lst)\n\
    \                          lst\n                          (string (car lst))))\n\
    \                    (regexp-match* regexp string)))))\n  (define (find-occurrence\
    \ string substr)\n    (if (string-length string)\n        (if (string-contains\
    \ string substr)\n            (+ 1 (find-occurrence (split-string string (regexp\
    \ (regexp-quote substr))) substr))\n            0)\n        0))\n  (find-occurrence\
    \ string substring))\n", "  (define (same-at-index index)\n    (and (>= (+ index\
    \ (string-length substring)) (string-length string))\n         (string=? substring\
    \ (substring string index (+ index (string-length substring))))))\n  (define (count\
    \ start)\n    (if (same-at-index start)\n        (+ 1 (count (+ start 1)))\n \
    \       0))\n  (count 0))\n", "  (define (loop string substring count)\n    (cond\
    \ ((or (string=? string \"\") (string=? substring \"\")) count)\n          ((string-contains\
    \ substring string) (loop (substring string 1) substring (+ count 1)))\n     \
    \     (else count)))\n  (loop string substring 0))\n", "  (let loop ([string string]\
    \ [n 0])\n    (if (not (string-contains string substring))\n        n\n      \
    \  (loop (substring string (+ 1 (string-index string substring)))\n          \
    \    (+ 1 n)))))\n", "  (let ((counter 0))\n    (for ([i (in-range (string-length\
    \ string))])\n      (let ((sub (substring string i (+ i (string-length substring)))))\n\
    \        (if (string=? sub substring)\n            (set! counter (+ counter 1)))))\n\
    \    counter))\n", "  (define (helper-how-many-times ss s)\n    (cond [(string=?\
    \ ss \"\") 0]\n          [(string=? s \"\") 0]\n          [(string=? ss s) (+\
    \ 1 (helper-how-many-times (substring ss 1) s))]\n          [else (helper-how-many-times\
    \ (substring ss 1) s)]))\n  (helper-how-many-times string substring))\n", "  (define\
    \ (times string substring sublen)\n    (if (zero? sublen)\n        0\n       \
    \ (let ([beg (find-first substring string)])\n          (if (negative? beg)\n\
    \              0\n              (+ 1 (times (substring string (+ beg 1) (string-length\
    \ string)) substring sublen))))))\n  (times string substring (string-length substring)))\n",
  "  (if (string-contains string substring)\n      (+ 1 (how_many_times (string-tail\
    \ string (- (string-length substring) 1)) substring))\n      0))\n", "  (define\
    \ (find-substring str sub)\n    (if (string-contains? str sub)\n        (add1\
    \ (find-substring (string-drop str 1) sub))\n        0))\n  (find-substring string\
    \ substring))\n", "  (let ([n (- (string-length string) (string-length substring))])\n\
    \    (define (count-substring s i)\n      (if (= i n)\n          0\n         \
    \ (if (equal? substring (substring s i (+ i (string-length substring))))\n   \
    \           (+ 1 (count-substring s (+ i 1)))\n              (count-substring\
    \ s (+ i 1)))))\n    (count-substring string 0)))\n", "  (define (rec offset)\n\
    \    (cond [(empty? string) 0]\n          [(empty? substring) 0]\n          [(equal?\
    \ (substring string 0 (length substring)) substring) (+ 1 (rec (+ offset (length\
    \ substring))))]\n          [else (rec (+ offset 1))]))\n  (rec 0))\n", "  (if\
    \ (string-contains string substring)\n      (+ 1 (how_many_times (string-drop\
    \ string 1) substring))\n      0))\n", "  (let recur ((index 0) (count 0))\n \
    \   (cond ((string-index string substring index)\n           (recur (+ index 1)\
    \ (+ count 1)))\n          (else count))))\n", "  (if (= (length string) 0)\n\
    \      0\n      (if (string-contains string substring)\n          (+ 1 (how_many_times\
    \ (substring string 1) substring))\n          0)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
