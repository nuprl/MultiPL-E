name: HumanEval_157_right_angle_triangle
language: rkt
prompt: "#lang racket\n\n;; Given the lengths of the three sides of a triangle. Return\
  \ #t if the three\n;; sides form a right-angled triangle, #f otherwise.\n;; A right-angled\
  \ triangle is a triangle in which one angle is right angle or \n;; 90 degree.\n\
  ;; Example:\n;; >>> (right_angle_triangle 3 4 5)\n;; #t\n;; >>> (right_angle_triangle\
  \ 1 2 3)\n;; #f\n(define (right_angle_triangle a b c)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n\
  \    (check-equal? (candidate 3 4 5) #t)\n    (check-equal? (candidate 1 2 3) #f)\n\
  \    (check-equal? (candidate 10 6 8) #t)\n    (check-equal? (candidate 2 2 2) #f)\n\
  \    (check-equal? (candidate 7 24 25) #t)\n    (check-equal? (candidate 10 5 7)\
  \ #f)\n    (check-equal? (candidate 5 12 13) #t)\n    (check-equal? (candidate 15\
  \ 8 17) #t)\n    (check-equal? (candidate 48 55 73) #t)\n    (check-equal? (candidate\
  \ 1 1 1) #f)\n    (check-equal? (candidate 2 2 10) #f)\n))\n\n(test-humaneval)"
completions: ["  (if (and (sqrt a) (sqrt b) (sqrt c))\n      (let* ([a (sqrt a)]\n\
    \             [b (sqrt b)]\n             [c (sqrt c)])\n        (if (and (>= a\
    \ 0) (>= b 0) (>= c 0))\n            (let ([d (vector (list a a) (list b b) (list\
    \ c c)]\n                  [a (pow a 2)]\n                  [b (pow b 2)]\n  \
    \                [c (pow c 2)])\n              (if (and (member a d) (member b\
    \ d) (member c d))\n                  #t\n                  #f))\n           \
    \ #f))\n      #f))", "  (and (and (&lt; a (max b c)) (&lt; b (max a c)) (&lt;\
    \ c (max a b)))\n       (and (= (expt a 2) (+ (expt b 2) (expt c 2)))\n      \
    \      (= (expt a 2) (+ (expt b 2) (expt c 2)))\n            (= (expt a 2) (+\
    \ (expt b 2) (expt c 2))))))\n", "  (and (= b c)\n       (= a (sqrt (+ (* b b)\
    \ (* c c))))))\n", "  (and (= (sqrt (+ (* a a) (* b b))) c)\n       (<= a b) (<=\
    \ b c)))\n", "  (cond\n    [(= a (sqrt (+ (sqr b) (sqr c)))) #t]\n    [(= b (sqrt\
    \ (+ (sqr a) (sqr c)))) #t]\n    [(= c (sqrt (+ (sqr a) (sqr b)))) #t]\n    [else\
    \ #f]))", "  (let ([ad ((<= 0 a) (and (< a b) (< a c)))]\n        [bd ((<= 0 b)\
    \ (and (< b a) (< b c)))]\n        [cd ((<= 0 c) (and (< c a) (< c b))))])\n \
    \   (and ad bd cd\n         (or (and (= (+ a (* b b)) (* c c))\n             \
    \     (= (+ (* a a) (* b b)) (* c c)))\n             (and (= (+ a (* c c)) (*\
    \ b b))\n                  (= (+ (* a a) (* c c)) (* b b)))\n             (and\
    \ (= (+ (* a a) (* b b)) (* c c))\n                  (= (+ (* a a) (* c c)) (*\
    \ b b)))))))\n", "  (= 90\n     (acos (/ (+ (* a a) (* b b) (* c c)) \n      \
    \        (* 2 a b c)))))", "  (and (and (and (> a 0) (> b 0) (> c 0))\n      \
    \      (<= a (+ b c))\n            (<= b (+ a c))\n            (<= c (+ a b)))\n\
    \       (or (and (= (pow a 2) (+ (pow b 2) (pow c 2)))\n                (= a (max\
    \ (max a b) c)))\n           (and (= (pow b 2) (+ (pow a 2) (pow c 2)))\n    \
    \            (= b (max (max a b) c)))\n           (and (= (pow c 2) (+ (pow a\
    \ 2) (pow b 2)))\n                (= c (max (max a b) c))))))\n", "  (cond\n \
    \   [(and (= c (square-root (+ (square a) (square b))))\n          (= b (square-root\
    \ (+ (square a) (square c))))\n          (= a (square-root (+ (square b) (square\
    \ c)))))\n     #t]\n    [else #f]))\n", "  (define (square a) (* a a))\n  (define\
    \ (hypot a b) (sqrt (+ (square a) (square b))))\n  (define (pythagoras a b c)\n\
    \    (and (or (= (hypot a b) c) (= (hypot a c) b) (= (hypot b c) a))\n       \
    \  (= (hypot a b) (hypot a c))))\n  (pythagoras a b c))\n", "  (if (and (= (square\
    \ a) (+ (square b) (square c)))\n           (= (square b) (+ (square a) (square\
    \ c)))\n           (= (square c) (+ (square a) (square b))))\n      #t\n     \
    \ #f))\n", "  (cond\n    [(>= a b c)   #f]\n    [(= a (* b b)) #t]\n    [(= b\
    \ (* a a)) #t]\n    [(= c (* a a)) #t]\n    [(= c (* b b)) #t]\n    [else #f]))\n",
  "  (define (square x) (* x x))\n  (define (is-pythagoras? a b c)\n    (and (= a\
    \ (+ b c))\n         (= (square a) (+ (square b) (square c)))\n         (< a (+\
    \ b c))))\n  (is-pythagoras? a b c))", "  ;; ***** your code goes here *****\n\
    )\n```\n\nHint: If a^2 + b^2 = c^2, then a, b, c form a right-angled triangle.\n\
    \n### (1d)\nWrite a function `largest_element` that takes a list of numbers and\
    \ returns the largest number in the list.\nExample:\n```racket\n>>> (largest_element\
    \ (list 1 5 4 2 7))\n7\n```\n\n### (1e)\nWrite a function `largest_in_each_row`\
    \ that takes a matrix (defined as a list of lists) and returns a list of the largest\n\
    number in each row of the matrix. Example:\n```racket\n>>> (largest_in_each_row\
    \ (list (list 1 2) (list 3 4 5) (list 6 7 8 9)))", "  (and (and (<= a b) (<= b\
    \ c))\n       (or (= a (+ b c))\n           (= b (+ a c))\n           (= c (+\
    \ a b)))))\n", "  (define max-side (if (or (= a (max a b c)) (= b (max a b c)))\
    \ (max a b c) c))\n  (define min-side (if (or (= a (min a b c)) (= b (min a b\
    \ c))) (min a b c) c))\n  (define middle-side (if (and (not (= a (max a b c)))\
    \ (not (= a (min a b c)))) a b))\n  (= (sqr min-side) (+ (sqr middle-side) (sqr\
    \ max-side)))\n  )\n", "  (cond\n    [(and (<= a b) (<= b c)) (if (= (sqr a) (+\
    \ (sqr b) (sqr c))) #t #f)]\n    [(and (<= a c) (<= c b)) (if (= (sqr a) (+ (sqr\
    \ c) (sqr b))) #t #f)]\n    [(and (<= b a) (<= a c)) (if (= (sqr b) (+ (sqr a)\
    \ (sqr c))) #t #f)]\n    [(and (<= b c) (<= c a)) (if (= (sqr b) (+ (sqr c) (sqr\
    \ a))) #t #f)]\n    [(and (<= c a) (<= a b)) (if (= (sqr c) (+ (sqr a) (sqr b)))\
    \ #t #f)]\n    [(and (<= c b) (<= b a)) (if (= (sqr c) (+ (sqr b) (sqr a))) #t\
    \ #f)]\n    [else #f]))\n", "  (if (>= a b c)\n      (if (>= b c a)\n        \
    \  (if (>= c a b)\n              #t\n              #f)\n          #f)\n      #f))\n",
  "  (let ((sides (vector a b c)))\n    (vector-sort < sides)\n    (equal? (vector-ref\
    \ sides 0) \n            (sqrt (+ (expt (vector-ref sides 1) 2)\n            \
    \         (expt (vector-ref sides 2) 2))))))\n", "  (and\n   (or (= a (- c b))\
    \ (= b (- c a)) (= c (- a b)))\n   (and\n    (and (&lt;= a c) (&lt;= a b))\n \
    \   (and (&lt;= b c) (&lt;= b a))\n    (and (&lt;= c a) (&lt;= c b)))))\n</code>\n\
    I tried my best to make the code succinct, but I feel that it could be improved.\
    \ Could you give me some hints for further improvement?\n\n\nA:\n\nObligatory\
    \ readability section\n\nStyle guide: write <code>right-angle-triangle</code>\
    \ instead of <code>right_angle_triangle</code>.\n<code>right-angle-triangle</code>\
    \ is a good name, but <code>right-triangle?</code> is better.\n\nAlgorithm\n\n\
    Unnecessary code: why do you need to check that <code>a &lt;= c</code> and <code>a\
    \ &lt;= b</code>? If you know that <code>a &lt;= c</code>, you also know that\
    \ <code>a &lt;= b</code>. You don't need to check both.\nProbabilistic analysis:\
    \ Your test has a chance of succeeding even when the numbers don't represent a\
    \ right triangle. This can happen when the square root is not precise enough.\
    \ For example, if you pass in <code>a</code> = 1, <code>b</code> = 2, and <code>c</code>\
    \ = 1.41421356237309504880168872420969807856967187537694807317667973799073247846210703885038753432764157273501384623091229702492483605585073721264412149709993583141322266592750559275579995050115278206057147,\
    \ then <code>a</code> squared is less than <code>b</code> squared, but <code>a</code>\
    \ squared + <code>b</code> squared is approximately equal to <code>c</code> squared,\
    \ so your test would incorrectly pass. The numbers I used here are not arbitrary.",
  "  (and (positive? a)\n       (positive? b)\n       (positive? c)\n       (and (>\
    \ a b)\n            (> a c)\n            (= (+ (* b b) (* c c)) (* a a)))\n  \
    \     #t))\n", "  (let ([sorted-sides (list (sort a b c)]))\n    (cond\n     \
    \ [(> (car sorted-sides) (cadr sorted-sides)) #f]\n      [(> (car sorted-sides)\
    \ (caddr sorted-sides)) #f]\n      [(> (cadr sorted-sides) (caddr sorted-sides))\
    \ #f]\n      [else (= (+ (car sorted-sides) (cadr sorted-sides)) (caddr sorted-sides))])))\n",
  "  (cond ((and (= (square a) (+ (square b) (square c))) \n              (= (square\
    \ b) (+ (square a) (square c)))\n              (= (square c) (+ (square a) (square\
    \ b)))) #t)\n        (else #f)))\n", "  (cond\n    [(= (square a) (+ (square b)\
    \ (square c))) #t]\n    [(= (square b) (+ (square a) (square c))) #t]\n    [(=\
    \ (square c) (+ (square a) (square b))) #t]\n    [else #f]))\n", "  (cond\n  \
    \  [(and (> a b) (> a c))\n     (and (= (sqr b) (+ (sqr c) (sqr a)))\n       \
    \   (= (sqr a) (+ (sqr b) (sqr c))))]\n    [(and (> b a) (> b c))\n     (and (=\
    \ (sqr a) (+ (sqr c) (sqr b)))\n          (= (sqr b) (+ (sqr a) (sqr c))))]\n\
    \    [(and (> c a) (> c b))\n     (and (= (sqr a) (+ (sqr b) (sqr c)))\n     \
    \     (= (sqr c) (+ (sqr a) (sqr b))))]))\n", "  (cond\n    [(and (> a 0) (> b\
    \ 0) (> c 0)) #t]\n    [else #f]))", '  (and (>= a b c) (= a (+ (* b b) (* c c)))))',
  "  (define (square x) (* x x))\n  (define (right-angle? a b c)\n    (define (is-pythagorean-triple?\
    \ a b c)\n      (and (square a) (square b) (square c)))\n    (or (and (= (square\
    \ a) (+ (square b) (square c))) (= 90 90))\n        (and (= (square b) (+ (square\
    \ a) (square c))) (= 90 90))\n        (and (= (square c) (+ (square a) (square\
    \ b))) (= 90 90))))\n  (define (sort-triple a b c)\n    (cond\n      [(> a b)\
    \ (sort-triple b a c)]\n      [(> b c) (sort-triple a c b)]\n      [else (list\
    \ a b c)]))\n  (let ([xs (sort-triple a b c)])\n    (right-angle? (car xs) (cadr\
    \ xs) (caddr xs))))\n```\n\n### 1.2.2\n\n```racket\n#lang racket\n", "  (cond\
    \ ((and (< a b) (< a c)) (and (< (+ a b) c) #t))\n        ((and (< b a) (< b c))\
    \ (and (< (+ b a) c) #t))\n        ((and (< c a) (< c b)) (and (< (+ c a) b) #t))\n\
    \        (else #f)))\n", "  (let ([max (max (max a b) c)])\n    (cond\n      [(or\
    \ (= a max) (= b max) (= c max)) #f]\n      [(and\n        (= (sqr max) (+ (sqr\
    \ a) (sqr b)))\n        (= (sqr max) (+ (sqr a) (sqr c)))\n        (= (sqr max)\
    \ (+ (sqr b) (sqr c)))) #t]\n      [else #f])))\n", "  (and (&lt;= a b c)\n  \
    \     (= (expt a 2) (+ (expt b 2) (expt c 2)))))\n", "  (define (square x) (*\
    \ x x))\n  (define (hypotenuse x y)\n    (sqrt (+ (square x) (square y))))\n \
    \ (define (is_right? a b c)\n    (= (hypotenuse a b) c))\n  (is_right? a b c))\n",
  "  (cond\n    [(and (<= a b) (<= b c)) (display \"Triangle is \")\n     (if (= (sqrt\
    \ (+ (* a a) (* b b))) c) (display \"#t\") (display \"#f\"))]\n    [(and (<= a\
    \ c) (<= c b)) (display \"Triangle is \")\n     (if (= (sqrt (+ (* a a) (* c c)))\
    \ b) (display \"#t\") (display \"#f\"))]\n    [(and (<= b a) (<= a c)) (display\
    \ \"Triangle is \")\n     (if (= (sqrt (+ (* b b) (* a a))) c) (display \"#t\"\
    ) (display \"#f\"))]\n    [(and (<= b c) (<= c a)) (display \"Triangle is \")\n\
    \     (if (= (sqrt (+ (* b b) (* c c))) a) (display \"#t\") (display \"#f\"))]\n\
    \    [(and (<= c a) (<= a b)) (display \"Triangle is \")\n     (if (= (sqrt (+\
    \ (* c c) (* a a))) b) (display \"#t\") (display \"#f\"))]\n    [(and (<= c b)\
    \ (<= b a)) (display \"Triangle is \")\n     (if (= (sqrt (+ (* c c) (* b b)))\
    \ a) (display \"#t\") (display \"#f\"))]\n    [(display \"Error\")]))\n", "  (define\
    \ s (square a b c))\n  (and (positive? (square a))\n       (or (and (= (square\
    \ a) (+ (square b) (square c)))\n                (equal? (square a) (square b)\
    \ (square c)))\n           (and (= (square b) (+ (square a) (square c)))\n   \
    \             (equal? (square b) (square a) (square c)))\n           (and (= (square\
    \ c) (+ (square a) (square b)))\n                (equal? (square c) (square a)\
    \ (square b))))))\n", "  (define (right-angle? a b c)\n    (or (and (= a (sqrt\
    \ (+ (* b b) (* c c))))\n             (or (= b (sqrt (+ (* a a) (* c c))))\n \
    \                (= c (sqrt (+ (* a a) (* b b))))))\n        #f))\n  (right-angle?\
    \ a b c))", "  (let ([p (pythagorean-triplet a b c)])\n    (if p \n        (if\
    \ (not (is-integral? (sqrt (car p))))\n            #f\n            #t)\n     \
    \   #f)))\n", "  (if (and\n       (< a (+ b c))\n       (< b (+ a c))\n      \
    \ (< c (+ a b)))\n      #t\n      #f))\n", "  (and (and (<= a (+ b c)) (<= b (+\
    \ a c)) (<= c (+ a b))) \n       (or (and (= a (sqrt (+ (sqr b) (sqr c))))\n \
    \               (= b (sqrt (+ (sqr a) (sqr c))))\n                (= c (sqrt (+\
    \ (sqr a) (sqr b)))))\n           (and (= a (sqrt (+ (sqr b) (sqr c))))\n    \
    \            (= c (sqrt (+ (sqr a) (sqr b))))\n                (= b (sqrt (+ (sqr\
    \ a) (sqr c)))))\n           (and (= b (sqrt (+ (sqr a) (sqr c))))\n         \
    \       (= c (sqrt (+ (sqr a) (sqr b))))\n                (= a (sqrt (+ (sqr b)\
    \ (sqr c)))))\n           (and (= b (sqrt (+ (sqr a) (sqr c))))\n            \
    \    (= a (sqrt (+ (sqr b) (sqr c))))\n                (= c (sqrt (+ (sqr a) (sqr\
    \ b)))))\n           (and (= c (sqrt (+ (sqr a) (sqr b))))\n                (=\
    \ a (sqrt (+ (sqr b) (sqr c))))\n                (= b (sqrt (+ (sqr a) (sqr c)))))\n\
    \           (and (= c (sqrt (+ (sqr a) (sqr b))))\n                (= b (sqrt\
    \ (+ (sqr a) (sqr c))))\n                (= a (sqrt (+ (sqr b) (sqr c))))))))\n",
  "  (define (square-root x)\n    (sqrt x))\n  (define (pow x y)\n    (expt x y))\n\
    \  (define (big-num x y)\n    (if (> x y) x y))\n  (define (small-num x y)\n \
    \   (if (< x y) x y))\n  (define (middle-num x y z)\n    (cond ((and (< x y) (<\
    \ y z)) y)\n          ((and (< x z) (< z y)) z)\n          ((and (< y x) (< x\
    \ z)) x)))\n  (define (contains-zero? x y z)\n    (cond ((= x 0) #t)\n       \
    \   ((= y 0) #t)\n          ((= z 0) #t)\n          (else #f)))\n  (cond ((contains-zero?\
    \ a b c) #f)\n        ((= (square-root (pow a 2)) (+ (pow (big-num a b c) 2) (pow\
    \ (small-num a b c) 2))) #t)\n        ((= (square-root (pow b 2)) (+ (pow (big-num\
    \ a b c) 2) (pow (small-num a b c) 2))) #t)\n        ((= (square-root (pow c 2))\
    \ (+ (pow (big-num a b c) 2) (pow (small-num a b c) 2))) #t)\n        ((= (square-root\
    \ (pow (big-num a b c) 2)) (+ (pow (middle-num a b c) 2) (pow (small-num a b c)\
    \ 2))) #t)\n        ((= (square-root (pow (middle-num a b c) 2)) (+ (pow (big-num\
    \ a b c) 2) (pow (small-num a b c) 2))) #t)\n        ((= (square-root (pow (small-num\
    \ a b c) 2)) (+ (pow (big-num a b c) 2) (pow (middle-num a b c) 2))) #t)\n   \
    \     (else #f)))\n", "  (let ([a_sqr (square a)]\n        [b_sqr (square b)]\n\
    \        [c_sqr (square c)])\n    (or (and (= a b) (= a_sqr (+ b_sqr c_sqr)))\n\
    \        (and (= a c) (= a_sqr (+ b_sqr c_sqr)))\n        (and (= b c) (= b_sqr\
    \ (+ a_sqr c_sqr))))))\n", "  (cond\n    [(= (* a a) (+ (* b b) (* c c))) #t]\n\
    \    [else #f]))\n", "  (or (and (= (+ (square a) (square b)) (square c)) \n \
    \          (not (= a b c)))\n      (and (= (+ (square a) (square c)) (square b))\
    \ \n           (not (= a b c)))\n      (and (= (+ (square b) (square c)) (square\
    \ a)) \n           (not (= a b c)))))\n", "  (and (and (&lt;= a (+ b c)) (&gt;=\
    \ a (- b c)))\n       (and (&lt;= b (+ a c)) (&gt;= b (- a c)))\n       (and (&lt;=\
    \ c (+ a b)) (&gt;= c (- a b)))))\n</code>\nIs there any better way to implement\
    \ that function?\n\n\nA:\n\n<code>(define (right_angle_triangle a b c)\n  (and\
    \ (&lt;= a b c)\n       (&lt;= (* a a) (+ (* b b) (* c c)))\n       (&lt;= (*\
    \ b b) (+ (* a a) (* c c)))\n       (&lt;= (* c c) (+ (* a a) (* b b)))))\n</code>\n",
  "  (define sum (sum a b c))\n  (if (and (= (square a) (+ (square b) (square c)))\
    \ (< sum (* 2 a)))\n      #t\n      #f))\n", "  (define (is-right-angle-triangle\
    \ lst)\n    (or (apply = lst)\n        (or (apply = (sort lst (\u03BB (x y) (&lt;\
    \ x y))))\n            (apply = (sort lst (\u03BB (x y) (&gt; x y)))))))\n  (and\
    \ (and (&lt;= a b) (&lt;= b c))\n       (is-right-angle-triangle (map square (list\
    \ a b c)))))\n</code>\nIs this implementation good enough?\n\n\nA:\n\nThree issues:\n\
    \nIt's good to see that you are following the \"infix first\" policy on Racket.\n\
    \nIn this case, however, it's not clear to me why <code>right_angle_triangle</code>\
    \ is a function instead of a <code>syntax-rules</code> pattern. It would be more\
    \ readable.\n\nThe first conjunct is unnecessary.\n\nIt's a bad idea to use <code>sort</code>;\
    \ <code>apply</code> on a list of numbers is a dead giveaway that your code can\
    \ be written better.\n\n\n", "  (and (= 90 (angle_of_triangle a b c))\n      \
    \ (= 90 (angle_of_triangle b c a))\n       (= 90 (angle_of_triangle c a b))))\n",
  "  (and (= (+ (expt a 2) (expt b 2)) (expt c 2))\n       (>= a b c)))\n", "  (define\
    \ (is-right-triangle a b c)\n    (or (and (= a (sqrt (+ (* b b) (* c c))))\n \
    \            (= b (sqrt (+ (* a a) (* c c))))\n             (= c (sqrt (+ (* a\
    \ a) (* b b)))))\n        (and (= b (sqrt (+ (* a a) (* c c))))\n            \
    \ (= c (sqrt (+ (* a a) (* b b))))\n             (= a (sqrt (+ (* b b) (* c c)))))\n\
    \        (and (= c (sqrt (+ (* a a) (* b b))))\n             (= a (sqrt (+ (*\
    \ b b) (* c c))))\n             (= b (sqrt (+ (* a a) (* c c)))))))\n  (is-right-triangle\
    \ a b c))", "  (or (= (square a) (+ (square b) (square c)))\n      (= (square\
    \ b) (+ (square a) (square c)))\n      (= (square c) (+ (square a) (square b)))))\n",
  "  (cond\n    [(= (sqrt (+ (* a a) (* b b))) c) #t]\n    [(= (sqrt (+ (* a a) (*\
    \ c c))) b) #t]\n    [(= (sqrt (+ (* b b) (* c c))) a) #t]\n    [else #f]))\n",
  "  (cond\n    [(or (or (or (= a (sqrt (+ (* b b) (* c c))))\n              (= b\
    \ (sqrt (+ (* a a) (* c c)))))\n            (= c (sqrt (+ (* a a) (* b b)))))\n\
    \         (or (or (= a (- (sqrt (+ (* b b) (* c c))) 1))\n              (= b (-\
    \ (sqrt (+ (* a a) (* c c))) 1)))\n            (= c (- (sqrt (+ (* a a) (* b b)))\
    \ 1))))]\n    #t)\n  (else\n    #f))\n", "  (and (&lt; a (+ b c))\n       (&lt;\
    \ b (+ a c))\n       (&lt; c (+ a b))))\n</code>\nHow to make this code more readable?\n\
    \n\nA:\n\nUsing <code>and</code> and <code>&lt;</code> is ok.\nYou could add some\
    \ whitespace and make the names a bit more descriptive:\n<code>(define (right-angle-triangle?\
    \ a b c)\n  (and (&lt; a (+ b c))\n       (&lt; b (+ a c))\n       (&lt; c (+\
    \ a b))))\n</code>\nThe <code>?</code> is often used for predicate functions,\
    \ ie. functions that return either <code>#t</code> or <code>#f</code>.  (Yes,\
    \ that's <code>#t</code> and <code>#f</code>, not <code>true</code> and <code>false</code>.)\n",
  "  (and\n   (and (and (= (square a) (+ (square b) (square c))) \n             (=\
    \ (square b) (+ (square a) (square c))))\n        (and (= (square c) (+ (square\
    \ a) (square b))) \n             (= (square c) (+ (square a) (square b)))))\n\
    \   #t))\n", "  (cond\n    [(and (= a (sqrt (+ (* b b) (* c c)))) (= b (sqrt (+\
    \ (* a a) (* c c)))) (= c (sqrt (+ (* a a) (* b b))))) #t]\n    [else #f]))",
  "  (cond ((or (< a 1) (< b 1) (< c 1))\n         #f)\n        ((and (= (expt a 2)\
    \ (+ (expt b 2) (expt c 2)))\n              (= (expt b 2) (+ (expt a 2) (expt\
    \ c 2)))\n              (= (expt c 2) (+ (expt a 2) (expt b 2))))\n         #t)\n\
    \        (else\n         #f)))\n", "  (cond [(and (= a (sqrt (+ (* b b) (* c c))))\n\
    \            (= b (sqrt (+ (* a a) (* c c))))\n            (= c (sqrt (+ (* a\
    \ a) (* b b))))) #t]\n        [else #f]))\n", "  (or (and (= a (sqrt (+ (* b b)\
    \ (* c c))))\n           (= b (sqrt (+ (* a a) (* c c))))\n           (= c (sqrt\
    \ (+ (* a a) (* b b)))))\n      (and (= a (sqrt (+ (* b b) (* c c))))\n      \
    \     (= b (sqrt (+ (* a a) (* c c))))\n           (= c (sqrt (+ (* a a) (* b\
    \ b)))))\n      (and (= a (sqrt (+ (* b b) (* c c))))\n           (= b (sqrt (+\
    \ (* a a) (* c c))))\n           (= c (sqrt (+ (* a a) (* b b)))))))", "  (and\
    \ (or (= a (sqrt (+ (* b b) (* c c))))\n           (= b (sqrt (+ (* a a) (* c\
    \ c))))\n           (= c (sqrt (+ (* a a) (* b b)))))\n       (and (<= a b) (<=\
    \ b c))))\n", "  ;; helper for square of numbers\n  (define (sq n) (* n n))\n\
    \  ;; pythagorean theorem\n  (define (pyth a b c)\n    (if (and (>= a b) (>= a\
    \ c))\n        (= (+ (sq b) (sq c)) (sq a))\n        (if (and (>= b a) (>= b c))\n\
    \            (= (+ (sq a) (sq c)) (sq b))\n            (= (+ (sq a) (sq b)) (sq\
    \ c)))))\n  (pyth a b c))\n```\n\n**Programming Paradigms:**\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(and (= a (expt b 2)) (= b (expt c 2))) #t]\n    [(and\
    \ (= a (expt c 2)) (= c (expt b 2))) #t]\n    [(and (= b (expt a 2)) (= a (expt\
    \ c 2))) #t]\n    [(and (= b (expt c 2)) (= c (expt a 2))) #t]\n    [(and (= c\
    \ (expt a 2)) (= a (expt b 2))) #t]\n    [(and (= c (expt b 2)) (= b (expt a 2)))\
    \ #t]\n    [else #f]))\n", "  (cond\n    [(and (or (= a (sqrt (+ (* b b) (* c\
    \ c)))) (= b (sqrt (+ (* a a) (* c c)))) (= c (sqrt (+ (* a a) (* b b)))))\n \
    \     #t)]\n    [else #f]))\n", "  (let ([aa (square a)]\n        [bb (square\
    \ b)]\n        [cc (square c)])\n    (and (<= aa (+ bb cc))\n         (<= bb (+\
    \ aa cc))\n         (<= cc (+ aa bb)))))\n", "  (define (triangle-sort lst)\n\
    \    (sort lst (lambda (x y)\n                (if (< x y) #t #f))))\n  (define\
    \ (sum-of-squares lst)\n    (apply + (map (lambda (x) (* x x)) lst)))\n  (define\
    \ (max-square lst)\n    (car (reverse lst)))\n  (define (rst lst)\n    (map (lambda\
    \ (x) (* x x)) (cdr (reverse lst))))\n  (define (sum-of-pow-triple lst)\n    (apply\
    \ + (map (lambda (x) (* x x)) lst)))\n  (if (= (sum-of-pow-triple (triangle-sort\
    \ (list a b c)))\n           (sum-of-squares (triangle-sort (list a b c))))\n\
    \      #f\n      (= (max-square (triangle-sort (list a b c)))\n         (sum-of-pow-triple\
    \ (rst (triangle-sort (list a b c)))))))", "  (let ((max (apply max (list a b\
    \ c))))\n    (and (= max c)\n         (= (- a b (- max)) 0))))", "  (cond\n  \
    \  [(and (< a b) (< a c))\n     (= (sqr (+ (sqr (- b c)) (sqr (- a c)))) (sqr\
    \ (+ (sqr (- b a)) (sqr c))))]\n    [(and (< b a) (< b c))\n     (= (sqr (+ (sqr\
    \ (- a c)) (sqr (- b c)))) (sqr (+ (sqr (- a b)) (sqr c))))]\n    [(and (< c a)\
    \ (< c b))\n     (= (sqr (+ (sqr (- a b)) (sqr (- a c)))) (sqr (+ (sqr (- b a))\
    \ (sqr c))))]))\n ", "  (= c (exact-square-root (+ (exact-square a) (exact-square\
    \ b)))))\n", "  (and (>= a b c)\n       (= (+ (* a a) (* b b)) (* c c))))\n",
  "  (if (and (> a 0) (> b 0) (> c 0))\n      (if (or (= (square a) (+ (square b)\
    \ (square c)))\n              (= (square b) (+ (square a) (square c)))\n     \
    \         (= (square c) (+ (square a) (square b))))\n          #t\n          #f)\n\
    \      #f))\n", "  (and (> a 0) (> b 0) (> c 0)))\n", "  (and\n   (<= a b c)\n\
    \   (= (expt a 2)\n      (+ (expt b 2)\n         (expt c 2)))))\n", "  (let ([hyp\
    \ (max a b c)])\n    (and (= (max (abs (- hyp a)) (abs (- hyp b)) (abs (- hyp\
    \ c))) 0)\n         (= (+ a b c) (* 2 hyp)))))\n", "  (cond\n    ((and (= a (sqrt\
    \ (+ (* b b) (* c c))))\n          (= b (sqrt (+ (* a a) (* c c))))\n        \
    \  (= c (sqrt (+ (* a a) (* b b)))))\n     #t)\n    (else #f)))\n", "  (cond\n\
    \    [(or (< a 0) (< b 0) (< c 0)) #f]\n    [(and (= (+ (sqr a) (sqr b)) (sqr\
    \ c))\n          (= (+ (sqr a) (sqr c)) (sqr b))\n          (= (+ (sqr b) (sqr\
    \ c)) (sqr a))) #t]\n    [else #f]))\n", "  (or (and (= (+ (expt a 2) (expt b\
    \ 2)) (expt c 2)) #t)\n      (and (= (+ (expt a 2) (expt c 2)) (expt b 2)) #t)\n\
    \      (and (= (+ (expt b 2) (expt c 2)) (expt a 2)) #t)))\n", "  (= 90 (angle\
    \ a b c)))\n", "  ;;;; YOUR CODE GOES HERE\n  )\n```\n\n## Problem 2\n\n```\n\
    #lang racket\n", "  (if (and (= a b) (= b c))\n      #f\n      (if (or (and (>=\
    \ (+ a b) c)\n                   (>= (+ b c) a)\n                   (>= (+ c a)\
    \ b))\n              (and (>= (+ a b) c)\n                   (>= (+ b c) a)\n\
    \                   (>= (+ c a) b)))\n          #t\n          #f)))\n", "  (define\
    \ (sqr n) (* n n))\n  (define (max2 a b)\n    (if (&gt; a b) a b))\n  (define\
    \ (max3 a b c)\n    (max2 (max2 a b) c))\n  (define (pythagorean a b c)\n    (cond\
    \ ((eq? a (max3 a b c)) (= (sqr a) (+ (sqr b) (sqr c))))\n          ((eq? b (max3\
    \ a b c)) (= (sqr b) (+ (sqr a) (sqr c))))\n          ((eq? c (max3 a b c)) (=\
    \ (sqr c) (+ (sqr a) (sqr b))))))\n  (pythagorean a b c))\n", "  (and (not (<\
    \ a 0))\n       (not (< b 0))\n       (not (< c 0))\n       (and (< (+ a b) c)\n\
    \            (< (+ b c) a)\n            (< (+ a c) b)))\n  (and (and (< (+ a b)\
    \ c)\n            (< (+ b c) a)\n            (< (+ a c) b))\n       (or (= (sqr\
    \ a) (+ (sqr b) (sqr c)))\n           (= (sqr b) (+ (sqr a) (sqr c)))\n      \
    \     (= (sqr c) (+ (sqr a) (sqr b)))))\n", "  (begin\n    (display a)\n    (display\
    \ b)\n    (display c)\n    (display (sqrt (+ (* a a) (* b b))))\n    (display\
    \ (= c (sqrt (+ (* a a) (* b b)))))\n    (display (sqrt (+ (* a a) (* c c))))\n\
    \    (display (= b (sqrt (+ (* a a) (* c c)))))\n    (display (sqrt (+ (* b b)\
    \ (* c c))))\n    (display (= a (sqrt (+ (* b b) (* c c)))))\n    (or (= c (sqrt\
    \ (+ (* a a) (* b b))))\n        (= b (sqrt (+ (* a a) (* c c))))\n        (=\
    \ a (sqrt (+ (* b b) (* c c)))))))\n", "  (cond\n    [(or (= a (* b b)) (= b (*\
    \ a a)) (= c (* a a))) #t]\n    [else #f]))\n", "  (equal? (sqrt (+ (* a a) (*\
    \ b b))) c))\n</code>\n", "  (cond\n    [(and (= (sqr a) (+ (sqr b) (sqr c)))\
    \ (> a 0) (> b 0) (> c 0)) #t]\n    [else #f]))\n", "  (and (<= a b c)\n     \
    \  (or (and (<= a (* b b)) (<= b (* c c)))\n           (and (<= b (* a a)) (<=\
    \ a (* c c)))\n           (and (<= c (* a a)) (<= a (* b b)))))\n", "  (and (and\
    \ (<= a b) (<= b c)) \n       (= (+ (* a a) (* b b)) (* c c))))\n", "  (letrec\n\
    \      ((fn (lambda (a b c)\n             (or\n              (and (= a (sqrt (+\
    \ (* b b) (* c c))))\n                   #t)\n              (and (= b (sqrt (+\
    \ (* a a) (* c c))))\n                   #t)\n              (and (= c (sqrt (+\
    \ (* a a) (* b b))))\n                   #t)\n              #f))))\n    (fn a\
    \ b c)))\n", "  (and (> a 0)\n       (> b 0)\n       (> c 0)\n       (= (or (=\
    \ (pow a 2) (+ (pow b 2) (pow c 2)))\n              (= (pow b 2) (+ (pow a 2)\
    \ (pow c 2)))\n              (= (pow c 2) (+ (pow a 2) (pow b 2))))\n        \
    \  #t)))\n", "  (and (> a 0) (> b 0) (> c 0)\n       (or (= (square a) (+ (square\
    \ b) (square c)))\n           (= (square b) (+ (square a) (square c)))\n     \
    \      (= (square c) (+ (square a) (square b))))))\n", "  (define (sq x) (* x\
    \ x))\n  (let ([max (max a b c)]\n        [rest (cons (if (equal? a max) b c)\
    \ (if (equal? a max) c b))])\n    (and (and (and (and (&lt; a 0) (&lt; b 0) (&lt;\
    \ c 0))\n                    (&lt; (+ (car rest) (cadr rest)) max))\n        \
    \       (&lt;= a (+ (car rest) (cadr rest))))\n          (= (sq max) (+ (sq (car\
    \ rest)) (sq (cadr rest)))))))\n</code>\n", "  (define (pythagoras a b)\n    (sqrt\
    \ (+ (* a a) (* b b))))\n  (and (and (and (<= a b) (<= b c)) (< c (+ a b))) \n\
    \       (or (or (= (pythagoras a b) c) (= (pythagoras a c) b)) (= (pythagoras\
    \ b c) a))))", "  ;; If sides are less than or equal to 0, a triangle can't be\
    \ formed\n  (if (<= a 0)\n      #f\n      ;; If side1 is hypotenuse then side1^2\
    \ = side2^2 + side3^2\n      (if (= (square a) (+ (square b) (square c)))\n  \
    \        #t\n          ;; If side2 is hypotenuse then side2^2 = side1^2 + side3^2\n\
    \          (if (= (square b) (+ (square a) (square c)))\n              #t\n  \
    \            ;; If side3 is hypotenuse then side3^2 = side1^2 + side2^2\n    \
    \          (if (= (square c) (+ (square a) (square b)))\n                  #t\n\
    \                  #f))))))\n", "  (and (cond [(= (+ (expt a 2) (expt b 2)) (expt\
    \ c 2)) #t]\n              [(= (+ (expt a 2) (expt c 2)) (expt b 2)) #t]\n   \
    \           [(= (+ (expt b 2) (expt c 2)) (expt a 2)) #t]\n              [else\
    \ #f])\n       (and (<= a b) (<= b c))))", "  (and (<= a c) (<= b c) \n      \
    \ (<= c (+ a b))\n       (<= (sqr c) (+ (sqr a) (sqr b)))))\n", "  (= 90 (angle\
    \ a b c)))\n", "  (and (<= a b c)\n       (or (= (expt a 2) (+ (expt b 2) (expt\
    \ c 2)))\n           (= (expt b 2) (+ (expt a 2) (expt c 2)))\n           (= (expt\
    \ c 2) (+ (expt a 2) (expt b 2))))))\n", "  (and (= (expt a 2) (+ (expt b 2) (expt\
    \ c 2))) #t))\n", "  (cond [(= (expt a 2) (+ (expt b 2) (expt c 2))) #t]\n   \
    \     [else #f]))\n", "  (if (and (<= a c) (<= b c))\n      (if (and (<= a b)\
    \ (<= b a))\n          (if (and (<= c (+ a b)) (>= c (- a b)))\n             \
    \ (if (and (<= c (- a b)) (>= c (+ a b)))\n                  #t\n            \
    \      #f)\n              #f)\n          #f)\n      #f))\n", "  (and (and (<=\
    \ a b) (<= b c))\n       (= (expt (+ (expt a 2) (expt b 2)) 0.5) c)))", "  (and\n\
    \   (and (<= 1 a) (<= a 100))\n   (and (<= 1 b) (<= b 100))\n   (and (<= 1 c)\
    \ (<= c 100))\n   (= 3 (+ (expt a 2) (expt b 2) (expt c 2)))\n   )\n  )\n", " \
    \ (if (and (= (square a) (+ (square b) (square c)))\n           (= (square b)\
    \ (+ (square a) (square c)))\n           (= (square c) (+ (square a) (square b))))\n\
    \      #t\n      #f))\n", "  (or (= a (sqrt (+ (* b b) (* c c))))\n      (= b\
    \ (sqrt (+ (* a a) (* c c))))\n      (= c (sqrt (+ (* a a) (* b b))))))", "  (cond\n\
    \    [(or\n      (= a (sqrt (+ (* b b) (* c c))))\n      (= b (sqrt (+ (* a a)\
    \ (* c c))))\n      (= c (sqrt (+ (* a a) (* b b)))))\n      #t]\n    [else #f]))\n",
  "  (define (to-the-power n)\n    (lambda (x) (expt x n)))\n  (define (square x)\
    \ (to-the-power 2 x))\n  (define (cube x) (to-the-power 3 x))\n  (define (greatest\
    \ x y z)\n    (cond ((> x y) (greatest x z))\n          ((> y z) y)\n        \
    \  (else z)))\n  (define (sum-of-squares x y z)\n    (+ (square x) (square y)\
    \ (square z)))\n  (define (sum-of-cubes x y z)\n    (+ (cube x) (cube y) (cube\
    \ z)))\n  (and (> a 0) (> b 0) (> c 0)\n       (= (greatest a b c) c)\n      \
    \ (= (sum-of-squares a b c) (sum-of-cubes a b c))))\n", "  (and (> a 0)\n    \
    \   (> b 0)\n       (> c 0)\n       (and (or (and (= a (sqrt (+ (* b b) (* c c))))\n\
    \                       )\n                  (and (= b (sqrt (+ (* a a) (* c c))))\n\
    \                       )\n                  (and (= c (sqrt (+ (* a a) (* b b))))\n\
    \                       )\n                  )\n            )\n       )\n  )\n",
  "  (let ([hypotenuse (list-ref (sort (list a b c) >) 0)])\n    (and (= (expt a 2)\
    \ (+ (expt b 2) (expt c 2)))\n         (exact? hypotenuse))))\n", "  (cond ((and\
    \ (= (pow a 2) (+ (pow b 2) (pow c 2))) (> a b c)) #t)\n        ((and (= (pow\
    \ b 2) (+ (pow a 2) (pow c 2))) (> b a c)) #t)\n        ((and (= (pow c 2) (+\
    \ (pow a 2) (pow b 2))) (> c a b)) #t)\n        (else #f)))", "  (cond\n    [(>=\
    \ a (+ b c)) #f]\n    [(>= b (+ a c)) #f]\n    [(>= c (+ a b)) #f]\n    [else\
    \ #t]))\n", "  (let ((hypo (max a b c))\n        (adj1 (min a b c))\n        (adj2\
    \ (if (and (= a (max a b c))\n                       (= b (min a b c)))\n    \
    \              c\n                  b)))\n    (= (square hypo) (+ (square adj1)\
    \ (square adj2)))))\n", "  (cond\n    [(< a 0) #f]\n    [(< b 0) #f]\n    [(<\
    \ c 0) #f]\n    [(<= a (+ b c)) #f]\n    [(<= b (+ a c)) #f]\n    [(<= c (+ a\
    \ b)) #f]\n    [else (= (expt a 2) (+ (expt b 2) (expt c 2)))]))\n```\n\n```racket\n\
    #lang racket\n", "  (and (> a 0) (> b 0) (> c 0)\n       (or (and (= a (sqrt (+\
    \ (* b b) (* c c))))\n                (= b (sqrt (+ (* a a) (* c c))))\n     \
    \           (= c (sqrt (+ (* a a) (* b b)))))\n           (and (= b (sqrt (+ (*\
    \ a a) (* c c))))\n                (= a (sqrt (+ (* b b) (* c c))))\n        \
    \        (= c (sqrt (+ (* a a) (* b b)))))\n           (and (= c (sqrt (+ (* a\
    \ a) (* b b))))\n                (= a (sqrt (+ (* b b) (* c c))))\n          \
    \      (= b (sqrt (+ (* a a) (* c c))))))))\n```\n\n```racket\n#lang racket\n",
  "  (and (= a (sqrt (+ (* b b) (* c c))))\n       (or (= b (sqrt (+ (* a a) (* c\
    \ c))))\n           (= c (sqrt (+ (* a a) (* b b)))))))", "  (cond\n    ((and\
    \ (= (expt a 2) (+ (expt b 2) (expt c 2)))\n          (or (= (expt b 2) (+ (expt\
    \ a 2) (expt c 2)))\n              (= (expt c 2) (+ (expt a 2) (expt b 2)))))\n\
    \     #t)\n    (else #f)))", "  (cond\n    [(and (= (square a) (+ (square b) (square\
    \ c)))\n          (= (square b) (+ (square a) (square c)))\n          (= (square\
    \ c) (+ (square a) (square b)))) #t]\n    [else #f]))\n```\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(not (number? a)) (error \"side a should be a number!\"\
    )]\n    [(not (number? b)) (error \"side b should be a number!\")]\n    [(not\
    \ (number? c)) (error \"side c should be a number!\")]\n    [(not (> a 0)) (error\
    \ \"side a should be positive!\")]\n    [(not (> b 0)) (error \"side b should\
    \ be positive!\")]\n    [(not (> c 0)) (error \"side c should be positive!\")]\n\
    \    [else\n     (define (square a) (* a a))\n     (define (sum a b) (+ a b))\n\
    \     (define (sub a b) (- a b))\n     (define (abs a) (if (< a 0) (- a) a))\n\
    \     (define (max a b) (if (> a b) a b))\n     (define (min a b) (if (< a b)\
    \ a b))\n     (define (pythagorean? a b c)\n       (define (equal? a b c)\n  \
    \       (and (equal? a (square b)) (equal? a (square c))))\n       (and (equal?\
    \ a (sum (square b) (square c)))\n            (equal? b (sum (square a) (square\
    \ c)))\n            (equal? c (sum (square a) (square b)))))\n     (or (pythagorean?\
    \ a b c)\n         (pythagorean? a c b)\n         (pythagorean? b a c)\n     \
    \    (pythagorean? b c a)\n         (pythagorean? c a b)\n         (pythagorean?\
    \ c b a))]))\n", "  (if (and (<= a b c)\n           (<= b c a)\n           (<=\
    \ c a b))\n      (or (and (= (+ (* a a) (* b b)) (* c c))\n               (= b\
    \ c))\n          (and (= (+ (* a a) (* c c)) (* b b))\n               (= c b))\n\
    \          (and (= (+ (* b b) (* c c)) (* a a))\n               (= c a)))\n  \
    \    #f))", "  (define (is_right-angle a b c)\n    (eq? (sqrt (+ (square a) (square\
    \ b))) c))\n  (cond\n    [(or (is_right-angle a b c) (is_right-angle a c b) (is_right-angle\
    \ b c a)) #t]\n    [else #f]))", "  ;; check if given arguments are numbers\n\
    \  (cond ((not (number? a)) (error \"a should be a number\"))\n        ((not (number?\
    \ b)) (error \"b should be a number\"))\n        ((not (number? c)) (error \"\
    c should be a number\")))\n  ;; check if given arguments are positive\n  (cond\
    \ ((< a 0) (error \"a should be positive\"))\n        ((< b 0) (error \"b should\
    \ be positive\"))\n        ((< c 0) (error \"c should be positive\")))\n  ;; check\
    \ if given arguments are integers\n  (cond ((not (integer? a)) (error \"a should\
    \ be integer\"))\n        ((not (integer? b)) (error \"b should be integer\"))\n\
    \        ((not (integer? c)) (error \"c should be integer\")))\n  ;; check if\
    \ given arguments are triangle\n  (cond ((not (integer? a)) (error \"a should\
    \ be integer\"))\n        ((not (integer? b)) (error \"b should be integer\"))\n\
    \        ((not (integer? c)) (error \"c should be integer\")))\n  (cond ((>= (+\
    \ a b) c) (error \"arguments are not triangle\"))\n        ((>= (+ a c) b) (error\
    \ \"arguments are not triangle\"))\n        ((>= (+ b c) a) (error \"arguments\
    \ are not triangle\")))\n  ;; main\n  (cond ((= (sqrt (+ (* a a) (* b b))) c)\
    \ #t)\n        ((= (sqrt (+ (* a a) (* c c))) b) #t)\n        ((= (sqrt (+ (*\
    \ b b) (* c c))) a) #t)\n        (else #f)))\n", "  (and (> a 0) (> b 0) (> c\
    \ 0)\n       (> a b) (> a c) (> (square a) (+ (square b) (square c)))\n      \
    \ (< a b) (< a c) (< (square a) (+ (square b) (square c)))))\n", "  (or\n   (and\
    \ (= (expt a 2) (+ (expt b 2) (expt c 2))) (= b c))\n   (and (= (expt b 2) (+\
    \ (expt a 2) (expt c 2))) (= a c))\n   (and (= (expt c 2) (+ (expt a 2) (expt\
    \ b 2))) (= a b))))\n", "  (and (= (apply max (list a b c)) c)\n       (<= (+\
    \ a b) c)))\n", "  (cond\n    ((or (< a b) (< a c))\n     (right_angle_triangle\
    \ b a c))\n    ((or (< b c) (< b a))\n     (right_angle_triangle c b a))\n   \
    \ ((and (= a b) (= b c))\n     #f)\n    ((and (= a b) (= (expt a 2) (+ (expt b\
    \ 2) (expt c 2))))\n     #t)\n    ((and (= a b) (= (expt a 2) (+ (expt b 2) (expt\
    \ c 2))))\n     #t)\n    ((= (+ (expt a 2) (expt b 2)) (expt c 2))\n     #t)\n\
    \    (else\n     #f)))\n```\n\n### Question 23\n\n```scheme\n#lang racket\n",
  '  (equal? (sqrt (+ (* a a) (* b b))) c))', "  (or (= (+ (square a) (square b))\
    \ (square c))\n      (= (+ (square a) (square c)) (square b))\n      (= (+ (square\
    \ b) (square c)) (square a))))", "  (if (and (&lt;= a c) (&lt;= b c))\n      (if\
    \ (= (+ (* a a) (* b b)) (* c c))\n          #t\n          #f)\n      #f))\n",
  "  ; [code here]\n  )\n", "  (define s-pyth-identity\n    (lambda (a b c)\n    \
    \  (and (or (= (expt a 2) (+ (expt b 2) (expt c 2)))\n               (= (expt\
    \ b 2) (+ (expt a 2) (expt c 2)))\n               (= (expt c 2) (+ (expt a 2)\
    \ (expt b 2))))\n           #t)))\n  (define s-harsh-identity\n    (lambda (a\
    \ b c)\n      (or (= (* a a) (+ (* b b) (* c c)))\n          (= (* b b) (+ (*\
    \ a a) (* c c)))\n          (= (* c c) (+ (* a a) (* b b))))))\n  (define s-compare-sides\n\
    \    (lambda (a b c)\n      (and (not (= a b))\n           (not (= b c))\n   \
    \        (not (= a c)))))\n  (define (s-sort-sides a b c)\n    (cond ((and (>=\
    \ a b) (>= b c)) (list a b c))\n          ((and (>= a c) (>= c b)) (list a c b))\n\
    \          ((and (>= b a) (>= a c)) (list b a c))\n          ((and (>= b c) (>=\
    \ c a)) (list b c a))\n          ((and (>= c a) (>= a b)) (list c a b))\n    \
    \      ((and (>= c b) (>= b a)) (list c b a))))\n  (define s-check-hypotenuse\n\
    \    (lambda (a b c)\n      (and (>= c a)\n           (>= c b))))\n  (define (s-triangle-hypotenuse\
    \ a b c)\n    (and (s-check-hypotenuse a b c)\n         (s-pyth-identity a b c)))\n\
    \  (define (s-triangle-other-sides a b c)\n    (and (not (s-check-hypotenuse a\
    \ b c))\n         (s-pyth-identity a b c)))\n  (define (s-right-angle-triangle\
    \ a b c)\n    (cond ((s-tri", "  (cond\n    [(= (square a) (+ (square b) (square\
    \ c))) #t]\n    [(= (square b) (+ (square a) (square c))) #t]\n    [(= (square\
    \ c) (+ (square a) (square b))) #t]\n    [else #f]))\n", "  (define (max_side\
    \ a b c)\n    (cond ((> a b) (if (> a c) a c))\n          ((> b c) b)\n      \
    \    (else c)))\n  (define (sum a b c)\n    (+ a b c))\n  (define (hypotenuse\
    \ a b c)\n    (max_side a b c))\n  (define (sum_of_other_two a b c)\n    (- (sum\
    \ a b c) (hypotenuse a b c)))\n  (define (square a)\n    (* a a))\n  (= (square\
    \ (hypotenuse a b c)) (+ (square (sum_of_other_two a b c)))))\n", "  (and\n  \
    \ (= (expt a 2)\n      (+ (expt b 2)\n         (expt c 2)))\n   (or (and (= a\
    \ b)\n            (= b c))\n       (and (= b c)\n            (= a c))\n      \
    \ (and (= a b)\n            (= c a)))))\n", "  (and (triangle a b c) (or (eq?\
    \ 90 (angle a b c))\n                            (eq? 90 (angle b c a))\n    \
    \                        (eq? 90 (angle c a b)))))\n", "  (and (> a 0) (> b 0)\
    \ (> c 0)\n       (or (= (pow a 2) (+ (pow b 2) (pow c 2)))\n           (= (pow\
    \ b 2) (+ (pow a 2) (pow c 2)))\n           (= (pow c 2) (+ (pow a 2) (pow b 2))))))\n",
  "  (and (positive? a) (positive? b) (positive? c)\n       (or (and (<= a b) (<=\
    \ a c) (< (+ a b) c))\n           (and (<= b a) (<= b c) (< (+ b a) c))\n    \
    \       (and (<= c a) (<= c b) (< (+ c a) b)))))\n", "  (cond ((= (sqrt (+ (*\
    \ a a) (* b b))) c) #t)\n        ((= (sqrt (+ (* a a) (* c c))) b) #t)\n     \
    \   ((= (sqrt (+ (* b b) (* c c))) a) #t)\n        (else #f)))\n```\n\n## Question\
    \ 17\n```#lang racket\n", "  (let ((max (apply max (list a b c))))\n    (and (<\
    \ max (apply + (list a b c)))\n         (= (+ (expt (- (apply + (list a b c))\
    \ max) 2)\n                (expt max 2))\n            (expt (apply + (list a b\
    \ c)) 2)))))\n", "  (cond\n    [(and (>= a 0) (>= b 0) (>= c 0)) (and (= (+ (*\
    \ a a) (* b b)) (* c c)) (= 90 (right_angle_triangle_get_angle a b c)))]\n   \
    \ [else (error \"Not a triangle!\")]))\n", "  (let ((a-squared (* a a))\n    \
    \    (b-squared (* b b))\n        (c-squared (* c c)))\n    (cond ((= a-squared\
    \ (+ b-squared c-squared)) #t)\n          ((= b-squared (+ a-squared c-squared))\
    \ #t)\n          ((= c-squared (+ a-squared b-squared)) #t)\n          (else #f))))\n",
  "  (begin\n    (define c2 (+ (* a a) (* b b)))\n    (define c0 (sqrt c2))\n    (if\
    \ (= c0 c) #t #f)))\n</code>\nHere is the code for it in Python:\n<code>import\
    \ math\n\ndef right_angle_triangle(a, b, c):\n    c2 = a*a + b*b\n    c0 = math.sqrt(c2)\n\
    \    if c0 == c:\n        return True\n    else:\n        return False\n</code>\n\
    I wonder what is wrong with my code and why the Python code runs faster than the\
    \ Racket code.\n\n\nA:\n\nThe Python code is comparing floating point numbers.\
    \  The Racket code is comparing exact numbers.  The Python code is going to be\
    \ faster because of this.\nThe floating point comparison is going to be faster\
    \ because the numbers can be used as-is.  The exact comparison is going to take\
    \ a lot longer because it has to find the true exact values for c0 and c.  It\
    \ will then have to check the actual exact values for equality.  This is a lot\
    \ more work than just checking if two floats are equal.\n", "  (let ([hyp (sqrt\
    \ (+ (* a a) (* b b)))])\n    (= c hyp)))\n</code>\n<code>#lang racket\n", " \
    \ (and (and (< a b) (< a c))\n       (or (and (= (+ (* a a) (* b b)) (* c c))\
    \ #t)\n           (and (= (+ (* a a) (* c c)) (* b b)) #t)\n           (and (=\
    \ (+ (* b b) (* c c)) (* a a)) #t))))\n```\n\n```scheme\n#lang racket\n", "  (cond\n\
    \    [(>= (max a b c) (+ (min a b) (min b c))) #f]\n    [(> (max a b c) (- (min\
    \ a b) (min b c))) #f]\n    [else #t]))\n", "  (define (square x) (* x x))\n \
    \ (define (max a b) (if (> a b) a b))\n  (define (middle a b c)\n    (cond\n \
    \     ((and (< a b) (< b c)) b)\n      ((and (< b a) (< a c)) a)\n      ((and\
    \ (< c a) (< a b)) a)\n      ((and (< a c) (< c b)) c)\n      ((and (< b c) (<\
    \ c a)) c)\n      ((and (< c b) (< b a)) b)))\n  (define (min a b) (if (< a b)\
    \ a b))\n  (define (hypotenuse a b) (max a b))\n  (define (cathetus1 a b) (middle\
    \ a b (min a b)))\n  (define (cathetus2 a b) (min a b))\n  (define (is_right_angle?\
    \ a b c)\n    (= (square c) (+ (square a) (square b))))\n  (is_right_angle? (cathetus1\
    \ a b) (cathetus2 a b) (hypotenuse a b)))\n", "  (or\n   (and (< a b) (< b c)\
    \ (< (+ (* a a) (* b b)) (* c c)))\n   (and (< a c) (< c b) (< (+ (* a a) (* c\
    \ c)) (* b b)))\n   (and (< b a) (< a c) (< (+ (* b b) (* a a)) (* c c)))\n  \
    \ (and (< b c) (< c a) (< (+ (* b b) (* c c)) (* a a)))\n   (and (< c a) (< a\
    \ b) (< (+ (* c c) (* a a)) (* b b)))\n   (and (< c b) (< b a) (< (+ (* c c) (*\
    \ b b)) (* a a)))))\n", "  (cond ((> (+ a b) c) #t)\n        ((> (+ a c) b) #t)\n\
    \        ((> (+ b c) a) #t)\n        (else #f)))\n", "  (if (and (>= a 0) (>=\
    \ b 0) (>= c 0))\n      (or (and (= (square a) (+ (square b) (square c)))\n  \
    \             (= a b))\n          (and (= (square b) (+ (square a) (square c)))\n\
    \               (= b c))\n          (and (= (square c) (+ (square a) (square b)))\n\
    \               (= a c)))\n      (error \"One of the input is negative\")))\n",
  "  (and (>= a b c)\n       (or (= (sqr a) (+ (sqr b) (sqr c)))\n           (= (sqr\
    \ b) (+ (sqr a) (sqr c)))\n           (= (sqr c) (+ (sqr a) (sqr b)))))\n  )\n",
  "  ;; Use the Pythagorean theorem to calculate the remaining sides\n  (and (and\
    \ (>= a 0) (>= b 0) (>= c 0))\n       (= (+ (* a a) (* b b)) (* c c))))\n", " \
    \ (cond\n    [(and (= (expt (+ (expt a 2) (expt b 2)) 0.5) c)\n          (= (expt\
    \ (+ (expt b 2) (expt c 2)) 0.5) a)\n          (= (expt (+ (expt a 2) (expt c\
    \ 2)) 0.5) b))\n     #t]\n    [else #f]))\n", "  ;; 1. Find the largest side,\
    \ which we call x\n  ;; 2. Find the remaining sides and call them y and z\n  ;;\
    \ 3. If y^2 + z^2 = x^2, then it's a right triangle\n  (define largest\n    (if\
    \ (> a b)\n        (if (> a c)\n            a\n            c)\n        (if (>\
    \ b c)\n            b\n            c)))\n  (define smallest\n    (if (< a b)\n\
    \        (if (< a c)\n            a\n            c)\n        (if (< b c)\n   \
    \         b\n            c)))\n  (define middle\n    (if (and (> a b) (< a c))\n\
    \        a\n        (if (and (> b a) (< b c))\n            b\n            c)))\n\
    \  (equal? (+ (sqr middle) (sqr smallest)) (sqr largest)))\n", "  (cond\n    [(>\
    \ a b) (right_angle_triangle b a c)]\n    [(> a c) (right_angle_triangle c a b)]\n\
    \    [(= a (sqrt (+ (* b b) (* c c)))) #t]\n    [else #f]))\n", "    (=\n    \
    \    (pow c 2)\n        (+\n            (pow a 2)\n            (pow b 2)\n   \
    \     )\n    )\n)\n", '  (= (sort (list a b c) <) (list (sqrt (+ (* a a) (* b
    b))) (sqrt (+ (* a a) (* c c))) (sqrt (+ (* b b) (* c c))))))', "  (or (and (<=\
    \ a b) (<= a c) (<= b c) (<= (+ (* a a) (* b b)) (* c c)))\n      (and (<= a b)\
    \ (<= a c) (<= b c) (<= (+ (* a a) (* c c)) (* b b)))\n      (and (<= a b) (<=\
    \ a c) (<= b c) (<= (+ (* b b) (* c c)) (* a a)))))\n", "  (or (= (expt a 2) (+\
    \ (expt b 2) (expt c 2)))\n      (= (expt b 2) (+ (expt a 2) (expt c 2)))\n  \
    \    (= (expt c 2) (+ (expt a 2) (expt b 2)))))", "  (= 90\n     (exact->inexact\n\
    \      (inexact->exact (acos (/ (* (- b c) b) (* 2 a (- b c))))))))\n", "  (cond\n\
    \    [(= a 0) #f]\n    [(= b 0) #f]\n    [(= c 0) #f]\n    [(= a b) #f]\n    [(=\
    \ a c) #f]\n    [(= b c) #f]\n    [(< a (+ b c)) #f]\n    [(< b (+ a c)) #f]\n\
    \    [(< c (+ a b)) #f]\n    [else (and (= (^ a 2) (+ (^ b 2) (^ c 2)))\n    \
    \           (= (^ b 2) (+ (^ a 2) (^ c 2)))\n               (= (^ c 2) (+ (^ a\
    \ 2) (^ b 2))))]))\n", "  (if (and (positive? a) (positive? b) (positive? c))\n\
    \      (let ([g (* (- (expt a 2) (expt b 2) (expt c 2)) 0.5)])\n        (if (=\
    \ g (round g))\n            #t\n            #f))\n      #f))\n", "  (define (square\
    \ n) (* n n))\n  (define (is-right-angle? a b c)\n    (and (= a (sqrt (+ (square\
    \ b) (square c))))\n         (= b (sqrt (+ (square a) (square c))))\n        \
    \ (= c (sqrt (+ (square a) (square b))))))\n  (is-right-angle? a b c))\n", " \
    \ (cond\n    [(and (>= a 0) (>= b 0) (>= c 0)) (equal? (sqrt (+ (* a a) (* b b)))\
    \ c)]\n    [else #f]))\n```\n\n```scheme\n#lang racket\n", "  (define (is_right_angle\
    \ a b c)\n    (cond ((= (expt a 2) (+ (expt b 2) (expt c 2)))\n           #t)\n\
    \          ((= (expt b 2) (+ (expt a 2) (expt c 2)))\n           #t)\n       \
    \   ((= (expt c 2) (+ (expt a 2) (expt b 2)))\n           #t)\n          (else\
    \ #f)))\n  (define (sorted a b c)\n    (cond ((and (<= a b) (<= b c))\n      \
    \     (list a b c))\n          ((and (<= a c) (<= c b))\n           (list a c\
    \ b))\n          ((and (<= b a) (<= a c))\n           (list b a c))\n        \
    \  ((and (<= b c) (<= c a))\n           (list b c a))\n          ((and (<= c a)\
    \ (<= a b))\n           (list c a b))\n          ((and (<= c b) (<= b a))\n  \
    \         (list c b a))))\n  (apply is_right_angle (sorted a b c)))\n", "  (and\
    \ (and (&lt;= a b) (&lt;= b c))\n       (= (sqrt (+ (* a a) (* b b))) c)))\n</code>\n\
    3rd solution:\n<code>#lang racket\n", "  (let ([diff3 (- (* a a) (- (* b b) (*\
    \ c c)))])\n    (or (and (eqv? diff3 0) (>= a b))\n        (and (eqv? diff3 0)\
    \ (>= b a)))))\n", "  (letrec ([triple-of (lambda (x y z)\n                  \
    \      (and (= (+ x y) z)\n                             (= (+ x z) y)\n      \
    \                       (= (+ y z) x)))])\n    (triple-of a b c)))\n", "  (or\
    \ (= (square a) (+ (square b) (square c)))\n      (= (square b) (+ (square a)\
    \ (square c)))\n      (= (square c) (+ (square a) (square b)))))\n", "  (cond\n\
    \    [(and (= 90 (angle a b c))\n          (and (and (or (= a b) (= a c) (= b\
    \ c)) (= a b c))\n               (or (= a b) (= a c) (= b c)))) #t]\n    [else\
    \ #f]))\n", "  (or (= 90 (triangle_angle a b c))\n      (= 90 (triangle_angle\
    \ b c a))\n      (= 90 (triangle_angle c a b))))\n", "  (cond ((or (<= a 0) (<=\
    \ b 0) (<= c 0)) #f)\n        ((and (= a (expt (+ (expt b 2) (expt c 2)) 0.5))\n\
    \              (= b (expt (+ (expt a 2) (expt c 2)) 0.5))\n              (= c\
    \ (expt (+ (expt a 2) (expt b 2)) 0.5))) #t)\n        (else #f)))", "  (and (>=\
    \ a b c)\n       (= (+ (* a a) (* b b)) (* c c))))\n", "  (cond ((= a (sqrt (+\
    \ (* b b) (* c c)))) #t)\n        ((= b (sqrt (+ (* a a) (* c c)))) #t)\n    \
    \    ((= c (sqrt (+ (* a a) (* b b)))) #t)\n        (else #f)))\n", "  (and (<=\
    \ a b c)\n       (<= (* a a) (+ (* b b) (* c c)))\n       (<= (* b b) (+ (* a\
    \ a) (* c c)))\n       (<= (* c c) (+ (* a a) (* b b)))))", "  (let* ((ab (sqr\
    \ a b)) (bc (sqr b c)) (ac (sqr a c)))\n    (or (= ac (+ ab bc)) (= ab (+ bc ac))\
    \ (= bc (+ ab ac)))))\n", "  (define (pow x n)\n    (if (= n 0)\n        1\n \
    \       (* x (pow x (- n 1)))))\n  (if (= (+ (pow a 2) (pow b 2)) (pow c 2))\n\
    \      #t\n      #f))\n", "  (let ((angle-b (/ (* b b) (+ (* a a) (* c c))))\n\
    \        (angle-c (/ (* c c) (+ (* a a) (* b b)))))\n    (or (equal? angle-b (sqrt\
    \ 2))\n        (equal? angle-c (sqrt 2)))))\n", "  (or (and (= (sqr a) (+ (sqr\
    \ b) (sqr c)))\n           (and (> b c) (> a c)))\n      (and (= (sqr b) (+ (sqr\
    \ a) (sqr c)))\n           (and (> a c) (> b c)))\n      (and (= (sqr c) (+ (sqr\
    \ a) (sqr b)))\n           (and (> a b) (> c b)))))\n", "  (define (square x)\
    \ (* x x))\n  (and (and (<= a b) (<= b c))\n       (= (+ (square a) (square b))\
    \ (square c))))\n", "  (or (= (expt a 2) (+ (expt b 2) (expt c 2)))\n      (=\
    \ (expt b 2) (+ (expt a 2) (expt c 2)))\n      (= (expt c 2) (+ (expt a 2) (expt\
    \ b 2)))))", "  ; Is angle A 90 degrees?\n  (and (>= a b c)\n       (= (sqrt (+\
    \ (* a a) (* b b))) c))\n  ; Is angle B 90 degrees?\n  (and (>= b a c)\n     \
    \  (= (sqrt (+ (* b b) (* a a))) c))\n  ; Is angle C 90 degrees?\n  (and (>= c\
    \ a b)\n       (= (sqrt (+ (* c c) (* a a))) b)))\n", "  (define (right-angle?\
    \ a b c)\n    (= (* a a) (+ (* b b) (* c c))))\n  (and (> a 0) (> b 0) (> c 0)\n\
    \       (or (right-angle? a b c)\n           (right-angle? b c a)\n          \
    \ (right-angle? c a b))))\n```\n\n```racket\n#lang racket\n", "  (or (and (= (*\
    \ a a) (+ (* b b) (* c c)))\n           (or (= (* b b) (+ (* a a) (* c c)))\n\
    \               (= (* c c) (+ (* a a) (* b b)))))\n      #f))\n", "  (= (+ (*\
    \ a a) (* b b)) (* c c)))\n", "  (or (and (= a (* c c)) (= b (* c c)))\n     \
    \ (and (= b (* c c)) (= a (* c c)))\n      (and (= a (* b b)) (= c (* b b)))\n\
    \      (and (= b (* a a)) (= c (* a a)))\n      (and (= c (* a a)) (= b (* a a)))))",
  "  (equal? (and (> a 0) (> b 0) (> c 0))\n           (and (< (+ a b) c) (< (+ a\
    \ c) b) (< (+ b c) a))))\n", "  (and (and (< a (+ b c))\n            (< b (+ a\
    \ c))\n            (< c (+ a b)))\n       (= (expt a 2) (+ (expt b 2) (expt c\
    \ 2)))))\n", "  (cond\n    [(or (= a b) (= b c) (= a c)) (boolean=? #t (is_right_angle\
    \ a b c))]\n    [(>= a b) (boolean=? #t (is_right_angle a b c))]\n    [(>= b c)\
    \ (boolean=? #t (is_right_angle a b c))]\n    [else (boolean=? #t (is_right_angle\
    \ a b c))]))\n", "  (let ([max (max a b c)])\n    (and (= (expt (- max a) 2) (+\
    \ (expt (- max b) 2) (expt (- max c) 2)))\n         (= (expt (- max b) 2) (+ (expt\
    \ (- max a) 2) (expt (- max c) 2)))\n         (= (expt (- max c) 2) (+ (expt (-\
    \ max a) 2) (expt (- max b) 2))))))\n```\n\n## Problem 2:\n\n```racket\n#lang\
    \ racket\n", "  (and (&lt;= a b c)\n       (&lt;= (square a) (+ (square b) (square\
    \ c)))\n       (&lt;= (square b) (+ (square a) (square c)))\n       (&lt;= (square\
    \ c) (+ (square a) (square b)))))\n</code>\nThanks in advance.\n\n\nA:\n\nThe\
    \ problem is that the operator <code>&lt;=</code> is not defined for every value\
    \ of <code>a</code>, <code>b</code>, and <code>c</code>. So as soon as any of\
    \ those values is negative, you can't call <code>&lt;=</code> on it. That's what\
    \ you get from the error message. (You might also get the error if any of those\
    \ values is not a number, but I think that's not the case in your code.)\nSo you\
    \ need to check if all values are positive, before calling <code>&lt;=</code>.\n\
    <code>(define (right_angle_triangle a b c)\n  (and (&lt;= a b c)\n       (&lt;=\
    \ (square a) (+ (square b) (square c)))\n       (&lt;= (square b) (+ (square a)\
    \ (square c)))\n       (&lt;= (square c) (+ (square a) (square b)))\n       (&lt;=\
    \ 0 a)\n       (&lt;= 0 b)\n       (&lt;= 0 c)))\n</code>\nI don't like this solution,\
    \ but it is the most direct solution.\nA more elegant solution is to define a\
    \ helper function, that checks if all values are positive, and only calls the\
    \ <code>right_angle_triangle</code> function if this is the case.\n<code>(define\
    \ (right_angle_triangle a b c)\n  (and (&lt;= a b c)\n       (&lt;= (square a)\
    \ (+ (square b) (square c)))\n       (&lt;= (square b) (+ (square a) (square c)))\n\
    \       (&lt;= (square c) (+ (square a) (square b)))))\n", "  (and (and (<= a\
    \ b) (<= b c))\n       (or (= (* a a) (+ (* b b) (* c c)))\n           (= (* b\
    \ b) (+ (* a a) (* c c)))\n           (= (* c c) (+ (* a a) (* b b))))))", " \
    \ (if (and (= (square a) (+ (square b) (square c)))\n           (= (square b)\
    \ (+ (square a) (square c)))\n           (= (square c) (+ (square a) (square b))))\n\
    \      #t\n      #f))\n", "  (cond [(and (= (pow a 2) (+ (pow b 2) (pow c 2)))\
    \ (and (= (pow b 2) (+ (pow a 2) (pow c 2))) (= (pow c 2) (+ (pow a 2) (pow b\
    \ 2))))) #t]\n        [else #f]))\n```\n\n## 2.a\n\n```racket\n#lang racket\n",
  "  (cond [(< a b c) (< (* a a) (+ (* b b) (* c c)))]\n        [(= a b c) (< (* a\
    \ a) (+ (* b b) (* c c)))]\n        [(> a b c) (< (* a a) (+ (* b b) (* c c)))]))",
  "  (cond\n    [(= a (sqrt (+ (sqr b) (sqr c))))]\n    [(= b (sqrt (+ (sqr a) (sqr\
    \ c))))]\n    [(= c (sqrt (+ (sqr a) (sqr b))))]\n    [else false]))", "  (cond\
    \ [(and (= a (sqrt (+ (* b b) (* c c)))) (= b (sqrt (+ (* a a) (* c c)))) (= c\
    \ (sqrt (+ (* a a) (* b b)))))\n         #t]\n        [else\n         #f]))\n",
  "  (if (and (plus? a b c)\n           (or (= (pow a 2) (+ (pow b 2) (pow c 2)))\n\
    \               (= (pow b 2) (+ (pow a 2) (pow c 2)))\n               (= (pow\
    \ c 2) (+ (pow a 2) (pow b 2)))))\n      #t\n      #f))\n", "  (let* ([hyp (*\
    \ a a)]\n         [cat (* b b)]\n         [hyp-cat (+ hyp cat)])\n    (= hyp-cat\
    \ (* c c))))\n", '  (= (+ (expt a 2) (expt b 2)) (expt c 2)))', "  (if (or (=\
    \ a 0) (= b 0) (= c 0))\n      #f\n      (if (or (> (+ a b) c) (> (+ a c) b) (>\
    \ (+ b c) a))\n          #f\n          (if (or (= (square a) (+ (square b) (square\
    \ c)))\n                  (= (square b) (+ (square a) (square c)))\n         \
    \         (= (square c) (+ (square a) (square b))))\n              #t\n      \
    \        #f))))", "  (define (order a b)\n    (cond\n      [(< a b) #t]\n    \
    \  [else #f]))\n  (cond\n    [(and (= (expt a 2) (+ (expt b 2) (expt c 2)))\n\
    \          (order a b)\n          (order a c)) #t]\n    [else #f]))\n```\n\n-\
    \ `double_list.rkt`\n```\n#lang racket\n", "  (let ([max (max (max a b) c)])\n\
    \    (and\n     (and\n      (= (expt a 2) (+ (expt b 2) (expt c 2)))\n      (or\
    \ (= a max) (= b max) (= c max)))\n     (and\n      (= (expt b 2) (+ (expt a 2)\
    \ (expt c 2)))\n      (or (= a max) (= b max) (= c max)))\n     (and\n      (=\
    \ (expt c 2) (+ (expt a 2) (expt b 2)))\n      (or (= a max) (= b max) (= c max))))))\n",
  "  (define (square x) (* x x))\n  (define (hypotenuse) (sqrt (+ (square a) (square\
    \ b))))\n  (and (< a c) (< b c) (< (hypotenuse) c)))", "  (let ([hypotenuse (max\
    \ a b c)]\n        [side1 (min a b c)]\n        [side2 (if (or (equal? a hypotenuse)\
    \ (equal? b hypotenuse))\n                   (max a b)\n                   (min\
    \ a b))])\n    (equal?\n     (sqr hypotenuse)\n     (+ (sqr side1) (sqr side2)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
