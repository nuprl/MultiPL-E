name: HumanEval_157_right_angle_triangle
language: rkt
prompt: "#lang racket\n\n;; Given the lengths of the three sides of a triangle. Return\
  \ #t if the three\n;; sides form a right-angled triangle, #f otherwise.\n;; A right-angled\
  \ triangle is a triangle in which one angle is right angle or \n;; 90 degree.\n\
  ;; Example:\n;; >>> (right_angle_triangle 3 4 5)\n;; #t\n;; >>> (right_angle_triangle\
  \ 1 2 3)\n;; #f\n(define (right_angle_triangle a b c)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n\
  \    (check-equal? (candidate 3 4 5) #t)\n    (check-equal? (candidate 1 2 3) #f)\n\
  \    (check-equal? (candidate 10 6 8) #t)\n    (check-equal? (candidate 2 2 2) #f)\n\
  \    (check-equal? (candidate 7 24 25) #t)\n    (check-equal? (candidate 10 5 7)\
  \ #f)\n    (check-equal? (candidate 5 12 13) #t)\n    (check-equal? (candidate 15\
  \ 8 17) #t)\n    (check-equal? (candidate 48 55 73) #t)\n    (check-equal? (candidate\
  \ 1 1 1) #f)\n    (check-equal? (candidate 2 2 10) #f)\n))\n\n(test-humaneval)"
completions: ["  (if (and (sqrt a) (sqrt b) (sqrt c))\n      (let* ([a (sqrt a)]\n\
    \             [b (sqrt b)]\n             [c (sqrt c)])\n        (if (and (>= a\
    \ 0) (>= b 0) (>= c 0))\n            (let ([d (vector (list a a) (list b b) (list\
    \ c c)]\n                  [a (pow a 2)]\n                  [b (pow b 2)]\n  \
    \                [c (pow c 2)])\n              (if (and (member a d) (member b\
    \ d) (member c d))\n                  #t\n                  #f))\n           \
    \ #f))\n      #f))", "  (and (and (&lt; a (max b c)) (&lt; b (max a c)) (&lt;\
    \ c (max a b)))\n       (and (= (expt a 2) (+ (expt b 2) (expt c 2)))\n      \
    \      (= (expt a 2) (+ (expt b 2) (expt c 2)))\n            (= (expt a 2) (+\
    \ (expt b 2) (expt c 2))))))\n", "  (and (= b c)\n       (= a (sqrt (+ (* b b)\
    \ (* c c))))))\n", "  (and (= (sqrt (+ (* a a) (* b b))) c)\n       (<= a b) (<=\
    \ b c)))\n", "  (cond\n    [(= a (sqrt (+ (sqr b) (sqr c)))) #t]\n    [(= b (sqrt\
    \ (+ (sqr a) (sqr c)))) #t]\n    [(= c (sqrt (+ (sqr a) (sqr b)))) #t]\n    [else\
    \ #f]))", "  (let ([ad ((<= 0 a) (and (< a b) (< a c)))]\n        [bd ((<= 0 b)\
    \ (and (< b a) (< b c)))]\n        [cd ((<= 0 c) (and (< c a) (< c b))))])\n \
    \   (and ad bd cd\n         (or (and (= (+ a (* b b)) (* c c))\n             \
    \     (= (+ (* a a) (* b b)) (* c c)))\n             (and (= (+ a (* c c)) (*\
    \ b b))\n                  (= (+ (* a a) (* c c)) (* b b)))\n             (and\
    \ (= (+ (* a a) (* b b)) (* c c))\n                  (= (+ (* a a) (* c c)) (*\
    \ b b)))))))\n", "  (= 90\n     (acos (/ (+ (* a a) (* b b) (* c c)) \n      \
    \        (* 2 a b c)))))", "  (and (and (and (> a 0) (> b 0) (> c 0))\n      \
    \      (<= a (+ b c))\n            (<= b (+ a c))\n            (<= c (+ a b)))\n\
    \       (or (and (= (pow a 2) (+ (pow b 2) (pow c 2)))\n                (= a (max\
    \ (max a b) c)))\n           (and (= (pow b 2) (+ (pow a 2) (pow c 2)))\n    \
    \            (= b (max (max a b) c)))\n           (and (= (pow c 2) (+ (pow a\
    \ 2) (pow b 2)))\n                (= c (max (max a b) c))))))\n", "  (cond\n \
    \   [(and (= c (square-root (+ (square a) (square b))))\n          (= b (square-root\
    \ (+ (square a) (square c))))\n          (= a (square-root (+ (square b) (square\
    \ c)))))\n     #t]\n    [else #f]))\n", "  (define (square a) (* a a))\n  (define\
    \ (hypot a b) (sqrt (+ (square a) (square b))))\n  (define (pythagoras a b c)\n\
    \    (and (or (= (hypot a b) c) (= (hypot a c) b) (= (hypot b c) a))\n       \
    \  (= (hypot a b) (hypot a c))))\n  (pythagoras a b c))\n", "  (if (and (= (square\
    \ a) (+ (square b) (square c)))\n           (= (square b) (+ (square a) (square\
    \ c)))\n           (= (square c) (+ (square a) (square b))))\n      #t\n     \
    \ #f))\n", "  (cond\n    [(>= a b c)   #f]\n    [(= a (* b b)) #t]\n    [(= b\
    \ (* a a)) #t]\n    [(= c (* a a)) #t]\n    [(= c (* b b)) #t]\n    [else #f]))\n",
  "  (define (square x) (* x x))\n  (define (is-pythagoras? a b c)\n    (and (= a\
    \ (+ b c))\n         (= (square a) (+ (square b) (square c)))\n         (< a (+\
    \ b c))))\n  (is-pythagoras? a b c))", "  ;; ***** your code goes here *****\n\
    )\n```\n\nHint: If a^2 + b^2 = c^2, then a, b, c form a right-angled triangle.\n\
    \n### (1d)\nWrite a function `largest_element` that takes a list of numbers and\
    \ returns the largest number in the list.\nExample:\n```racket\n>>> (largest_element\
    \ (list 1 5 4 2 7))\n7\n```\n\n### (1e)\nWrite a function `largest_in_each_row`\
    \ that takes a matrix (defined as a list of lists) and returns a list of the largest\n\
    number in each row of the matrix. Example:\n```racket\n>>> (largest_in_each_row\
    \ (list (list 1 2) (list 3 4 5) (list 6 7 8 9)))", "  (and (and (<= a b) (<= b\
    \ c))\n       (or (= a (+ b c))\n           (= b (+ a c))\n           (= c (+\
    \ a b)))))\n", "  (define max-side (if (or (= a (max a b c)) (= b (max a b c)))\
    \ (max a b c) c))\n  (define min-side (if (or (= a (min a b c)) (= b (min a b\
    \ c))) (min a b c) c))\n  (define middle-side (if (and (not (= a (max a b c)))\
    \ (not (= a (min a b c)))) a b))\n  (= (sqr min-side) (+ (sqr middle-side) (sqr\
    \ max-side)))\n  )\n", "  (cond\n    [(and (<= a b) (<= b c)) (if (= (sqr a) (+\
    \ (sqr b) (sqr c))) #t #f)]\n    [(and (<= a c) (<= c b)) (if (= (sqr a) (+ (sqr\
    \ c) (sqr b))) #t #f)]\n    [(and (<= b a) (<= a c)) (if (= (sqr b) (+ (sqr a)\
    \ (sqr c))) #t #f)]\n    [(and (<= b c) (<= c a)) (if (= (sqr b) (+ (sqr c) (sqr\
    \ a))) #t #f)]\n    [(and (<= c a) (<= a b)) (if (= (sqr c) (+ (sqr a) (sqr b)))\
    \ #t #f)]\n    [(and (<= c b) (<= b a)) (if (= (sqr c) (+ (sqr b) (sqr a))) #t\
    \ #f)]\n    [else #f]))\n", "  (if (>= a b c)\n      (if (>= b c a)\n        \
    \  (if (>= c a b)\n              #t\n              #f)\n          #f)\n      #f))\n",
  "  (let ((sides (vector a b c)))\n    (vector-sort < sides)\n    (equal? (vector-ref\
    \ sides 0) \n            (sqrt (+ (expt (vector-ref sides 1) 2)\n            \
    \         (expt (vector-ref sides 2) 2))))))\n", "  (and\n   (or (= a (- c b))\
    \ (= b (- c a)) (= c (- a b)))\n   (and\n    (and (&lt;= a c) (&lt;= a b))\n \
    \   (and (&lt;= b c) (&lt;= b a))\n    (and (&lt;= c a) (&lt;= c b)))))\n</code>\n\
    I tried my best to make the code succinct, but I feel that it could be improved.\
    \ Could you give me some hints for further improvement?\n\n\nA:\n\nObligatory\
    \ readability section\n\nStyle guide: write <code>right-angle-triangle</code>\
    \ instead of <code>right_angle_triangle</code>.\n<code>right-angle-triangle</code>\
    \ is a good name, but <code>right-triangle?</code> is better.\n\nAlgorithm\n\n\
    Unnecessary code: why do you need to check that <code>a &lt;= c</code> and <code>a\
    \ &lt;= b</code>? If you know that <code>a &lt;= c</code>, you also know that\
    \ <code>a &lt;= b</code>. You don't need to check both.\nProbabilistic analysis:\
    \ Your test has a chance of succeeding even when the numbers don't represent a\
    \ right triangle. This can happen when the square root is not precise enough.\
    \ For example, if you pass in <code>a</code> = 1, <code>b</code> = 2, and <code>c</code>\
    \ = 1.41421356237309504880168872420969807856967187537694807317667973799073247846210703885038753432764157273501384623091229702492483605585073721264412149709993583141322266592750559275579995050115278206057147,\
    \ then <code>a</code> squared is less than <code>b</code> squared, but <code>a</code>\
    \ squared + <code>b</code> squared is approximately equal to <code>c</code> squared,\
    \ so your test would incorrectly pass. The numbers I used here are not arbitrary."]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
