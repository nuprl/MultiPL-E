name: HumanEval_2_truncate_number
language: rkt
prompt: "#lang racket\n\n;; Given a positive floating point number, it can be decomposed\
  \ into\n;; and integer part (largest integer smaller than given number) and decimals\n\
  ;; (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n\
  ;; >>> (truncate_number 3.5)\n;; 0.5\n(define (truncate_number number)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n\
  \    (check-equal? (candidate 3.5) 0.5)\n    (check-equal? (candidate 1.25) 0.25)\n\
  \    (check-equal? (candidate 123.0) 0.0)\n))\n\n(test-humaneval)"
completions: ["  (if (zero? (floor number))\n      (- number (floor number))\n   \
    \   (truncate_number (- number (floor number)))))\n", "  (/ (- number (floor number))\
    \ 1))\n", "  (- number (inexact->exact (floor number))))\n", "  (remainder number\
    \ (floor number)))\n", "  (modulo number 1))\n", "  (exact->inexact (/ (- number\
    \ (inexact->exact (floor number))) 1)))\n", "  (if (<= number 1)\n      0\n  \
    \    (- number (floor number))))\n", "  (remainder number (integer->exact (floor\
    \ number))))\n", "  (define (decimal num)\n    (remainder num 1))\n  (cond\n \
    \   [(integer? number) (decimal number)]\n    [(>= number 1) (decimal number)]\n\
    \    [else (decimal (* number 10))]))\n", "  (- number (inexact->exact (floor\
    \ number))))\n", "  (logand (- number (floor number)) (expt 2 54)))\n", "  (define\
    \ integer-part (inexact->exact (floor number)))\n  (- number integer-part))\n",
  "  (define decimals (- number (floor number)))\n  decimals)\n", '  (remainder number
    (floor number)))', "  (- number (integer->exact (inexact->integer number))))\n",
  "  (- number (floor number)))\n", "  (inexact->exact (floor (- number (exact->inexact\
    \ (floor number))))))\n", "  ;; Check if number is really a number\n  (if (number?\
    \ number)\n      (if (> number 0)\n          ;; return the decimal part of the\
    \ number,\n          ;; subtracting the integer part from the original number\n\
    \          (- number (round number))\n          \"Number is not positive\")\n\
    \      \"Number is not a number\"))\n", "  (define int_part (integer->inexact\
    \ (truncate number)))\n  (- number int_part))\n", "  (define integer-part (truncate\
    \ number))\n  (- number integer-part))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
