name: HumanEval_25_factorize
language: rkt
prompt: "#lang racket\n\n;; Return list of prime factors of given integer in the order\
  \ from smallest to largest.\n;; Each of the factors should be listed number of times\
  \ corresponding to how many times it appeares in factorization.\n;; Input number\
  \ should be equal to the product of all factors\n;; >>> (factorize 8)\n;; (list\
  \ 2 2 2)\n;; >>> (factorize 25)\n;; (list 5 5)\n;; >>> (factorize 70)\n;; (list\
  \ 2 5 7)\n(define (factorize n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate factorize))\n\
  \    (check-equal? (candidate 2) (list 2))\n    (check-equal? (candidate 4) (list\
  \ 2 2))\n    (check-equal? (candidate 8) (list 2 2 2))\n    (check-equal? (candidate\
  \ 57) (list 3 19))\n    (check-equal? (candidate 3249) (list 3 3 19 19))\n    (check-equal?\
  \ (candidate 185193) (list 3 3 3 19 19 19))\n    (check-equal? (candidate 20577)\
  \ (list 3 19 19 19))\n    (check-equal? (candidate 18) (list 2 3 3))\n))\n\n(test-humaneval)"
completions: ["  (define (get-primes up-to)\n    (if (= up-to 1) (list)\n        (let*\
    \ ([d (get-min-divisor up-to)]\n               [ps (get-primes (- up-to 1))])\n\
    \          (if (= d 0) ps\n              (cons d ps)))))\n  (define (get-min-divisor\
    \ n)\n    (define (get-next-divisor n from)\n      (if (< from n)\n          (if\
    \ (zero? (modulo n from)) from\n              (get-next-divisor n (+ from 1)))\n\
    \          0))\n    (get-next-divisor n 2))\n  (define (factorize-one n p)\n \
    \   (if (= (modulo n p) 0)\n        (cons p (factorize-one (/ n p) p))\n     \
    \   (list)))\n  (define (factorize-all n)\n    (if (= n 1) (list)\n        (let*\
    \ ([p (get-min-divisor n)]\n               [pf (factorize-one n p)])\n       \
    \   (append pf (factorize-all (div n (apply * pf)))))))\n  (factorize-all n))",
  "  (let loop ([i 2] [n n] [r '()])\n    (cond\n      [(equal? 1 n) (reverse r)]\n\
    \      [(zero? (modulo n i)) (loop i (/ n i) (cons i r))]\n      [else (loop (+\
    \ i 1) n r)])))\n", "  (if (= n 1)\n      (list)\n      (append (list (/ n (factor\
    \ n))) (factorize (/ n (factor n))))))\n", "  (define (prime? n)\n    (cond [(=\
    \ n 1) (error \"1 is not a prime\")]\n          [(= n 2) #t]\n          [(even?\
    \ n) #f]\n          [else\n           (let loop ([n (- n 1)])\n             (cond\
    \ [(= n 1) #t]\n                   [(prime? n) #f]\n                   [else (loop\
    \ (- n 1))]))]))\n  (define (factorize-helper n m)\n    (if (prime? m)\n     \
    \   (if (= 0 (modulo n m))\n            (cons m (factorize-helper (/ n m) m))\n\
    \            (factorize-helper n (+ m 1)))\n        (factorize-helper n (+ m 1))))\n\
    \  (factorize-helper n 2))\n", "  (factors n 2))\n", "  (cond [(equal? n 1) empty]\n\
    \        [(= n (gcd n (car (factorize (- n 1)))))\n         (cons n (factorize\
    \ (- n 1)))]\n        [else (factorize (- n 1))]))\n", "  (factorize-helper n\
    \ n))\n", "  (define (find-factor n k)\n    (cond ((zero? (modulo n k)) (list\
    \ k (find-factor (quotient n k) k)))\n          ((or (< n k) (= n 1)) null)\n\
    \          (else (find-factor n (+ k 1)))))\n  (find-factor n 2))\n", "  (let\
    \ ([x 2])\n    (cond\n      [(= x n) (list x)]\n      [(= 0 (modulo n x)) (cons\
    \ x (factorize (/ n x)))]\n      [else (factorize n (+ x 1))])))\n", "  (define\
    \ (divides? a b)\n    (= (remainder b a) 0))\n  (define (find-divisor n test-divisor)\n\
    \    (cond ((> (square test-divisor) n) n)\n          ((divides? test-divisor\
    \ n) test-divisor)\n          (else (find-divisor n (+ test-divisor 1)))))\n \
    \ (define (fact-iter n divisor)\n    (if (= n 1)\n        (list)\n        (let\
    \ ((result (fact-iter (/ n divisor) divisor)))\n          (if (= divisor (car\
    \ result))\n              result\n              (cons divisor result)))))\n  (fact-iter\
    \ n (find-divisor n 2)))\n", "  (define (find-divisor n test-divisor)\n    (cond\
    \ ((> (square test-divisor) n) n)\n          ((divides? test-divisor n) test-divisor)\n\
    \          (else (find-divisor n (+ test-divisor 1)))))\n  (define (divides? a\
    \ b)\n    (= (remainder b a) 0))\n  (define (prime? n)\n    (= n (find-divisor\
    \ n 2)))\n  (define (factorize-iter n val result)\n    (cond ((prime? n) (append\
    \ result (list n)))\n          ((prime? val) (factorize-iter (/ n val) 2 (append\
    \ result (list val))))\n          (else (factorize-iter n (+ val 1) result))))\n\
    \  (factorize-iter n 2 '()))\n", "  (define (factorize-n-aux n i)\n    (if (equal?\
    \ i n)\n        (list n)\n        (if (zero? (modulo n i))\n            (cons\
    \ i (factorize-n-aux (quotient n i) i))\n            (factorize-n-aux n (+ i 1)))))\n\
    \  (factorize-n-aux n 2))\n", "  (define (find-factor x)\n    (if (= x n) n\n\
    \        (if (= (remainder n x) 0) x\n            (find-factor (+ x 1)))))\n \
    \ (define (prime-factors-iter x counter)\n    (if (= x 0) '()\n        (if (=\
    \ (remainder x (find-factor counter)) 0)\n            (cons (find-factor counter)\
    \ (prime-factors-iter (/ x (find-factor counter)) counter))\n            (prime-factors-iter\
    \ x (+ counter 1)))))\n  (prime-factors-iter n 2))\n```\n\n## Chapter 7\n\n###\
    \ Ex.1\n\n```#lang racket\n", "  (define (factorize-iter n primes)\n    (if (=\
    \ n 1)\n        (empty)\n        (define prime (car primes))\n        (if (= (remainder\
    \ n prime) 0)\n            (cons prime (factorize-iter (/ n prime) primes))\n\
    \            (factorize-iter n (cdr primes)))))\n  (factorize-iter n (range 2\
    \ n)))\n", "  (let helper ([x n] [res (list)])\n    (cond\n      [(< x 2) res]\n\
    \      [(even? x) (helper (/ x 2) (cons 2 res))]\n      [(odd? x)\n       (let\
    \ helper2 ([x x] [res res])\n         (cond\n           [(= x 1) res]\n      \
    \     [(= (modulo x (car res)) 0) (helper2 (/ x (car res)) res)]\n           [else\
    \ (helper2 (/ x (car res)) (cons x res))]))])))", "  (cond [(= n 1) (list 1)]\n\
    \        [(prime? n) (list n)]\n        [else\n         (let loop ([n n] [factors\
    \ (list)])\n           (if (= n 1) factors\n               (let loop2 ([i 2])\n\
    \                 (if (= (modulo n i) 0)\n                     (loop (quotient\
    \ n i) (cons i factors))\n                     (loop2 (+ i 1))))))]))\n", "  (factorize-inner\
    \ n 2 '()))\n", "  (define (is-prime n)\n    (if (= n 1)\n        #f\n       \
    \ (define (iter n i)\n          (if (= i n)\n              #t\n              (if\
    \ (= (remainder n i) 0)\n                  #f\n                  (iter n (+ i\
    \ 1)))))\n        (iter n 2)))\n  (define (prime-factors n)\n    (define (loop\
    \ n i)\n      (if (= n 1)\n          '()\n          (if (is-prime i)\n       \
    \       (if (= (remainder n i) 0)\n                  (cons i (loop (/ n i) i))\n\
    \                  (loop n (+ i 1)))\n              (loop n (+ i 1)))))\n    (loop\
    \ n 2))\n  (define (multiply-duplicates lst)\n    (define (loop lst result)\n\
    \      (if (null? lst)\n          result\n          (loop (cdr lst) (cons (car\
    \ lst) (cons (car lst) result)))))\n    (reverse (loop lst '())))\n  (multiply-duplicates\
    \ (prime-factors n)))\n", "  (cond [(= n 1) (list)]\n        [(prime? n) (list\
    \ n)]\n        [else\n         (cons (first (filter (lambda (x) (zero? (modulo\
    \ n x))) (range 2 n)))\n               (factorize (quotient n (first (filter (lambda\
    \ (x) (zero? (modulo n x))) (range 2 n))))))]))\n", "  (define (divide n k)\n\
    \    (if (= n 1)\n        '()\n        (if (= (remainder n k) 0)\n           \
    \ (cons k (divide (quotient n k) k))\n            (divide n (+ k 1)))))\n  (divide\
    \ n 2))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
