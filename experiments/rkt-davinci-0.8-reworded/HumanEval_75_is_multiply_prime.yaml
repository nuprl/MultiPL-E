name: HumanEval_75_is_multiply_prime
language: rkt
prompt: "#lang racket\n\n;; Write a function that returns true if the given number\
  \ is the multiplication of 3 prime numbers\n;; and false otherwise.\n;; Knowing\
  \ that (a) is less then 100. \n;; Example:\n;; >>> (is_multiply_prime 30)\n;; #t\n\
  ;; 30 = 2 * 3 * 5\n(define (is_multiply_prime a)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_multiply_prime))\n\
  \    (check-equal? (candidate 5) #f)\n    (check-equal? (candidate 30) #t)\n   \
  \ (check-equal? (candidate 8) #t)\n    (check-equal? (candidate 10) #f)\n    (check-equal?\
  \ (candidate 125) #t)\n    (check-equal? (candidate 105) #t)\n    (check-equal?\
  \ (candidate 126) #f)\n    (check-equal? (candidate 729) #f)\n    (check-equal?\
  \ (candidate 891) #f)\n    (check-equal? (candidate 1001) #t)\n))\n\n(test-humaneval)"
completions: ["  (define (is_prime n)\n    (define (is_divisible-by? k n)\n      (=\
    \ (remainder n k) 0))\n    (define (loop j n)\n      (cond ((= j n) #t)\n    \
    \        ((is_divisible-by? j n) #f)\n            (else (loop (+ j 1) n))))\n\
    \    (loop 2 n))\n  (define (prime-of-list lst)\n    (if (null? lst)\n       \
    \ #f\n        (if (is_prime (car lst))\n            (car lst)\n            (prime-of-list\
    \ (cdr lst)))))\n  (define (loop n)\n    (cond ((= n 3) #f)\n          ((is_prime\
    \ n) n)\n          (else (loop (- n 1)))))\n  (define (is_multiply_of-three-prime?\
    \ n)\n    (let ((x (loop n))\n          (y (loop (- n 1)))\n          (z (loop\
    \ (- n 2))))\n      (if (or (= x #f) (= y #f) (= z #f))\n          #f\n      \
    \    (if (= n (* x y z))\n              #t\n              #f))))\n  (is_multiply_of-three-prime?\
    \ a))\n", "  (cond ((= a 2) #t)\n        ((or (even? a) (= (modulo a 3) 0)) #f)\n\
    \        (else (is_prime a))))\n", "  (cond\n    [(= a 3) #t]\n    [(= a 5) #t]\n\
    \    [(= a 7) #t]\n    [(= a 11) #t]\n    [(= a 13) #t]\n    [(= a 17) #t]\n \
    \   [(= a 19) #t]\n    [(= a 23) #t]\n    [(= a 29) #t]\n    [(= a 31) #t]\n \
    \   [(= a 37) #t]\n    [(= a 41) #t]\n    [(= a 43) #t]\n    [(= a 47) #t]\n \
    \   [(= a 53) #t]\n    [(= a 59) #t]\n    [(= a 61) #t]\n    [(= a 67) #t]\n \
    \   [(= a 71) #t]\n    [(= a 73) #t]\n    [(= a 79) #t]\n    [(= a 83) #t]\n \
    \   [(= a 89) #t]\n    [(= a 97) #t]\n    [#t #f]))\n", "  (define (is_prime a)\n\
    \    (define (loop i)\n      (if (= i a)\n          #t\n          (if (= (remainder\
    \ a i) 0)\n              #f\n              (loop (+ i 1)))))\n    (loop 2))\n\
    \  (define (loop3 a)\n    (if (= a 2)\n        #f\n        (if (= (remainder a\
    \ 3) 0)\n            (if (is_prime (/ a 3))\n                #t\n            \
    \    (loop3 (/ a 3)))\n            (loop3 (/ a 3)))))\n  (define (loop2 a)\n \
    \   (if (= a 2)\n        #f\n        (if (= (remainder a 2) 0)\n            (if\
    \ (is_prime (/ a 2))\n                #t\n                (loop2 (/ a 2)))\n \
    \           (loop2 (/ a 2)))))\n  (if (= (is_prime a) #t)\n      #t\n      (if\
    \ (= (loop2 a) #t)\n          #t\n          (loop3 a))))", "  (define (divisible-by?\
    \ a b)\n    (= (remainder a b) 0))\n  (define (is-prime? n)\n    (define (iter\
    \ n i)\n      (if (< i n)\n          (if (divisible-by? n i)\n              #f\n\
    \              (iter n (+ i 1)))\n          #t))\n    (iter n 2))\n  (define (iter\
    \ a i max)\n    (if (< i max)\n        (if (divisible-by? a i)\n            (if\
    \ (is-prime? i)\n                (if (= (quotient a i) 1)\n                  \
    \  #t\n                    (iter (quotient a i) 2 max))\n                (iter\
    \ a (+ i 1) max))\n            (iter a (+ i 1) max))\n        #f))\n  (iter a\
    \ 2 (quotient a 2)))\n```\n\n```racket\n#lang racket\n", "  (define is_prime?\n\
    \    (cond\n      [(= a 2) #t]\n      [(even? a) #f]\n      [else\n       (define\
    \ (rec n)\n         (cond\n           [(= n 1) #t]\n           [(= (modulo a n)\
    \ 0) #f]\n           [else (rec (- n 1))]))\n       (rec (- a 1))]))\n  (define\
    \ (have-common-divisor? a b)\n    (cond\n      [(= b 0) #f]\n      [(= (modulo\
    \ a b) 0) #t]\n      [else (have-common-divisor? b (modulo a b))]))\n  (define\
    \ (rec n)\n    (cond\n      [(= n (ceiling (/ a 2))) #f]\n      [(is_prime? n)\n\
    \       (cond\n         [(is_prime? (- a n))\n          (cond\n            [(is_prime?\
    \ (- (/ a n) (- a n))) #t]\n            [else (rec (+ n 1))])]\n         [else\
    \ (rec (+ n 1))])]\n      [else (rec (+ n 1))]))\n  (cond\n    [(= a 1) #f]\n\
    \    [(is_prime? a) #f]\n    [else (rec 2)]))", "  (define (helper n p)\n    (if\
    \ (= n 1)\n        #t\n        (if (prime? p)\n            (if (= (modulo n p)\
    \ 0)\n                (helper (/ n p) p)\n                (helper n (+ p 1)))\n\
    \            (helper n (+ p 1)))))\n  (helper a 2))\n", "  (define (is_prime a)\n\
    \    (define (divisors a)\n      (local [(define (iter n i)\n                (cond\n\
    \                  [(= n i) #f]\n                  [(= (modulo a i) 0) i]\n  \
    \                [else (iter n (+ i 1))]))]\n        (iter a 2)))\n    (not (divisors\
    \ a)))\n  (define (is_factor a)\n    (define (iter n i)\n      (cond\n       \
    \ [(= n i) #f]\n        [(= (modulo a i) 0) (and (is_prime i) (is_prime (/ a i)))]\n\
    \        [else (iter n (+ i 1))]))\n    (iter a 2))\n  (is_factor a))\n", "  (define\
    \ (prime? a)\n    (cond\n      [(< a 2) #f]\n      [(equal? a 2) #t]\n      [(equal?\
    \ (remainder a 2) 0) #f]\n      [else (let loop ([i 3])\n               (cond\n\
    \                 [(<= i (sqrt a))\n                  (if (equal? (remainder a\
    \ i) 0)\n                      #f\n                      (loop (+ i 2)))]\n  \
    \               [else #t]))]))\n  (define (is_multiply-prime-inner a current-product\
    \ current-numbers)\n    (if (<= current-product a)\n        (if (equal? (remainder\
    \ a current-product) 0)\n            (let loop ([i 2])\n              (if (prime?\
    \ i)\n                  (if (= (length current-numbers) 3)\n                 \
    \     (begin\n                        (display (list current-numbers))\n     \
    \                   (display \" \")\n                        (display current-product)\n\
    \                        (display \" \")\n                        (display (remainder\
    \ a current-product))\n                        (newline)\n                   \
    \     #t)\n                      (is_multiply-prime-inner (quotient a i) (* current-product\
    \ i) (cons i current-numbers)))\n                  (loop (+ i 1))))\n        \
    \    (is_multiply-prime-inner a current-product current-numbers))\n        #f))\n\
    \  (is_multiply-prime-inner a 1 '()))\n", "  (cond\n    [(= a 1) #f]\n    [(=\
    \ a 2) #f]\n    [(= a 3) #f]\n    [(and (is_prime a)\n          (is_prime (/ a\
    \ 2))\n          (is_prime (/ a 3))) #t]\n    [else #f]))\n", "  (is_multiply_prime_helper\
    \ a 2 1 1 1))\n", "  (if (= (factors a) 3)\n      #t\n      #f))\n", "  (let ([b\
    \ (find_divs a)])\n    (and (is_prime (first b))\n         (is_prime (second b))\n\
    \         (is_prime (third b)))))\n", "  (let ([is_prime? (lambda (a) (eq? 2 (how_many_primes?\
    \ a)))])\n    (cond [(is_prime? a) #f]\n          [(zero? (modulo a 2)) (is_multiply_prime\
    \ (/ a 2))]\n          [(zero? (modulo a 3)) (is_multiply_prime (/ a 3))]\n  \
    \        [(zero? (modulo a 5)) (is_multiply_prime (/ a 5))]\n          [else #f])))\n",
  "  (if (and (prime? a) (prime? (/ a 2)) (prime? (/ a 3)))\n      #t\n      #f))",
  "    (define (is-prime n)\n        (define (iter n i)\n          (if (< i 2)\n \
    \             #t\n              (if (= (remainder n i) 0)\n                  #f\n\
    \                  (iter n (- i 1)))))\n        (iter n (quotient n 2)))\n   \
    \ (define (get-factors n)\n        (define (iter n i acc)\n            (if (=\
    \ n 1)\n                acc\n                (if (= (remainder n i) 0)\n     \
    \               (iter (/ n i) i (cons i acc))\n                    (iter n (+\
    \ i 1) acc))))\n        (iter n 2 '()))\n    (define (n-prime-factors n)\n   \
    \     (length (filter is-prime (get-factors n))))\n    (= (n-prime-factors a)\
    \ 3))\n```\n\n**12.**\n``` #lang racket\n", "  (cond [(is_prime a) #f]\n     \
    \   [else (is_multiply_prime2 a 2)]))", "  (if (zero? (modulo a 2))\n      (if\
    \ (zero? (modulo a 3))\n          (if (zero? (modulo a 5))\n              #t\n\
    \              #f)\n          #f)\n      #f))\n", "  (cond ((or (= a 0) (= a 1))\
    \ #f)\n        ((prime? a) #f)\n        ((prime? (- a 2)) #f)\n        ((prime?\
    \ (- a 6)) #f)\n        ((prime? (- a 30)) #f)\n        ((prime? (- a 210)) #f)\n\
    \        ((prime? (- a 2310)) #f)\n        ((prime? (- a 30030)) #f)\n       \
    \ ((prime? (- a 510510)) #f)\n        ((prime? (- a 9699690)) #f)\n        (else\
    \ #t)))\n", "  (define (is_prime a)\n    (and (> a 1)\n         (not (any (lambda\
    \ (e) (= (remainder a e) 0))\n                   (range 2 a)))))\n  (define (is_primes_multiply\
    \ x n)\n    (cond ((= n 3) #t)\n          ((is_prime x) (is_primes_multiply (remainder\
    \ a x) (+ n 1)))\n          (else (is_primes_multiply (remainder a (add1 x)) n))))\n\
    \  (is_primes_multiply a 0))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
