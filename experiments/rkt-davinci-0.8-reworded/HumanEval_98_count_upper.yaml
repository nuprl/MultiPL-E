name: HumanEval_98_count_upper
language: rkt
prompt: "#lang racket\n\n;; Given a string s, count the number of uppercase vowels\
  \ in even indices.\n;; For example:\n;; >>> (count_upper \"aBCdEf\")\n;; 1\n;; >>>\
  \ (count_upper \"abcdefg\")\n;; 0\n;; >>> (count_upper \"dBBE\")\n;; 0\n(define\
  \ (count_upper s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n\
  \    (check-equal? (candidate \"aBCdEf\") 1)\n    (check-equal? (candidate \"abcdefg\"\
  ) 0)\n    (check-equal? (candidate \"dBBE\") 0)\n    (check-equal? (candidate \"\
  B\") 0)\n    (check-equal? (candidate \"U\") 1)\n    (check-equal? (candidate \"\
  \") 0)\n    (check-equal? (candidate \"EEEE\") 2)\n))\n\n(test-humaneval)"
completions: ["  (letrec ((vowels (list #\\a #\\e #\\i #\\o #\\u))\n           (count-even-uppercase-vowels\n\
    \            (lambda (s)\n              (if (string-empty? s)\n              \
    \    0\n                  (if (and (= (remainder (string-length s) 2) 0)\n   \
    \                        (char-upcase? (string-ref s 0))\n                   \
    \        (member (string-ref s 0) vowels))\n                      (+ 1 (count-even-uppercase-vowels\
    \ (substring s 1)))\n                      (count-even-uppercase-vowels (substring\
    \ s 1)))))))\n    (count-even-uppercase-vowels s)))\n", "  (for/sum ([x (in-string\
    \ s)])\n    (if (and (char-upper-case? x)\n             (even? (string-index s\
    \ x)))\n        1\n        0)))\n", "  (let ((s-len (string-length s))\n     \
    \   (count 0))\n    (for ([i (in-range 0 s-len s-len)])\n      (define (is-upper-vowel?\
    \ c)\n        (and (char-upper-case? c)\n             (member c (string-&gt;list\
    \ \"AEIOUY\"))))\n      (if (is-upper-vowel? (string-ref s i))\n          (set!\
    \ count (+ count 1))))\n    count))\n", "  (count (lambda (c)\n           (and\
    \ (vowel? c)\n                (or (even? (string-index c \"a\"))\n           \
    \         (even? (string-index c \"e\"))\n                    (even? (string-index\
    \ c \"i\"))\n                    (even? (string-index c \"o\"))\n            \
    \        (even? (string-index c \"u\")))))\n         (string->list s)))\n```\n\
    \n```racket\n#lang racket\n", "  (define (upper-vowel? c)\n    (or (equal? #\\\
    A c)\n        (equal? #\\E c)\n        (equal? #\\I c)\n        (equal? #\\O c)\n\
    \        (equal? #\\U c)))\n  (define (even-vowel? c i)\n    (and (upper-vowel?\
    \ c)\n         (even? i)))\n  (define (counth s i)\n    (if (null? s)\n      \
    \  0\n        (if (even-vowel? (car s) i)\n            (+ 1 (counth (cdr s) (+\
    \ i 1)))\n            (counth (cdr s) (+ i 1)))))\n  (counth s 0))\n", "  (if\
    \ (empty? s)\n      0\n      (if (and (char-upper-case? (first s))\n         \
    \      (member (first s) '(\"A\" \"E\" \"I\" \"O\" \"U\")))\n          (+ 1 (count_upper\
    \ (rest s)))\n          (count_upper (rest s)))))\n", "  (cond\n    [(&lt; (string-length\
    \ s) 2) 0]\n    [(&gt;= (string-length s) 2)\n     (if (and (char-upcase? (string-ref\
    \ s 1)) (vowel? (string-ref s 1)))\n         (+ 1 (count_upper (substring s 2)))\n\
    \         (count_upper (substring s 2)))]))\n", "  (let ((s (string-&gt;list s)))\n\
    \    (count-if (\u03BB (x) (and (char-upcase? x) (even? (string-index s x))))\n\
    \              s)))\n</code>\nI'm not sure if I can pass <code>s</code> directly\
    \ to <code>string-index</code> like that, but it works like that.\nHow can I improve\
    \ the performance of my program? \n\n\nA:\n\n<code>#lang racket\n", "  (cond\n\
    \    [else (string-upcase s)]))\n", "  (define (c u s i)\n    (cond\n      [(=\
    \ i (string-length s)) u]\n      [(and (= 1 (modulo i 2))\n            (member\
    \ (string-ref s i) (list #\\A #\\E #\\I #\\O #\\U)))\n       (c (+ u 1) s (+ i\
    \ 1))]\n      [else (c u s (+ i 1))]))\n  (c 0 s 0))\n", "  ;; First: get the\
    \ uppercase vowels\n  (cond\n    [(null? s) 0]\n    [else (+ (if (is-upper-vowel\
    \ (string-ref s 0)) 1 0)\n             (count_upper (substring s 2)))]))\n", " \
    \ (cond\n    [(= (string-length s) 0) 0]\n    [(and (char-upper-case? (string-ref\
    \ s 0))\n          (vowel? (string-ref s 0)))\n     (+ 1 (count_upper (substring\
    \ s 2)))]\n    [else (count_upper (substring s 2))]))\n", "  (cond\n    [(string-empty?\
    \ s) 0]\n    [(vowel? (string-ref s 0))\n     (if (even? (string-length s))\n\
    \         (+ 1 (count_upper (string-tail s)))\n         (count_upper (string-tail\
    \ s)))]\n    [else (count_upper (string-tail s))]))\n", "  (if (empty? s)\n  \
    \    0\n      (if (and (char-vowel? (char-upcase (first s)))\n               (even?\
    \ (char->integer (first s))))\n          (+ 1 (count_upper (rest s)))\n      \
    \    (count_upper (rest s)))))\n", "  (let ((count 0))\n    (for/fold ([count\
    \ 0]) ([i (in-range (string-length s))])\n      (if (and (char-numeric? (string-ref\
    \ s i)) (even? i))\n          (if (char-upper-case? (string-ref s i))\n      \
    \        (+ count 1)\n              count)\n          count))\n    )\n  )", " \
    \ ;; result is the number of vowels\n  (let ([result 0])\n    ;; for every character\
    \ in the string, (s c)\n    (for ([c (in-string s)])\n      ;; count an uppercase\
    \ character if it is a vowel and the index is even\n      (if (and (in '#(#\\\
    A #\\E #\\I #\\O #\\U) (char-upcase c))\n               (even? (string-index s\
    \ c)))\n          (set! result (+ result 1))))\n    result))", "  (for/sum ((i\
    \ (in-range (string-length s)))\n            (v (in-set \"AEIOU\"))\n        \
    \    #:when (and (eq? v (string-upcase (string-ref s i)))\n                  \
    \      (even? i)))\n    1))\n", "  (cond ((string-empty? s) 0)\n        ((even?\
    \ (string-length s))\n         (count_upper (substring s 1 (string-length s))))\n\
    \        ((char-upcase? (string-ref s 0))\n         (+ 1 (count_upper (substring\
    \ s 2 (string-length s)))))\n        (else (count_upper (substring s 1 (string-length\
    \ s))))))\n", "  (cond\n    [(empty? s) 0]\n    [(empty? (rest s)) 0]\n    [(and\
    \ (char-upper-case? (first s))\n          (member (first s) (list #\\A #\\E #\\\
    I #\\O #\\U)))\n     (+ 1 (count_upper (rest (rest s))))]\n    [else (count_upper\
    \ (rest (rest s)))]))\n", "  (let ((count 0))\n    (for ([ch (in-string s)])\n\
    \      (when (and (char-upper-case? ch)\n                 (even? (string-index\
    \ s ch)))\n        (set! count (+ count 1))))\n    count))\n```\n\n```scheme\n\
    #lang racket\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
