name: HumanEval_52_below_threshold
language: rkt
prompt: "#lang racket\n\n;; Return #t if all numbers in the list l are below threshold\
  \ t.\n;; >>> (below_threshold (list 1 2 4 10) 100)\n;; #t\n;; >>> (below_threshold\
  \ (list 1 20 4 10) 5)\n;; #f\n(define (below_threshold l t)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_threshold))\n\
  \    (check-equal? (candidate (list 1 2 4 10) 100) #t)\n    (check-equal? (candidate\
  \ (list 1 20 4 10) 5) #f)\n    (check-equal? (candidate (list 1 20 4 10) 21) #t)\n\
  \    (check-equal? (candidate (list 1 20 4 10) 22) #t)\n    (check-equal? (candidate\
  \ (list 1 8 4 10) 11) #t)\n    (check-equal? (candidate (list 1 8 4 10) 10) #f)\n\
  ))\n\n(test-humaneval)"
completions: ["  (cond\n    [(null? l) #t]\n    [(> (car l) t) #f]\n    [else (below_threshold\
    \ (cdr l) t)]))\n", "  (cond\n    [(empty? l) #t]\n    [(< (first l) t) (below_threshold\
    \ (rest l) t)]\n    [else #f]))\n", "  (cond\n    [(null? l) #t]\n    [(< (car\
    \ l) t) (below_threshold (cdr l) t)]\n    [else #f]))\n", "  (cond ((null? l)\
    \ #t)\n        ((> (car l) t) #f)\n        (else (below_threshold (cdr l) t))))\n",
  "  (cond\n    [(empty? l) #t]\n    [(> (first l) t) #f]\n    [else (below_threshold\
    \ (rest l) t)]))\n", "  (define (check_l t_l)\n    (cond ((null? t_l) #t)\n  \
    \        ((< (car t_l) t) (check_l (cdr t_l)))\n          (else #f)))\n  (check_l\
    \ l))", "  (cond [(empty? l) #t]\n        [(> (first l) t) #f]\n        [else\
    \ (below_threshold (rest l) t)]))\n", "  (cond [(empty? l) #t]\n        [(< (first\
    \ l) t) (below_threshold (rest l) t)]\n        [else #f]))\n", "  (if (null? l)\n\
    \      #t\n      (if (&lt; (car l) t)\n          (below_threshold (cdr l) t)\n\
    \          #f)))\n", "  (cond\n    [(empty? l) #t]\n    [(> (first l) t) #f]\n\
    \    [else (below_threshold (rest l) t)]))\n", "  (if (null? l)\n      #t\n  \
    \    (if (< (car l) t)\n          (below_threshold (cdr l) t)\n          #f)))\n",
  "  (andmap (lambda (x) (< x t)) l))\n", "  (foldr\n   (lambda (x acc)\n     (and\
    \ (< x t) acc))\n   #t\n   l))\n", "  (cond\n    [(empty? l) #t]\n    [(< (first\
    \ l) t) (below_threshold (rest l) t)]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ l) true]\n    [(> (first l) t) false]\n    [else (below_threshold (rest l) t)]))\n",
  "  (cond\n    [(empty? l) #t]\n    [(< (first l) t) (below_threshold (rest l) t)]\n\
    \    [else #f]))\n", "  (if (empty? l)\n      #t\n      (if (&lt; (first l) t)\n\
    \          (below_threshold (rest l) t)\n          #f)))\n", "  (cond ((null?\
    \ l) #t)\n        ((< (car l) t) (below_threshold (cdr l) t))\n        (else #f)))\n",
  "  (cond\n    [(null? l) #t]\n    [(and (number? (car l)) (&lt; (car l) t)) (below_threshold\
    \ (cdr l) t)]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(< (first\
    \ l) t) (below_threshold (rest l) t)]\n    [else #f]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
