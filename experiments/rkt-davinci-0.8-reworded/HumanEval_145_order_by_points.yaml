name: HumanEval_145_order_by_points
language: rkt
prompt: "#lang racket\n\n;; Write a function which sorts the given list of integers\n\
  ;; in ascending order according to the sum of their digits.\n;; Note: if there are\
  \ several items with similar sum of their digits,\n;; order them based on their\
  \ index in original list.\n;; For example:\n;; >>> (order_by_points (list 1 11 -1\
  \ -11 -12))\n;; (list -1 -11 1 -12 11)\n;; >>> (order_by_points (list ))\n;; (list\
  \ )\n(define (order_by_points nums)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate order_by_points))\n\
  \    (check-equal? (candidate (list 1 11 -1 -11 -12)) (list -1 -11 1 -12 11))\n\
  \    (check-equal? (candidate (list 1234 423 463 145 2 423 423 53 6 37 3457 3 56\
  \ 0 46)) (list 0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457))\n    (check-equal?\
  \ (candidate (list )) (list ))\n    (check-equal? (candidate (list 1 -11 -32 43\
  \ 54 -98 2 -3)) (list -3 -32 -98 -11 1 2 43 54))\n    (check-equal? (candidate (list\
  \ 1 2 3 4 5 6 7 8 9 10 11)) (list 1 10 2 11 3 4 5 6 7 8 9))\n    (check-equal? (candidate\
  \ (list 0 6 6 -76 -21 23 4)) (list -76 -21 0 4 23 6 6))\n))\n\n(test-humaneval)"
completions: ["  (define (points n)\n    (if (= n 0)\n        0\n        (+ (remainder\
    \ n 10) (points (quotient n 10)))))\n  (define (points-num-list-helper nums)\n\
    \    (for/list ([n nums])\n      (cons (points n) n)))\n  (map second (sort (points-num-list-helper\
    \ nums) <)))\n", "  (map car\n       (sort-by (\u03BB (a b)\n                \
    \  (cond [(= (cdr a) (cdr b))\n                         (= (car a) (car b))]\n\
    \                        [(> (cdr a) (cdr b))]\n                        [else]))\n\
    \                (map (\u03BB (num)\n                       (cons num (sum-digits\
    \ num)))\n                     nums))))\n", "  (sort (map (\u03BB (num)\n    \
    \           (list num (sum-digits num)))\n             nums)\n        (\u03BB\
    \ (n1 n2) (< (cadr n1) (cadr n2)))))\n", "  (sort (build-alist nums)\n       \
    \ #:key cdr\n        #:compare <))\n", "  (define (digit-sum num)\n    (define\
    \ (df num acc)\n      (if (= num 0)\n          acc\n          (df (quotient num\
    \ 10) (+ acc (remainder num 10)))))\n    (df num 0))\n  (define (ordering nums)\n\
    \    (sort (map (lambda (n) (list n (digit-sum n))) nums) (lambda (n1 n2) (&lt;\
    \ (cadr n1) (cadr n2)))))\n  (map car (ordering nums)))\n</code>\n", "  (match\
    \ (length nums)\n    [(0) (list)]\n    [_ (apply append\n          (for/list ([n\
    \ (in-list nums)])\n            (list (list n (accumulate + 0 (map string->number\
    \ (string-&gt;list (number-&gt;string n))))))))]))\n</code>\nI'm not sure if that's\
    \ the best way to do it, but it works.  It's a single pass through the list and\
    \ does not create any new lists.\nYou might also consider using <code>quicksort</code>\
    \ or <code>mergesort</code> instead of <code>sort</code>.  For instance:\n<code>#lang\
    \ racket\n", "  (sort (map (lambda (x) (list x (string->number (number->string\
    \ x)))) nums) (lambda (a b) (cond ((< (last a) (last b)) #t) ((> (last a) (last\
    \ b)) #f) ((< (first a) (first b)) #t) ((> (first a) (first b)) #f) (else #f)))))\n",
  "  (sort (list-of-nums-to-list-of-lists nums) \n        (lambda (x y)\n        \
    \  (&lt; (sum-of-list x)\n             (sum-of-list y)\n             )\n     \
    \     )\n        )\n  )\n", "  (sort (map (lambda (x)\n               (cons x\
    \ (sum-digits x)))\n             nums)\n        (lambda (a b)\n          (cond\n\
    \            [(< (cdr a) (cdr b)) #t]\n            [(> (cdr a) (cdr b)) #f]\n\
    \            [else (< (car a) (car b))]))))\n", "  (sort nums (lambda (n1 n2)\n\
    \               (< (sum-digits n1) (sum-digits n2)))))\n", "  (sort nums\n   \
    \     (lambda (a b) (or (< (sum-digits a) (sum-digits b))\n                  \
    \        (and (= (sum-digits a) (sum-digits b))\n                            \
    \   (< (seq-position nums a) (seq-position nums b)))))))\n", "  (sort nums\n \
    \       (lambda (a b)\n          (let ((a (abs a))\n                (b (abs b)))\n\
    \            (cond\n              [(= (sum-digits a) (sum-digits b))\n       \
    \        (equal? a b)]\n              [(< (sum-digits a) (sum-digits b))\n   \
    \            true]\n              [else\n               false])))))\n", "  (define\
    \ (get-points num)\n    (if (zero? num)\n        0\n        (+ (remainder num\
    \ 10) (get-points (quotient num 10)))))\n  (define (add-points num acc)\n    (cons\
    \ (cons num (get-points num)) acc))\n  (define (sort-by-points x y)\n    (if (<\
    \ (get-points (car x)) (get-points (car y)))\n        x\n        y))\n  (define\
    \ (nums->points nums)\n    (foldl add-points '() nums))\n  (define (points->nums\
    \ points)\n    (map car points))\n  (define (get-unique points)\n    (define (el-unique?\
    \ el)\n      (not (member (car el) (map car (cdr el)))))\n    (filter el-unique?\
    \ points))\n  (define (get-unique-nums nums)\n    (points->nums (get-unique (nums->points\
    \ nums))))\n  (define (add-equals points)\n    (define (get-index-of num points)\n\
    \      (for/first ([(p) points] #:when (equal? num (car p)))\n               \
    \  (cdr p)))\n    (define (add-indexes num)\n      (cons num (get-index-of num\
    \ points)))\n    (map add-indexes (map car points)))\n  (define (sort-equals points)\n\
    \    (define (get-equals points)\n      (filter (lambda (p) (equal? (car p) (cadr\
    \ p))) points))\n    (define (get-unequals points)\n      (filter (lambda (p)\
    \ (not (equal? (car p) (cadr p)))) points))\n    (define (sort-equals points)\n\
    \      (filter (lambda (p) (equal? (car p) (cadr p))) points))\n    (define (sort-unequals\
    \ points)\n      (filter (lambda (p) (not (equal? (car p) (cadr p)))) points))\n\
    \    (append (sort-equals points) (sort-unequals points)))\n  (define (sort-by-index\
    \ points", "  (sort\n   (\u03BB (nums)\n     (\u03BB (a b)\n       (< (sum-digits\
    \ a) (sum-digits b))))\n   nums))\n", "  ;; TODO: your code here\n  (error \"\
    not implemented yet\"))\n```\n\n## Input & Output examples\n\n### Input\n```racket",
  "  (sort (append nums (map (lambda (i) (summ-digits i)) nums))\n        (lambda\
    \ (num1 num2)\n          (and (number? num1) (number? num2)\n               (<\
    \ (summ-digits num1) (summ-digits num2))))))\n", "  (define (order_by_points-iter\
    \ nums res)\n    (cond [(empty? nums) res]\n          [else (let ([next-number\
    \ (car nums)])\n                  (define (insert-number n lst)\n            \
    \        (cond [(empty? lst) (list n)]\n                          [(<= (sum-digits\
    \ n) (sum-digits (car lst)))\n                           (cons n lst)]\n     \
    \                     [else (cons (car lst) (insert-number n (cdr lst)))]))\n\
    \                  (order_by_points-iter (cdr nums) (insert-number next-number\
    \ res)))]))\n  (order_by_points-iter nums (list)))\n", "  (define (sum-of-digits\
    \ num)\n    (cond [(zero? num) 0]\n          [else (+ (remainder num 10) (sum-of-digits\
    \ (quotient num 10)))]))\n  (define (find-max lst)\n    (if (null? (cdr lst))\n\
    \        (car lst)\n        (if (< (sum-of-digits (car lst)) (sum-of-digits (cadr\
    \ lst)))\n            (find-max (cdr lst))\n            (car lst))))\n  (define\
    \ (find-max-index lst)\n    (if (equal? (find-max lst) (car lst))\n        0\n\
    \        (+ 1 (find-max-index (cdr lst)))))\n  (define (remove-max lst)\n    (if\
    \ (equal? (find-max lst) (car lst))\n        (cdr lst)\n        (cons (car lst)\
    \ (remove-max (cdr lst)))))\n  (define (recursive-order lst result)\n    (if (null?\
    \ lst)\n        result\n        (recursive-order (remove-max lst) (cons (find-max\
    \ lst) result))))\n  (recursive-order nums (list)))\n", "  (local [(define (order_by_points-iter\
    \ xs acc)\n            (if (null? xs)\n                acc\n                (let*\
    \ ([x (car xs)]\n                       [xs (cdr xs)]\n                      \
    \ [acc (append acc (list x))])\n                  (order_by_points-iter xs acc))))]\n\
    \    (order_by_points-iter nums '())))\n", "  (let ([lst (map (lambda (n) (list\
    \ n (sum-digits n))) nums)])\n    (map first (sort lst (lambda (a b)\n       \
    \                    (cond\n                             [(> (second a) (second\
    \ b)) #t]\n                             [(< (second a) (second b)) #f]\n     \
    \                        [else\n                              (< (position (first\
    \ a) nums)\n                                 (position (first b) nums))]))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
