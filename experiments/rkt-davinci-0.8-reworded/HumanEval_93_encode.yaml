name: HumanEval_93_encode
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a message, and encodes in\
  \ such a \n;; way that it swaps case of all letters, replaces all vowels in \n;;\
  \ the message with the letter that appears 2 places ahead of that \n;; vowel in\
  \ the english alphabet. \n;; Assume only letters. \n;; Examples:\n;; >>> (encode\
  \ \"test\")\n;; \"TGST\"\n;; >>> (encode \"This is a message\")\n;; \"tHKS KS C\
  \ MGSSCGG\"\n(define (encode message)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n\
  \    (check-equal? (candidate \"TEST\") \"tgst\")\n    (check-equal? (candidate\
  \ \"Mudasir\") \"mWDCSKR\")\n    (check-equal? (candidate \"YES\") \"ygs\")\n  \
  \  (check-equal? (candidate \"This is a message\") \"tHKS KS C MGSSCGG\")\n    (check-equal?\
  \ (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\")\n))\n\
  \n(test-humaneval)"
completions: ["  (letrec ([swap-case (lambda (char)\n                        (if (char-upper-case?\
    \ char)\n                            (char-downcase char)\n                  \
    \          (char-upcase char)))]\n           [shift (lambda (char)\n         \
    \           (if (or (char=? char #\\a) (char=? char #\\e) (char=? char #\\i) (char=?\
    \ char #\\o) (char=? char #\\u))\n                        (cons (swap-case char)\
    \ #\\c)\n                        (cons (swap-case char) (swap-case char))))])\n\
    \    (string-append (map shift (string->list message)))))\n", "  (let ((list-message\
    \ (list->string (string->list message))))\n    (printf \"list-message: ~a\\n\"\
    \ list-message)\n    (display (string-replace list-message (string->list \"aAeEiIoOuU\"\
    ) (string->list \"yYhHjJpPvV\")))))\n", "  (cond [(empty? message) empty]\n  \
    \      [else (cons (swapcase (first message))\n                    (encode (rest\
    \ message)))]))", "  (cond\n    [(empty? message) empty]\n    [else (cons\n  \
    \          (char-upcase (char-upcase (first message)))\n            (encode (rest\
    \ message)))]))", "  (cond\n    [(string=? message \"\") \n     \"\"]\n    [(string=?\
    \ (substring message 0 1) (substring message 0 1) )\n     (string-append\n   \
    \   (substring message 0 1)\n      (encode (substring message 1)))]\n    [(string=?\
    \ (substring message 0 1) (substring message 0 1) )\n     (string-append\n   \
    \   (substring message 0 1)\n      (encode (substring message 1)))]\n    [else\n\
    \     (string-append\n      (string-append\n       (substring message 0 1)\n \
    \      (substring message 1))\n      (encode (substring message 2)))]))\n", " \
    \ (cond\n    [(empty? message) empty]\n    [else (append (encode-char (first message))\n\
    \                  (encode (rest message)))]))\n", "  (for/list ([char (in-string\
    \ message)])\n    (cond [(char-alphabetic? char)\n           (cond [(char-vowel?\
    \ char)\n                  (integer->char (+ 2 (char->integer char)))]\n     \
    \            [else\n                  (cond [(char-upcase? char)\n           \
    \              (char-downcase char)]\n                        [else\n        \
    \                 (char-upcase char)])])]\n          [else\n           char])))\n\
    </code>\nObviously, I'd like to replace each of the nested <code>cond</code>s\
    \ with some kind of <code>match</code> expression, but I'm not sure how to.\n\n\
    \nA:\n\nI think <code>cond</code> is a bit better suited for tasks like this.\
    \ But it is also possible to use pattern matching in this way:\n<code>(define\
    \ (encode message)\n  (for/list ([char (in-string message)])\n    (match (cons\
    \ char '())\n      [(cons #\\a ..) (integer-&gt;char (+ (char-&gt;integer char)\
    \ 2))]\n      [(cons #\\e ..) (integer-&gt;char (+ (char-&gt;integer char) 2))]\n\
    \      [(cons #\\i ..) (integer-&gt;char (+ (char-&gt;integer char) 2))]\n   \
    \   [(cons #\\o ..) (integer-&gt;char (+ (char-&gt;integer char) 2))]\n      [(cons\
    \ #\\u ..) (integer-&gt;char (+ (char-&gt;integer char) 2))]\n      [(cons #\\\
    A ..) (char-downcase char)]\n      [(cons #\\E ..) (char-downcase char)]\n   \
    \   [(cons #\\I ..) (char-downcase char)]\n      [(cons #\\O ..) (char-downcase\
    \ char)]\n      [(cons #\\U ..) (char-downcase char)]\n      [(cons #\\B ..) (char-upcase\
    \ char)]\n      [(cons #\\C ..) (char-upcase char)]\n      [(cons #\\D ..) (char-upcase\
    \ char)]\n      [(cons #\\F ..) (char-upcase char)]\n", "  (regexp-replace* #rx\"\
    [aeiou]\" message\n                   (lambda (m)\n                     (string-upcase\n\
    \                      (string-ref (string-append message \"XX\")\n          \
    \                        (+ 2 (string-index message (string-downcase m))))))))\n\
    ```\n\n```Racket", "  (string-map (lambda (x)\n                (let ((char (string-ref\
    \ message x)))\n                  (if (char-alphabetic? char)\n              \
    \        (if (char-vowel? char)\n                          (encode-one-vowel char)\n\
    \                          (encode-one-consonant char))\n                    \
    \  char)))\n              message))\n", "  (for/list ([m (in-string message)])\n\
    \    (cond \n      [(char-lower-case? m) (char-upcase m)]\n      [(char-upper-case?\
    \ m) (char-downcase m)]\n      [(char=? m #\\a) #\\c]\n      [(char=? m #\\e)\
    \ #\\g]\n      [(char=? m #\\i) #\\k]\n      [(char=? m #\\o) #\\q]\n      [(char=?\
    \ m #\\u) #\\w]\n      [(char=? m #\\A) #\\C]\n      [(char=? m #\\E) #\\G]\n\
    \      [(char=? m #\\I) #\\K]\n      [(char=? m #\\O) #\\Q]\n      [(char=? m\
    \ #\\U) #\\W]\n      [else m])))\n", "  (define (chr-upcase c)\n    (integer->char\
    \ (+ (char-upcase (char->integer c))\n                      (if (char-alphabetic?\
    \ c) 0 32))))\n  (define (letter-offset? c)\n    (if (char-alphabetic? c)\n  \
    \      (if (char-lower-case? c)\n            (- (char-upcase c) c)\n         \
    \   (- c (char-downcase c)))\n        0))\n  (string-&gt;list\n   (string-map\n\
    \    (lambda (c)\n      (if (memq c '(#\\a #\\e #\\i #\\o #\\u))\n          (chr-upcase\
    \ (+ (char-upcase c) 2))\n          (chr-upcase c)))\n    (string-map (lambda\
    \ (c) (chr-upcase c)) message))))\n", "  (define (swapCase ch)\n    (cond\n  \
    \    [(char-lower-case? ch) (char-upcase ch)]\n      [(char-upper-case? ch) (char-downcase\
    \ ch)]\n      [else ch]))\n  (define (encode-letter ch)\n    (define vowel-map\
    \ '((#\\a . #\\c) (#\\e . #\\g) (#\\i . #\\k) (#\\o . #\\q) (#\\u . #\\y)))\n\
    \    (cond\n      [(member ch '(#\\a #\\e #\\i #\\o #\\u))\n       (cdr (assoc\
    \ ch vowel-map))]\n      [(member ch '(#\\A #\\E #\\I #\\O #\\U))\n       (char-downcase\
    \ (cdr (assoc (char-downcase ch) vowel-map)))]\n      [else (swapCase ch)]))\n\
    \  (define (aux cur)\n    (cond\n      [(empty? cur) (list)]\n      [else (cons\
    \ (encode-letter (first cur)) (aux (rest cur)))]))\n  (list->string (aux (string->list\
    \ message))))\n</code>\nI would like to know if there are some ways to make this\
    \ code less complex and/or more functional.\n\n\nA:\n\nFor the sake of this answer,\
    \ I am going to ignore the requirement of swapping case.  I am going to focus\
    \ on code clarity and ease of understanding.\n\nThere are unnecessary parenthesis\
    \ used at certain places.  As a result, it is difficult to tell what the intent\
    \ of the author was.\n<code>(if (or (empty? s) (empty? m)) empty (cons (char-&gt;integer\
    \ (first s)) (encode-message (rest s) m)))\n</code>\n\nIt is a good idea to use\
    \ a better name than <code>s</code> or <code>m</code> when defining the parameter\
    \ names.  Since the comments make it clear what the arguments are, it is a good\
    \ idea to use descriptive names.\n\nThere is a lot of repetition in the <code>encode-letter</code>\
    \ function.  In fact, the only difference between the two cases are the value\
    \ of <code>a", "  (let ([chars (string->list message)])\n    (map (lambda (c)\n\
    \           (cond\n             [(char-alphabetic? c)\n              (let ([i\
    \ (char-downcase c)])\n                (if (member i (string->list \"aeiou\"))\n\
    \                    (let ([j (+ 2 i)])\n                      (if (> j #\\u)\n\
    \                          (char (- j #\\u))\n                          (char\
    \ j)))\n                    (if (char-lower-case? c)\n                       \
    \ (char-upcase c)\n                        (char-downcase c))))]\n           \
    \  [else c]))\n         chars)))\n", "  (list->string (map char-upcase message)))\n",
  "  (build-string (string-length message)\n                (lambda (i)\n        \
    \          (let ((pchar (string-ref message i)))\n                    (if (char-alphabetic?\
    \ pchar)\n                        (let ((lcase (char-downcase pchar)))\n     \
    \                     (cond ((or (char=? lcase #\\a)\n                       \
    \              (char=? lcase #\\e)\n                                     (char=?\
    \ lcase #\\i)\n                                     (char=? lcase #\\o)\n    \
    \                                 (char=? lcase #\\u))\n                     \
    \            (let ((next (list-ref (list #\\b #\\c #\\d #\\f #\\g)\n         \
    \                                              (- (char-downcase pchar) #\\a))))\n\
    \                                   (if (char-alphabetic? next)\n            \
    \                           (char-upcase next)\n                             \
    \          next)))\n                                (else (if (char-alphabetic?\
    \ pchar)\n                                          (char-upcase pchar)\n    \
    \                                      pchar))))\n                        pchar))))))\n",
  "  (define (letter-in-string? string letter)\n    (let loop ([i 0])\n      (if (equal?\
    \ i (string-length string))\n          #f\n          (if (equal? (string-ref string\
    \ i) letter)\n              #t\n              (loop (+ i 1))))))\n  (define (encode-letter\
    \ letter)\n    (cond [(letter-in-string? \"AaEeIiOoUu\" letter)\n           (string-upcase\
    \ (string-ref \"DdFfHhJjLl\" (- (string-ci=? letter \"U\") 1)))]\n          [(letter-in-string?\
    \ \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\" letter)\n         \
    \  (string-upcase (string-ref \"CcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZzAaBb\"\
    \ (- (string-ci=? letter \"z\") 1)))]\n          [else\n           (letter)]))\n\
    \  (define (encode-string string)\n    (let loop ([i 0] [result \"\"])\n     \
    \ (if (equal? i (string-length string))\n          result\n          (loop (+\
    \ i 1) (string-append result (encode-letter (string-ref string i)))))))\n  (encode-string\
    \ message))\n</code>\nIt checks if the letter is a vowel and if it is, it encodes\
    \ it by adding two places in the alphabet, otherwise it checks if the letter is\
    \ in the alphabet and if it is it encodes it by subtracting two places from the\
    \ alphabet, otherwise it returns the letter unchanged.\nThe problem was that when\
    \ I tested with the strings <code>\"This is a message\"</code> and <code>\"test\"\
    </code> the function returned <code>\"tHKS KS C MGSSCGG\"</code> and <code>\"\
    TGST\"</code> respectively, when it should have returned <code>\"tHKS KS", " \
    \ (define (swap-case c)\n    (cond\n      [(or (char=? c #\\a) (char=? c #\\A))\
    \ #\\@]\n      [(or (char=? c #\\e) (char=? c #\\E)) #\\3]\n      [(or (char=?\
    \ c #\\i) (char=? c #\\I)) #\\1]\n      [(or (char=? c #\\o) (char=? c #\\O))\
    \ #\\0]\n      [(or (char=? c #\\u) (char=? c #\\U)) #\\8]\n      [(or (char=?\
    \ c #\\Y) (char=? c #\\y)) #\\7]\n      [(upper-case? c) (lower-case c)]\n   \
    \   [(lower-case? c) (upper-case c)]\n      [else c]))\n  (define (encode-char\
    \ c)\n    (cond\n      [(or (char=? c #\\a) (char=? c #\\A)) (swap-case #\\c)]\n\
    \      [(or (char=? c #\\e) (char=? c #\\E)) (swap-case #\\g)]\n      [(or (char=?\
    \ c #\\i) (char=? c #\\I)) (swap-case #\\k)]\n      [(or (char=? c #\\o) (char=?\
    \ c #\\O)) (swap-case #\\m)]\n      [(or (char=? c #\\u) (char=? c #\\U)) (swap-case\
    \ #\\q)]\n      [(or (char=? c #\\Y) (char=? c #\\y)) (swap-case #\\s)]\n    \
    \  [else (swap-case c)]))\n  (string-join (map encode-char (string->list message))))",
  "  (define (next-char char-value)\n    (cond\n      [(= char-value 122) (mod (+\
    \ char-value 2) 122)]\n      [(= char-value 90) (mod (+ char-value 2) 90)]\n \
    \     [else (+ char-value 2)]))\n  (define (is-vowel? char)\n    (cond\n     \
    \ [(eq? char 'A) #t]\n      [(eq? char 'E) #t]\n      [(eq? char 'I) #t]\n   \
    \   [(eq? char 'O) #t]\n      [(eq? char 'U) #t]\n      [(eq? char 'a) #t]\n \
    \     [(eq? char 'e) #t]\n      [(eq? char 'i) #t]\n      [(eq? char 'o) #t]\n\
    \      [(eq? char 'u) #t]\n      [else #f]))\n  (define (encode-char char)\n \
    \   (let ((char-value (char->integer char)))\n      (cond\n        [(char-alphabetic?\
    \ char)\n         (if (is-vowel? char)\n             (integer->char (next-char\
    \ char-value))\n             (if (char-upper-case? char)\n                 (integer->char\
    \ (- char-value 32))\n                 (integer->char (+ char-value 32))))]\n\
    \        [else char])))\n  (string-map encode-char message))\n", "  (map (\u03BB\
    \ (c)\n         (cond [(char-alphabetic? c)\n                (cond [(char-uppercase?\
    \ c)\n                       (int-&gt;char (+ (char-&gt;integer c) 1))]\n    \
    \                  [(char-lowercase? c)\n                       (int-&gt;char\
    \ (- (char-&gt;integer c) 1))])]\n               [else c]))\n       message))\n\
    </code>\nMy problem is I am having trouble with the second part of the question\
    \ which is the message encoding. I believe I did the first part correctly which\
    \ is to swap the case, but I am not sure how to replace the vowel in the message.\n\
    \n\nA:\n\nYou're not far from it. The only thing that's wrong is that your <code>char-&gt;integer</code>\
    \ and <code>integer-&gt;char</code> are not properly interacting with the rest\
    \ of the problem.\nThe Unicode set provides a layout for the letters of the english\
    \ alphabet that matches the alphabetical ordering. This means that if we have\
    \ a character representing one letter and we want the next one, then we can just\
    \ convert it to an integer, add one, and then convert it back into a character.\n\
    You can use this fact to convert from one vowel to the next one. Since you have\
    \ to add two, you have to also make sure to handle the special case of <code>z</code>\
    \ and <code>Z</code>.\nThe following code is provided for your convenience and\
    \ to avoid giving you the answer on a silver platter. It is not perfect, but it\
    \ should be enough to help you out of your problem and, who knows, maybe you'll\
    \ find the right answer all by yourself!\n<code>(define (next-vowel c)\n  (define\
    \ next-pos (-&gt;integer c))\n  (set! next-pos (+ next-pos 2))\n  (if (&gt; next-pos\
    \ 122)\n      (set! next-pos (char-&gt;integer #\\A))\n      (set! next-pos (+\
    \ next-pos 1)))\n  (int-&gt;char next-pos))\n</code>\n", "  (let ((message-characters\
    \ (string->list message)))\n    (string-append\n     (map (lambda (char)\n   \
    \         (cond ((eq? char #\\e) #\\g)\n                  ((eq? char #\\i) #\\\
    k)\n                  ((eq? char #\\o) #\\q)\n                  ((eq? char #\\\
    u) #\\w)\n                  ((eq? char #\\a) #\\c)\n                  ((eq? char\
    \ #\\E) #\\G)\n                  ((eq? char #\\I) #\\K)\n                  ((eq?\
    \ char #\\O) #\\Q)\n                  ((eq? char #\\U) #\\W)\n               \
    \   ((eq? char #\\A) #\\C)\n                  (else (if (char-lower-case? char)\n\
    \                            (char-upcase char)\n                            (char-downcase\
    \ char)))))\n          message-characters))))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
