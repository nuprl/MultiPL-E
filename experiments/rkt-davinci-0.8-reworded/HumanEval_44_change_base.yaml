name: HumanEval_44_change_base
language: rkt
prompt: "#lang racket\n\n;; Change numerical base of input number x to base.\n;; return\
  \ string representation after the conversion.\n;; base numbers are less than 10.\n\
  ;; >>> (change_base 8 3)\n;; \"22\"\n;; >>> (change_base 8 2)\n;; \"1000\"\n;; >>>\
  \ (change_base 7 2)\n;; \"111\"\n(define (change_base x base)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n\
  \    (check-equal? (candidate 8 3) \"22\")\n    (check-equal? (candidate 9 3) \"\
  100\")\n    (check-equal? (candidate 234 2) \"11101010\")\n    (check-equal? (candidate\
  \ 16 2) \"10000\")\n    (check-equal? (candidate 8 2) \"1000\")\n    (check-equal?\
  \ (candidate 7 2) \"111\")\n    (check-equal? (candidate 2 3) \"2\")\n    (check-equal?\
  \ (candidate 3 4) \"3\")\n    (check-equal? (candidate 4 5) \"4\")\n    (check-equal?\
  \ (candidate 5 6) \"5\")\n    (check-equal? (candidate 6 7) \"6\")\n    (check-equal?\
  \ (candidate 7 8) \"7\")\n))\n\n(test-humaneval)"
completions: ["  (define (change_base-iter x base result)\n    (cond ((&lt; x base)\n\
    \           (string-append (number-&gt;string x) result))\n          (else\n \
    \          (change_base-iter (quotient x base) base (string-append (number-&gt;string\
    \ (remainder x base)) result)))))\n  (change_base-iter x base \"\"))\n", "  (cond\
    \ ((< x base) (number->string x))\n        (else (string-append (change_base (quotient\
    \ x base) base)\n                             (number->string (remainder x base))))))\n",
  "  (cond\n    [(= x 0) \"\"]\n    [else (string-append (change_base (quotient x\
    \ base) base)\n                         (number->string (remainder x base)))]))\n",
  "  (cond [(= x 0) \"\"]\n        [else (append (change_base (quotient x base) base)\n\
    \                      (list (number->string (remainder x base))))]))", "  (cond\n\
    \    [(< x 10) (number->string x)]\n    [else (string-append (change_base (quotient\
    \ x base) base)\n                         (number->string (remainder x base)))]))\n\
    ```\n\n```\n#lang racket\n", "  (if (= x 0)\n      \"\"\n      (string-append\
    \ (change_base (quotient x base) base)\n                     (number->string (remainder\
    \ x base)))))\n", "  (if (= base 10)\n      (number->string x)\n      (if (= x\
    \ 0)\n          \"0\"\n          (string-append (change_base (/ x base) base)\n\
    \                         (number->string (modulo x base))))))\n", "  (change_base_helper\
    \ x base \"\"))\n", "  (define (change-base-iter x base)\n    (cond ((= x 0)\n\
    \           '())\n          (else\n           (cons (modulo x base)\n        \
    \         (change-base-iter (quotient x base) base)))))\n  (let loop ((xs (change-base-iter\
    \ x base))\n             (ans '()))\n    (cond ((null? xs)\n           (reverse\
    \ ans))\n          (else\n           (loop (cdr xs)\n                 (cons (number->string\
    \ (car xs))\n                       ans))))))\n", "  (define (change_base_iter\
    \ x base result)\n    (if (= x 0)\n        result\n        (change_base_iter (quotient\
    \ x base) base (string (+ (remainder x base) #\\0) result))))\n  (change_base_iter\
    \ x base \"\"))\n", "  (define (change_base-iter x base r)\n    (cond [(= x 0)\
    \ r]\n          [else (change_base-iter\n                 (/ x base)\n       \
    \          base\n                 (number->string (+ (* base (string->number r))\n\
    \                                    (remainder x base))))]))\n  (change_base-iter\
    \ x base \"0\"))\n", "  (if (= x 0)\n      \"0\"\n      (let loop ([rem (modulo\
    \ x base)]\n                 [result \"\"]\n                 [x (/ x base)])\n\
    \        (if (= x 0)\n            (string-append result (number->string rem))\n\
    \            (loop (modulo x base)\n                  (string-append result (number->string\
    \ rem))\n                  (/ x base))))))\n", "  (define (change-base-iter x\
    \ result)\n    (if (= x 0)\n        result\n        (change-base-iter (quotient\
    \ x base) (string (remainder x base) result))))\n  (change-base-iter x \"\"))\n",
  "  (number->string (number->integer (string->number (number->string x) base))))\n",
  "  (define (accumulator x base acc)\n    (if (&lt; x base)\n        (string-append\
    \ (number-&gt;string x) acc)\n        (accumulator (/ x base) base (string-append\
    \ (number-&gt;string (remainder x base)) acc))))\n  (accumulator x base \"\"))\n",
  "  (let ((num x)\n        (output \"\"))\n    (while (> num 0)\n      (set! output\
    \ (string-append output (number->string (remainder num base))))\n      (set! num\
    \ (quotient num base)))\n    (reverse output)))\n", "  (if (= x 0)\n      \"\"\
    \n      (string-append (change_base (quotient x base) base)\n                \
    \     (number->string (remainder x base)))))\n", "  (string-append\n   (if (=\
    \ (remainder x base) 0)\n       \"\"\n       (number->string (remainder x base)))\n\
    \   (if (= x 0)\n       \"\"\n       (change_base (quotient x base) base))))\n",
  "  (define (aux n acc)\n    (if (zero? n)\n        acc\n        (aux (quotient n\
    \ base)\n             (cons (modulo n base) acc))))\n  (string-join (reverse (map\
    \ number->string (aux x '()))) \"\"))\n", "  (cond\n    [(<= x 0) \"\"]\n    [else\n\
    \     (change_base (quotient x base) base)\n     (number->string (remainder x\
    \ base))]))\n", "  (define (change-base-iter x d)\n    (if (= x 0)\n        \"\
    \"\n        (begin\n          (string-append (number->string (remainder x base))\
    \ (change-base-iter (quotient x base) d)))))\n  (change-base-iter x base))\n",
  "  (define (helper x base)\n    (if (= x 0) '()\n        (cons (remainder x base)\
    \ (helper (floor (/ x base)) base))))\n  (reverse (map number->string (helper\
    \ x base))))\n", "  (if (= x 0)\n      \"0\"\n      (string-append (change_base\
    \ (/ x base) base) (number->string (% x base)))))\n", "  (cond [(= x 0) \"\"]\n\
    \        [else\n         (number->string\n          (+ (remainder x base) 48)\n\
    \          (change_base (quotient x base) base))]))\n", "  (if (= x 0)\n     \
    \ \"\"\n      (string-append (change_base (quotient x base) base)\n          \
    \           (string (remainder x base)))))\n", "  (cond [(< x base) (number->string\
    \ x)]\n        [else (string-append (change_base (quotient x base) base) (number->string\
    \ (remainder x base)))]))\n", "  (if (= x 0)\n      \"\"\n      (string-append\
    \ (change_base (quotient x base) base)\n                     (number->string (remainder\
    \ x base)))))\n", "  (string-append (string-concatenate (map (\u03BB (x) (string\
    \ (char x))) (reverse (integer->list x base))))))\n", "  (cond [(= x 0) \"\"]\n\
    \        [else (change_base (- x 1) base) (number->string (- x 1))]))\n```\n\n\
    ## References\n\n- [(How to Think Like a Computer Scientist -- Learning with Python:\
    \   \nChapter 1 A Word About Python (\uC911\uB7B5)](http://openbookproject.net/thinkcs/python/english3e/the_first_program.html)\n\
    - [The First Program](https://runestone.academy/runestone/books/published/thinkcspy/SimplePythonData/TheFirstProgram.html)\n\
    - [Chapter 2 - Simple Expressions](https://runestone.academy/runestone/books/published/thinkcspy/SimplePythonData/Chapter02.html)\n\
    - [Chapter 3 - Functions](https://runestone.academy/runestone/books/published/thinkcspy/Functions/toctree.html)\n\
    - [Chapter 4 - Conditionals](https://runestone.academy/runestone/books/published/thinkcspy/Conditionals/toctree.html)\n\
    - [Chapter 5 - Fruitful Functions](https://runestone.academy/runestone/books/published/thinkcspy/FruitfulFunctions/toctree.html)\n\
    - [Chapter 6 - Iteration](https://runestone.academy/runestone/books/published/thinkcspy/Iteration/toctree.html)\n\
    - [Chapter 7 - Strings](https://runestone.academy/runestone/books/published/thinkcspy/Strings/toctree.html)\n\
    - [Chapter 8 - Case Study: Interface Design](https://runestone.academy/runestone/books/published/thinkcspy/CaseStudyInterfaceDesign/toctree.html)\n\
    - [Chapter 9 - Lists](https://runestone.academy/runestone/books/published/thinkcspy/Lists/toctree.html)\n\
    - [Chapter 10 - Dictionaries](https://runestone.academy/runestone/books/published/thinkcspy/Dictionaries/toctree.html)\n\
    - [Chapter 11 - Tuples](https://runestone", "  (define (change x result)\n   \
    \ (cond\n      [(= x 0) (build-list (length result) (lambda (i) #\\0))]\n    \
    \  [(zero? (modulo x base)) (change (quotient x base) (cons #\\0 result))]\n \
    \     [else (change (quotient x base) (cons (digit->char (+ (modulo x base) 48))\
    \ result))]))\n  (list->string (change x '())))\n", "  (if (= x 0)\n      \"\"\
    \n      (change_base (quotient x base) base)\n      (number->string (remainder\
    \ x base))))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (string-append (change_base\
    \ (quotient x base) base)\n                         (number->string (remainder\
    \ x base)))]))\n", "  (if (= x 0)\n      (string-append \"\" \"\")\n      (string-append\
    \ (change_base (quotient x base) base) (number->string (remainder x base)))))\n",
  "  (define (iter x base result)\n    (cond ((= x 0) (number->string result))\n \
    \         (else (iter (quotient x base) base (+ (* base (remainder x base)) result)))))\n\
    \  (iter x base 0))\n", "  (if (zero? x)\n      \"\"\n      (let ([r (modulo x\
    \ base)])\n        (string-append (change_base (quotient x base) base)\n     \
    \                  (number->string r)))))\n", "  (if (zero? x)\n      \"0\"\n\
    \      (if (negative? x)\n          (string-append \"-\" (change_base (- x) base))\n\
    \          (if (< x base)\n              (number->string x)\n              (string-append\
    \ (change_base (quotient x base) base) (number->string (remainder x base)))))))\n",
  "  (define (change_base x base out)\n    (cond [(< x base) (string-append out (number->string\
    \ x))]\n          [else (change_base (quotient x base) base\n                \
    \             (string-append out (number->string (remainder x base))))]))\n  (change_base\
    \ x base \"\"))\n", "  (cond [(< x base) (number->string x)]\n        [else (string-append\
    \ (change_base (quotient x base) base)\n                             (number->string\
    \ (remainder x base)))]))\n```\n\n```\n#lang racket\n", "  (cond ((zero? x) \"\
    \")\n        (else (string-append (number->string (remainder x base))\n      \
    \                       (change_base (quotient x base) base)))))\n```\n\n```racket\n\
    #lang racket\n", "  (cond\n    [(eq? x 0) \"\"]\n    [else (append (change_base\
    \ (quotient x base) base)\n                  (number->string (remainder x base)))]))\n",
  "  (cond\n    [(< x base) (number->string x)]\n    [else (string-append (change_base\
    \ (quotient x base) base)\n                         (number->string (remainder\
    \ x base)))]))\n```\n\n# Chapter 15: Objects and Classes\n\n## Ex. 15.1\n\n```\
    \ #lang racket\n", "  (let loop ([x x] [digits '()])\n    (cond\n      [(zero?\
    \ x) (list->string (reverse digits))]\n      [else (loop (quotient x base) (cons\
    \ (remainder x base) digits))])))\n", "  (let loop ([x x] [acc 0] [i 0])\n   \
    \ (cond [(zero? x)\n           (number->string acc)]\n          [else\n      \
    \     (loop (quotient x base)\n                 (+ (* (remainder x base) (expt\
    \ 10 i)) acc)\n                 (+ i 1))])))\n", "  (change_base_rec x base \"\
    \"))\n", "  (define (change_base_iter x base acc)\n    (if (= x 0) acc\n     \
    \   (change_base_iter (quotient x base) base (string (+ (remainder x base) #\\\
    0) acc))))\n  (change_base_iter x base \"\"))\n", "  (number->string (number->base\
    \ x base)))\n", "  (define (loop x r)\n    (cond\n      [(zero? x) r]\n      [else\
    \ (loop (quotient x base) (string (remainder x base) r))]))\n  (loop x \"\"))\n",
  "  (number->string (number->base-n x base)))\n", "  (cond\n    [(= x 0) \"\"]\n\
    \    [else (string-append (change_base (quotient x base) base)\n             \
    \            (number->string (remainder x base)))]))\n", "  (cond [(< x base)\
    \ (number->string x)]\n        [else (string-append (change_base (quotient x base)\
    \ base)\n                             (number->string (remainder x base)))]))\n",
  "  (number->string\n   (inexact->exact\n    (round\n     (* (/ x 10.0) (expt base\
    \ 10))))))\n", "  (define (f x)\n    (if (zero? x)\n        \"\"\n        (number->string\
    \ (+ (* base (f (quotient x base))) (remainder x base)))))\n  (string-append (f\
    \ x) \"\"))\n", "  (define (change_base-iter x result)\n    (if (zero? x)\n  \
    \      result\n        (change_base-iter (quotient x base) (string (remainder\
    \ x base) result))))\n  (change_base-iter x \"\"))\n", "  (define (div_mod x div)\n\
    \    (let ([div_x (/ x div)]\n          [mod_x (- x (* div_x div))])\n      (list\
    \ div_x mod_x)))\n  (define (iter x div str-x)\n    (let ([div_x (div_mod x div)])\n\
    \      (if (eq? (car div_x) 0)\n          (string-append (number->string (cadr\
    \ div_x)) str-x)\n          (iter (car div_x) div (string-append (number->string\
    \ (cadr div_x)) str-x)))))\n  (iter x base \"\"))\n", "  (if (zero? x)\n     \
    \ \"0\"\n      (begin\n        (if (= 1 x)\n            \"1\"\n            (begin\n\
    \              (if (= base 2)\n                  (string-append (change_base (/\
    \ x 2) base) (number->string (remainder x 2)))\n                  (begin\n   \
    \                 (if (= base 3)\n                        (string-append (change_base\
    \ (/ x 3) base) (number->string (remainder x 3)))\n                        (begin\n\
    \                          (if (= base 4)\n                              (string-append\
    \ (change_base (/ x 4) base) (number->string (remainder x 4)))\n             \
    \                 (begin\n                                (if (= base 5)\n   \
    \                                 (string-append (change_base (/ x 5) base) (number->string\
    \ (remainder x 5)))\n                                    (begin\n            \
    \                          (if (= base 6)\n                                  \
    \        (string-append (change_base (/ x 6) base) (number->string (remainder\
    \ x 6)))\n                                          (begin\n                 \
    \                           (if (= base 7)\n                                 \
    \               (string-append (change_base (/ x 7) base) (number->string (remainder\
    \ x 7)))\n                                                (begin\n           \
    \                                       (if (= base 8)\n                     \
    \                                 (string-append (change_base (/ x 8) base) (number->string\
    \ (remainder x 8)))\n                                                      (begin\n\
    \                                                        (if (= base 9)\n    \
    \                                                        (string-append (change_base\
    \ (/ x 9) base) (number->string (remainder x 9)))\n                          \
    \                                  \"error\"))))))))))))))))))))\n", "  (define\
    \ (digit x)\n    (remainder x base))\n  (define (recur x digits)\n    (if (zero?\
    \ x)\n        digits\n        (recur (quotient x base) (cons (digit x) digits))))\n\
    \  (define (accumulate digits)\n    (if (null? digits)\n        \"\"\n       \
    \ (string-append (number->string (car digits)) (accumulate (cdr digits)))))\n\
    \  (accumulate (recur x '())))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (change_base\
    \ (quotient x base) base) (number->string (remainder x base))]))\n", "  (cond\
    \ ((= base 1) (make-string x #\\0))\n        ((= base 10) (number->string x))\n\
    \        (else\n         (begin\n           (define (make-str-base-1 x acc)\n\
    \             (if (= x 0)\n                 acc\n                 (make-str-base-1\
    \ (quotient x base) (string-append acc (number->string (remainder x base))))))\n\
    \           (make-str-base-1 x \"\")))))\n", "  (define (change-base-iter x base\
    \ res)\n    (cond ((= x 0)\n           (string-join (reverse res) \"\"))\n   \
    \       (else\n           (change-base-iter (quotient x base) base (cons (number->string\
    \ (remainder x base)) res)))))\n  (change-base-iter x base '()))\n", "  (define\
    \ (change-base-inter x base out-str)\n    (cond ((= x 0) out-str)\n          (else\
    \ (change-base-inter (quotient x base) base (string (+ (remainder x base) 48)\
    \ out-str)))))\n  (string-reverse (change-base-inter x base \"\")))\n", "  (cond\n\
    \    [(= x 0) \"\"]\n    [else (change_base (/ x base) base) (number->string (%\
    \ x base))]))\n", "  (number->string (string->number x base)))\n", "  (local [(define\
    \ (change_base x base result)\n            (cond [(zero? x) result]\n        \
    \          [else (change_base (quotient x base) base (string (remainder x base)\
    \ result))]))]\n    (change_base x base \"\")))\n", "  (define (change_x x base\
    \ l)\n    (if (= x 0)\n        (apply string-append (reverse l))\n        (change_x\
    \ (/ x base) base (cons (number->string (% x base)) l))))\n  (change_x x base\
    \ '()))\n", "  (local [(define (cb n base s)\n            (cond [(zero? n) s]\n\
    \                  [else (cb (quotient n base) base\n                        \
    \    (string (modulo n base) s))]))]\n    (cb x base \"\")))\n</code>\nI also\
    \ tried to use <code>number-&gt;string</code>, but it doesn't work well:\n<code>#lang\
    \ racket\n", "  (cond [(= x 0) \"\"]\n        [else (change_base (quotient x base)\
    \ base)\n              (number->string (remainder x base))]))\n", "  (define (change_to\
    \ x base)\n    (cond\n      [(= x 0) '()]\n      [else (cons (modulo x base) (change_to\
    \ (quotient x base) base))]))\n  (define (change-to-str lst)\n    (if (empty?\
    \ lst)\n        \"\"\n        (string-append (number->string (car lst)) (change-to-str\
    \ (cdr lst)))))\n  (change-to-str (reverse (change_to x base))))\n", "  (define\
    \ (iter x res)\n    (if (= x 0)\n        res\n        (iter (quotient x base)\
    \ (string (remainder x base) res))))\n  (iter x \"\"))\n", "  (define (iter x\
    \ acc)\n    (cond [(= x 0) (reverse acc)]\n          [else (iter (quotient x base)\
    \ (cons (remainder x base) acc))]))\n  (define (remainder x base)\n    (modulo\
    \ x base))\n  (define (quotient x base)\n    (inexact->exact (floor (/ x base))))\n\
    \  (define (reverse lst)\n    (foldr (lambda (x acc) (cons x acc)) '() lst))\n\
    \  (foldr (lambda (x acc) (string-append acc (number->string x))) \"\" (iter x\
    \ '())))\n", "  (cond [(= x 0) \"\" ]\n        [else\n         (string-append\
    \ (change_base (quotient x base) base)\n                        (number->string\
    \ (remainder x base)))]))\n", "  (if (= x 0) \"\"\n      (string-append (change_base\
    \ (quotient x base) base)\n                     (number->string (remainder x base)))))\n",
  "  (displayln x)\n  (let loop ((x x) (s '()))\n    (cond ((= x 0) (string-append\
    \ (map (\u03BB (a) (integer->char (+ a #\\0))) (reverse s))))\n          (else\
    \ (loop (quotient x base) (cons (remainder x base) s))))))\n", "  (let loop ((x\
    \ x) (base base) (res \"\"))\n    (cond ((zero? x) res)\n          ((eq? x base)\
    \ (string-append res \"1\"))\n          (else (let ((div (quotient x base))\n\
    \                       (rem (remainder x base)))\n                  (loop div\
    \ base (string-append res (number->string rem))))))))\n", "  (define (change_base-iter\
    \ x base num-digits)\n    (cond\n      [(= x 0) (build-string num-digits (lambda\
    \ (i) #\\0))]\n      [(= (remainder x base) 0) (change_base-iter (/ x base) base\
    \ (+ num-digits 1))]\n      [else (string-append (change_base-iter (/ x base)\
    \ base (+ num-digits 1)) (number->string (remainder x base)))]))\n  (change_base-iter\
    \ x base 0))\n", "  (number->string\n   (integer->char\n    (number->string\n\
    \     x))))\n", "  (define (change_base_helper x base)\n    (if (= x 0)\n    \
    \    '()\n        (cons (modulo x base) (change_base_helper (quotient x base)\
    \ base))))\n  (string-join (reverse (change_base_helper x base)) \"\"))\n", " \
    \ (if (= x 0)\n      \"\"\n      (string-append (number->string (% x base))\n\
    \                     (change_base (quotient x base) base))))\n", "  (local ((define\
    \ (change x base)\n             (cond [(zero? x) \"\"]\n                   [(negative?\
    \ x) (string-append \"-\" (change (- x) base))]\n                   [else (let\
    \ ([r (remainder x base)])\n                           (string-append (change\
    \ (quotient x base) base)\n                                          (number->string\
    \ r)))])))\n    (change x base)))\n", "  (number->string (string->number x base)))\n",
  "  (cond\n    [(> x base) (string-append (change_base (/ x base) base) (number->string\
    \ (remainder x base)))]\n    [else (number->string x)]))\n", "  (cond\n    [(=\
    \ x 0) \"\"]\n    [else\n     (string-append (change_base (quotient x base) base)\n\
    \                    (number->string (remainder x base)))]))\n", "  (define (transform\
    \ x)\n    (if (= x 0)\n        0\n        (+ (* x base) (transform (- x 1)))))\n\
    \  (change_base2 (transform x) \"\"))\n", "  (cond\n    [(= x 0) \"\"]\n    [else\
    \ (change_base (/ x base) base) (number->string (% x base))]))\n", "  (if (= x\
    \ 0)\n      \"\"\n      (string-append (change_base (quotient x base) base)\n\
    \                     (number->string (remainder x base)))))\n", "  (if (or (or\
    \ (not (number? x)) (not (integer? x))) (not (integer? base)))\n      \"NaN\"\n\
    \      (if (or (< base 2) (> base 10))\n          \"NaN\"\n          (if (< x\
    \ 0)\n              (string-append \"-\" (change_base (- x) base))\n         \
    \     (if (= x 0)\n                  \"0\"\n                  (number->string\
    \ (remainder x base)))))))\n", "  (number->string \n   (integer->char\n    (remainder\
    \ x base))))", "  (cond\n    [(zero? x) \"\"]\n    [else (change_base (quotient\
    \ x base) base) (number->string (remainder x base))]))\n", "  (cond [(= base 10)\
    \ (number->string x)]\n        [else (my_loop (/ x base) (modulo x base) base)]))",
  "  (cond [(= x 0) \"\"]\n        [else (string-append (change_base (quotient x base)\
    \ base)\n                             (number->string (remainder x base)))]))\n",
  "  (let loop ([x x] [out '()])\n    (if (zero? x)\n        (apply string (reverse\
    \ out))\n        (loop (quotient x base) (cons (modulo x base) out)))))\n", " \
    \ (define (change_base-iter x base)\n    (cond\n      ((= x 0) \"\")\n      (else\
    \ (change_base-iter (quotient x base) base)\n            (number->string (remainder\
    \ x base)))))\n  (change_base-iter x base))\n", "  (if (= x 0)\n      \"\"\n \
    \     (let ((remainder (% x base)))\n        (string-append (change_base (/ x\
    \ base) base) (number->string remainder)))))\n", "  (let loop ([x x] [res \"\"\
    ])\n    (if (zero? x)\n        res\n        (loop (quotient x base)\n        \
    \      (string-append res (string (modulo x base)))))))\n", "  (cond [(= x 0)\
    \ \"\"]\n        [else (string-append (change_base (quotient x base) base) (number->string\
    \ (remainder x base)))]))\n", "  (define (change_helper x2 base2 result)\n   \
    \ (if (zero? x2)\n        result\n        (change_helper (quotient x2 base2) base2\n\
    \                       (string (remainder x2 base2) result))))\n  (change_helper\
    \ x base \"\"))\n", "  (define (change_to_base_using_decimal_to_binary x base)\n\
    \    (decimal_to_binary x base))\n  (define (change_to_base_using_decimal_to_any\
    \ x base)\n    (decimal_to_any x base))\n  (cond\n    [(= base 2) (change_to_base_using_decimal_to_binary\
    \ x base)]\n    [else (change_to_base_using_decimal_to_any x base)]))\n", "  (if\
    \ (zero? x) \"\"\n      (string-append (change_base (quotient x base) base)\n\
    \                     (number->string (remainder x base)))))\n", "  (local ((define\
    \ (add_bit i)\n             (string-append i \"1\")))\n    (define (convert n\
    \ c)\n      (if (= n 0)\n          c\n          (convert (- n 1) (add_bit c))))\n\
    \    (cond\n      [(= x 0) \"0\"]\n      [(= x 1) \"1\"]\n      [else (convert\
    \ x \"\")])))\n", "  (cond\n    [(zero? x) \"\"]\n    [else (append (change_base\
    \ (quotient x base) base)\n                  (number->string (remainder x base)))]))\n",
  "  (define (rec_change_base x base)\n    (cond [(= x 0) \"\"]\n          [else\n\
    \           (rec_change_base (quotient x base) base)\n           (number->string\
    \ (remainder x base))]))\n  (rec_change_base x base))\n", "  (if (= 0 x)\n   \
    \   \"\"\n      (begin\n        (string (remainder x base))\n        (change_base\
    \ (quotient x base) base))))\n", "  (local ((define (get_numbers n)\n        \
    \    (cond ((> n base) (append (get_numbers (quotient n base))\n             \
    \                         (list (remainder n base))))\n                  (else\
    \ (list n)))))\n    (string-join (map number->string (get_numbers x)) \"\")))\n",
  "  (define (change-base-iter x rstr)\n    (cond ((= x 0) rstr)\n          (else\
    \ (change-base-iter (quotient x base) (string (+ (remainder x base) #\\0) rstr)))))\n\
    \  (change-base-iter x \"\"))\n", "  (cond ((= base 2) (number->string x 2))\n\
    \        ((= base 3) (number->string x 3))\n        ((= base 4) (number->string\
    \ x 4))\n        ((= base 5) (number->string x 5))\n        ((= base 6) (number->string\
    \ x 6))\n        ((= base 7) (number->string x 7))\n        ((= base 8) (number->string\
    \ x 8))\n        ((= base 9) (number->string x 9))\n        (else (string-append\
    \ \"Base number is not supported.\"))))\n```\n\n```racket\n#lang racket\n", " \
    \ (define (aux x base)\n    (cond ((= x 0) \"\")\n          (else (string (modulo\
    \ x base)) (aux (quotient x base) base))))\n  (reverse (aux x base)))\n", "  (define\
    \ (inner x r-str)\n    (if (= x 0) r-str\n        (let ([remainder (modulo x base)])\n\
    \          (inner (quotient x base) (string-append (number->string remainder)\
    \ r-str)))))\n  (inner x \"\"))\n", "  (letrec ((digit-to-digit\n            (lambda\
    \ (x)\n              (cond\n                [(= x 0) #f]\n                [(<\
    \ x 10) (number->string x)]\n                [else (number->string (+ x 87))])))\n\
    \           (calc\n            (lambda (x base)\n              (if (= x 0)\n \
    \                 (list \"\")\n                  (let ((rest (quotient x base)))\n\
    \                    (cons (digit-to-digit (remainder x base))\n             \
    \             (calc rest base)))))))\n    (list->string (calc x base))))\n", " \
    \ (define (change_base-inner n base acc)\n    (cond\n      [(= n 0) acc]\n   \
    \   [else (change_base-inner (quotient n base) base\n                        \
    \       (string-append acc (number->string (remainder n base))))]))\n  (change_base-inner\
    \ x base \"\"))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (append (change_base\
    \ (quotient x base) base)\n                  (number->string (remainder x base)))]))",
  "  (cond [(= x 0) \"\"]\n        [else\n         (string-append (change_base (quotient\
    \ x base) base)\n                        (string (integer->char (+ (+ (remainder\
    \ x base)\n                                                      (* base base))\
    \ 48))))]))\n", "  (if (zero? x)\n      \"\"\n      (if (= 1 base)\n         \
    \ \"1\"\n          (string-append (change_base (quotient x base) base)\n     \
    \                    (number->string (remainder x base))))))\n", "  (cond\n  \
    \  [(zero? x) \"\" ]\n    [else (number->string (remainder x base))\n        \
    \  (change_base (quotient x base) base)]))\n", "  (number->string x base))\n",
  "  (define (iter x result base)\n    (if (= x 0)\n        result\n        (let ((remainder\
    \ (modulo x base)))\n          (iter (quotient x base) (string remainder result)\
    \ base))))\n  (iter x \"\" base))\n", "  (define (to-hex x)\n    (cond\n     \
    \ [(= x 0) \"\"]\n      [else (string-append (to-hex (quotient x base)) (number->string\
    \ (remainder x base)))]))\n  (to-hex x))\n", "  (define (change_base-helper x\
    \ base acc)\n    (cond ((= x 0) acc)\n          (else (change_base-helper (quotient\
    \ x base) base (string (remainder x base) acc)))))\n  (change_base-helper x base\
    \ \"\"))\n", "  (if (= x 0)\n      \"\"\n      (number->string (+ (* x (base^(string-length(change_base\
    \ (- x 1) base)))) (char->integer (string-ref (change_base (- x 1) base) 0))))))\n\
    \n", "  (define (loop n a)\n    (if (= n 0) a\n        (loop (quotient n base)\
    \ (string (remainder n base) a))))\n  (loop x \"\"))\n", "  (cond\n    [(= x 0)\
    \ \"\"]\n    [else (string-append (change_base (quotient x base) base)\n     \
    \                    (number->string (remainder x base)))]))\n", "  (cond\n  \
    \  [(= x 0) \"\"]\n    [else\n     (append (change_base (quotient x base) base)\n\
    \             (number->string (remainder x base)))]))\n", "  (if (= x 0)\n   \
    \   \"\"\n      (string-append (change_base (quotient x base) base)\n        \
    \             (number->string (remainder x base)))))\n", "  (if (= x 0)\n    \
    \  \"\"\n      (append (change_base (quotient x base) base)\n              (number->string\
    \ (remainder x base)))))\n", "  (cond\n    [(= base 10) (number->string x)]\n\
    \    [(= x 0) \"\"]\n    [else (string-append (change_base (quotient x base) base)\n\
    \                         (number->string (remainder x base)))]))\n", "  (cond\
    \ ((= x 0) \"\")\n        (else (string-append (change_base (quotient x base)\
    \ base)\n                             (number->string (remainder x base))))))\n",
  "  (define (inner x)\n    (cond [(zero? x) \"\"]\n          [else\n           (string\
    \ (remainder x base))\n           (inner (quotient x base))]))\n  (inner x))\n\
    </code>\nWhen I type in the racket REPL:\n<code>&gt; (define (change_base x base)\n\
    \  (define (inner x)\n    (cond [(zero? x) \"\"]\n          [else\n          \
    \ (string (remainder x base))\n           (inner (quotient x base))]))\n  (inner\
    \ x))\n</code>\nit works fine and gives me the right result.\nHowever, when I\
    \ run the program by typing:\n<code>&gt; (load \"change_base.rkt\")\n&gt; (change_base\
    \ 7 2)\n</code>\nI get error:\n<code>procedure application: expected procedure,\
    \ given: #&lt;void&gt;; arguments were: 2\n</code>\nWhy is this happening and\
    \ how can I fix this?\n\n\nA:\n\nThere's a discrepancy between the <code>define</code>\
    \ and the output of the function.\nWhen you enter the function on the REPL, you\
    \ get the output.\n<code>&gt; (define (change_base x base)\n  (define (inner x)\n\
    \    (cond [(zero? x) \"\"]\n          [else\n           (string (remainder x\
    \ base))\n           (inner (quotient x base))]))\n  (inner x))\n&gt; (change_base\
    \ 8 3)\n\"22\"\n</code>\nWhen you load the file and run the function, you get\
    \ the error.\n<code>&gt; (load \"change_base.rkt\")\n&gt; (change_base 8 3)\n\
    procedure application: expected procedure, given: #&lt;void&gt;; arguments were:\
    \ 3\n</code>\nSo there's a difference between the function you wrote and the function\
    \ you're running. Perhaps you changed the function in the file but forgot to restart\
    \ the REPL and load the file again?\n", "  (if (= x 0)\n      \"0\"\n      (number->string\n\
    \       (truncate\n        (/\n         (round (* (log x) (log 10 base)))\n  \
    \       (log 10 base))))))\n", "  (number->string (number-&gt;integer (string-&gt;number\
    \ x base))))\n", "  (local\n    [(define (change_base-iter x base str)\n     \
    \  (cond\n         [(< x base) (string-append str (number->string x))]\n     \
    \    [else (change_base-iter (quotient x base) base (string-append str (number->string\
    \ (remainder x base))))]))]\n    (change_base-iter x base \"\")))\n", "  (if (=\
    \ x 0)\n      \"\"\n      (change_base (/ x base) base)\n      (number->string\
    \ (remainder x base))))\n", "  (define (change_base1 x base)\n    (cond ((= x\
    \ 0) \"\")\n          (else (cons (remainder x base) (change_base1 (quotient x\
    \ base) base)))))\n  (define (convert base x)\n    (if (equal? x \"\") '()\n \
    \       (cons (if (equal? (car x) '()) '() (car x)) (convert base (cdr x)))))\n\
    \  (if (equal? (remainder x base) '()) (car (change_base1 x base))\n      (convert\
    \ base (change_base1 x base))))", "  (number->string (number->integer (number->string\
    \ x) base)))\n", "  (define (change_base_iter y base result)\n    (cond ((= base\
    \ 0) result)\n          ((= y 0) (change_base_iter (- y 1) base (append result\
    \ '(\"0\"))))\n          ((= (remainder y base) 0)\n           (change_base_iter\
    \ (/ y base) base (append result '(\"0\"))))\n          (else (change_base_iter\
    \ (/ y base) base (append result '(\"1\"))))))\n  (change_base_iter x base '()))\n\
    ```\n\n```\n$ ./change_base.rkt 8 3\n\"22\"\n```\n\n```\n$ ./change_base.rkt 8\
    \ 2\n\"1000\"\n```\n\n```\n$ ./change_base.rkt 7 2\n\"111\"\n```", "  (string->number\
    \ (number->string x base)))\n", "  (if (= x 0)\n      \"\"\n      (change_base\
    \ (quotient x base) base)\n      (number->string (remainder x base))))", "  (define\
    \ (recur x)\n    (if (= x 0)\n        \"\"\n        (begin\n          (string-append\
    \ (number->string (remainder x base))\n                         (recur (quotient\
    \ x base))))))\n  (recur x))\n", "  (define (change n)\n    (if (&lt; n base)\n\
    \        (number-&gt;string n)\n        (change (quotient n base))\n        (number-&gt;string\
    \ (remainder n base))))\n  (change x))\n", "  (if (or (equal? x 0) (equal? base\
    \ 1))\n      \"\"\n      (string-append (change_base (quotient x base) base)\n\
    \                     (number->string (remainder x base)))))\n", "  (if (zero?\
    \ x)\n      \"\"\n      (string-append (change_base (quotient x base) base) (number->string\
    \ (remainder x base)))))\n", "  (define (f n x-accum)\n    (cond [(= n 0) x-accum]\n\
    \          [else (f (- n 1)\n                   (string-append (number->string\
    \ (modulo x base)) x-accum))]))\n  (f (quotient x base) \"\"))\n", "  (define\
    \ (helper x num)\n    (if (= x 0)\n        num\n        (helper (quotient x base)\
    \ (string (remainder x base) num))))\n  (helper x \"\"))\n", "  (cond [(= x 0)\
    \ \"\"]\n        [else (change_base (/ x base) base)\n              (number->string\
    \ (% x base))]))\n", "  (define n (/ x base))\n  (define r (modulo x base))\n\
    \  (cond ((= x 0) \"\")\n        ((&lt; n 1) (number-&gt;string r))\n        (else\
    \ (string-append (change_base n base) (number-&gt;string r)))))\n", "  (cond ((=\
    \ x 0) \"\")\n        (else (number->string (remainder x base))\n            \
    \  (change_base (quotient x base) base))))\n", "  (cond [(zero? x) \"\"]\n   \
    \     [else (change_base (quotient x base) base) (number->string (remainder x\
    \ base))]))\n", "  (define (change-helper x base digits)\n    (if (= x 0)\n  \
    \      (list->string digits)\n        (change-helper (quotient x base) base (cons\
    \ (modulo x base) digits))))\n  (change-helper x base null))\n", "  (cond [(zero?\
    \ x) \"\"]\n        [else (change_base (quotient x base) base) (number->string\
    \ (remainder x base))]))\n", "  (string-append\n   (if (even? x)\n       (change_base\
    \ (quotient x 2) base)\n       (change_base (quotient (- x 1) 2) base))\n   (number->string\
    \ (remainder x 2))))\n", "  (define (change_base_iter x base n)\n    (cond ((=\
    \ n base) (string x))\n          ((= (modulo x n) 0) (string #\\0))\n        \
    \  (else (string #\\1))))\n  (if (= base 2)\n      (change_base_iter x base 2)\n\
    \      (define (next_base n)\n        (if (= (modulo x n) 0)\n            (change_base_iter\
    \ x base n)\n            (next_base (+ n 1))))\n      (next_base 2)))\n", "  (displayln\
    \ x)\n  (if (not (negative? x))\n      (string-append (change_base (- x base)\
    \ base) (number->string (% x base)))\n      (string-append (number->string (%\
    \ x base))\n                     (change_base (+ x base) base))))\n", "  (define\
    \ (helper x)\n    (if (zero? x) '()\n        (cons (remainder x base) (helper\
    \ (quotient x base)))))\n  (list->string (reverse (helper x))))\n", "  (define\
    \ (change_base_helper x)\n    (if (= x 0)\n        #f\n        (cons (modulo x\
    \ base) (change_base_helper (quotient x base)))))\n  (define (change_base_helper_2\
    \ x)\n    (if x\n        (cons (number->string (car x)) (change_base_helper_2\
    \ (cdr x)))\n        '()))\n  (apply string-append (reverse (change_base_helper_2\
    \ (change_base_helper x)))))\n```\n#### 2.8 Designing a new language\n* In this\
    \ exercise, we're given two languages, Scheme and Lisp. We're instructed to design\
    \ a new language. Since Racket is a Lisp dialect, I'm gonna use Racket to design\
    \ a new language.\n\n* The design requirements:\n  * the program should be written\
    \ in the new language\n  * the program should take an input from the user using\
    \ read\n  * the program should be able to process the input\n  * the program should\
    \ write the result of the input to the console using write\n\n* Here's a solution:\n\
    ```racket\n#lang racket\n", "  (define (change_base-iter x base)\n    (cond [(<\
    \ x base) (number->string x)]\n          [else (string-append (change_base-iter\
    \ (/ x base) base)\n                               (number->string (remainder\
    \ x base)))]))\n  (change_base-iter x base))\n", "  (cond\n    [(zero? x) \"\"\
    ]\n    [else (change_base (quotient x base) base) (number->string (remainder x\
    \ base))]))\n", "  (define (change_base_helper x base)\n    (if (= x 0) '()\n\
    \        (append (change_base_helper (quotient x base) base)\n               \
    \ (list (remainder x base)))))\n  (string-append\n   (map number->string (change_base_helper\
    \ x base))))\n", "  (cond [(= x 0) \"\"]\n        [else (let ((result (change_base\
    \ (quotient x base) base)))\n                (string-append result (number->string\
    \ (remainder x base))))]))\n", "  (cond\n    ((= x 0) \"\")\n    (else (change_base\
    \ (/ x base) base) (number->string (remainder x base)))))\n", "  (let loop ([x\
    \ x] [base base] [result \"\"])\n    (cond\n      [(= x 0) result]\n      [else\
    \ (loop (quotient x base) base (string (remainder x base) result))])))\n", " \
    \ (string->number (number->string x base)))\n", "  (if (= x 0)\n      \"\"\n \
    \     (let ([rest (change_base (quotient x base) base)])\n        (string-append\
    \ rest (number->string (remainder x base))))))\n", "  (if (null? x)\n      '()\n\
    \      (cons (list->string (list (remainder x base)))\n            (change_base\
    \ (quotient x base) base))))\n", "  (define (iter i digits)\n    (cond ((< i 0)\
    \ digits)\n          ((= i 0) (append digits (list i)))\n          (else (iter\
    \ (quotient i base)\n                      (append digits (list (remainder i base)))))))\n\
    \  (apply string (iter x '())))\n", "  (if (zero? x)\n      \"0\"\n      (if (zero?\
    \ (remainder x base))\n          (change_base (quotient x base) base)\n      \
    \    (string-append (change_base (quotient x base) base) (number->string (remainder\
    \ x base))))))\n", "  (displayln \"Write your own code here.\")\n  \"\")\n", " \
    \ (do ((x x (- (/ x base))))\n      ((zero? x) \"\")\n    (display (modulo x base))))\n",
  "  (if (zero? x)\n      \"\"\n      (number->string (remainder x base))\n      \
    \    (change_base (quotient x base) base)))\n", "  (define (loop x base res)\n\
    \    (if (&lt;= x 0) res\n        (loop (- x 1) base (string (modulo x base) res))))\n\
    \  (loop x base \"\"))\n", "  (cond\n    [(zero? x) \"\"]\n    [else (string-append\
    \ (change_base (quotient x base) base)\n                  (number->string (remainder\
    \ x base)))]))", "  (if (eq? x 0)\n      \"\"\n      (begin (string-append (change_base\
    \ (quotient x base) base)\n                            (number->string (remainder\
    \ x base))))))\n", "  (define (inner x base result)\n    (cond\n      [(zero?\
    \ x) (reverse result)]\n      [else (inner (quotient x base) base (cons (remainder\
    \ x base) result))]))\n  (string-join (inner x base '()) \"\"))\n", "  (if (equal?\
    \ x 0)\n      \"0\"\n      (begin\n        (letrec ((calc (lambda (a b acc)\n\
    \                         (if (equal? a 0)\n                             acc\n\
    \                             (calc (quotient a b) b (string-append acc (number->string\
    \ (remainder a b))))))))\n          (calc x base \"\")))))\n", "  (define-values\
    \ (quotient remainder) (quotient/remainder x base))\n  (cond ((= quotient 0) (number->string\
    \ remainder))\n        (else (string-append (change_base quotient base) (number->string\
    \ remainder)))))\n", "  (cond\n    [(zero? x) \"\"]\n    [else (string-append\
    \ (change_base (/ x base) base) (number->string (remainder x base)))]))\n", " \
    \ (define (ch_helper x base r)\n    (cond ((= x base) (string-append r (number->string\
    \ x)))\n          ((< x base) (string-append r (number->string x)))\n        \
    \  (else (ch_helper (/ x base) base (string-append r (number->string (remainder\
    \ x base)))))))\n  (ch_helper x base \"\"))\n", "  (letrec ([x x]\n          \
    \ [res \"\"]\n           [recur (lambda (x)\n                    (if (= x 0)\n\
    \                        res\n                        (let ([q (quotient x base)]\n\
    \                              [r (remainder x base)])\n                     \
    \     (set! res (string-append (number->string r) res))\n                    \
    \      (recur q))))])\n    (recur x)))\n", "  (cond\n    [(zero? x) \"\"]\n  \
    \  [else (string-append (change_base (quotient x base) base)\n               \
    \          (number->string (remainder x base)))]))\n", "  (list->string (reverse\
    \ (change_base_rec x base))))\n", "  (define (change_base1 x base)\n    (cond\n\
    \      [(zero? x) \"\"]\n      [else\n       (cons (number->string (remainder\
    \ x base))\n             (change_base1 (quotient x base) base))]))\n  (change_base1\
    \ x base))\n", "  (if (= x 0)\n      \"\"\n      (string-append (change_base (quotient\
    \ x base) base)\n                     (number->string (remainder x base)))))",
  "  (define (change_base_iter x)\n    (if (zero? x)\n        (list)\n        (cons\
    \ (remainder x base) (change_base_iter (quotient x base)))))\n  (string-join (reverse\
    \ (map number->string (change_base_iter x)))))\n", "  (define (change-to-base\
    \ x base)\n    (if (= x 0) '()\n        (cons (% x base) (change-to-base (quotient\
    \ x base) base))))\n  (string-join (reverse (change-to-base x base)) \"\"))\n",
  "  (if (zero? x) \"\"\n      (string-append (change_base (quotient x base) base)\n\
    \                     (number->string (remainder x base)))))\n", "  (if (= x 0)\n\
    \      \"\"\n      (string-append (change_base (quotient x base) base)\n     \
    \                (number->string (remainder x base)))))\n", "  (define (change_base_helper\
    \ x base acc)\n    (if (= x 0)\n        acc\n        (let* ([new_x (quotient x\
    \ base)]\n               [new_acc (string-append (number->string (remainder x\
    \ base)) acc)])\n          (change_base_helper new_x base new_acc))))\n  (change_base_helper\
    \ x base \"\"))\n", "  (cond\n    [(< x base) (number->string x)]\n    [else\n\
    \     (string-append\n      (change_base (quotient x base) base)\n      (number->string\
    \ (remainder x base)))]))\n", "  (cond [(= x 0) \"\"]\n        [else (append (change_base\
    \ (/ x base) base) (number->string (remainder x base)))]))", "  (if (= x 0)\n\
    \      \"\"\n      (string-append (change_base (quotient x base) base)\n     \
    \                (string (remainder x base)))))\n", "  (cond\n    [(= x 0) \"\"\
    ]\n    [else (concat (change_base (quotient x base) base)\n\t\t  (number->string\
    \ (remainder x base)))]))\n", "  (cond\n    [(= x 0) \"\"]\n    [else\n     (string-append\
    \ (change_base (quotient x base) base)\n                    (number->string (remainder\
    \ x base)))]))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (change_base (quotient\
    \ x base) base) (number->string (remainder x base))]))\n", "  (define (change-base\
    \ x base s)\n    (if (= x 0)\n        s\n        (change-base (/ x base) base\
    \ (string (+ (% x base) 48) s))))\n  (change-base x base \"\"))\n", "  (letrec\n\
    \      ((number-to-base\n\t(lambda (a)\n\t  (letrec\n\t      ((l\n\t\t(lambda\
    \ (x)\n\t\t  (cons (remainder x base)\n\t\t\t(if (&lt; x base)\n\t\t\t    '()\n\
    \t\t\t    (l (quotient x base)))))))\n\t    (reverse (l a))))))\n    (string-join\
    \ (number-to-base x) \"\")))\n", "  (define (change_base_iter x base result)\n\
    \    (if (= x 0)\n        result\n        (change_base_iter (quotient x base)\
    \ base (string (remainder x base) result))))\n  (change_base_iter x base \"\"\
    ))\n", "  (define (change_base_helper x base res)\n    (cond ((= x 0) (string-append\
    \ res \"\"))\n          (else (change_base_helper\n                  (/ x base)\
    \ base\n                  (string-append (number->string (remainder x base)) res)))))\n\
    \  (change_base_helper x base \"\"))\n", "  (define (iterator x base)\n    (let*\
    \ ([d (modulo x base)]\n           [r (/ x base)])\n      (if (= r 0)\n      \
    \    (number->string d)\n          (string-append (iterator r base) (number->string\
    \ d)))))\n  (iterator x base))\n", "  (if (= x 0)\n      \"0\"\n      (let loop\
    \ ((x x) (s \"\"))\n        (cond\n          [(= x 0) (reverse s)]\n         \
    \ [else (loop (quotient x base) (string (+ (remainder x base) 48) s))]))))\n",
  "  (if (< x base)\n      (number->string x)\n      (string-append (change_base (/\
    \ x base) base)\n                     (number->string (modulo x base)))))\n",
  "  (if (= x 0)\n      \"\"\n      (let ([digit (modulo x base)])\n        (if (=\
    \ digit 10)\n            (string-append (change_base (quotient x base) base) \"\
    A\")\n            (string-append (change_base (quotient x base) base) (number->string\
    \ digit))))))\n", "  (cond [(= x 0) \"\"]\n        [else (change_base (quotient\
    \ x base) base)\n             (number->string (remainder x base))]))\n", "  (define\
    \ (div_by_base i)\n    (if (< i base)\n        i\n        (div_by_base (/ i base))))\n\
    \  (define (convert_helper i)\n    (cond ((< i base)\n           (string i))\n\
    \          (else\n           (string (modulo i base))\n           (convert_helper\
    \ (div_by_base i)))))\n  (convert_helper x))\n", "  (if (= x 0)\n      \"\"\n\
    \      (string-append (change_base (quotient x base) base)\n                 \
    \    (number->string (remainder x base)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
