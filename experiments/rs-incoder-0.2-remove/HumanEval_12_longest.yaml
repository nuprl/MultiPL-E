name: HumanEval_12_longest
language: rs
prompt: "/// Out of list of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n"
tests: "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
  \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
  ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
  x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
  kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
completions: ['    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by(|a,
    b| a.len() < b.len()).ok()', "    strings\n        .iter()\n        .fold(None,\
    \ |mut acc, s| {\n            if acc.is_none() {\n                Some(s.to_string())\n\
    \            } else {\n                if acc.len() > s.len() {\n            \
    \        Some(acc.unwrap())\n                } else {\n                    Some(s)\n\
    \                }\n            }\n        })", "    strings\n        .iter()\n\
    \        .fold(None, |mut acc, s| {\n            if acc.is_none() {\n        \
    \        acc = Some(s);\n            } else {\n                let len = s.len();\n\
    \                if len > acc.unwrap().len() {\n                    acc = Some(s);\n\
    \                }\n            }\n            acc\n        })", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest_len = String::new();\n\
    \    let mut longest_str = String::new();\n\n    for s in strings {\n        let\
    \ len = s.len();\n        if len > longest_len.len() {\n            longest_len\
    \ = len;\n            longest_str = s;\n        }\n    }\n\n    Some(longest_str)",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok_or(Error::BadRequest(ErrorKind::InvalidParam, \"No\
    \ string provided\"))", "    let mut longest = String::new();\n    for s in strings\
    \ {\n        if longest.len() < s.len() {\n            longest = s;\n        }\n\
    \    }\n    longest.cloned()", "    strings\n        .iter()\n        .map(|s|\
    \ s.len())\n        .max()\n        .cloned()\n        .ok()", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as i32).cloned())", "    strings\n        .iter()\n        .fold(None, |mut\
    \ acc, s| {\n            let len = s.len();\n            if acc.is_none() || len\
    \ > acc.unwrap().len() {\n                Some(s)\n            } else {\n    \
    \            None\n            }\n        })", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by(|a,
    b| a.len() < b.len()).unwrap_or(None)', "    let mut longest_len = String::new();\n\
    \    let mut longest_str = String::new();\n    for s in strings {\n        let\
    \ len = s.len();\n        if len > longest_len.len() {\n            longest_len\
    \ = len;\n            longest_str = s;\n        }\n    }\n    Some(longest_str)",
  "    strings\n        .iter()\n        .fold(None, |mut acc, s| {\n            if\
    \ acc.is_none() {\n                Some(s)\n            } else {\n           \
    \     if acc.len() > s.len() {\n                    Some(acc)\n              \
    \  } else {\n                    Some(s)\n                }\n            }\n \
    \       })", "    if strings.is_empty() {\n        return None;\n    }\n\n   \
    \ let mut longest_len = String::new();\n    let mut longest_str = String::new();\n\
    \n    for s in strings {\n        let len = s.len();\n        if len > longest_len.len()\
    \ {\n            longest_len = len;\n            longest_str = s;\n        }\n\
    \    }\n\n    Some(longest_str)", '    strings.iter().max_by_key(|s| s.len())',
  "    let mut longest_len = String::new();\n    let mut longest_str = String::new();\n\
    \    for s in strings {\n        if longest_len.len() < s.len() {\n          \
    \  longest_len = s.len();\n            longest_str = s;\n        }\n    }\n  \
    \  longest_str.ok_or(format!(\"No string in list has length {}\", longest_len))"]
stop_tokens:
- "\n}"
