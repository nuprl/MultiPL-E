name: HumanEval_12_longest
language: rs
prompt: "/// Out of list of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n"
tests: "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
  \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
  ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
  x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
  kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
completions: ['    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by(|a,
    b| a.len() < b.len()).ok()', "    strings\n        .iter()\n        .fold(None,\
    \ |mut acc, s| {\n            if acc.is_none() {\n                Some(s.to_string())\n\
    \            } else {\n                if acc.len() > s.len() {\n            \
    \        Some(acc.unwrap())\n                } else {\n                    Some(s)\n\
    \                }\n            }\n        })", "    strings\n        .iter()\n\
    \        .fold(None, |mut acc, s| {\n            if acc.is_none() {\n        \
    \        acc = Some(s);\n            } else {\n                let len = s.len();\n\
    \                if len > acc.unwrap().len() {\n                    acc = Some(s);\n\
    \                }\n            }\n            acc\n        })", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest_len = String::new();\n\
    \    let mut longest_str = String::new();\n\n    for s in strings {\n        let\
    \ len = s.len();\n        if len > longest_len.len() {\n            longest_len\
    \ = len;\n            longest_str = s;\n        }\n    }\n\n    Some(longest_str)",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok_or(Error::BadRequest(ErrorKind::InvalidParam, \"No\
    \ string provided\"))", "    let mut longest = String::new();\n    for s in strings\
    \ {\n        if longest.len() < s.len() {\n            longest = s;\n        }\n\
    \    }\n    longest.cloned()", "    strings\n        .iter()\n        .map(|s|\
    \ s.len())\n        .max()\n        .cloned()\n        .ok()", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as i32).cloned())", "    strings\n        .iter()\n        .fold(None, |mut\
    \ acc, s| {\n            let len = s.len();\n            if acc.is_none() || len\
    \ > acc.unwrap().len() {\n                Some(s)\n            } else {\n    \
    \            None\n            }\n        })", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by(|a,
    b| a.len() < b.len()).unwrap_or(None)', "    let mut longest_len = String::new();\n\
    \    let mut longest_str = String::new();\n    for s in strings {\n        let\
    \ len = s.len();\n        if len > longest_len.len() {\n            longest_len\
    \ = len;\n            longest_str = s;\n        }\n    }\n    Some(longest_str)",
  "    strings\n        .iter()\n        .fold(None, |mut acc, s| {\n            if\
    \ acc.is_none() {\n                Some(s)\n            } else {\n           \
    \     if acc.len() > s.len() {\n                    Some(acc)\n              \
    \  } else {\n                    Some(s)\n                }\n            }\n \
    \       })", "    if strings.is_empty() {\n        return None;\n    }\n\n   \
    \ let mut longest_len = String::new();\n    let mut longest_str = String::new();\n\
    \n    for s in strings {\n        let len = s.len();\n        if len > longest_len.len()\
    \ {\n            longest_len = len;\n            longest_str = s;\n        }\n\
    \    }\n\n    Some(longest_str)", '    strings.iter().max_by_key(|s| s.len())',
  "    let mut longest_len = String::new();\n    let mut longest_str = String::new();\n\
    \    for s in strings {\n        if longest_len.len() < s.len() {\n          \
    \  longest_len = s.len();\n            longest_str = s;\n        }\n    }\n  \
    \  longest_str.ok_or(format!(\"No string in list has length {}\", longest_len))",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s|\
    \ s.len() as u32).cloned())\n        .ok()\n        .and_then(|s| s.len())", '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .fold(None, |mut acc, s| {\n\
    \            if acc.is_none() {\n                acc = Some(s);\n            }\
    \ else {\n                let len = s.len();\n                if len > acc.unwrap().len()\
    \ {\n                    acc = Some(s);\n                }\n            }\n  \
    \          acc\n        })", "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .and_then(|len| strings.iter().map(|s| s.len() as i32).max().filter(|&len|\
    \ len == len).last())", "    let mut longest = String::new();\n    let mut longest_len\
    \ = String::new();\n    for s in strings {\n        let len = s.len();\n     \
    \   if len > longest_len.len() {\n            longest = s;\n            longest_len\
    \ = len;\n        }\n    }\n    longest_len.len()\n        .cmp(&longest.len())\n\
    \        .map(|i| longest.chars().nth(i))\n        .unwrap_or(None)", '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .fold(None, |mut acc, str| {\n\
    \            let len = str.len();\n            if len > acc.len() {\n        \
    \        Some(str)\n            } else {\n                None\n            }\n\
    \        })", '    strings.iter().max_by(|a, b| a.len() < b.len()).unwrap_or(None)',
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok()\n        .and_then(|len| strings.iter().max_by(|a,\
    \ b| a.len() < b.len() && a.len() == len))\n        .cloned()", "    let mut longest\
    \ = String::new();\n    let mut longestlen = String::new();\n    for s in strings\
    \ {\n        if longestlen.len() > s.len() {\n            longest = s;\n     \
    \       longestlen = s.len();\n        }\n    }\n    longest.cloned()", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as u32).cloned())\n        .ok()\n        .and_then(|s| s.clone())", '    strings.iter().max_by(|a,
    b| a.len() < b.len()).unwrap_or(None)', "    strings\n        .iter()\n      \
    \  .fold(None, |mut acc, s| {\n            if acc.is_none() {\n              \
    \  Some(s.to_string())\n            } else {\n                if acc.unwrap().len()\
    \ < s.len() {\n                    Some(acc.unwrap().to_string())\n          \
    \      } else {\n                    Some(s.to_string())\n                }\n\
    \            }\n        })", "    strings\n        .iter()\n        .fold(None,\
    \ |mut acc, s| {\n            if acc.is_none() {\n                Some(s.to_owned())\n\
    \            } else {\n                let mut len = s.len();\n              \
    \  let mut max_len = acc.unwrap().len();\n                let mut max_len = if\
    \ max_len < len { max_len } else { len };\n                if max_len == len {\n\
    \                    Some(s.to_owned())\n                } else {\n          \
    \          Some(acc.unwrap().to_owned())\n                }\n            }\n \
    \       })", "    let mut longest = String::new();\n    for s in strings {\n \
    \       if longest.len() < s.len() {\n            longest = s;\n        }\n  \
    \  }\n    longest.cloned()", '    strings.iter().max_by(|a, b| a.len() < b.len()).unwrap_or(None)',
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s|\
    \ s.len() as usize).cloned())", "    strings\n        .iter()\n        .map(|s|\
    \ s.len())\n        .max()\n        .cloned()\n        .ok_or(Error::BadRequest(ErrorKind::InvalidParam,\
    \ \"Longest string not found\"))", "    strings\n        .iter()\n        .map(|s|\
    \ s.len())\n        .max()\n        .cloned()\n        .ok_or(Error::BadRequest(ErrorKind::InvalidParam,\
    \ \"Longest string not found\"))", "    strings\n        .iter()\n        .map(|s|\
    \ s.len())\n        .max()\n        .cloned()\n        .ok()\n        .and_then(|len|\
    \ strings.iter().max_by_key(|s| s.len() as u64).cloned())", "    strings.iter().fold(None,\
    \ |max, s| {\n        let len = s.len();\n        if len > max {\n           \
    \ Some(s)\n        } else {\n            None\n        }\n    })", "    let mut\
    \ longest = String::new();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    longest.cloned()", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as u32).cloned())\n        .ok()", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n\n    let mut max_len = String::new();\n    let mut max_len =\
    \ strings[0].len();\n    for s in strings {\n        if s.len() > max_len {\n\
    \            max_len = s.len();\n        }\n    }\n\n    for s in strings {\n\
    \        if s.len() == max_len {\n            return Some(s);\n        }\n   \
    \ }\n\n    None", "    strings\n        .iter()\n        .map(|s| s.chars().count())\n\
    \        .max()\n        .cloned()\n        .ok()\n        .and_then(|s| strings.iter().find(|s|\
    \ s == s).cloned())", '    strings.iter().max_by_key(|s| s.len())', "    strings\n\
    \        .iter()\n        .map(|s| s.chars().count())\n        .max()\n      \
    \  .cloned()\n        .unwrap_or(0)\n        .to_string()", "    strings\n   \
    \     .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as usize).cloned())", "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .and_then(|len| strings.iter().max_by(|a, b| a.len()\
    \ < b.len() && a.len() == len))", '    strings.iter().max_by_key(|s| s.len())',
  "    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0];\n    for s in strings.iter().rev() {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as u64).cloned())\n        .ok()\n        .and_then(|s| s.len())", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as u32).cloned())", "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .cloned()\n        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s|\
    \ s.len() as u32).cloned())", '    strings.iter().max_by(|a, b| a.len() < b.len()).unwrap_or(None)',
  '    strings.iter().max_by_key(|s| s.len())', "    strings\n        .iter()\n  \
    \      .fold(None, |mut acc, s| {\n            let len = s.len();\n          \
    \  if acc.is_none() || len > acc.unwrap().len() {\n                Some(s)\n \
    \           } else {\n                None\n            }\n        })", '    strings.iter().max_by(|a,
    b| a.len() < b.len()).unwrap_or(None)', '    strings.iter().max_by(|a, b| a.len()
    < b.len()).unwrap_or(None)', "    strings\n        .iter()\n        .fold(None,\
    \ |mut acc, s| {\n            if acc.is_none() {\n                Some(s.to_string())\n\
    \            } else {\n                let mut len = s.len();\n              \
    \  let mut max_len = acc.unwrap().len();\n                while len < max_len\
    \ {\n                    len += 1;\n                }\n                if len\
    \ == max_len {\n                    Some(acc.unwrap().clone())\n             \
    \   } else {\n                    None\n                }\n            }\n   \
    \     })", "    strings.iter().fold(None, |max, s| {\n        if let Some(len)\
    \ = s.length() {\n            if len > max {\n                Some(s)\n      \
    \      } else {\n                None\n            }\n        } else {\n     \
    \       None\n        }\n    })", "    let mut longest_len = String::new();\n\
    \    let mut longest_str = String::new();\n    for s in strings {\n        let\
    \ len = s.len();\n        if len > longest_len.len() {\n            longest_len\
    \ = len;\n            longest_str = s;\n        }\n    }\n    Some(longest_str)",
  "    let mut longest = String::new();\n    for s in strings {\n        if longest.len()\
    \ < s.len() {\n            longest = s;\n        }\n    }\n    longest.cloned()",
  "    let mut longest = String::new();\n    for s in strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    longest.cloned()",
  '    strings.iter().max_by_key(|s| s.len())', "    strings\n        .iter()\n  \
    \      .map(|s| s.len())\n        .max()\n        .cloned()\n        .ok_or(Error::BadRequest(ErrorKind::InvalidParam,\
    \ \"Longest string length is invalid\"))", "    if strings.is_empty() {\n    \
    \    return None;\n    }\n    let mut longest = strings[0];\n    for s in strings.iter().rev()\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    Some(longest)", '    strings.iter().max_by(|a, b| a.len() < b.len()).unwrap_or(None)',
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .and_then(|len| strings.iter().max_by(|a, b| a.len() < b.len() && a.len()\
    \ == len))", "    if strings.is_empty() {\n        return None;\n    }\n    let\
    \ mut longest = strings[0];\n    for s in strings.iter().rev() {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest)",
  '    strings.iter().max_by_key(|s| s.len()).ok()', "    strings\n        .iter()\n\
    \        .map(|s| s.len())\n        .max()\n        .cloned()\n        .ok()\n\
    \        .and_then(|len| strings.iter().max_by_key(|s| s.len() as u64).cloned())",
  "    let mut longest = String::new();\n    for s in strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    longest.cloned()",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s|\
    \ s.len() as u32).cloned())", '    strings.iter().max_by_key(|s| s.len())', " \
    \   strings\n        .iter()\n        .fold(None, |mut acc, s| {\n           \
    \ if acc.is_none() {\n                Some(s.to_string())\n            } else\
    \ {\n                if acc.unwrap().len() < s.len() {\n                    Some(acc.unwrap().to_string())\n\
    \                } else {\n                    Some(s.to_string())\n         \
    \       }\n            }\n        })", '    strings.iter().max_by(|a, b| a.len()
    < b.len()).unwrap_or(None)', "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .cloned()\n        .ok_or(format!(\"No string in list\
    \ has length greater than {}\", MAX_STRING_LENGTH))", '    strings.iter().max_by(|a,
    b| a.len() < b.len()).unwrap_or(None)', "    strings\n        .iter()\n      \
    \  .map(|s| s.len())\n        .max()\n        .cloned()\n        .ok_or(format!(\"\
    No string in list has length greater than one\"))", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = String::new();\n   \
    \ let mut max_index = -1;\n    for &s in strings {\n        let len = s.len();\n\
    \        if max_len.len() < len {\n            max_len = s;\n            max_index\
    \ = len;\n        }\n    }\n\n    if max_len.len() == 0 {\n        return None;\n\
    \    }\n\n    Some(max_len.to_string())", "    strings.iter().fold(None, |mut\
    \ a, s| {\n        if a.is_none() {\n            a = Some(s);\n        } else\
    \ if a.len() < s.len() {\n            a = Some(a);\n        } else {\n       \
    \     a = Some(s);\n        }\n        a\n    })", "    strings\n        .iter()\n\
    \        .map(|s| s.len())\n        .max()\n        .cloned()\n        .ok()\n\
    \        .and_then(|len| strings.iter().max_by_key(|s| s.len() as usize).cloned())",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s|\
    \ s.len() as i32).cloned())", '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by(|a,
    b| a.len() < b.len()).unwrap_or(None)', "    let mut longest = String::new();\n\
    \    let mut longestlen = String::new();\n    for s in strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n            longestlen = s.len();\n\
    \        }\n    }\n    if longest.len() == 0 {\n        return None;\n    }\n\
    \    Some(longest)", "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .cloned()\n        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s|\
    \ s.len() as u32).cloned())", "    strings\n        .iter()\n        .fold(None,\
    \ |mut acc, s| {\n            let len = s.len();\n            if len > acc.len()\
    \ {\n                Some(s.clone())\n            } else if len == acc.len() {\n\
    \                Some(acc.clone())\n            } else {\n                None\n\
    \            }\n        })", "    let mut longest_len = String::new();\n    let\
    \ mut longest_str = String::new();\n    for s in strings {\n        if s.len()\
    \ > longest_len.len() {\n            longest_len = s.len();\n            longest_str\
    \ = s;\n        }\n    }\n    Some(longest_str)", "    strings\n        .iter()\n\
    \        .map(|s| s.len())\n        .max()\n        .cloned()\n        .ok()\n\
    \        .and_then(|len| strings.iter().max_by_key(|s| s.len() as u64).cloned())",
  "    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_len\
    \ = String::new();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n        }\n    }\n\n    Some(max_len)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest = strings[0];\n    for\
    \ s in strings.iter().rev() {\n        if s.len() > longest.len() {\n        \
    \    longest = s;\n        }\n    }\n    Some(longest)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest = strings[0];\n    let\
    \ mut longestlen = longest.len();\n    for s in strings {\n        if s.len()\
    \ > longestlen {\n            longest = s;\n            longestlen = s.len();\n\
    \        }\n    }\n    Some(longest)", '    strings.iter().max_by(|a, b| a.len()
    < b.len()).unwrap_or(None)', "    if strings.is_empty() {\n        return None;\n\
    \    }\n\n    let mut longest_len = String::new();\n    let mut longest_str =\
    \ String::new();\n\n    for s in strings {\n        if s.len() > longest_len.len()\
    \ {\n            longest_len = s.len();\n            longest_str = s;\n      \
    \  }\n    }\n\n    Some(longest_str)", '    strings.iter().max_by(|a, b| a.len()
    < b.len()).unwrap_or(None)', "    strings\n        .iter()\n        .fold(None,\
    \ |mut longest, s| {\n            if let Some(mut len) = longest.len() {\n   \
    \             if len < s.len() {\n                    longest = Some(s);\n   \
    \             }\n            }\n            longest\n        })", "    strings\n\
    \        .iter()\n        .fold(None, |mut acc, s| {\n            if acc.is_none()\
    \ {\n                acc = Some(s);\n            } else {\n                let\
    \ len = s.len();\n                if len > acc.unwrap().len() {\n            \
    \        acc = Some(s);\n                }\n            }\n            acc\n \
    \       })", "    if strings.is_empty() {\n        return None;\n    }\n\n   \
    \ let mut longest = strings[0];\n    let mut longest_len = strings[0].len();\n\
    \n    for s in strings.iter().rev() {\n        if s.len() > longest_len {\n  \
    \          longest = s;\n            longest_len = s.len();\n        }\n    }\n\
    \n    longest", "    let mut longest = String::new();\n    for s in strings {\n\
    \        if s.len() > longest.len() {\n            longest = s;\n        }\n \
    \   }\n    longest.cloned()", '    strings.iter().max_by_key(|s| s.len())', " \
    \   strings\n        .iter()\n        .fold(None, |mut acc, s| {\n           \
    \ if acc.is_none() {\n                Some(s.to_string())\n            } else\
    \ {\n                if acc.len() > s.len() {\n                    Some(acc.unwrap())\n\
    \                } else {\n                    Some(s.to_string())\n         \
    \       }\n            }\n        })", "    strings\n        .iter()\n       \
    \ .map(|s| s.len())\n        .max()\n        .and_then(|len| strings.iter().max_by(|a,\
    \ b| a.len() < b.len() && a.len() == len))", '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut longest = strings[0];\n    let mut longest_len = strings[0].len();\n\n \
    \   for s in strings.iter().rev() {\n        if s.len() > longest_len {\n    \
    \        longest = s;\n            longest_len = s.len();\n        }\n    }\n\n\
    \    Some(longest)", "    let mut longest = String::new();\n    let mut longestlen\
    \ = String::new();\n    for s in strings {\n        if s.len() > longestlen.len()\
    \ {\n            longest = s;\n            longestlen = s.len();\n        }\n\
    \    }\n    longest.cloned()", "    let mut longest_len = String::new();\n   \
    \ let mut longest_str = String::new();\n    for s in strings {\n        if s.len()\
    \ > longest_len.len() {\n            longest_len = s.len();\n            longest_str\
    \ = s;\n        }\n    }\n    Some(longest_str)", '    strings.iter().max_by_key(|s|
    s.len())', "    let mut longest = String::new();\n    for s in strings {\n   \
    \     if longest.len() < s.len() {\n            longest = s;\n        }\n    }\n\
    \    longest.cloned()", "    if strings.is_empty() {\n        return None;\n \
    \   }\n\n    let mut longest_len = String::new();\n    let mut longest_str = String::new();\n\
    \n    for s in strings {\n        let len = s.len();\n        if len > longest_len.len()\
    \ {\n            longest_len = len;\n            longest_str = s;\n        }\n\
    \    }\n\n    Some(longest_str)", "    let mut longest_len = 0;\n    let mut longest_str\
    \ = None;\n    for s in strings {\n        let len = s.len();\n        if len\
    \ > longest_len {\n            longest_len = len;\n            longest_str = Some(s);\n\
    \        }\n    }\n    longest_str", "    strings\n        .iter()\n        .map(|s|\
    \ s.len())\n        .max()\n        .cloned()\n        .ok()\n        .and_then(|len|\
    \ strings.iter().max_by_key(|s| s.len() as u32).cloned())", "    let mut longest\
    \ = String::new();\n    for s in strings {\n        if longest.len() < s.len()\
    \ {\n            longest = s;\n        }\n    }\n    longest.cloned()", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .and_then(|len|\
    \ strings.iter().max_by(|a, b| a.len() < b.len() && a.len() == len))", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as u32).cloned().ok())", "    if strings.is_empty() {\n        return None;\n\
    \    }\n\n    let mut longest = strings[0];\n    for string in strings.iter().rev()\
    \ {\n        if string.length() > longest.length() {\n            longest = string;\n\
    \        }\n    }\n\n    Some(longest)", "    strings\n        .iter()\n     \
    \   .map(|s| s.len())\n        .max()\n        .cloned()\n        .ok()\n    \
    \    .and_then(|len| strings.iter().max_by_key(|s| s.len() as usize).cloned())\n\
    \        .ok()\n        .and_then(|s| s.clone())", "    strings\n        .iter()\n\
    \        .fold(None, |mut acc, s| {\n            if let Some(mut len) = acc.len();\
    \ *len < s.len() {\n                acc = Some(s);\n            }\n          \
    \  acc\n        })", '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by(|a,
    b| a.len() < b.len()).unwrap_or(None)', "    strings\n        .iter()\n      \
    \  .map(|s| s.len())\n        .max()\n        .cloned()\n        .ok()\n     \
    \   .and_then(|len| strings.iter().max_by(|a, b| a.len() < b.len() && a.len()\
    \ == len))", "    strings\n        .iter()\n        .fold(None, |mut acc, s| {\n\
    \            if acc.is_none() {\n                acc = Some(s);\n            }\
    \ else {\n                let len = s.len();\n                if len > acc.unwrap().len()\
    \ {\n                    acc = Some(s);\n                }\n            }\n  \
    \          acc\n        })", '    strings.iter().max_by_key(|s| s.len())', " \
    \   let mut longest = String::new();\n    for s in strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    longest.cloned()",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok_or(Error::BadRequest(ErrorKind::InvalidParam, \"No\
    \ string with longest length\"))", '    strings.iter().max_by_key(|s| s.len())',
  "    let mut longest = String::new();\n    for s in strings {\n        if longest.len()\
    \ < s.len() {\n            longest = s;\n        }\n    }\n    longest.cloned()",
  '    strings.iter().max_by_key(|s| s.len())', "    let mut longest = String::new();\n\
    \    let mut longestlen = String::new();\n    for s in strings {\n        if s.len()\
    \ > longestlen.len() {\n            longest = s;\n            longestlen = s.len();\n\
    \        }\n    }\n    longest.cloned()", '    strings.iter().max_by_key(|s| s.len()).unwrap_or(None)',
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by(|a, b|
    a.len() < b.len()).unwrap_or(None)', "    if strings.is_empty() {\n        return\
    \ None;\n    }\n\n    let mut longest_len = String::new();\n    let mut longest_str\
    \ = String::new();\n\n    for s in strings {\n        if s.len() > longest_len.len()\
    \ {\n            longest_len = s.len();\n            longest_str = s;\n      \
    \  }\n    }\n\n    Some(longest_str)", "    strings\n        .iter()\n       \
    \ .map(|s| s.chars().count())\n        .max()\n        .cloned()\n        .ok()\n\
    \        .and_then(|s| strings.iter().find(|s| s == s).cloned())", '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n    let\
    \ mut longest = strings[0];\n    for s in strings.iter().rev() {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest)",
  '    strings.iter().max_by_key(|s| s.len())', "    strings\n        .iter()\n  \
    \      .map(|s| s.len())\n        .max()\n        .and_then(|len| strings.iter().map(|s|\
    \ s.len() as usize).max().filter(|&len| len == len).first())", '    strings.iter().max_by(|a,
    b| a.len() < b.len()).unwrap_or(None)', '    strings.iter().max_by_key(|s| s.len())',
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by(|a, b| a.len() < b.len()).unwrap_or(None)',
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s|\
    \ s.len() as u32).cloned())\n        .ok()", "    if strings.is_empty() {\n  \
    \      return None;\n    }\n    let mut longest = strings[0];\n    for s in strings.iter().rev()\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    Some(longest)", '    strings.iter().max_by(|a, b| a.len() < b.len()).unwrap_or(None)',
  "    strings\n        .iter()\n        .fold(None, |mut acc, s| {\n            if\
    \ acc.is_none() {\n                Some(s.to_owned())\n            } else {\n\
    \                if acc.len() > s.len() {\n                    Some(acc.to_owned())\n\
    \                } else {\n                    None\n                }\n     \
    \       }\n        })", "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as u32).take(len))", "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .and_then(|len| strings.iter().max_by_key(|s| s.len()\
    \ as i32).unwrap())", "    let mut longest = String::new();\n    for s in strings\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    longest.cloned()", '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .fold(None, |mut acc, s| {\n\
    \            if acc.is_none() {\n                Some(s.clone())\n           \
    \ } else {\n                if acc.len() > s.len() {\n                    Some(acc.clone())\n\
    \                } else {\n                    None\n                }\n     \
    \       }\n        })", '    strings.iter().max_by(|a, b| a.len() < b.len()).unwrap_or(None)',
  '    strings.iter().max_by(|a, b| a.len() < b.len()).unwrap_or(None)', '    strings.iter().max_by_key(|s|
    s.len())', "    let mut longest_len = String::new();\n    let mut longest_str\
    \ = String::new();\n    for s in strings {\n        if s.len() > longest_len.len()\
    \ {\n            longest_len = s.len();\n            longest_str = s;\n      \
    \  }\n    }\n    Some(longest_str)", "    strings\n        .iter()\n        .fold(None,\
    \ |mut acc, s| {\n            if acc.is_none() {\n                Some(s.to_string())\n\
    \            } else {\n                if acc.len() < s.len() {\n            \
    \        Some(acc.unwrap())\n                } else {\n                    Some(s.to_string())\n\
    \                }\n            }\n        })", "    strings\n        .iter()\n\
    \        .map(|s| s.len())\n        .max()\n        .cloned()\n        .ok()",
  '    strings.iter().max_by_key(|s| s.len()).unwrap_or(None)', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    let mut longest\
    \ = String::new();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    longest.cloned()", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    strings\n      \
    \  .iter()\n        .fold(None, |mut acc, s| {\n            if acc.is_none() {\n\
    \                acc = Some(s);\n            } else {\n                let len\
    \ = s.len();\n                if len > acc.unwrap().len() {\n                \
    \    acc = Some(s);\n                }\n            }\n            acc\n     \
    \   })", '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut longest = strings[0];\n    for s in strings.iter().rev() {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n\n    Some(longest)",
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut longest = strings[0];\n    for s in strings.iter().rev() {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest)",
  "    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_len\
    \ = String::new();\n    let mut longest_str = String::new();\n    for s in strings\
    \ {\n        if s.len() > longest_len.len() {\n            longest_len = s.len();\n\
    \            longest_str = s;\n        }\n    }\n\n    Some(longest_str)", " \
    \   let mut longest = String::new();\n    let mut longestlen = String::new();\n\
    \    for s in strings {\n        if s.len() > longestlen.len() {\n           \
    \ longest = s;\n            longestlen = s.len();\n        }\n    }\n    if longest.len()\
    \ == 0 {\n        return None;\n    }\n    Some(longest)", "    strings\n    \
    \    .iter()\n        .fold(None, |mut acc, s| {\n            if acc.is_none()\
    \ {\n                Some(s.len())\n            } else {\n                if s.len()\
    \ > acc.unwrap().len() {\n                    Some(s)\n                } else\
    \ {\n                    acc\n                }\n            }\n        })", " \
    \   if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_len\
    \ = String::new();\n    let mut longest_str = String::new();\n    for s in strings\
    \ {\n        if s.len() > longest_len.len() {\n            longest_len = s.len();\n\
    \            longest_str = s;\n        }\n    }\n    Some(longest_str)", "   \
    \ if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0];\n    for s in strings.iter().rev() {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = strings[0];\n    for s\
    \ in strings.iter().rev() {\n        if s.len() > longest.len() {\n          \
    \  longest = s;\n        }\n    }\n    longest", '    strings.iter().max_by_key(|s|
    s.len()).unwrap_or(None)', "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut longest = strings[0];\n    for s in strings.iter().rev() {\n\
    \        if s.len() > longest.len() {\n            longest = s;\n        }\n \
    \   }\n    longest", '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    let mut longest = String::new();\n    for s in strings {\n   \
    \     if longest.len() < s.len() {\n            longest = s;\n        }\n    }\n\
    \    longest.cloned()", "    let mut longest = String::new();\n    let mut longest_len\
    \ = String::new();\n    for s in strings {\n        if s.len() > longest_len.len()\
    \ {\n            longest = s;\n            longest_len = s.len();\n        }\n\
    \    }\n    longest_len.cloned()", "    let mut longest = String::new();\n   \
    \ for s in strings {\n        if s.len() > longest.len() {\n            longest\
    \ = s;\n        }\n    }\n    longest.cloned()", "    strings\n        .iter()\n\
    \        .map(|s| s.len())\n        .max()\n        .cloned()\n        .ok()",
  '    strings.iter().max_by(|a, b| a.len() < b.len()).unwrap_or(None)', "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .ok_or(Error::BadRequest(ErrorKind::NotFound, \"No string found\"))",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .ok()\n        .and_then(|len| strings.iter().max_by_key(|s|\
    \ s.len() as u32).cloned())", '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    let mut longest_len = String::new();\n    let mut longest_str\
    \ = String::new();\n    for s in strings {\n        let len = s.len();\n     \
    \   if len > longest_len.len() {\n            longest_len = len;\n           \
    \ longest_str = s;\n        }\n    }\n    Some(longest_str)", "    strings\n \
    \       .iter()\n        .fold(None, |mut acc, s| {\n            if acc.is_none()\
    \ {\n                Some(s.len())\n            } else {\n                if acc.unwrap().len()\
    \ < s.len() {\n                    Some(acc.unwrap())\n                } else\
    \ {\n                    Some(s)\n                }\n            }\n        })",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ strings[0];\n    for s in strings.iter().rev() {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = strings[0];\n    for s\
    \ in strings.iter().rev() {\n        if s.len() > longest.len() {\n          \
    \  longest = s;\n        }\n    }\n    Some(longest)", "    let mut longest =\
    \ String::new();\n    for s in strings {\n        if longest.len() < s.len() {\n\
    \            longest = s;\n        }\n    }\n    longest.cloned()", "    let mut\
    \ longest = String::new();\n    let mut longest_len = String::new();\n    for\
    \ s in strings {\n        if s.len() > longest_len.len() {\n            longest\
    \ = s;\n            longest_len = s.len();\n        }\n    }\n    longest_len.cloned()"]
stop_tokens:
- "\n}"
