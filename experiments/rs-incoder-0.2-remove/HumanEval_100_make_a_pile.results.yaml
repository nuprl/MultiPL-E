language: rs
name: HumanEval_100_make_a_pile
results:
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg3y9u6kl.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut levels = Vec::new();\n    let mut level = 1;\n    while n != 0 {\n\
    \        pile.push(n);\n        levels.push_back(level);\n        if n % 2 ==\
    \ 0 {\n            n = n / 2;\n        } else {\n            n = (3 * n) + 1;\n\
    \        }\n        level += 1;\n    }\n    levels.reverse();\n    pile\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_back` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmpwh2ap7ux.rs:15:16\n   |\n15 |         levels.push_back(level);\n\
    \   |                ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n == 0 {\n   \
    \     return vec![0];\n    }\n    let mut pile = vec![0];\n    if n % 2 == 0 {\n\
    \        pile.push(n / 2);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ + 1);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[3, 5, 7]`', /tmp/tmp1_sc69c1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push(i + 1);\n    }\n    for i in 2..n / 2 {\n        pile.push(i\
    \ * 2);\n    }\n    for i in 3..n / 2 {\n        pile.push(i * 3);\n    }\n  \
    \  for i in 4..n / 2 {\n        pile.push(i * 4);\n    }\n    for i in 5..n /\
    \ 2 {\n        pile.push(i * 5);\n    }\n    for i in 6..n / 2 {\n        pile.push(i\
    \ * 6);\n    }\n    for i in 7..n / 2 {\n        pile.push(i * 7);\n    }\n  \
    \  for i in 8..n / 2 {\n        pile.push(i * 8);\n    }\n    for i in 9..n /\
    \ 2 {\n        pile.push(i * 9);\n    }\n    for i in 10..n / 2 {\n        pile.push(i\
    \ * 10);\n    }\n    for i in 11..n / 2 {\n        pile.push(i * 11);\n    }\n\
    \    for i in 12..n / 2 {\n        pile.push(i * 12);\n    }\n    for i in 13..n\
    \ / 2 {\n        pile.push(i * 13);\n    }\n    for i in 14..n / 2 {\n       \
    \ pile.push(i * 14);\n    }\n    for i in 15..n / 2 {\n        pile.push(i * 15);\n\
    \    }\n    for i in 16..n / 2 {\n        pile.push(i * 16);\n    }\n    for i\
    \ in 17..n / 2 {\n        pile.push(i * 17);\n    }\n    for i in 18..n / 2 {\n\
    \        pile.push(i * 18);\n    }\n    for i in 19..n / 2 {\n        pile.push(i\
    \ * 19);\n    }\n    for i in 20..n / 2 {\n        pile.push(i * 20);\n    }\n\
    \    for i in 21..n / 2 {\n        pile.push(i * 21);\n    }\n    for i in 22..n\
    \ / 2 {\n        pile.push(i * 22);\n    }\n    for i in 23..n / 2 {\n       \
    \ pile.push(i * 23);\n    }\n    for i in 24..n / 2 {\n        pile.push(i * 24);\n\
    \    }\n    for i in 25..n / 2 {\n        pile.push(i * 25);\n    }\n    for i\
    \ in 26..n / 2 {\n        pile.push(i * 26);\n    }\n    for i in 27..n / 2 {\n\
    \        pile.push(i * 27);\n    }\n    for i in 28..n / 2 {\n        pile.push(i\
    \ * 28);\n    }\n    for i in 29\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpfittvh1j.rs:99:1\n   |\n\
    99 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        if i % 2 == 0 {\n \
    \           pile[i] = pile[i / 2] + 1;\n        } else {\n            pile[i]\
    \ = pile[i / 2] + 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzfidnqr5.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:14:13\n   |\n14 |            \
    \ pile[i] = pile[i / 2] + 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:14:23\n   |\n14 |  \
    \           pile[i] = pile[i / 2] + 1;\n   |                       ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:16:13\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 2;\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:16:23\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 2;\n   |                     \
    \  ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 5 p"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 2);\n    }\n    for i in 1..n {\n        pile.push((i + 1) * (i + 1));\n \
    \   }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 9]`,\n right: `[3, 5, 7]`', /tmp/tmphogx5gjx.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    pile.push(n);\n    if n % 2 == 0 {\n        pile.push(n - 1);\n    }\n  \
    \  pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[3, 5, 7]`', /tmp/tmp4d1b2njl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += 2;\n    \
    \    }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ruth_2d.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp2ruth_2d.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp2ruth_2d.rs:16:13\n\
    \   |\n16 |             pile[i] += 2;\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    pile.push(n);\n    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else\
    \ {\n        pile.push(n - 2);\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpwwojz9fi.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        for _ in 0..n {\n            pile.push(n - 1);\n\
    \        }\n    } else {\n        for _ in 0..n {\n            pile.push(n - 1);\n\
    \        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpyc_chs1l.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    if n % 2 == 1 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 0..n / 2 {\n        pile.push(n\
    \ - 2 * i);\n    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i + 1);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i + 2);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(n - 2 * i + 3);\n    }\n    for i in\
    \ 0..n / 2 {\n        pile.push(n - 2 * i + 4);\n    }\n    for i in 0..n / 2\
    \ {\n        pile.push(n - 2 * i + 5);\n    }\n    for i in 0..n / 2 {\n     \
    \   pile.push(n - 2 * i + 6);\n    }\n    for i in 0..n / 2 {\n        pile.push(n\
    \ - 2 * i + 7);\n    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i +\
    \ 8);\n    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i + 9);\n   \
    \ }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i + 10);\n    }\n    for\
    \ i in 0..n / 2 {\n        pile.push(n - 2 * i + 11);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(n - 2 * i + 12);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push(n - 2 * i + 13);\n    }\n    for i in 0..n / 2 {\n        pile.push(n\
    \ - 2 * i + 14);\n    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i\
    \ + 15);\n    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i + 16);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i + 17);\n    }\n \
    \   for i in 0..n / 2 {\n        pile.push(n - 2 * i + 18);\n    }\n    for i\
    \ in 0..n / 2 {\n        pile.push(n - 2 * i + 19);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(n - 2 * i + 20);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push(n - 2 * i + 21);\n    }\n    for i in 0..n / 2 {\n        pile.push(n\
    \ - 2 * i + 22);\n    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i\
    \ + 23);\n    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i + 24);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push(n - 2 * i + 25);\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpv4bbums0.rs:103:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n92  |     for i in 0..n /\
    \ 2 {\n    |                       - this delimiter might not be properly closed...\n\
    93  |         pile.push(n - 2 * i + 25);\n94  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n103 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpv4bbums0.rs:9:29\n  |\n9 | fn make_a_pile(n: isize) -> Vec<isize>\
    \ {\n  |    -----------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut next_odd_level = 0;\n    let mut next_even_level = 0;\n    for i\
    \ in 0..n {\n        if i % 2 == 0 {\n            pile.push(next_even_level);\n\
    \            next_even_level += 1;\n        } else {\n            pile.push(next_odd_level);\n\
    \            next_odd_level += 1;\n        }\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 1]`,\n right: `[3, 5, 7]`', /tmp/tmphxn6mtjr.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) + (i as isize));\n        }\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 3, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpqkp1w2qf.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    pile[1..].iter().cloned().for_each(|x| {\n \
    \       if x.is_odd() {\n            pile[2] += x;\n        } else {\n       \
    \     pile[2] += x;\n            pile[3] += x;\n        }\n    });\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzxswj8tm.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_odd` found\
    \ for type `{integer}` in the current scope\n  --> /tmp/tmpzxswj8tm.rs:13:14\n\
    \   |\n13 |         if x.is_odd() {\n   |              ^^^^^^ method not found\
    \ in `{integer}`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i + 1);\n\
    \        } else {\n            pile.push(n - i);\n        }\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3]`,\n right: `[3, 5, 7]`', /tmp/tmpivmsi7d2.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    pile.push(n);\n    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else\
    \ {\n        pile.push(n - 2);\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpifco5li0.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    if n % 2 == 0 {\n        pile[1] += 1;\n   \
    \ }\n    for i in 2..=n {\n        pile[i] += pile[i - 1];\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9nj_6uup.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp9nj_6uup.rs:16:9\n   |\n16 |         pile[i]\
    \ += pile[i - 1];\n   |         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9nj_6uup.rs:16:20\n   |\n16 |  \
    \       pile[i] += pile[i - 1];\n   |                    ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, 2 * n - 1]\n    }\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5]`,\n right: `[3, 5, 7]`', /tmp/tmp_5rwpzed.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n];\n    let mut i = 0;\n    while i < n {\n        pile[i] = i + 1;\n     \
    \   if n % 2 == 0 {\n            i += 2;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6jmtddtt.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n];\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n10 |     let mut pile =\
    \ vec![0; n.try_into().unwrap()];\n   |                            ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp6jmtddtt.rs:13:9\n\
    \   |\n13 |         pile[i] = i + 1;\n   |         ^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        pile[i] += pile[i\
    \ - 1];\n        if i % 2 == 0 {\n            pile[i] += 1;\n        }\n    }\n\
    \    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnq0_oghc.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpnq0_oghc.rs:13:9\n   |\n13 |         pile[i]\
    \ += pile[i - 1];\n   |         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpnq0_oghc.rs:13:20\n   |\n13 |         pile[i] += pile[i\
    \ - 1];\n   |                    ^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpnq0_oghc.rs:15:13\n   |\n15 |  \
    \           pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut n = 0;\n    while n < n {\n        pile.push(n);\n        if n %\
    \ 2 == 0 {\n            n = n + 1;\n        } else {\n            n = n + 2;\n\
    \        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[3, 5, 7]`', /tmp/tmpf2t_ss7c.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..n+1 {\n        if i % 2 == 0 {\n\
    \            pile[i] += pile[i - 1];\n        } else {\n            pile[i] +=\
    \ pile[i - 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qgcjyvn.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp_qgcjyvn.rs:14:13\n   |\n14 |         \
    \    pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp_qgcjyvn.rs:14:24\n   |\n14 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp_qgcjyvn.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp_qgcjyvn.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `u"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    let mut i = 0;\n    while i < n {\n        if n % 2 == 0 {\n  \
    \          pile[i] = pile[i / 2] + (i + 1);\n        } else {\n            pile[i]\
    \ = pile[i / 2] + 1;\n        }\n        i += 1;\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxfg53i42.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxfg53i42.rs:14:13\n   |\n14 |         \
    \    pile[i] = pile[i / 2] + (i + 1);\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxfg53i42.rs:14:23\n   |\n14 |  \
    \           pile[i] = pile[i / 2] + (i + 1);\n   |                       ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxfg53i42.rs:16:13\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 1;\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxfg53i42.rs:16:23\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 1;\n   |                     \
    \  ^^^^^^^^^^^ slice "
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut level = vec![0; n];\n    let mut next_level = vec![0; n];\n    let\
    \ mut next_level_odd = vec![0; n];\n    let mut next_level_even = vec![0; n];\n\
    \    let mut odd_count = 0;\n    let mut even_count = 0;\n    let mut odd_count_even\
    \ = 0;\n    let mut even_count_even = 0;\n    let mut odd_count_odd = 0;\n   \
    \ let mut even_count_odd = 0;\n    let mut odd_count_even_odd = 0;\n    let mut\
    \ even_count_even_odd = 0;\n    let mut odd_count_even_even_odd = 0;\n    let\
    \ mut even_count_even_even_odd = 0;\n    let mut odd_count_even_even_even_odd\
    \ = 0;\n    let mut even_count_even_even_even_odd = 0;\n    let mut odd_count_even_even_even_even_odd\
    \ = 0;\n    let mut even_count_even_even_even_even_odd = 0;\n    let mut odd_count_even_even_even_even_even_odd\
    \ = 0;\n    let mut even_count_even_even_even_even_even_odd = 0;\n    let mut\
    \ odd_count_even_even_even_even_even_even_odd = 0;\n    let mut even_count_even_even_even_even_even_even_odd\
    \ = 0;\n    let mut odd_count_even_even_even_even_even_even_even_odd = 0;\n  \
    \  let mut even_count_even_even_even_even_even_even_even_odd = 0;\n    let mut\
    \ odd_count_even_even_even_even_even_even_even_even_odd = 0;\n    let mut even_count_even_even_even_even_even_even_even_even_odd\
    \ = 0;\n    let mut odd_count_even_even_even_even_even_even_even_even_even_odd\
    \ = 0;\n    let mut even_count_even_even_even_even_even_even_even_even_even_odd\
    \ = 0;\n    let mut odd_count_even_even_even_even_even_even_even_even_even_even_odd\
    \ = 0;\n    let mut even_count_even_even_even_even_even_even_even_even_even_even_odd\
    \ = 0;\n    let mut od\n}\n\nfn main() {\n    let candidate = make_a_pile;\n \
    \   assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8xdw6dzb.rs:41:15\n   |\n\
    41 |     let mut od\n   |               ^ help: add `;` here\n42 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8xdw6dzb.rs:11:29\n \
    \  |\n11 |     let mut level = vec![0; n];\n   |                             ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n11 |     let mut\
    \ level = vec![0; n.try_into().unwrap()];\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8xdw6dzb.rs:12:34\n   |\n12 |\
    \     let mut next_level = vec![0; n];\n   |                                 \
    \ ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ next_level = vec![0; n.try_into().unwrap()];\n   |                         \
    \          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8xdw6dzb.rs:13:38\n\
    \   |\n13 |     let mut next_level_odd = vec![0; n];\n   |                   \
    \                   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    13 |     let mut next_level_odd = vec![0; n.try_into().unwrap()];\n   |      \
    \                                 ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8xdw6dzb.rs:14:39\n   |\n14 |     let mut next_level_even\
    \ = vec![0; n];\n   |                                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     let mut next_level_even =\
    \ vec![0; n.try_into().unwrap()];\n   |                                      \
    \  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8xdw6dzb.rs:9:29\n\
    \  |\n9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------       \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no ta"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += 2;\n    \
    \    }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ruth_2d.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp2ruth_2d.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp2ruth_2d.rs:16:13\n\
    \   |\n16 |             pile[i] += 2;\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut next_odd_level = 0;\n    let mut next_even_level = 0;\n    for i\
    \ in 0..n {\n        if i % 2 == 0 {\n            next_even_level += 1;\n    \
    \    } else {\n            next_odd_level += 1;\n        }\n        pile.push(next_odd_level);\n\
    \        pile.push(next_even_level);\n    }\n    pile\n}\n\nfn main() {\n    let\
    \ candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n   \
    \ assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5,\
    \ 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
    \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 1, 1, 2]`,\n right: `[3, 5, 7]`', /tmp/tmp2ck2kk6q.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) & !i);\n        }\n    }\n  \
    \  pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpw_ch0ud8.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 1..n {\n        pile.push(i);\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 1, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpnb_iegeh.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut next_odd_num = 0;\n    let mut next_even_num = 0;\n    for i in 0..n\
    \ {\n        if i % 2 == 0 {\n            next_even_num += i;\n        } else\
    \ {\n            next_odd_num += i;\n        }\n        pile.push(next_odd_num);\n\
    \        pile.push(next_even_num);\n    }\n    pile\n}\n\nfn main() {\n    let\
    \ candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n   \
    \ assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5,\
    \ 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
    \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 1, 0, 1, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpm7rpt258.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i + 1);\n\
    \        } else {\n            pile.push(i + 2);\n        }\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 3]`,\n right: `[3, 5, 7]`', /tmp/tmp8u8hzn49.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 1;\n    while n != 0 {\n        if n % 2 == 0 {\n       \
    \     pile.push(level);\n            n /= 2;\n        } else {\n            pile.push(level\
    \ + 1);\n            n /= 2;\n        }\n        level += 1;\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppsxl87oa.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmppsxl87oa.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..n+1 {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb8c1qc89.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpb8c1qc89.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpb8c1qc89.rs:16:13\n   |\n16 |  \
    \           pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpb8c1qc89.rs:16:24\n   |\n16 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        let mut stones = Vec::new();\n        for _ in 0..n {\n            stones.push(1);\n\
    \        }\n        stones.push(stones.len() as isize);\n        return stones;\n\
    \    }\n    let mut stones = Vec::new();\n    for _ in 0..n {\n        stones.push(1);\n\
    \    }\n    stones.push(stones.len() as isize);\n    stones.iter().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpup2wge31.rs:24:1\n   |\n24\
    \ | }\n   | ^\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_,\
    \ isize> as Iterator>::Item == &&_`\n    --> /tmp/tmpup2wge31.rs:23:34\n     |\n\
    23   |     stones.iter().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev()...\n\
    \     |                                  ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `rev` exists for struct `Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpup2wge31.rs:23:43\n\
    \   |\n23 |   ....cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev().cloned().rev(...\n\
    \   |                ^^^ method cannot be called on `Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Rev<Cloned<std::slice::Iter<'_, isize>>>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n           `Cloned<Rev<Cloned<std::slice::Iter<'_, isize>>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut current_level = 1;\n    let mut next_level = 1;\n    while n != 0\
    \ {\n        if n % 2 == 0 {\n            next_level = current_level;\n      \
    \      current_level = current_level + 1;\n        } else {\n            next_level\
    \ = current_level;\n            current_level = current_level + 1;\n        }\n\
    \        pile.push(next_level);\n        n = n / 2;\n    }\n    pile\n}\n\nfn\
    \ main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: value assigned to `next_level` is never read\n  --> /tmp/tmp3ru_b4pt.rs:12:13\n\
    \   |\n12 |     let mut next_level = 1;\n   |             ^^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `n`\n  --> /tmp/tmp3ru_b4pt.rs:22:9\n   |\n9  | fn make_a_pile(n: isize) ->\
    \ Vec<isize> {\n   |                - help: consider making this binding mutable:\
    \ `mut n`\n...\n22 |         n = n / 2;\n   |         ^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 0..n / 2\
    \ {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 2);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 3);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 4);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 5);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 6);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 7);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 8);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 9);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 10);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 11);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 12);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(i + 13);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 14);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 15);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 16);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(i + 17);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 18);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 19);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 20);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(i + 21);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 22);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 23);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 24);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(i + 25);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 26);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 27);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 28);\n    }\n    for i in 0.\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpvqqr4qn5.rs:99:1\n   |\n\
    99 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) as isize);\n        }\n    }\n\
    \    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpp_mdznul.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg3y9u6kl.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        if i % 2 == 0 {\n \
    \           pile[i] = pile[i / 2] + 1;\n        } else {\n            pile[i]\
    \ = pile[i / 2] + 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzfidnqr5.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:14:13\n   |\n14 |            \
    \ pile[i] = pile[i / 2] + 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:14:23\n   |\n14 |  \
    \           pile[i] = pile[i / 2] + 1;\n   |                       ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:16:13\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 2;\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:16:23\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 2;\n   |                     \
    \  ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 5 p"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    pile[1] = if n % 2 == 0 {\n        pile[0] +\
    \ 2\n    } else {\n        pile[0] + 1\n    };\n    for i in 2..=n {\n       \
    \ pile[i] = if i % 2 == 0 {\n            pile[i - 1] + 2\n        } else {\n \
    \           pile[i - 1] + 1\n        };\n    }\n    pile\n}\n\nfn main() {\n \
    \   let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n\
    \    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu716n3x2.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpu716n3x2.rs:18:9\n   |\n18 |         pile[i]\
    \ = if i % 2 == 0 {\n   |         ^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpu716n3x2.rs:19:13\n   |\n19 |             pile[i - 1] + 2\n   |\
    \             ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpu716n3x2.rs:21:13\n\
    \   |\n21 |             pile[i - 1] + 1\n   |             ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        pile[i] = if i % 2\
    \ == 0 {\n            pile[i / 2] + 1\n        } else {\n            pile[i /\
    \ 2]\n        };\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkddg0_2q.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkddg0_2q.rs:13:9\n   |\n13 |         pile[i]\
    \ = if i % 2 == 0 {\n   |         ^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpkddg0_2q.rs:14:13\n   |\n14 |             pile[i / 2] + 1\n   |\
    \             ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkddg0_2q.rs:16:13\n\
    \   |\n16 |             pile[i / 2]\n   |             ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push((i + 1) * 2);\n    }\n    for i in 2..n / 2 {\n       \
    \ pile.push((i + 1) * 2 - 1);\n    }\n    for i in 3..n / 2 {\n        pile.push((i\
    \ + 1) * 2 - 2);\n    }\n    for i in 4..n / 2 {\n        pile.push((i + 1) *\
    \ 2 - 3);\n    }\n    for i in 5..n / 2 {\n        pile.push((i + 1) * 2 - 4);\n\
    \    }\n    for i in 6..n / 2 {\n        pile.push((i + 1) * 2 - 5);\n    }\n\
    \    for i in 7..n / 2 {\n        pile.push((i + 1) * 2 - 6);\n    }\n    for\
    \ i in 8..n / 2 {\n        pile.push((i + 1) * 2 - 7);\n    }\n    for i in 9..n\
    \ / 2 {\n        pile.push((i + 1) * 2 - 8);\n    }\n    for i in 10..n / 2 {\n\
    \        pile.push((i + 1) * 2 - 9);\n    }\n    for i in 11..n / 2 {\n      \
    \  pile.push((i + 1) * 2 - 10);\n    }\n    for i in 12..n / 2 {\n        pile.push((i\
    \ + 1) * 2 - 11);\n    }\n    for i in 13..n / 2 {\n        pile.push((i + 1)\
    \ * 2 - 12);\n    }\n    for i in 14..n / 2 {\n        pile.push((i + 1) * 2 -\
    \ 13);\n    }\n    for i in 15..n / 2 {\n        pile.push((i + 1) * 2 - 14);\n\
    \    }\n    for i in 16..n / 2 {\n        pile.push((i + 1) * 2 - 15);\n    }\n\
    \    for i in 17..n / 2 {\n        pile.push((i + 1) * 2 - 16);\n    }\n    for\
    \ i in 18..n / 2 {\n        pile.push((i + 1) * 2 - 17);\n    }\n    for i in\
    \ 19..n / 2 {\n        pile.push((i + 1) * 2 - 18);\n    }\n    for i in 20..n\
    \ / 2 {\n        pile.push((i + 1) * 2 - 19);\n    }\n    for i in 21..n / 2 {\n\
    \        pile.push((i + 1) * 2 - 20);\n    }\n    for i in 22..n / 2 {\n     \
    \   pile.push((i + 1) * 2 - 21);\n    }\n    for i in 23..n / 2 {\n        pile.push((i\
    \ + 1) * 2 - 22);\n    }\n    for i in 24..n / 2 {\n        pile.push((i + 1)\
    \ * 2 - 23);\n    }\n    for i in 25..n / 2 {\n        pile.push((i + 1) * 2 -\
    \ 24);\n    }\n    for i in 26..n / 2 {\n\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_e17bad8.rs:100:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n89  |     for i in 26..n /\
    \ 2 {\n    |                        - this delimiter might not be properly closed...\n\
    90  | \n91  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n100 | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_e17bad8.rs:9:29\n\
    \  |\n9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------       \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n+1, n+2]\n    } else {\n        vec![n, n-1, n-2]\n    }\n}\n\
    \nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 1]`,\n right: `[3, 5, 7]`', /tmp/tmp1o0g8pi3.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut next_odd_level = 0;\n    let mut next_even_level = 0;\n    for _\
    \ in 0..n {\n        if n % 2 == 0 {\n            pile.push(next_even_level);\n\
    \            next_even_level += 1;\n        } else {\n            pile.push(next_odd_level);\n\
    \            next_odd_level += 1;\n        }\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpyiaupjk8.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    pile[n] += 1;\n    for i in 1..=n {\n      \
    \  if i % 2 == 0 {\n            pile[i] += pile[i - 1];\n        } else {\n  \
    \          pile[i] += pile[i - 2];\n        }\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnjhxi289.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpnjhxi289.rs:12:5\n   |\n12 |     pile[n]\
    \ += 1;\n   |     ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpnjhxi289.rs:15:13\n\
    \   |\n15 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpnjhxi289.rs:15:24\n\
    \   |\n15 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpnjhxi289.rs:17:13\n\
    \   |\n17 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help:"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        make_a_pile_odd(n)\n    } else {\n        make_a_pile_even(n)\n    }\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `make_a_pile_odd` in this scope\n  -->\
    \ /tmp/tmp2q1nhwll.rs:11:9\n   |\n11 |         make_a_pile_odd(n)\n   |      \
    \   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `make_a_pile_even` in this scope\n  --> /tmp/tmp2q1nhwll.rs:13:9\n   |\n13 |\
    \         make_a_pile_even(n)\n   |         ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n + 1]\n    } else {\n        vec![n, n - 1]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2]`,\n right: `[3, 5, 7]`', /tmp/tmp0z5cnskp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    let mut i = 0;\n    while i < n {\n        pile[i] = i + 1;\n \
    \       if i % 2 == 0 {\n            i += 1;\n        } else {\n            i\
    \ += 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg2tcqfdc.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpg2tcqfdc.rs:13:9\n   |\n13 |         pile[i]\
    \ = i + 1;\n   |         ^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    pile.push(n);\n    if n % 2 == 0 {\n        pile.push(n - 1);\n    }\n  \
    \  if n % 2 == 1 {\n        pile.push(n - 2);\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpzllpwbzs.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    pile.push(1);\n    if n % 2 == 1 {\n        pile.push(n - 1);\n    }\n  \
    \  for i in 2..n / 2 {\n        pile.push((i + 1) * i);\n    }\n    pile\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpd6hvt0tz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            pile.push(n\
    \ % 2);\n            n /= 2;\n        } else {\n            pile.push(n / 2);\n\
    \            n /= 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1]`,\n right: `[3, 5, 7]`', /tmp/tmp49fbdfmu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 1;\n    while level < n {\n        pile.push(level);\n  \
    \      if n % 2 == 0 {\n            level += 1;\n        } else {\n          \
    \  level += 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[3, 5, 7]`', /tmp/tmpieow8hm0.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut level = 1;\n    while n != 0 {\n        if n % 2 == 0 {\n       \
    \     pile.push(level);\n            n /= 2;\n        } else {\n            pile.push(level\
    \ - 1);\n            n /= 2;\n        }\n        level += 1;\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp89vhggx1.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmp89vhggx1.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    if n % 2 == 0 {\n        pile[1] += 1;\n   \
    \ }\n    for i in 2..=n {\n        pile[i] += pile[i - 1];\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9nj_6uup.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp9nj_6uup.rs:16:9\n   |\n16 |         pile[i]\
    \ += pile[i - 1];\n   |         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9nj_6uup.rs:16:20\n   |\n16 |  \
    \       pile[i] += pile[i - 1];\n   |                    ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i);\n   \
    \     } else {\n            pile.push(n - i);\n        }\n    }\n    pile\n}\n\
    \nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpy58lo2fz.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) & !i);\n        }\n    }\n  \
    \  pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpw_ch0ud8.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg3y9u6kl.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    pile[1..].iter().cloned().for_each(|x| {\n \
    \       if x.is_odd() {\n            pile[2] += 1;\n        } else {\n       \
    \     pile[2] += 2;\n        }\n    });\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3hk4i_2q.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0599]: no method named `is_odd` found\
    \ for type `{integer}` in the current scope\n  --> /tmp/tmp3hk4i_2q.rs:13:14\n\
    \   |\n13 |         if x.is_odd() {\n   |              ^^^^^^ method not found\
    \ in `{integer}`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 0;\n    while n != 0 {\n        pile.push(level);\n     \
    \   n -= 1;\n        level += 1;\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpwdwegm2b.rs:14:9\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n14 |         n -= 1;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push((n\
    \ - 1) / 2);\n    }\n    for i in 0..n {\n        pile.push((i + 1) * pile[n -\
    \ 1 - i]);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmptl1a80kb.rs:17:29\n\
    \   |\n17 |         pile.push((i + 1) * pile[n - 1 - i]);\n   |              \
    \               ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 0;\n    while level < n {\n        if n % 2 == 0 {\n    \
    \        pile.push(level + 1);\n            n /= 2;\n        } else {\n      \
    \      pile.push(level + 1);\n            n /= 2;\n            pile.push(n);\n\
    \        }\n        level += 1;\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpbqcghlni.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpbqcghlni.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    } else {\n        pile.push(n\
    \ / 2 + 1);\n    }\n    for i in 0..n {\n        pile.push(i + 1);\n    }\n  \
    \  pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 2, 3]`,\n right: `[3, 5, 7]`', /tmp/tmpqb3e5n08.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    if n % 2 == 0 {\n        pile[1] += 1;\n   \
    \ }\n    for i in 2..=n {\n        pile[i] += pile[i - 1];\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9nj_6uup.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp9nj_6uup.rs:16:9\n   |\n16 |         pile[i]\
    \ += pile[i - 1];\n   |         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9nj_6uup.rs:16:20\n   |\n16 |  \
    \       pile[i] += pile[i - 1];\n   |                    ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut i = 0;\n    while i < n {\n        if n % 2 == 0 {\n            pile.push(n\
    \ - i);\n            i += 1;\n        } else {\n            pile.push(i);\n  \
    \          i += 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpb2qe43cb.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut levels = vec![];\n    let mut level = 0;\n    while n != 0 {\n  \
    \      pile.push(level);\n        levels += vec![level];\n        level += 1;\n\
    \        n -= 1;\n    }\n    pile.push(level);\n    levels += vec![level];\n \
    \   level += 1;\n    levels.reverse();\n    levels\n}\n\nfn main() {\n    let\
    \ candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n   \
    \ assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5,\
    \ 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
    \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<_>`\n  --> /tmp/tmpnhuz428w.rs:15:9\n   |\n15 |         levels += vec![level];\n\
    \   |         ------^^^^^^^^^^^^^^^\n   |         |\n   |         cannot use `+=`\
    \ on type `Vec<_>`\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `Vec<_>`\n  --> /tmp/tmpnhuz428w.rs:20:5\n   |\n20 |     levels\
    \ += vec![level];\n   |     ------^^^^^^^^^^^^^^^\n   |     |\n   |     cannot\
    \ use `+=` on type `Vec<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut num_stones = n;\n    while num_stones > 0 {\n        if num_stones\
    \ % 2 == 0 {\n            pile.push(num_stones / 2);\n            num_stones =\
    \ num_stones / 2;\n        } else {\n            pile.push(num_stones);\n    \
    \        num_stones = num_stones - 1;\n        }\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1, 1]`,\n right: `[3, 5, 7]`', /tmp/tmp876p3n0e.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n];\n    pile[0] += 1;\n    for i in 1..n {\n        if i % 2 == 0 {\n     \
    \       pile[i] += 1;\n        } else {\n            pile[i] += pile[i - 1];\n\
    \        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxj147qdh.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n];\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n10 |     let mut pile =\
    \ vec![0; n.try_into().unwrap()];\n   |                             ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxj147qdh.rs:14:13\n\
    \   |\n14 |             pile[i] += 1;\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxj147qdh.rs:16:13\n   |\n16 |  \
    \           pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxj147qdh.rs:16:24\n   |\n16 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    if n % 2 == 0 {\n        pile[1] += 1;\n   \
    \ }\n    for i in 2..=n {\n        if i % 2 == 0 {\n            pile[i] += 1;\n\
    \        } else {\n            pile[i] += pile[i - 1];\n        }\n    }\n   \
    \ pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgwn6y8ap.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpgwn6y8ap.rs:17:13\n   |\n17 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgwn6y8ap.rs:19:13\n   |\n19 |  \
    \           pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgwn6y8ap.rs:19:24\n   |\n19 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        if i % 2 == 0 {\n \
    \           pile[i] = pile[i - 1] + 1;\n        } else {\n            pile[i]\
    \ = pile[i - 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo6zcqqxa.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:14:13\n   |\n14 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:14:23\n   |\n14 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:16:13\n   |\n16 |            \
    \ pile[i] = pile[i - 1];\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:16:23\n   |\n16 |            \
    \ pile[i] = pile[i - 1];\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = h"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 0;\n    while n != 0 {\n        if n % 2 == 0 {\n       \
    \     pile.push(level);\n            n /= 2;\n        } else {\n            pile.push(level\
    \ + 1);\n            n /= 2;\n        }\n        level += 1;\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpjl23988l.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpjl23988l.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        make_a_pile_odd(n)\n    } else {\n        make_a_pile_even(n)\n    }\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `make_a_pile_odd` in this scope\n  -->\
    \ /tmp/tmp2q1nhwll.rs:11:9\n   |\n11 |         make_a_pile_odd(n)\n   |      \
    \   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `make_a_pile_even` in this scope\n  --> /tmp/tmp2q1nhwll.rs:13:9\n   |\n13 |\
    \         make_a_pile_even(n)\n   |         ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push((n\
    \ - 1) / 2);\n    }\n    for i in 0..n {\n        pile.push((i + 1) * pile[pile.len()\
    \ - 1]);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 6]`,\n right: `[3, 5, 7]`', /tmp/tmpe38m42r5.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) + (i as isize));\n        }\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 3, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpqkp1w2qf.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push((i + 1) * 2);\n    }\n    for i in 2..n / 2 {\n       \
    \ pile.push((i + 1) * 2 + 1);\n    }\n    for i in 3..n / 2 {\n        pile.push((i\
    \ + 1) * 2 + 2);\n    }\n    for i in 4..n / 2 {\n        pile.push((i + 1) *\
    \ 2 + 3);\n    }\n    for i in 5..n / 2 {\n        pile.push((i + 1) * 2 + 4);\n\
    \    }\n    for i in 6..n / 2 {\n        pile.push((i + 1) * 2 + 5);\n    }\n\
    \    for i in 7..n / 2 {\n        pile.push((i + 1) * 2 + 6);\n    }\n    for\
    \ i in 8..n / 2 {\n        pile.push((i + 1) * 2 + 7);\n    }\n    for i in 9..n\
    \ / 2 {\n        pile.push((i + 1) * 2 + 8);\n    }\n    for i in 10..n / 2 {\n\
    \        pile.push((i + 1) * 2 + 9);\n    }\n    for i in 11..n / 2 {\n      \
    \  pile.push((i + 1) * 2 + 10);\n    }\n    for i in 12..n / 2 {\n        pile.push((i\
    \ + 1) * 2 + 11);\n    }\n    for i in 13..n / 2 {\n        pile.push((i + 1)\
    \ * 2 + 12);\n    }\n    for i in 14..n / 2 {\n        pile.push((i + 1) * 2 +\
    \ 13);\n    }\n    for i in 15..n / 2 {\n        pile.push((i + 1) * 2 + 14);\n\
    \    }\n    for i in 16..n / 2 {\n        pile.push((i + 1) * 2 + 15);\n    }\n\
    \    for i in 17..n / 2 {\n        pile.push((i + 1) * 2 + 16);\n    }\n    for\
    \ i in 18..n / 2 {\n        pile.push((i + 1) * 2 + 17);\n    }\n    for i in\
    \ 19..n / 2 {\n        pile.push((i + 1) * 2 + 18);\n    }\n    for i in 20..n\
    \ / 2 {\n        pile.push((i + 1) * 2 + 19);\n    }\n    for i in 21..n / 2 {\n\
    \        pile.push((i + 1) * 2 + 20);\n    }\n    for i in 22..n / 2 {\n     \
    \   pile.push((i + 1) * 2 + 21);\n    }\n    for i in 23..n / 2 {\n        pile.push((i\
    \ + 1) * 2 + 22);\n    }\n    for i in 24..n / 2 {\n        pile.push((i + 1)\
    \ * 2 + 23);\n    }\n    for i in 25..n / 2 {\n        pile.push((i + 1) * 2 +\
    \ 24);\n    }\n    for i in 26..n / 2 {\n\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdjitdyo1.rs:100:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n89  |     for i in 26..n /\
    \ 2 {\n    |                        - this delimiter might not be properly closed...\n\
    90  | \n91  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n100 | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdjitdyo1.rs:9:29\n\
    \  |\n9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------       \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 - 1);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 1);\n \
    \   }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 2);\n    }\n \
    \   for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 3);\n    }\n    for i\
    \ in 0..n / 2 {\n        pile.push((i + 1) * 2 + 4);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + 1) * 2 + 5);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push((i + 1) * 2 + 6);\n    }\n    for i in 0..n / 2 {\n       \
    \ pile.push((i + 1) * 2 + 7);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 + 8);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2 + 9);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 10);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 11);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 12);\n    }\n    for\
    \ i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 13);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + 1) * 2 + 14);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push((i + 1) * 2 + 15);\n    }\n    for i in 0..n / 2 {\n      \
    \  pile.push((i + 1) * 2 + 16);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 + 17);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2 + 18);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 19);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 20);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 21);\n    }\n    for\
    \ i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 22);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + \n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfbs4fgtz.rs:100:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n89  |     for i in 0..n /\
    \ 2 {\n    |                       - this delimiter might not be properly closed...\n\
    90  |         pile.push((i + \n91  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n100 | }\n    |   ^\n\nerror: expected expression,\
    \ found `)`\n  --> /tmp/tmpfbs4fgtz.rs:91:1\n   |\n91 | }\n   | ^ expected expression\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpfbs4fgtz.rs:90:19\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                   \
    \                     - closing delimiter possibly meant for this\n...\n90 | \
    \        pile.push((i + \n   |                   ^ unclosed delimiter\n91 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfbs4fgtz.rs:9:29\n\
    \  |\n9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------       \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    pile.push(n);\n    if n % 2 == 0 {\n        pile.push(n - 1);\n    }\n  \
    \  pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[3, 5, 7]`', /tmp/tmp4d1b2njl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg3y9u6kl.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    if n % 2 == 0 {\n        pile[1] = pile[0] +\
    \ 1;\n    } else {\n        pile[1] = pile[0];\n    }\n    for i in 2..=n {\n\
    \        pile[i] = pile[i - 1] + if i % 2 == 0 {\n            pile[i / 2]\n  \
    \      } else {\n            pile[i / 2] + 1\n        };\n    }\n    pile\n}\n\
    \nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ne_ar28.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9ne_ar28.rs:18:9\n   |\n18 |         pile[i]\
    \ = pile[i - 1] + if i % 2 == 0 {\n   |         ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9ne_ar28.rs:18:19\n   |\n18 |         pile[i]\
    \ = pile[i - 1] + if i % 2 == 0 {\n   |                   ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9ne_ar28.rs:19:13\n   |\n19 |            \
    \ pile[i / 2]\n   |             ^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9ne_ar28.rs:21:13\n   |\n21 |            \
    \ pile[i / 2] + 1\n   |             ^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait "
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 0..n / 2\
    \ {\n        pile.push((i + 1) * 2);\n    }\n    for i in 0..n / 2 {\n       \
    \ pile.push((i + 1) * 2 - 1);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 - 2);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2 - 3);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 4);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 5);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 6);\n    }\n    for\
    \ i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 7);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + 1) * 2 - 8);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push((i + 1) * 2 - 9);\n    }\n    for i in 0..n / 2 {\n       \
    \ pile.push((i + 1) * 2 - 10);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 - 11);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2 - 12);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 13);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 14);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 15);\n    }\n    for\
    \ i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 16);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + 1) * 2 - 17);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push((i + 1) * 2 - 18);\n    }\n    for i in 0..n / 2 {\n      \
    \  pile.push((i + 1) * 2 - 19);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 - 20);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2 - 21);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 22);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 23);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 - 24);\n    }\n    for\
    \ i in 0..n / 2 {\n\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpj1ffkw7k.rs:100:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n89  |     for i in 0..n /\
    \ 2 {\n    |                       - this delimiter might not be properly closed...\n\
    90  | \n91  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n100 | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpj1ffkw7k.rs:9:29\n\
    \  |\n9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------       \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = vec![];\n    let mut stones = vec![];\n    let mut odd_stones\
    \ = vec![];\n    let mut even_stones = vec![];\n    let mut next_odd_stones =\
    \ vec![];\n    let mut next_even_stones = vec![];\n    let mut next_level = vec![];\n\
    \    let mut next_stones = vec![];\n    let mut odd_stones_count = vec![];\n \
    \   let mut even_stones_count = vec![];\n    let mut next_odd_stones_count = vec![];\n\
    \    let mut next_even_stones_count = vec![];\n    let mut next_level_count =\
    \ vec![];\n    let mut next_stones_count = vec![];\n    let mut odd_stones_count_count\
    \ = vec![];\n    let mut even_stones_count_count = vec![];\n    let mut next_odd_stones_count_count\
    \ = vec![];\n    let mut next_even_stones_count_count = vec![];\n    let mut next_level_count_count\
    \ = vec![];\n    let mut next_stones_count_count = vec![];\n    let mut odd_stones_count_count_count\
    \ = vec![];\n    let mut even_stones_count_count_count = vec![];\n    let mut\
    \ next_odd_stones_count_count_count = vec![];\n    let mut next_even_stones_count_count_count\
    \ = vec![];\n    let mut next_level_count_count_count = vec![];\n    let mut next_stones_count_count_count\
    \ = vec![];\n    let mut odd_stones_count_count_count_count = vec![];\n    let\
    \ mut even_stones_count_count_count_count = vec![];\n    let mut next_odd_stones_count_count_count_count\
    \ = vec![];\n    let mut next_even_stones_count_count_count_count = vec![];\n\
    \    let mut next_level_count_count_count_count = vec![];\n    let mut next_stones_count_count_count_count\
    \ = vec![];\n    let mut odd_stones_count_count_count_count_count = vec![];\n\
    \    let mut even_stones_count_count_count_count_count = vec![];\n    let mut\
    \ next_odd_stones_count_count_count_count_count = vec![];\n    let mut next_even_stones_count_count_count_count_count\
    \ = vec![];\n    let mut next_level_count_count_count_count_count = vec![];\n\
    \    let mut next_stones_count_count_count_count_count = vec![];\n    let mut\
    \ od\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv8dypseg.rs:49:15\n   |\n\
    49 |     let mut od\n   |               ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpv8dypseg.rs:9:29\n  |\n\
    9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------             \
    \ ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut num_stones = n;\n    while num_stones > 0 {\n        if num_stones\
    \ % 2 == 0 {\n            pile.push(num_stones / 2);\n            num_stones =\
    \ num_stones / 2;\n        } else {\n            pile.push(num_stones);\n    \
    \        num_stones = num_stones - 1;\n        }\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpuh1s7ju0.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    let mut i = 0;\n    while i < n {\n        if i % 2 == 0 {\n  \
    \          pile[i] = pile[i / 2] as isize + 1;\n        } else {\n           \
    \ pile[i] = pile[i / 2] as isize + 1;\n            i += 1;\n        }\n    }\n\
    \    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0h2549lr.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp0h2549lr.rs:14:13\n   |\n14 |         \
    \    pile[i] = pile[i / 2] as isize + 1;\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0h2549lr.rs:14:23\n   |\n14 |  \
    \           pile[i] = pile[i / 2] as isize + 1;\n   |                       ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp0h2549lr.rs:16:13\n\
    \   |\n16 |             pile[i] = pile[i / 2] as isize + 1;\n   |            \
    \ ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp0h2549lr.rs:16:23\n\
    \   |\n16 |             pile[i] = pile[i / 2] as isize + 1;\n   |            \
    \     "
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 0..n / 2\
    \ {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 1);\n    }\n    for i in 0..n / 2 {\n\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgi_8y2cl.rs:115:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n104 |     for i in 0..n /\
    \ 2 {\n    |                       - this delimiter might not be properly closed...\n\
    105 | \n106 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n115 | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpgi_8y2cl.rs:9:29\n\
    \  |\n9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------       \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, n - 2]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpmvx_50k_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, 2 * n - 1]\n    }\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5]`,\n right: `[3, 5, 7]`', /tmp/tmp_5rwpzed.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    pile.push(n);\n    if n % 2 == 0 {\n        pile.push(n - 1);\n    }\n  \
    \  pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[3, 5, 7]`', /tmp/tmp4d1b2njl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        if i % 2 == 0 {\n \
    \           pile[i] = pile[i - 1] + 1;\n        } else {\n            pile[i]\
    \ = pile[i - 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo6zcqqxa.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:14:13\n   |\n14 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:14:23\n   |\n14 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:16:13\n   |\n16 |            \
    \ pile[i] = pile[i - 1];\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:16:23\n   |\n16 |            \
    \ pile[i] = pile[i - 1];\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = h"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut i = 0;\n    while i < n {\n        if n % 2 == 0 {\n            pile.push(i\
    \ as isize);\n            i += 1;\n        } else {\n            i += 2;\n   \
    \     }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[3, 5, 7]`', /tmp/tmprnhyot_q.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    let mut i = 0;\n    while i < n {\n        pile[i] = i + 1;\n \
    \       if i % 2 == 0 {\n            i += 1;\n        } else {\n            i\
    \ += 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg2tcqfdc.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpg2tcqfdc.rs:13:9\n   |\n13 |         pile[i]\
    \ = i + 1;\n   |         ^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    if n % 2 == 0 {\n        pile[1] += 1;\n   \
    \ }\n    for n in 2..=n {\n        pile[n] += pile[n-1];\n    }\n    pile\n}\n\
    \nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk2xagup_.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpk2xagup_.rs:16:9\n   |\n16 |         pile[n]\
    \ += pile[n-1];\n   |         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpk2xagup_.rs:16:20\n   |\n16 |         pile[n] += pile[n-1];\n\
    \   |                    ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        let mut\
    \ even = n - 1;\n        while even > 0 {\n            pile.push(even % 2);\n\
    \            even /= 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let\
    \ candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n   \
    \ assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5,\
    \ 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
    \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpxfir2fwd.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    let mut next_odd = 1;\n    let mut next_even = 1;\n    for i in\
    \ 0..n {\n        if i % 2 == 0 {\n            pile[i] = next_even;\n        \
    \    next_even += 2;\n        } else {\n            pile[i] = next_odd;\n    \
    \        next_odd += 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let\
    \ candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n   \
    \ assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5,\
    \ 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
    \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwls0l3ed.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpwls0l3ed.rs:15:13\n   |\n15 |         \
    \    pile[i] = next_even;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpwls0l3ed.rs:18:13\n   |\n18 |  \
    \           pile[i] = next_odd;\n   |             ^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push((i + 1) * 2);\n    }\n    for i in 2..n / 2 {\n       \
    \ pile.push((i + 1) * 2);\n    }\n    for i in 3..n / 2 {\n        pile.push((i\
    \ + 1) * 2);\n    }\n    for i in 4..n / 2 {\n        pile.push((i + 1) * 2);\n\
    \    }\n    for i in 5..n / 2 {\n        pile.push((i + 1) * 2);\n    }\n    for\
    \ i in 6..n / 2 {\n        pile.push((i + 1) * 2);\n    }\n    for i in 7..n /\
    \ 2 {\n        pile.push((i + 1) * 2);\n    }\n    for i in 8..n / 2 {\n     \
    \   pile.push((i + 1) * 2);\n    }\n    for i in 9..n / 2 {\n        pile.push((i\
    \ + 1) * 2);\n    }\n    for i in 10..n / 2 {\n        pile.push((i + 1) * 2);\n\
    \    }\n    for i in 11..n / 2 {\n        pile.push((i + 1) * 2);\n    }\n   \
    \ for i in 12..n / 2 {\n        pile.push((i + 1) * 2);\n    }\n    for i in 13..n\
    \ / 2 {\n        pile.push((i + 1) * 2);\n    }\n    for i in 14..n / 2 {\n  \
    \      pile.push((i + 1) * 2);\n    }\n    for i in 15..n / 2 {\n        pile.push((i\
    \ + 1) * 2);\n    }\n    for i in 16..n / 2 {\n        pile.push((i + 1) * 2);\n\
    \    }\n    for i in 17..n / 2 {\n        pile.push((i + 1) * 2);\n    }\n   \
    \ for i in 18..n / 2 {\n        pile.push((i + 1) * 2);\n    }\n    for i in 19..n\
    \ / 2 {\n        pile.push((i + 1) * 2);\n    }\n    for i in 20..n / 2 {\n  \
    \      pile.push((i + 1) * 2);\n    }\n    for i in 21..n / 2 {\n        pile.push((i\
    \ + 1) * 2);\n    }\n    for i in 22..n / 2 {\n        pile.push((i + 1) * 2);\n\
    \    }\n    for i in 23..n / 2 {\n        pile.push((i + 1) * 2);\n    }\n   \
    \ for i in 24..n / 2 {\n        pile.push((i + 1) * 2);\n    }\n    for i in 25..n\
    \ / 2 {\n        pile.push((i + 1) * 2);\n    }\n    for i in 26..n / 2 {\n  \
    \      pile.push((i + 1) * 2);\n    }\n    for i in 27..n / 2 {\n        pile.push((i\
    \ + 1) * 2);\n    }\n    for i in \n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmphdppl4oo.rs:96:1\n\
    \   |\n96 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659975653
- exit_code: -1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut num_stones = n;\n    while num_stones > 0 {\n        if num_stones\
    \ % 2 == 0 {\n            pile.push(num_stones / 2);\n            num_stones =\
    \ num_stones / 2;\n        } else {\n            pile.push(num_stones);\n    \
    \        num_stones = num_stones % 2;\n        }\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659975658
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push(i);\n    }\n    for i in 2..n / 2 {\n        pile.push(i\
    \ * 2);\n    }\n    for i in 3..n / 2 {\n        pile.push(i * 3);\n    }\n  \
    \  for i in 4..n / 2 {\n        pile.push(i * 4);\n    }\n    for i in 5..n /\
    \ 2 {\n        pile.push(i * 5);\n    }\n    for i in 6..n / 2 {\n        pile.push(i\
    \ * 6);\n    }\n    for i in 7..n / 2 {\n        pile.push(i * 7);\n    }\n  \
    \  for i in 8..n / 2 {\n        pile.push(i * 8);\n    }\n    for i in 9..n /\
    \ 2 {\n        pile.push(i * 9);\n    }\n    for i in 10..n / 2 {\n        pile.push(i\
    \ * 10);\n    }\n    for i in 11..n / 2 {\n        pile.push(i * 11);\n    }\n\
    \    for i in 12..n / 2 {\n        pile.push(i * 12);\n    }\n    for i in 13..n\
    \ / 2 {\n        pile.push(i * 13);\n    }\n    for i in 14..n / 2 {\n       \
    \ pile.push(i * 14);\n    }\n    for i in 15..n / 2 {\n        pile.push(i * 15);\n\
    \    }\n    for i in 16..n / 2 {\n        pile.push(i * 16);\n    }\n    for i\
    \ in 17..n / 2 {\n        pile.push(i * 17);\n    }\n    for i in 18..n / 2 {\n\
    \        pile.push(i * 18);\n    }\n    for i in 19..n / 2 {\n        pile.push(i\
    \ * 19);\n    }\n    for i in 20..n / 2 {\n        pile.push(i * 20);\n    }\n\
    \    for i in 21..n / 2 {\n        pile.push(i * 21);\n    }\n    for i in 22..n\
    \ / 2 {\n        pile.push(i * 22);\n    }\n    for i in 23..n / 2 {\n       \
    \ pile.push(i * 23);\n    }\n    for i in 24..n / 2 {\n        pile.push(i * 24);\n\
    \    }\n    for i in 25..n / 2 {\n        pile.push(i * 25);\n    }\n    for i\
    \ in 26..n / 2 {\n        pile.push(i * 26);\n    }\n    for i in 27..n / 2 {\n\
    \        pile.push(i * 27);\n    }\n    for i in 28..n / 2 {\n        pile.push(i\
    \ * 28);\n    }\n    for i in 29..\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpncpavnsn.rs:99:1\n   |\n\
    99 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i);\n   \
    \     } else {\n            pile.push(i + 1);\n        }\n    }\n    pile\n}\n\
    \nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpex18_ort.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += pile[i - 1];\n        } else {\n            pile[i] +=\
    \ pile[i - 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz7ah0lpd.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:14:13\n   |\n14 |         \
    \    pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:14:24\n   |\n14 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `u"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    let mut i = 0;\n    while i < n {\n        if n % 2 == 0 {\n  \
    \          pile[i] = pile[i] + 2;\n        } else {\n            pile[i] = pile[i]\
    \ + 1;\n        }\n        i += 1;\n    }\n    pile\n}\n\nfn main() {\n    let\
    \ candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n   \
    \ assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5,\
    \ 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
    \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprlcrkoii.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmprlcrkoii.rs:14:13\n   |\n14 |         \
    \    pile[i] = pile[i] + 2;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprlcrkoii.rs:14:23\n   |\n14 |  \
    \           pile[i] = pile[i] + 2;\n   |                       ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprlcrkoii.rs:16:13\n   |\n16 |  \
    \           pile[i] = pile[i] + 1;\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprlcrkoii.rs:16:23\n   |\n16 |  \
    \           pile[i] = pile[i] + 1;\n   |                       ^^^^^^^ slice indices\
    \ are of type `usize` or range"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        if i % 2 == 0 {\n \
    \           pile[i] = pile[i / 2] + 1;\n        } else {\n            pile[i]\
    \ = pile[i / 2] + 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzfidnqr5.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:14:13\n   |\n14 |            \
    \ pile[i] = pile[i / 2] + 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:14:23\n   |\n14 |  \
    \           pile[i] = pile[i / 2] + 1;\n   |                       ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:16:13\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 2;\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:16:23\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 2;\n   |                     \
    \  ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 5 p"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: -1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 1;\n    while level < n {\n        let mut next_level = level;\n\
    \        while next_level % 2 == 0 {\n            next_level = next_level / 2;\n\
    \        }\n        pile.push(next_level);\n        level = next_level + 1;\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659975658
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    pile.push(n);\n    if n % 2 == 0 {\n        pile.push(n - 1);\n    }\n  \
    \  pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[3, 5, 7]`', /tmp/tmp4d1b2njl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        for _ in 0..n {\n            pile.push(n - 1);\n\
    \        }\n    } else {\n        for _ in 0..n {\n            pile.push(n - 1);\n\
    \        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpyc_chs1l.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..n+1 {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb8c1qc89.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpb8c1qc89.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpb8c1qc89.rs:16:13\n   |\n16 |  \
    \           pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpb8c1qc89.rs:16:24\n   |\n16 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 1;\n    while n >= level {\n        pile.push(level);\n \
    \       n -= level;\n        level += 1;\n    }\n    pile.push(n);\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpsyl7m3iu.rs:14:9\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n14 |         n -= level;\n\
    \   |         ^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    if n % 2 == 0 {\n        pile[1] += 1;\n   \
    \ }\n    for _ in 1..n {\n        pile[pile.len() - 1] += 1;\n        if n % 2\
    \ == 0 {\n            pile[pile.len() - 2] += 1;\n        }\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6zfky2ib.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 0;\n    while n != 0 {\n        if n % 2 == 0 {\n       \
    \     pile.push(level);\n            n /= 2;\n        } else {\n            pile.push(level\
    \ + 1);\n            n /= 2;\n        }\n        level += 1;\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpjl23988l.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpjl23988l.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, n - 2]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpmvx_50k_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, 2 * n - 1]\n    }\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5]`,\n right: `[3, 5, 7]`', /tmp/tmp_5rwpzed.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push(i * 2);\n    }\n    for i in 2..n / 2 {\n        pile.push(i\
    \ * 2 + 1);\n    }\n    for i in 3..n / 2 {\n        pile.push(i * 2 + 2);\n \
    \   }\n    for i in 4..n / 2 {\n        pile.push(i * 2 + 3);\n    }\n    for\
    \ i in 5..n / 2 {\n        pile.push(i * 2 + 4);\n    }\n    for i in 6..n / 2\
    \ {\n        pile.push(i * 2 + 5);\n    }\n    for i in 7..n / 2 {\n        pile.push(i\
    \ * 2 + 6);\n    }\n    for i in 8..n / 2 {\n        pile.push(i * 2 + 7);\n \
    \   }\n    for i in 9..n / 2 {\n        pile.push(i * 2 + 8);\n    }\n    for\
    \ i in 10..n / 2 {\n        pile.push(i * 2 + 9);\n    }\n    for i in 11..n /\
    \ 2 {\n        pile.push(i * 2 + 10);\n    }\n    for i in 12..n / 2 {\n     \
    \   pile.push(i * 2 + 11);\n    }\n    for i in 13..n / 2 {\n        pile.push(i\
    \ * 2 + 12);\n    }\n    for i in 14..n / 2 {\n        pile.push(i * 2 + 13);\n\
    \    }\n    for i in 15..n / 2 {\n        pile.push(i * 2 + 14);\n    }\n    for\
    \ i in 16..n / 2 {\n        pile.push(i * 2 + 15);\n    }\n    for i in 17..n\
    \ / 2 {\n        pile.push(i * 2 + 16);\n    }\n    for i in 18..n / 2 {\n   \
    \     pile.push(i * 2 + 17);\n    }\n    for i in 19..n / 2 {\n        pile.push(i\
    \ * 2 + 18);\n    }\n    for i in 20..n / 2 {\n        pile.push(i * 2 + 19);\n\
    \    }\n    for i in 21..n / 2 {\n        pile.push(i * 2 + 20);\n    }\n    for\
    \ i in 22..n / 2 {\n        pile.push(i * 2 + 21);\n    }\n    for i in 23..n\
    \ / 2 {\n        pile.push(i * 2 + 22);\n    }\n    for i in 24..n / 2 {\n   \
    \     pile.push(i * 2 + 23);\n    }\n    for i in 25..n / 2 {\n        pile.push(i\
    \ * 2 + 24);\n    }\n    for i in 26..n / 2 {\n        pile.push(i * 2 + 25);\n\
    \    }\n    for i in 27..n / 2 {\n        pile.push(i * \n}\n\nfn main() {\n \
    \   let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n\
    \    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjwojyvgf.rs:103:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n92  |     for i in 27..n /\
    \ 2 {\n    |                        - this delimiter might not be properly closed...\n\
    93  |         pile.push(i * \n94  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n103 | }\n    |   ^\n\nerror: expected expression,\
    \ found `)`\n  --> /tmp/tmpjwojyvgf.rs:94:1\n   |\n94 | }\n   | ^ expected expression\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpjwojyvgf.rs:93:18\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                   \
    \                     - closing delimiter possibly meant for this\n...\n93 | \
    \        pile.push(i * \n   |                  ^ unclosed delimiter\n94 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjwojyvgf.rs:9:29\n\
    \  |\n9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------       \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut num_stones = n;\n    while num_stones > 0 {\n        if num_stones\
    \ % 2 == 0 {\n            pile.push(num_stones / 2);\n            num_stones =\
    \ num_stones / 2;\n        } else {\n            pile.push(num_stones);\n    \
    \        num_stones = num_stones - 1;\n        }\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpuh1s7ju0.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 2..=n {\n        pile.push(i\
    \ * i);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 4, 9]`,\n right: `[3, 5, 7]`', /tmp/tmphakn2wzk.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut i = 0;\n    while i < n {\n        if n % 2 == 0 {\n            pile.push(n\
    \ - i);\n            i += 1;\n        } else {\n            pile.push(i);\n  \
    \          i += 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpdl6e0vbv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 0;\n    while n != 0 {\n        pile.push(level);\n     \
    \   if n % 2 == 0 {\n            level += 1;\n        } else {\n            level\
    \ += 2;\n        }\n        n /= 2;\n    }\n    pile\n}\n\nfn main() {\n    let\
    \ candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n   \
    \ assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5,\
    \ 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
    \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpnf9mx9o4.rs:19:9\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n19 |         n /= 2;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 1;\n    while level < n {\n        if n % 2 == 0 {\n    \
    \        pile.push(level);\n            n /= 2;\n        } else {\n          \
    \  pile.push(level + 1);\n            n /= 2;\n        }\n        level += 1;\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpswzgns25.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpswzgns25.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut current_level = Vec::new();\n    current_level.push(n);\n    pile.push(current_level);\n\
    \    while current_level.len() > 0 {\n        let mut next_level = Vec::new();\n\
    \        for n in current_level {\n            if n % 2 == 0 {\n             \
    \   next_level.push(n);\n            } else {\n                next_level.push(n\
    \ - 1);\n            }\n        }\n        pile.push(next_level);\n        current_level\
    \ = next_level;\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn8gbr5z0.rs:26:5\n   |\n\
    9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                          \
    \   ---------- expected `Vec<isize>` because of return type\n...\n26 |     pile\n\
    \   |     ^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, n - 2]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpmvx_50k_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push(i * 2);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ * 2 + 1);\n    }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 2);\n \
    \   }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 3);\n    }\n    for\
    \ i in 1..n / 2 {\n        pile.push(i * 2 + 4);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push(i * 2 + 5);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ * 2 + 6);\n    }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 7);\n \
    \   }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 8);\n    }\n    for\
    \ i in 1..n / 2 {\n        pile.push(i * 2 + 9);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push(i * 2 + 10);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ * 2 + 11);\n    }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 12);\n\
    \    }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 13);\n    }\n    for\
    \ i in 1..n / 2 {\n        pile.push(i * 2 + 14);\n    }\n    for i in 1..n /\
    \ 2 {\n        pile.push(i * 2 + 15);\n    }\n    for i in 1..n / 2 {\n      \
    \  pile.push(i * 2 + 16);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ * 2 + 17);\n    }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 18);\n\
    \    }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 19);\n    }\n    for\
    \ i in 1..n / 2 {\n        pile.push(i * 2 + 20);\n    }\n    for i in 1..n /\
    \ 2 {\n        pile.push(i * 2 + 21);\n    }\n    for i in 1..n / 2 {\n      \
    \  pile.push(i * 2 + 22);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ * 2 + 23);\n    }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 24);\n\
    \    }\n    for i in 1..n / 2 {\n        pile.push(i * 2 + 25);\n    }\n    for\
    \ i in 1..n / 2 {\n        pile.push(i\n}\n\nfn main() {\n    let candidate =\
    \ make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0jajeml0.rs:103:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n92  |     for i in 1..n /\
    \ 2 {\n    |                       - this delimiter might not be properly closed...\n\
    93  |         pile.push(i\n94  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n103 | }\n    |   ^\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp0jajeml0.rs:93:18\n   |\n9  | fn make_a_pile(n: isize) ->\
    \ Vec<isize> {\n   |                                        - closing delimiter\
    \ possibly meant for this\n...\n93 |         pile.push(i\n   |               \
    \   ^ unclosed delimiter\n94 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp0jajeml0.rs:9:29\n  |\n9 | fn make_a_pile(n:\
    \ isize) -> Vec<isize> {\n  |    -----------              ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 0..n {\n        pile.push(i\
    \ + 1);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 1, 2, 3]`,\n right: `[3, 5, 7]`', /tmp/tmpzvsc0q2a.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        if i % 2 == 0 {\n \
    \           pile[i] = pile[i / 2] as isize;\n        } else {\n            pile[i]\
    \ = pile[i / 2] + 1;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5t0mmavi.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5t0mmavi.rs:14:13\n   |\n14 |            \
    \ pile[i] = pile[i / 2] as isize;\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5t0mmavi.rs:14:23\n   |\n14 |            \
    \ pile[i] = pile[i / 2] as isize;\n   |                       ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp5t0mmavi.rs:16:13\n   |\n16 |  \
    \           pile[i] = pile[i / 2] + 1;\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5t0mmavi.rs:16:23\n   |\n16 |            \
    \ pile[i] = pile[i / 2] + 1;\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n];\n    let mut level = 0;\n    let mut next_odd_level = 0;\n    let mut next_even_level\
    \ = 0;\n    while level < n {\n        pile[level] = next_odd_level;\n       \
    \ pile[level + 1] = next_even_level;\n        if n % 2 == 0 {\n            next_even_level\
    \ += 1;\n        } else {\n            next_odd_level += 1;\n        }\n     \
    \   level += 2;\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprjrn_zcu.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n];\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n10 |     let mut pile =\
    \ vec![0; n.try_into().unwrap()];\n   |                             ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmprjrn_zcu.rs:15:9\n\
    \   |\n15 |         pile[level] = next_odd_level;\n   |         ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmprjrn_zcu.rs:16:9\n\
    \   |\n16 |         pile[level + 1] = next_even_level;\n   |         ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut i = 0;\n    while i < n {\n        if n % 2 == 0 {\n            pile.push(i\
    \ as isize);\n            i += 1;\n        } else {\n            pile.push((i\
    \ + 1) + (i as isize));\n            i += 2;\n        }\n    }\n    pile\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5]`,\n right: `[3, 5, 7]`', /tmp/tmpe1mouogw.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push((n\
    \ - 1) / 2);\n    }\n    for i in 0..n {\n        pile.push((i + 1) * pile[pile.len()\
    \ - 1]);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 6]`,\n right: `[3, 5, 7]`', /tmp/tmpe38m42r5.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut level = 1;\n    while n != 0 {\n        if n % 2 == 0 {\n       \
    \     pile.push(level);\n            n /= 2;\n        } else {\n            pile.push(level\
    \ + 1);\n            n /= 2;\n        }\n        level += 1;\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp8h3tbptw.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmp8h3tbptw.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push(i);\n    }\n    for i in 2..n / 2 {\n        pile.push((i\
    \ + 1) + (n - i) / 2);\n    }\n    for i in 3..n / 2 {\n        pile.push((i +\
    \ 1) + (n - i) / 2);\n    }\n    for i in 4..n / 2 {\n        pile.push((i + 1)\
    \ + (n - i) / 2);\n    }\n    for i in 5..n / 2 {\n        pile.push((i + 1) +\
    \ (n - i) / 2);\n    }\n    for i in 6..n / 2 {\n        pile.push((i + 1) + (n\
    \ - i) / 2);\n    }\n    for i in 7..n / 2 {\n        pile.push((i + 1) + (n -\
    \ i) / 2);\n    }\n    for i in 8..n / 2 {\n        pile.push((i + 1) + (n - i)\
    \ / 2);\n    }\n    for i in 9..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 10..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 11..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 12..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 13..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 14..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 15..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 16..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 17..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 18..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 19..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 20..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 21..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 22..n / 2 {\n        pile.push((i + 1) + (n - i) /\
    \ 2);\n    }\n    for i in 23..n / 2 {\n        pile.\n}\n\nfn main() {\n    let\
    \ candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n   \
    \ assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5,\
    \ 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
    \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6tisbfxb.rs:91:3\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                   \
    \                     - unclosed delimiter\n...\n80 |     for i in 23..n / 2 {\n\
    \   |                        - this delimiter might not be properly closed...\n\
    81 |         pile.\n82 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n91 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmp6tisbfxb.rs:82:1\n\
    \   |\n82 | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6tisbfxb.rs:81:9\n\
    \   |\n81 |         pile.\n   |         ^^^^ expected `()`, found struct `Vec`\n\
    \   |\n   = note: expected unit type `()`\n                 found struct `Vec<isize>`\n\
    help: you might have meant to return this value\n   |\n81 |         return pile;.\n\
    \   |         ++++++     +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp6tisbfxb.rs:9:29\n\
    \  |\n9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------       \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    pile[1] = 1;\n    for i in 2..=n {\n        if\
    \ i % 2 == 0 {\n            pile[i] = pile[i - 1] + 1;\n        } else {\n   \
    \         pile[i] = pile[i - 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n\
    \    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n\
    \    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp740tovh3.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp740tovh3.rs:15:13\n   |\n15 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp740tovh3.rs:15:23\n   |\n15 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp740tovh3.rs:17:13\n   |\n17 |            \
    \ pile[i] = pile[i - 1];\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp740tovh3.rs:17:23\n   |\n17 |            \
    \ pile[i] = pile[i - 1];\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = h"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += pile[i - 1];\n        } else {\n            pile[i] +=\
    \ pile[i - 1] + 1;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptcves38a.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmptcves38a.rs:14:13\n   |\n14 |         \
    \    pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmptcves38a.rs:14:24\n   |\n14 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmptcves38a.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1] + 1;\n   |             ^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmptcves38a.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1] + 1;\n   |                    \
    \    ^^^^^^^^^^^ slice indices are of"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut num_stones = n;\n    while num_stones > 0 {\n        let mut next_stones\
    \ = num_stones;\n        if num_stones % 2 == 0 {\n            next_stones +=\
    \ 1;\n        }\n        pile.push(next_stones);\n        num_stones -= next_stones;\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[3, 5, 7]`', /tmp/tmpg8e75hc8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 1 {\n        pile.push(n - 1);\n    } else {\n        let mut\
    \ n = n - 1;\n        while n != 0 {\n            if n % 2 == 0 {\n          \
    \      pile.push(n);\n                n /= 2;\n            } else {\n        \
    \        n /= 2;\n                pile.push(n);\n            }\n        }\n  \
    \  }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[3, 5, 7]`', /tmp/tmpg9tt0vhu.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, n - 2]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpmvx_50k_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut i = 0;\n    while i < n {\n        if n % 2 == 0 {\n            pile.push(i\
    \ as isize);\n            i += 1;\n        } else {\n            i += 2;\n   \
    \     }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[3, 5, 7]`', /tmp/tmprnhyot_q.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n == 0 {\n   \
    \     return vec![0];\n    }\n    let mut pile = vec![n - 1];\n    if n % 2 ==\
    \ 0 {\n        pile.push(n - 1);\n    }\n    for i in 2..n / 2 {\n        pile.push((n\
    \ - i) / 2);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[3, 5, 7]`', /tmp/tmpr_ua7sl_.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i /\
    \ 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpax30hyzb.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpax30hyzb.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpax30hyzb.rs:16:13\n   |\n16 |  \
    \           pile[i] += pile[i / 2];\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpax30hyzb.rs:16:24\n   |\n16 |  \
    \           pile[i] += pile[i / 2];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 0;\n    while n != 0 {\n        pile.push(level);\n     \
    \   level += n % 2 == 0 ? 1 : 2;\n        n /= 2;\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n\
    \  --> /tmp/tmp8e0icaby.rs:14:31\n   |\n14 |         level += n % 2 == 0 ? 1 :\
    \ 2;\n   |                               ^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += 2;\n    \
    \    }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ruth_2d.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp2ruth_2d.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp2ruth_2d.rs:16:13\n\
    \   |\n16 |             pile[i] += 2;\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += pile[i - 1];\n        } else {\n            pile[i] +=\
    \ pile[i - 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz7ah0lpd.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:14:13\n   |\n14 |         \
    \    pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:14:24\n   |\n14 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `u"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 2);\n    }\n    for i in 1..n {\n        pile.push(i + 1);\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3]`,\n right: `[3, 5, 7]`', /tmp/tmpagwt5wtz.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 1;\n    while level < n {\n        if n % 2 == 0 {\n    \
    \        pile.push(level);\n            n /= 2;\n        } else {\n          \
    \  pile.push(level + 1);\n            n /= 2;\n        }\n        level += 1;\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpswzgns25.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpswzgns25.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        let mut\
    \ odd_count = n - 1;\n        let mut even_count = n;\n        while odd_count\
    \ > 0 {\n            pile.push(odd_count as isize);\n            odd_count -=\
    \ 2;\n        }\n        while even_count > 0 {\n            pile.push(even_count\
    \ as isize);\n            even_count -= 2;\n        }\n    }\n    pile\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpbd5ks6gv.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    if n % 2 == 0 {\n        pile[1] += 1;\n   \
    \ }\n    for i in 2..n+1 {\n        pile[i] += pile[i - 1];\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbd6ganu9.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpbd6ganu9.rs:16:9\n   |\n16 |         pile[i]\
    \ += pile[i - 1];\n   |         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpbd6ganu9.rs:16:20\n   |\n16 |         pile[i] += pile[i\
    \ - 1];\n   |                    ^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i);\n   \
    \     } else {\n            let next = i + (i & 1);\n            pile.push(next);\n\
    \        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpujkqq7qj.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    pile[1] = if n % 2 == 0 { n / 2 } else { 3 *\
    \ n / 2 };\n    for i in 2..=n {\n        pile[i] = pile[i - 1] + if i % 2 ==\
    \ 0 { 1 } else { 2 };\n    }\n    pile\n}\n\nfn main() {\n    let candidate =\
    \ make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpavzl57gs.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpavzl57gs.rs:14:9\n   |\n14 |         pile[i]\
    \ = pile[i - 1] + if i % 2 == 0 { 1 } else { 2 };\n   |         ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpavzl57gs.rs:14:19\n   |\n14 |  \
    \       pile[i] = pile[i - 1] + if i % 2 == 0 { 1 } else { 2 };\n   |        \
    \           ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n - 1, n - 2, n - 3, n - 4, n - 5, n - 6, n - 7, n - 8, n - 9]\n\
    \    } else {\n        vec![n - 1, n - 2, n - 3, n - 4, n - 5, n - 6, n - 7, n\
    \ - 8, n - 9]\n    }\n}\n\nfn main() {\n    let candidate = make_a_pile;\n   \
    \ assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, -1, -2, -3, -4, -5, -6]`,\n right: `[3, 5, 7]`', /tmp/tmpbepw58y4.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n + 1]\n    } else {\n        vec![n, n - 1]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2]`,\n right: `[3, 5, 7]`', /tmp/tmp0z5cnskp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n == 0 {\n   \
    \     return vec![0];\n    }\n\n    let mut pile = vec![n - 1];\n\n    if n %\
    \ 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        let mut next_odd\
    \ = n - 1;\n        let mut next_even = n - 1;\n\n        while next_odd % 2 ==\
    \ 0 {\n            next_odd /= 2;\n        }\n\n        while next_even % 2 ==\
    \ 0 {\n            next_even /= 2;\n        }\n\n        pile.push(next_odd);\n\
    \        pile.push(next_even);\n    }\n\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 1]`,\n right: `[3, 5, 7]`', /tmp/tmp50nka9ma.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    pile[1] = 1;\n    for i in 2..=n {\n        if\
    \ i % 2 == 0 {\n            pile[i] = pile[i - 1] + 1;\n        } else {\n   \
    \         pile[i] = pile[i - 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n\
    \    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n\
    \    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp740tovh3.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp740tovh3.rs:15:13\n   |\n15 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp740tovh3.rs:15:23\n   |\n15 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp740tovh3.rs:17:13\n   |\n17 |            \
    \ pile[i] = pile[i - 1];\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp740tovh3.rs:17:23\n   |\n17 |            \
    \ pile[i] = pile[i - 1];\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = h"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 1;\n    while n != 0 {\n        if n % 2 == 0 {\n       \
    \     pile.push(level);\n            n /= 2;\n        } else {\n            pile.push(level\
    \ + 1);\n            n /= 2;\n        }\n        level += 1;\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppsxl87oa.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmppsxl87oa.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 0..n {\n        pile.push(i\
    \ + 1);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 1, 2, 3]`,\n right: `[3, 5, 7]`', /tmp/tmpzvsc0q2a.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, 2 * n - 1]\n    }\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5]`,\n right: `[3, 5, 7]`', /tmp/tmp_5rwpzed.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 0..n {\n        pile.push(i);\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 1, 2]`,\n right: `[3, 5, 7]`', /tmp/tmptm3jdxz_.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 0..n / 2\
    \ {\n        pile.push(i + 1);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 2);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 3);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 4);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 5);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 6);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 7);\n    }\n  \
    \  for i in 0..n / 2 {\n        pile.push(i + 8);\n    }\n    for i in 0..n /\
    \ 2 {\n        pile.push(i + 9);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 10);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 11);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 12);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(i + 13);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 14);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 15);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 16);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(i + 17);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 18);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 19);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 20);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(i + 21);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 22);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 23);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 24);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push(i + 25);\n    }\n    for i in 0..n / 2 {\n        pile.push(i\
    \ + 26);\n    }\n    for i in 0..n / 2 {\n        pile.push(i + 27);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push(i + 28);\n    }\n    for i in 0.\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpvqqr4qn5.rs:99:1\n   |\n\
    99 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) as isize);\n        }\n    }\n\
    \    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpp_mdznul.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..n+1 {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcn1f667c.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpcn1f667c.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpcn1f667c.rs:16:13\n   |\n16 |  \
    \           pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpcn1f667c.rs:16:24\n   |\n16 |  \
    \           pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..n+1 {\n        if i % 2 == 0 {\n\
    \            pile[i] += pile[i - 1];\n        } else {\n            pile[i] +=\
    \ pile[i - 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qgcjyvn.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp_qgcjyvn.rs:14:13\n   |\n14 |         \
    \    pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp_qgcjyvn.rs:14:24\n   |\n14 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp_qgcjyvn.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp_qgcjyvn.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `u"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        pile[i] += if n %\
    \ 2 == 0 {\n            pile[i / 2]\n        } else {\n            pile[(i / 2)\
    \ + 1]\n        };\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe_ipivn_.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpe_ipivn_.rs:13:9\n   |\n13 |         pile[i]\
    \ += if n % 2 == 0 {\n   |         ^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpe_ipivn_.rs:14:13\n   |\n14 |  \
    \           pile[i / 2]\n   |             ^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpe_ipivn_.rs:16:13\n   |\n16 |  \
    \           pile[(i / 2) + 1]\n   |             ^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 - 1);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 1);\n \
    \   }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 2);\n    }\n \
    \   for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 3);\n    }\n    for i\
    \ in 0..n / 2 {\n        pile.push((i + 1) * 2 + 4);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + 1) * 2 + 5);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push((i + 1) * 2 + 6);\n    }\n    for i in 0..n / 2 {\n       \
    \ pile.push((i + 1) * 2 + 7);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 + 8);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2 + 9);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 10);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 11);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 12);\n    }\n    for\
    \ i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 13);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + 1) * 2 + 14);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push((i + 1) * 2 + 15);\n    }\n    for i in 0..n / 2 {\n      \
    \  pile.push((i + 1) * 2 + 16);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 + 17);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2 + 18);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 19);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 20);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 21);\n    }\n    for\
    \ i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 22);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + \n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfbs4fgtz.rs:100:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n89  |     for i in 0..n /\
    \ 2 {\n    |                       - this delimiter might not be properly closed...\n\
    90  |         pile.push((i + \n91  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n100 | }\n    |   ^\n\nerror: expected expression,\
    \ found `)`\n  --> /tmp/tmpfbs4fgtz.rs:91:1\n   |\n91 | }\n   | ^ expected expression\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpfbs4fgtz.rs:90:19\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                   \
    \                     - closing delimiter possibly meant for this\n...\n90 | \
    \        pile.push((i + \n   |                   ^ unclosed delimiter\n91 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfbs4fgtz.rs:9:29\n\
    \  |\n9 | fn make_a_pile(n: isize) -> Vec<isize> {\n  |    -----------       \
    \       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, n - 2]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpmvx_50k_.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        if i % 2 == 0 {\n \
    \           pile[i] = pile[i / 2] + 1;\n        } else {\n            pile[i]\
    \ = pile[i / 2] + 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzfidnqr5.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:14:13\n   |\n14 |            \
    \ pile[i] = pile[i / 2] + 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:14:23\n   |\n14 |  \
    \           pile[i] = pile[i / 2] + 1;\n   |                       ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:16:13\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 2;\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzfidnqr5.rs:16:23\n\
    \   |\n16 |             pile[i] = pile[i / 2] + 2;\n   |                     \
    \  ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 5 p"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        pile.push(i);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ + 2);\n    }\n    for i in 1..n / 2 {\n        pile.push(i + 4);\n    }\n  \
    \  for i in 1..n / 2 {\n        pile.push(i + 6);\n    }\n    for i in 1..n /\
    \ 2 {\n        pile.push(i + 8);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ + 10);\n    }\n    for i in 1..n / 2 {\n        pile.push(i + 12);\n    }\n\
    \    for i in 1..n / 2 {\n        pile.push(i + 14);\n    }\n    for i in 1..n\
    \ / 2 {\n        pile.push(i + 16);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ + 18);\n    }\n    for i in 1..n / 2 {\n        pile.push(i + 20);\n    }\n\
    \    for i in 1..n / 2 {\n        pile.push(i + 22);\n    }\n    for i in 1..n\
    \ / 2 {\n        pile.push(i + 24);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ + 26);\n    }\n    for i in 1..n / 2 {\n        pile.push(i + 28);\n    }\n\
    \    for i in 1..n / 2 {\n        pile.push(i + 30);\n    }\n    for i in 1..n\
    \ / 2 {\n        pile.push(i + 32);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ + 34);\n    }\n    for i in 1..n / 2 {\n        pile.push(i + 36);\n    }\n\
    \    for i in 1..n / 2 {\n        pile.push(i + 38);\n    }\n    for i in 1..n\
    \ / 2 {\n        pile.push(i + 40);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ + 42);\n    }\n    for i in 1..n / 2 {\n        pile.push(i + 44);\n    }\n\
    \    for i in 1..n / 2 {\n        pile.push(i + 46);\n    }\n    for i in 1..n\
    \ / 2 {\n        pile.push(i + 48);\n    }\n    for i in 1..n / 2 {\n        pile.push(i\
    \ + 50);\n    }\n    for i in 1..n / 2 {\n        pile.push(i + 52);\n    }\n\
    \    for i in 1..n / 2 {\n        pile.push(i + 54\n}\n\nfn main() {\n    let\
    \ candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n   \
    \ assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5,\
    \ 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
    \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpf_8ne9ew.rs:106:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n95  |     for i in 1..n /\
    \ 2 {\n    |                       - this delimiter might not be properly closed...\n\
    96  |         pile.push(i + 54\n97  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n106 | }\n    |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpf_8ne9ew.rs:96:18\n   |\n9  | fn make_a_pile(n:\
    \ isize) -> Vec<isize> {\n   |                                        - closing\
    \ delimiter possibly meant for this\n...\n96 |         pile.push(i + 54\n   |\
    \                  ^ unclosed delimiter\n97 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpf_8ne9ew.rs:9:29\n  |\n9 | fn make_a_pile(n:\
    \ isize) -> Vec<isize> {\n  |    -----------              ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push((n - 1) / 2);\n    }\n    for i in 0..n {\n       \
    \ pile.push(i + 1);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 1, 2, 3]`,\n right: `[3, 5, 7]`', /tmp/tmply4g0l1d.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: -1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    pile.push(n);\n    while pile.len() > 0 {\n        let mut n = pile.pop().unwrap();\n\
    \        if n % 2 == 0 {\n            pile.push(n + 2);\n        } else {\n  \
    \          pile.push(n + 1);\n        }\n    }\n    pile\n}\n\nfn main() {\n \
    \   let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n\
    \    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659975658
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += pile[i - 1];\n        } else {\n            pile[i] +=\
    \ pile[i - 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz7ah0lpd.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:14:13\n   |\n14 |         \
    \    pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:14:24\n   |\n14 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpz7ah0lpd.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `u"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n == 0 {\n   \
    \     return vec![0];\n    }\n    let mut pile = vec![0];\n    let mut next_odd_n\
    \ = if n % 2 == 0 {\n        n + 1\n    } else {\n        n\n    };\n    let mut\
    \ next_even_n = if n % 2 == 0 {\n        n + 1\n    } else {\n        n\n    };\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(next_even_n);\n\
    \            next_even_n += 2;\n        } else {\n            pile.push(next_odd_n);\n\
    \            next_odd_n += 2;\n        }\n    }\n    pile\n}\n\nfn main() {\n\
    \    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n\
    \    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 3, 3, 5]`,\n right: `[3, 5, 7]`', /tmp/tmpqk5r9roh.rs:38:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    if n % 2 == 0 {\n        pile[1] += 1;\n   \
    \ }\n    for i in 2..=n {\n        pile[i] += pile[i - 1];\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9nj_6uup.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp9nj_6uup.rs:16:9\n   |\n16 |         pile[i]\
    \ += pile[i - 1];\n   |         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9nj_6uup.rs:16:20\n   |\n16 |  \
    \       pile[i] += pile[i - 1];\n   |                    ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 0..n {\n        pile.push(i\
    \ + 1);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 1, 2, 3]`,\n right: `[3, 5, 7]`', /tmp/tmpzvsc0q2a.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        pile[i] += pile[i\
    \ - 1];\n        if i % 2 == 0 {\n            pile[i] += 1;\n        }\n    }\n\
    \    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnq0_oghc.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpnq0_oghc.rs:13:9\n   |\n13 |         pile[i]\
    \ += pile[i - 1];\n   |         ^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpnq0_oghc.rs:13:20\n   |\n13 |         pile[i] += pile[i\
    \ - 1];\n   |                    ^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpnq0_oghc.rs:15:13\n   |\n15 |  \
    \           pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975652
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut level = 0;\n    while n != 0 {\n        if n % 2 == 0 {\n       \
    \     pile.push(level + 1);\n            n /= 2;\n        } else {\n         \
    \   pile.push(level);\n            n /= 2;\n            level += 1;\n        }\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpjh60zqv2.rs:15:13\n\
    \   |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpjh60zqv2.rs:18:13\n \
    \  |\n9  | fn make_a_pile(n: isize) -> Vec<isize> {\n   |                - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut i = 0;\n    while i < n {\n        if n % 2 == 0 {\n            pile.push(i\
    \ as isize);\n            i += 1;\n        } else {\n            pile.push((i\
    \ + 1) + (i as isize));\n            i += 2;\n        }\n    }\n    pile\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5]`,\n right: `[3, 5, 7]`', /tmp/tmpe1mouogw.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut level = 1;\n    while n >= level {\n        pile.push(level);\n \
    \       level += 1;\n    }\n    pile.push(n);\n    pile\n}\n\nfn main() {\n  \
    \  let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n\
    \    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 3]`,\n right: `[3, 5, 7]`', /tmp/tmpk2keuq8a.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 1 {\n        pile.push(n - 1);\n    } else {\n        let mut\
    \ odd = 1;\n        let mut even = n - 1;\n        while even > 0 {\n        \
    \    pile.push(odd);\n            odd += even;\n            even -= 2;\n     \
    \   }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n \
    \   assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[3, 5, 7]`', /tmp/tmpbzcuz40r.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbxfuxdx.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpxbxfuxdx.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n];\n    pile[0] += 1;\n    for i in 1..n {\n        if i % 2 == 0 {\n     \
    \       pile[i] += 1;\n        } else {\n            pile[i] += pile[i - 2];\n\
    \        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgdc8v_6v.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n];\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n10 |     let mut pile =\
    \ vec![0; n.try_into().unwrap()];\n   |                             ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpgdc8v_6v.rs:14:13\n\
    \   |\n14 |             pile[i] += 1;\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgdc8v_6v.rs:16:13\n   |\n16 |  \
    \           pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpgdc8v_6v.rs:16:24\n   |\n16 |  \
    \           pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n % 2 == 0 {\n\
    \        vec![n, n - 1]\n    } else {\n        vec![n, 2 * n - 1]\n    }\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5]`,\n right: `[3, 5, 7]`', /tmp/tmp_5rwpzed.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    if n % 2 == 1 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 2);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 - 1);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 1);\n \
    \   }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 2);\n    }\n \
    \   for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 3);\n    }\n    for i\
    \ in 0..n / 2 {\n        pile.push((i + 1) * 2 + 4);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + 1) * 2 + 5);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push((i + 1) * 2 + 6);\n    }\n    for i in 0..n / 2 {\n       \
    \ pile.push((i + 1) * 2 + 7);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 + 8);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2 + 9);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 10);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 11);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 12);\n    }\n    for\
    \ i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 13);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((i + 1) * 2 + 14);\n    }\n    for i in 0..n / 2 {\n\
    \        pile.push((i + 1) * 2 + 15);\n    }\n    for i in 0..n / 2 {\n      \
    \  pile.push((i + 1) * 2 + 16);\n    }\n    for i in 0..n / 2 {\n        pile.push((i\
    \ + 1) * 2 + 17);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) *\
    \ 2 + 18);\n    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 19);\n\
    \    }\n    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 20);\n    }\n\
    \    for i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 21);\n    }\n    for\
    \ i in 0..n / 2 {\n        pile.push((i + 1) * 2 + 22);\n    }\n    for i in 0..n\
    \ / 2 {\n        pile.push((\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmppktgt2k0.rs:100:3\n\
    \    |\n9   | fn make_a_pile(n: isize) -> Vec<isize> {\n    |                \
    \                        - unclosed delimiter\n...\n89  |     for i in 0..n /\
    \ 2 {\n    |                       - this delimiter might not be properly closed...\n\
    90  |         pile.push((\n91  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n100 | }\n    |   ^\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmppktgt2k0.rs:90:19\n   |\n9  | fn make_a_pile(n: isize) ->\
    \ Vec<isize> {\n   |                                        - closing delimiter\
    \ possibly meant for this\n...\n90 |         pile.push((\n   |               \
    \    ^ unclosed delimiter\n91 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppktgt2k0.rs:90:19\n   |\n90 |           pile.push((\n\
    \   |  ___________________^\n91 | | }\n   | |_^ expected `isize`, found `()`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmppktgt2k0.rs:9:29\n  |\n9 | fn make_a_pile(n:\
    \ isize) -> Vec<isize> {\n  |    -----------              ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) + (i as isize));\n        }\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 3, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpqkp1w2qf.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg3y9u6kl.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i + 1);\n\
    \        } else {\n            pile.push(n - i);\n        }\n    }\n    pile\n\
    }\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3]`,\n right: `[3, 5, 7]`', /tmp/tmpivmsi7d2.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n == 0 {\n   \
    \     return vec![0];\n    }\n    let mut pile = vec![n - 1];\n    if n % 2 ==\
    \ 0 {\n        pile.push(n - 1);\n    }\n    for i in 2..=n {\n        if i %\
    \ 2 == 0 {\n            pile.push(i);\n        } else {\n            pile.push(n\
    \ - i);\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 0]`,\n right: `[3, 5, 7]`', /tmp/tmpmrk932lm.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) + (i as isize));\n        }\n\
    \    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 3, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpqkp1w2qf.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    if n % 2 == 0 {\n        pile[1] += 1;\n   \
    \ }\n    for &i in &mut pile {\n        *i += *i / 2;\n    }\n    pile\n}\n\n\
    fn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3,\
    \ 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ljg_uuz.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ljg_uuz.rs:15:9\n\
    \   |\n15 |     for &i in &mut pile {\n   |         ^^    --------- this expression\
    \ has type `Option<&mut {integer}>`\n   |         |\n   |         types differ\
    \ in mutability\n   |         help: you can probably remove the explicit borrow:\
    \ `i`\n   |\n   = note: expected mutable reference `&mut {integer}`\n        \
    \              found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) | 0);\n        }\n    }\n   \
    \ pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpi_0ubyxi.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        for _ in 0..n {\n            pile.push(1);\n   \
    \     }\n    } else {\n        for _ in 0..n {\n            pile.push(0);\n  \
    \      }\n    }\n    for i in 1..n / 2 {\n        pile.push((pile[i - 1] + pile[i\
    \ - 2]) % 2);\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpumds3dy0.rs:21:20\n   |\n21 |         pile.push((pile[i - 1] + pile[i\
    \ - 2]) % 2);\n   |                    ^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpumds3dy0.rs:21:34\n   |\n21 |  \
    \       pile.push((pile[i - 1] + pile[i - 2]) % 2);\n   |                    \
    \              ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    let mut num_stones = n;\n    while num_stones > 0 {\n        if num_stones\
    \ % 2 == 0 {\n            pile.push(num_stones / 2);\n            num_stones =\
    \ num_stones / 2;\n        } else {\n            pile.push(num_stones);\n    \
    \        num_stones = num_stones - 1;\n        }\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1, 1]`,\n right: `[3, 5, 7]`', /tmp/tmpuh1s7ju0.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    if n == 0 {\n   \
    \     return vec![0];\n    }\n    let mut stones = vec![n - 1];\n    if n % 2\
    \ == 0 {\n        stones.push(n - 1);\n    }\n    for i in 1..stones.len() {\n\
    \        if stones[i-1] % 2 == 0 {\n            stones[i] += stones[i-1];\n  \
    \      } else {\n            stones[i] += stones[i-1] + 1;\n        }\n    }\n\
    \    stones\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[3, 5, 7]`', /tmp/tmpyb99ozv7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n\
    \    let mut num_stones = n;\n    while num_stones > 0 {\n        if num_stones\
    \ % 2 == 0 {\n            pile.push(num_stones / 2);\n            num_stones =\
    \ num_stones / 2;\n        } else {\n            pile.push(num_stones);\n    \
    \        num_stones = num_stones - 1;\n        }\n    }\n    pile\n}\n\nfn main()\
    \ {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5,\
    \ 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1, 1]`,\n right: `[3, 5, 7]`', /tmp/tmp876p3n0e.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += pile[i - 1];\n        } else {\n            pile[i] +=\
    \ pile[i - 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4igduzv1.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp4igduzv1.rs:14:13\n   |\n14 |         \
    \    pile[i] += pile[i - 1];\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4igduzv1.rs:14:24\n   |\n14 |  \
    \           pile[i] += pile[i - 1];\n   |                        ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp4igduzv1.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp4igduzv1.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `u"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += pile[i -\
    \ 2];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg3y9u6kl.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:13\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpg3y9u6kl.rs:16:24\n\
    \   |\n16 |             pile[i] += pile[i - 2];\n   |                        ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] += 1;\n    for i in 1..=n {\n        if i % 2 == 0 {\n\
    \            pile[i] += 1;\n        } else {\n            pile[i] += 2;\n    \
    \    }\n    }\n    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n\
    \    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4,\
    \ 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6),\
    \ vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14,\
    \ 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ruth_2d.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp2ruth_2d.rs:14:13\n   |\n14 |         \
    \    pile[i] += 1;\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp2ruth_2d.rs:16:13\n\
    \   |\n16 |             pile[i] += 2;\n   |             ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747323
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n / 2);\n    }\n    for i in 1..n / 2\
    \ {\n        if i % 2 == 0 {\n            pile.push(i);\n        } else {\n  \
    \          pile.push(n - i);\n        }\n    }\n    pile\n}\n\nfn main() {\n \
    \   let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n\
    \    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[3, 5, 7]`', /tmp/tmpk0vj78u9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
- exit_code: 1
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![0;\
    \ n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        if i % 2 == 0 {\n \
    \           pile[i] = pile[i - 1] + 1;\n        } else {\n            pile[i]\
    \ = pile[i - 1];\n        }\n    }\n    pile\n}\n\nfn main() {\n    let candidate\
    \ = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4),\
    \ vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n\
    \    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8),\
    \ vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo6zcqqxa.rs:10:28\n   |\n\
    10 |     let mut pile = vec![0; n + 1];\n   |                            ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n10 |     let mut\
    \ pile = vec![0; (n + 1).try_into().unwrap()];\n   |                         \
    \   +     +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:14:13\n   |\n14 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:14:23\n   |\n14 |            \
    \ pile[i] = pile[i - 1] + 1;\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:16:13\n   |\n16 |            \
    \ pile[i] = pile[i - 1];\n   |             ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo6zcqqxa.rs:16:23\n   |\n16 |            \
    \ pile[i] = pile[i - 1];\n   |                       ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = h"
  stdout: ''
  timestamp: 1659975652
- exit_code: 101
  program: "/// Given a positive integer n, you have to make a pile of n levels of\
    \ stones.\n/// The first level has n stones.\n/// The number of stones in the\
    \ next level is:\n/// - the next odd number if n is odd.\n/// - the next even\
    \ number if n is even.\n/// Return the number of stones in each level in a list,\
    \ where element at index\n/// i represents the number of stones in the level (i+1).\n\
    /// Examples:\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            pile.push(i as isize);\n\
    \        } else {\n            pile.push((i + 1) as isize);\n        }\n    }\n\
    \    pile\n}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
    \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
    \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14,\
    \ 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[3, 5, 7]`', /tmp/tmpp_mdznul.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659975653
