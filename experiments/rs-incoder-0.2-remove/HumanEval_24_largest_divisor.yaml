name: HumanEval_24_largest_divisor
language: rs
prompt: "/// For a given number n, find the largest number that divides n evenly,\
  \ smaller than n\nfn largest_divisor(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_divisor;\n    assert_eq!(candidate(3),\
  \ 1);\n    assert_eq!(candidate(7), 1);\n    assert_eq!(candidate(10), 5);\n   \
  \ assert_eq!(candidate(100), 50);\n    assert_eq!(candidate(49), 7);\n}\n"
completions: ["    let mut max_divisor = 0;\n    let mut max_divisor_size = 0;\n \
    \   let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_divisor_size_index = 0;\n    let mut max_divisor_index = 0;\n\
    \    let mut max_", "    let mut max_divisor = 0;\n    let mut max_divisor_remainder\
    \ = 0;\n    for i in 1..n {\n        if n % i == 0 {\n            if max_divisor\
    \ < i {\n                max_divisor = i;\n                max_divisor_remainder\
    \ = n % i;\n            }\n        }\n    }\n    max_divisor_remainder", "   \
    \ let mut max_divisor = 0;\n    let mut max_divisor_index = 0;\n    let mut max_divisor_value\
    \ = n;\n    for i in 1..=n {\n        if n % i == 0 {\n            if max_divisor\
    \ < i {\n                max_divisor = i;\n                max_divisor_index =\
    \ i;\n            }\n            if max_divisor_value < i {\n                max_divisor_value\
    \ = i;\n            }\n        }\n    }\n    max_divisor_index", "    let mut\
    \ max_divisor = 0;\n    let mut max_divisor_size = 0;\n    let mut max_divisor_value\
    \ = n;\n\n    for divisor in 1..=n {\n        if n % divisor == 0 {\n        \
    \    if divisor > max_divisor {\n                max_divisor = divisor;\n    \
    \            max_divisor_size = divisor;\n            } else if divisor == max_divisor\
    \ {\n                max_divisor_size = divisor + 1;\n            }\n        }\n\
    \    }\n\n    if max_divisor_size != max_divisor {\n        max_divisor_value\
    \ = max_divisor_size / max_divisor;\n    }\n\n    max_divisor_value", "    let\
    \ mut max_divisor = 0;\n    let mut max_divisor_index = 0;\n    let mut max_divisor_value\
    \ = n;\n\n    for divisor in 1..=n {\n        if n % divisor == 0 {\n        \
    \    if divisor > max_divisor {\n                max_divisor = divisor;\n    \
    \            max_divisor_index = divisor;\n            }\n        } else {\n \
    \           if divisor > max_divisor_value {\n                max_divisor_value\
    \ = divisor;\n                max_divisor_index = divisor;\n            }\n  \
    \      }\n    }\n\n    max_divisor_index", "    let mut max_divisor = 0;\n   \
    \ let mut max_divisor_size = 0;\n    for d in divisors(n) {\n        if n % d\
    \ == 0 {\n            if d > max_divisor {\n                max_divisor = d;\n\
    \                max_divisor_size = 1;\n            } else if d == max_divisor\
    \ {\n                max_divisor_size += 1;\n            }\n        }\n    }\n\
    \    max_divisor", "    let mut max_divisor = 0;\n    let mut max_divisor_size\
    \ = 0;\n    let mut max_divisor_size_size = 0;\n    for i in 1..=n {\n       \
    \ if n % i == 0 {\n            if max_divisor_size < i {\n                max_divisor_size\
    \ = i;\n                max_divisor_size_size = i;\n            }\n          \
    \  if max_divisor_size == i {\n                max_divisor_size_size = i;\n  \
    \          }\n        }\n    }\n    max_divisor", "    let mut max_divisor = 1;\n\
    \    let mut max_divisor_remainder = 0;\n    let mut max_divisor_remainder_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow = 1;\n    let mut max_divisor_remainder_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow = 1;\n    let mut\
    \ max_divisor_remainder_pow_pow_pow_pow_pow_pow = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n\
    \    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    let\
    \ mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    let mut\
    \ max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n    let mut max_divisor_remainder_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow\
    \ = 1;\n", "    let mut max_divisor = 0;\n    let mut max_divisor_size = 0;\n\
    \    for divisor in 1..=n {\n        if n % divisor == 0 {\n            if divisor\
    \ > max_divisor {\n                max_divisor = divisor;\n                max_divisor_size\
    \ = 1;\n            } else if divisor == max_divisor {\n                max_divisor_size\
    \ += 1;\n            }\n        }\n    }\n    max_divisor", "    let mut max_divisor\
    \ = 0;\n    let mut max_divisor_size = 0;\n    for d in divisors(n) {\n      \
    \  if n % d == 0 {\n            if d > max_divisor {\n                max_divisor\
    \ = d;\n                max_divisor_size = 1;\n            } else {\n        \
    \        max_divisor += d;\n                max_divisor_size++;\n            }\n\
    \        }\n    }\n    max_divisor", "    let mut max_divisor = 0;\n    let mut\
    \ max_divisor_index = 0;\n    for i in 1..=n {\n        if n % i == 0 {\n    \
    \        if max_divisor < i {\n                max_divisor = i;\n            \
    \    max_divisor_index = i;\n            }\n        }\n    }\n    max_divisor_index",
  "    let mut max_divisor = 0;\n    let mut max_divisor_index = 0;\n    let mut max_divisor_value\
    \ = n;\n    for divisor in 1..=n {\n        if n % divisor == 0 {\n          \
    \  if divisor > max_divisor {\n                max_divisor = divisor;\n      \
    \          max_divisor_index = divisor;\n            }\n        } else {\n   \
    \         if divisor > max_divisor_value {\n                max_divisor_value\
    \ = divisor;\n                max_divisor_index = divisor;\n            }\n  \
    \      }\n    }\n    max_divisor_index", "    let mut max_divisor = 0;\n    let\
    \ mut max_divisor_remainder = 0;\n    for divisor in 1..=n {\n        if n % divisor\
    \ == 0 {\n            if divisor > max_divisor {\n                max_divisor\
    \ = divisor;\n                max_divisor_remainder = n % divisor;\n         \
    \   }\n        }\n    }\n    max_divisor_remainder", "    let mut max_divisor\
    \ = 0;\n    let mut max_divisor_index = 0;\n    let mut max_divisor_value = n;\n\
    \    for divisor in 1..=n {\n        if n % divisor == 0 {\n            if divisor\
    \ > max_divisor {\n                max_divisor = divisor;\n                max_divisor_index\
    \ = divisor;\n            }\n        } else {\n            if divisor > max_divisor_value\
    \ {\n                max_divisor_value = divisor;\n                max_divisor_index\
    \ = divisor;\n            }\n        }\n    }\n    max_divisor_index", "    let\
    \ mut max_divisor = 0;\n    let mut max_divisor_size = 0;\n    for d in divisors(n)\
    \ {\n        if n % d == 0 {\n            if d > max_divisor {\n             \
    \   max_divisor = d;\n                max_divisor_size = 1;\n            } else\
    \ {\n                max_divisor += d;\n                max_divisor_size++;\n\
    \            }\n        }\n    }\n    max_divisor", "    let mut max_divisor =\
    \ n;\n    let mut max_divisor_index = 0;\n    let mut max_divisor_indexes: Vec<usize>\
    \ = Vec::new();\n\n    for i in 1..=max_divisor {\n        if n % i == 0 {\n \
    \           if max_divisor > i {\n                max_divisor = i;\n         \
    \       max_divisor_index = i;\n            }\n        } else {\n            if\
    \ max_divisor > i {\n                max_divisor = i;\n                max_divisor_index\
    \ = i;\n                max_divisor_indexes.push(i);\n            }\n        }\n\
    \    }\n\n    if max_divisor == n {\n        max_divisor_indexes.push(max_divisor_index);\n\
    \    }\n\n    max_divisor_indexes.sort_unstable();\n\n    max_divisor_indexes.pop();\n\
    \n    max_divisor_index", "    let mut max_divisor = 0;\n    let mut max_divisor_size\
    \ = n;\n    let mut max_divisor_value = n;\n\n    for divisor in 1..=n {\n   \
    \     if n % divisor == 0 {\n            if divisor > max_divisor {\n        \
    \        max_divisor = divisor;\n                max_divisor_size = max_divisor_value\
    \ - max_divisor;\n            }\n        }\n    }\n\n    max_divisor_value", " \
    \   let mut max_divisor = 0;\n    let mut max_divisor_size = n;\n    let mut max_divisor_value\
    \ = n;\n    while max_divisor_size != 1 {\n        if max_divisor_value % 2 ==\
    \ 0 {\n            max_divisor_value /= 2;\n        } else {\n            max_divisor_value\
    \ /= 3;\n        }\n        max_divisor_size = max_divisor_value + 1;\n      \
    \  if max_divisor_size > max_divisor {\n            max_divisor = max_divisor_size;\n\
    \        }\n    }\n    max_divisor", "    let mut max_divisor = 0;\n    let mut\
    \ max_divisor_size = 0;\n    for divisor in 1..=n {\n        if n % divisor ==\
    \ 0 {\n            if divisor > max_divisor {\n                max_divisor = divisor;\n\
    \                max_divisor_size = divisor;\n            } else if divisor ==\
    \ max_divisor {\n                max_divisor_size = divisor + 1;\n           \
    \ }\n        }\n    }\n    max_divisor", "    let mut max_divisor = n;\n    let\
    \ mut max_divisor_index = 0;\n    let mut max_divisor_value = n;\n    for divisor\
    \ in &[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97] {\n        if n % divisor == 0 {\n            if max_divisor\
    \ < divisor {\n                max_divisor = divisor;\n                max_divisor_index\
    \ = divisor as isize;\n                max_divisor_value = n;\n            }\n\
    \        }\n    }\n    max_divisor_index"]
stop_tokens:
- "\n}"
