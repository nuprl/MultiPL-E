language: rs
name: HumanEval_64_vowels_count
results:
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_end_index\
    \ = s.len();\n    while vowel_end_index > 0 {\n        if s[vowel_end_index -\
    \ 1] == 'a' || s[vowel_end_index - 1] == 'e' || s[vowel_end_index - 1] == 'i'\
    \ || s[vowel_end_index - 1] == 'o' || s[vowel_end_index - 1] == 'u' {\n      \
    \      vowel_count += 1;\n        }\n        vowel_end_index -= 1;\n    }\n  \
    \  vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8wev114.rs:10:12\n\
    \   |\n10 | ...   if s[vowel_end_index - 1] == 'a' || s[vowel_end_index - 1] ==\
    \ 'e' || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] == 'o'...\n \
    \  |          ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8wev114.rs:10:45\n\
    \   |\n10 | ...   if s[vowel_end_index - 1] == 'a' || s[vowel_end_index - 1] ==\
    \ 'e' || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] == 'o'...\n \
    \  |                                           ^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmps8wev114.rs:10:78\n   |\n10 | ... || s[vowel_end_index\
    \ - 1] == 'e' || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] == 'o'\
    \ || s[vowel_end_index - 1] == 'u' {\n   |                                   \
    \      ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8wev114.rs:10:111\n\
    \   |\n10 | ... || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] ==\
    \ 'o' || s[vowel_end_index - 1] == 'u' {\n   |                               \
    \          ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8wev114.rs:10:144\n\
    \   |\n10 | ... || s[vowel_end_index - 1] == 'o' || s[vowel_end_index - 1] ==\
    \ 'u' {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information "
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => (),\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmphtao6sj6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_end_index\
    \ = s.len();\n    while vowel_end_index > 0 {\n        let vowel = s[vowel_end_index\
    \ - 1];\n        if vowel == \"a\" || vowel == \"e\" || vowel == \"i\" || vowel\
    \ == \"o\" || vowel == \"u\" {\n            vowel_count += 1;\n        }\n   \
    \     vowel_end_index -= 1;\n    }\n    vowel_count\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprxtmf1su.rs:10:21\n\
    \   |\n10 |         let vowel = s[vowel_end_index - 1];\n   |                \
    \     ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowel_pos = 0;\n    let mut vowel_end_pos\
    \ = 0;\n    for c in s.chars() {\n        if vowels.contains(&c) {\n         \
    \   vowel_count += 1;\n        }\n        if c == 'y' {\n            vowel_pos\
    \ = vowel_end_pos;\n            vowel_end_pos = s.len();\n        }\n    }\n \
    \   vowel_count += vowel_end_pos - vowel_pos;\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm20y4tij.rs:21:5\n   |\n\
    6  | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n...\n21 |     vowel_count\n\
    \   |     ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    21 |     vowel_count.try_into().unwrap()\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0, s.len())\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \ --> /tmp/tmp6hx5y6d6.rs:7:5\n  |\n7 |     vowels_count(s, 0, s.len())\n  | \
    \    ^^^^^^^^^^^^ -  -  ------- supplied 3 arguments\n  |     |\n  |     expected\
    \ 1 argument\n  |\nnote: function defined here\n --> /tmp/tmp6hx5y6d6.rs:6:4\n\
    \  |\n6 | fn vowels_count(s: String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
