language: rs
name: HumanEval_64_vowels_count
results:
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_end_index\
    \ = s.len();\n    while vowel_end_index > 0 {\n        if s[vowel_end_index -\
    \ 1] == 'a' || s[vowel_end_index - 1] == 'e' || s[vowel_end_index - 1] == 'i'\
    \ || s[vowel_end_index - 1] == 'o' || s[vowel_end_index - 1] == 'u' {\n      \
    \      vowel_count += 1;\n        }\n        vowel_end_index -= 1;\n    }\n  \
    \  vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8wev114.rs:10:12\n\
    \   |\n10 | ...   if s[vowel_end_index - 1] == 'a' || s[vowel_end_index - 1] ==\
    \ 'e' || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] == 'o'...\n \
    \  |          ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8wev114.rs:10:45\n\
    \   |\n10 | ...   if s[vowel_end_index - 1] == 'a' || s[vowel_end_index - 1] ==\
    \ 'e' || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] == 'o'...\n \
    \  |                                           ^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmps8wev114.rs:10:78\n   |\n10 | ... || s[vowel_end_index\
    \ - 1] == 'e' || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] == 'o'\
    \ || s[vowel_end_index - 1] == 'u' {\n   |                                   \
    \      ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8wev114.rs:10:111\n\
    \   |\n10 | ... || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] ==\
    \ 'o' || s[vowel_end_index - 1] == 'u' {\n   |                               \
    \          ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps8wev114.rs:10:144\n\
    \   |\n10 | ... || s[vowel_end_index - 1] == 'o' || s[vowel_end_index - 1] ==\
    \ 'u' {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information "
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => (),\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmphtao6sj6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_end_index\
    \ = s.len();\n    while vowel_end_index > 0 {\n        let vowel = s[vowel_end_index\
    \ - 1];\n        if vowel == \"a\" || vowel == \"e\" || vowel == \"i\" || vowel\
    \ == \"o\" || vowel == \"u\" {\n            vowel_count += 1;\n        }\n   \
    \     vowel_end_index -= 1;\n    }\n    vowel_count\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprxtmf1su.rs:10:21\n\
    \   |\n10 |         let vowel = s[vowel_end_index - 1];\n   |                \
    \     ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowel_pos = 0;\n    let mut vowel_end_pos\
    \ = 0;\n    for c in s.chars() {\n        if vowels.contains(&c) {\n         \
    \   vowel_count += 1;\n        }\n        if c == 'y' {\n            vowel_pos\
    \ = vowel_end_pos;\n            vowel_end_pos = s.len();\n        }\n    }\n \
    \   vowel_count += vowel_end_pos - vowel_pos;\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm20y4tij.rs:21:5\n   |\n\
    6  | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n...\n21 |     vowel_count\n\
    \   |     ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    21 |     vowel_count.try_into().unwrap()\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0, s.len())\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \ --> /tmp/tmp6hx5y6d6.rs:7:5\n  |\n7 |     vowels_count(s, 0, s.len())\n  | \
    \    ^^^^^^^^^^^^ -  -  ------- supplied 3 arguments\n  |     |\n  |     expected\
    \ 1 argument\n  |\nnote: function defined here\n --> /tmp/tmp6hx5y6d6.rs:6:4\n\
    \  |\n6 | fn vowels_count(s: String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => (),\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmphtao6sj6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0, s.len())\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \ --> /tmp/tmp6hx5y6d6.rs:7:5\n  |\n7 |     vowels_count(s, 0, s.len())\n  | \
    \    ^^^^^^^^^^^^ -  -  ------- supplied 3 arguments\n  |     |\n  |     expected\
    \ 1 argument\n  |\nnote: function defined here\n --> /tmp/tmp6hx5y6d6.rs:6:4\n\
    \  |\n6 | fn vowels_count(s: String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_end_index\
    \ = s.len();\n    for c in s.chars() {\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' {\n            vowel_count += 1;\n        }\n  \
    \      if c == 'y' && vowel_end_index > 0 {\n            vowel_end_index -= 1;\n\
    \        }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpi_ahuihr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for c in s.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n            vowel_flag = true;\n        }\n        if c ==\
    \ 'y' {\n            if vowel_flag {\n                vowel_flag = false;\n  \
    \              vowel_count += 1;\n            }\n        }\n    }\n    vowel_count\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmpwy1_9znn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for c in s.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n            vowel_flag = true;\n        }\n        if c ==\
    \ 'y' {\n            vowel_flag = false;\n        }\n        if vowel_flag {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `2`', /tmp/tmpuhu4ro0x.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => (),\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmphtao6sj6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for ch in s.chars() {\n        if ch == 'a' || ch == 'e' || ch == 'i' ||\
    \ ch == 'o' || ch == 'u' {\n            vowel_flag = true;\n        }\n      \
    \  if ch == 'y' && !vowel_flag {\n            vowel_flag = true;\n        }\n\
    \        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n     \
    \   }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgcigwapq.rs:100:3\n\
    \    |\n6   | fn vowels_count(s: String) -> isize {\n    |                   \
    \                  - unclosed delimiter\n...\n9   |     for ch in s.chars() {\n\
    \    |                         - this delimiter might not be properly closed...\n\
    ...\n89  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n100 | }\n    |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpgcigwapq.rs:89:1\n\
    \   |\n88 |         if ch == 'y' && vowel_flag\n   |         -- this `if` expression\
    \ has a condition, but no block\n89 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpgcigwapq.rs:6:31\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ------------               ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => (),\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmphtao6sj6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_end_index\
    \ = s.len();\n    while vowel_end_index > 0 {\n        if s[vowel_end_index -\
    \ 1] == 'a' || s[vowel_end_index - 1] == 'e' || s[vowel_end_index - 1] == 'i'\
    \ || s[vowel_end_index - 1] == 'o' || s[vowel_end_index - 1] == 'u' {\n      \
    \      vowel_end_index -= 1;\n        } else {\n            vowel_count += 1;\n\
    \        }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2yh8ggyi.rs:10:12\n\
    \   |\n10 | ...   if s[vowel_end_index - 1] == 'a' || s[vowel_end_index - 1] ==\
    \ 'e' || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] == 'o'...\n \
    \  |          ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2yh8ggyi.rs:10:45\n   |\n10 | ...   if s[vowel_end_index - 1] ==\
    \ 'a' || s[vowel_end_index - 1] == 'e' || s[vowel_end_index - 1] == 'i' || s[vowel_end_index\
    \ - 1] == 'o'...\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2yh8ggyi.rs:10:78\n   |\n10 | ... || s[vowel_end_index - 1] ==\
    \ 'e' || s[vowel_end_index - 1] == 'i' || s[vowel_end_index - 1] == 'o' || s[vowel_end_index\
    \ - 1] == 'u' {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = he"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for c in s.chars() {\n        if vowels.contains(&c)\
    \ {\n            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpnmhtu8bp.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_end_index\
    \ = s.len();\n    for c in s.chars() {\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' {\n            vowel_count += 1;\n        } else\
    \ {\n            if c == s.chars().nth(vowel_end_index).unwrap() {\n         \
    \       vowel_end_index += 1;\n            }\n        }\n    }\n    vowel_count\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp41or9_fa.rs:13:52

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for c in s.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n            vowel_flag = true;\n        }\n        if c ==\
    \ 'y' {\n            vowel_flag = false;\n        }\n        if vowel_flag {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `2`', /tmp/tmpuhu4ro0x.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_chars: Vec<&str>\
    \ = s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u').collect();\n    for vowel in vowel_chars {\n        if vowel == 'y' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8hfs0j48.rs:8:61\n\
    \  |\n8 |     let mut vowel_chars: Vec<&str> = s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').collect();\n  |              \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n --> /tmp/tmp8hfs0j48.rs:8:73\n  |\n8 | \
    \    let mut vowel_chars: Vec<&str> = s.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').collect();\n  |                       \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n --> /tmp/tmp8hfs0j48.rs:8:85\n  |\n8 | \
    \    let mut vowel_chars: Vec<&str> = s.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').collect();\n  |                       \
    \                                                              ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n --> /tmp/tmp8hfs0j48.rs:8:97\n  |\n8 | \
    \    let mut vowel_chars: Vec<&str> = s.chars().filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').collect();\n  |                       \
    \                                                                          ^^\
    \ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8hfs0j48.rs:8:109\n\
    \  |\n8 |     let mut vowel_chars: Vec<&str> = s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => (),\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmphtao6sj6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for ch in s.chars() {\n        if ch == 'a' || ch == 'e' || ch == 'i' ||\
    \ ch == 'o' || ch == 'u' {\n            vowel_flag = true;\n        }\n      \
    \  if ch == 'y' {\n            vowel_flag = false;\n        }\n        if vowel_flag\
    \ {\n            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `2`', /tmp/tmpn_1llduf.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => vowel_count +=\
    \ 1,\n            _ => (),\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpa21lezmm.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for ch in s.chars() {\n        if ch == 'a' || ch == 'e' || ch == 'i' ||\
    \ ch == 'o' || ch == 'u' {\n            vowel_flag = true;\n        }\n      \
    \  if ch == 'y' && !vowel_flag {\n            vowel_flag = true;\n        }\n\
    \        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n     \
    \   }\n        if ch == 'y' && !vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && !vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp01pxei5o.rs:100:3\n\
    \    |\n6   | fn vowels_count(s: String) -> isize {\n    |                   \
    \                  - unclosed delimiter\n...\n9   |     for ch in s.chars() {\n\
    \    |                         - this delimiter might not be properly closed...\n\
    ...\n89  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n100 | }\n    |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp01pxei5o.rs:89:1\n\
    \   |\n88 |         if ch == 'y' && vowel\n   |         -- this `if` expression\
    \ has a condition, but no block\n89 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp01pxei5o.rs:6:31\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ------------               ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for ch in s.chars() {\n        if vowels.contains(ch)\
    \ {\n            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqs0n8gux.rs:10:28\n   |\n\
    10 |         if vowels.contains(ch) {\n   |                            ^^\n  \
    \ |                            |\n   |                            expected `&char`,\
    \ found `char`\n   |                            help: consider borrowing here:\
    \ `&ch`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowels = vec!['a'..'u'];\n\
    \    for ch in s.chars() {\n        if vowels.contains(ch) {\n            vowel_count\
    \ += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplsezdi9r.rs:10:28\n   |\n\
    10 |         if vowels.contains(ch) {\n   |                            ^^ expected\
    \ reference, found `char`\n   |\n   = note: expected reference `&std::ops::Range<char>`\n\
    \                   found type `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0, s.len())\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \ --> /tmp/tmp6hx5y6d6.rs:7:5\n  |\n7 |     vowels_count(s, 0, s.len())\n  | \
    \    ^^^^^^^^^^^^ -  -  ------- supplied 3 arguments\n  |     |\n  |     expected\
    \ 1 argument\n  |\nnote: function defined here\n --> /tmp/tmp6hx5y6d6.rs:6:4\n\
    \  |\n6 | fn vowels_count(s: String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for c in s.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n            vowel_flag = true;\n        }\n        if c ==\
    \ 'y' {\n            vowel_flag = false;\n        }\n        if vowel_flag {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `2`', /tmp/tmpuhu4ro0x.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for c in s.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n            vowel_flag = true;\n        }\n        if c ==\
    \ 'y' && vowel_flag {\n            vowel_flag = false;\n        }\n        if\
    \ c == 'y' && !vowel_flag {\n            vowel_count += 1;\n        }\n    }\n\
    \    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmp5ruo5o8m.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_chars =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    let mut vowel_char_count = vec![0, 1, 2,\
    \ 3, 4];\n    for c in s.chars() {\n        if vowel_chars.contains(&c) {\n  \
    \          vowel_count += vowel_char_count[vowel_chars.iter().position(|&x| x\
    \ == c).unwrap()];\n        }\n        vowel_char_count[vowel_chars.iter().position(|&x|\
    \ x == c).unwrap()] += 1;\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpadp96_zm.rs:14:67

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_end_index\
    \ = s.len();\n    let mut vowel_end_index2 = s.len();\n    let mut vowel_end_index3\
    \ = s.len();\n    let mut vowel_end_index4 = s.len();\n    let mut vowel_end_index5\
    \ = s.len();\n    let mut vowel_end_index6 = s.len();\n    let mut vowel_end_index7\
    \ = s.len();\n    let mut vowel_end_index8 = s.len();\n    let mut vowel_end_index9\
    \ = s.len();\n    let mut vowel_end_index10 = s.len();\n    let mut vowel_end_index11\
    \ = s.len();\n    let mut vowel_end_index12 = s.len();\n    let mut vowel_end_index13\
    \ = s.len();\n    let mut vowel_end_index14 = s.len();\n    let mut vowel_end_index15\
    \ = s.len();\n    let mut vowel_end_index16 = s.len();\n    let mut vowel_end_index17\
    \ = s.len();\n    let mut vowel_end_index18 = s.len();\n    let mut vowel_end_index19\
    \ = s.len();\n    let mut vowel_end_index20 = s.len();\n    let mut vowel_end_index21\
    \ = s.len();\n    let mut vowel_end_index22 = s.len();\n    let mut vowel_end_index23\
    \ = s.len();\n    let mut vowel_end_index24 = s.len();\n    let mut vowel_end_index25\
    \ = s.len();\n    let mut vowel_end_index26 = s.len();\n    let mut vowel_end_index27\
    \ = s.len();\n    let mut vowel_end_index28 = s.len();\n    let mut vowel_end_index29\
    \ = s.len();\n    let mut vowel_end_index30 = s.len();\n    let mut vowel_end_index31\
    \ = s.len();\n    let mut vowel_end_index32 = s.len();\n    let mut vowel_end_index33\
    \ = s.len();\n    let mut vowel_end_index34 = s.len();\n    let mut vowel_end_index35\
    \ = s.len();\n    let mut vowel_end_index36 = s.len();\n    let mut vowel_end_index37\
    \ = s.len();\n    let mut vowel_end_index38 = s.len();\n    let mut vowel_end_index39\
    \ = s.len();\n    let mut vowel_end_index40 = s.len\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpobx409r1.rs:47:38\n   |\n\
    47 |     let mut vowel_end_index40 = s.len\n   |                             \
    \         ^ help: add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0615]:\
    \ attempted to take value of method `len` on type `String`\n  --> /tmp/tmpobx409r1.rs:47:35\n\
    \   |\n47 |     let mut vowel_end_index40 = s.len\n   |                      \
    \             ^^^ method, not a field\n   |\nhelp: use parentheses to call the\
    \ method\n   |\n47 |     let mut vowel_end_index40 = s.len()\n   |           \
    \                           ++\n\nerror[E0308]: mismatched types\n --> /tmp/tmpobx409r1.rs:6:31\n\
    \  |\n6 | fn vowels_count(s: String) -> isize {\n  |    ------------         \
    \      ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0615.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        match ch {\n            'a' => vowel_count += 1,\n            'e' =>\
    \ vowel_count += 1,\n            'i' => vowel_count += 1,\n            'o' =>\
    \ vowel_count += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n\
    \        }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpqoxef61s.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, |c| c.is_vowel())\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpmmqfp48n.rs:7:22\n\
    \  |\n7 |     vowels_count(s, |c| c.is_vowel())\n  |                      ^ consider\
    \ giving this closure parameter a type\n  |\n  = note: type must be known at this\
    \ point\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpmmqfp48n.rs:7:5\n  |\n7 |     vowels_count(s, |c| c.is_vowel())\n\
    \  |     ^^^^^^^^^^^^ -  ---------------- supplied 2 arguments\n  |     |\n  |\
    \     expected 1 argument\n  |\nnote: function defined here\n --> /tmp/tmpmmqfp48n.rs:6:4\n\
    \  |\n6 | fn vowels_count(s: String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowel_pos = 0;\n    let mut vowel_end = s.len()\
    \ - 1;\n    while vowel_pos < vowel_end {\n        if s[vowel_pos] == vowels[vowel_pos]\
    \ {\n            vowel_count += 1;\n        }\n        vowel_pos += 1;\n    }\n\
    \    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplgdndnmd.rs:12:12\n\
    \   |\n12 |         if s[vowel_pos] == vowels[vowel_pos] {\n   |            ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for ch in s.chars() {\n        if vowels.contains(ch)\
    \ {\n            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqs0n8gux.rs:10:28\n   |\n\
    10 |         if vowels.contains(ch) {\n   |                            ^^\n  \
    \ |                            |\n   |                            expected `&char`,\
    \ found `char`\n   |                            help: consider borrowing here:\
    \ `&ch`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpx00rxuig.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for ch in s.chars() {\n        if ch == 'a' || ch == 'e' || ch == 'i' ||\
    \ ch == 'o' || ch == 'u' {\n            vowel_flag = true;\n        }\n      \
    \  if ch == 'y' {\n            vowel_flag = false;\n        }\n        if vowel_flag\
    \ {\n            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `2`', /tmp/tmp35w6_8lk.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \ --> /tmp/tmpaqatiguq.rs:7:5\n  |\n7 |     vowels_count(s, 0)\n  |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n  |     |\n  |     expected 1 argument\n  |\nnote:\
    \ function defined here\n --> /tmp/tmpaqatiguq.rs:6:4\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0, s.len())\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \ --> /tmp/tmp6hx5y6d6.rs:7:5\n  |\n7 |     vowels_count(s, 0, s.len())\n  | \
    \    ^^^^^^^^^^^^ -  -  ------- supplied 3 arguments\n  |     |\n  |     expected\
    \ 1 argument\n  |\nnote: function defined here\n --> /tmp/tmp6hx5y6d6.rs:6:4\n\
    \  |\n6 | fn vowels_count(s: String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        match ch {\n            'a' => vowel_count += 1,\n            'e' =>\
    \ vowel_count += 1,\n            'i' => vowel_count += 1,\n            'o' =>\
    \ vowel_count += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n\
    \        }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpqoxef61s.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => {}\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps2mk27k9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for ch in s.chars() {\n        if ch == 'a' || ch == 'e' || ch == 'i' ||\
    \ ch == 'o' || ch == 'u' {\n            vowel_flag = true;\n        }\n      \
    \  if ch == 'y' && !vowel_flag {\n            vowel_flag = true;\n        }\n\
    \        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n     \
    \   }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag {\n            vowel_flag = false;\n\
    \        }\n        if ch == 'y' && vowel_flag\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgcigwapq.rs:100:3\n\
    \    |\n6   | fn vowels_count(s: String) -> isize {\n    |                   \
    \                  - unclosed delimiter\n...\n9   |     for ch in s.chars() {\n\
    \    |                         - this delimiter might not be properly closed...\n\
    ...\n89  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n100 | }\n    |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpgcigwapq.rs:89:1\n\
    \   |\n88 |         if ch == 'y' && vowel_flag\n   |         -- this `if` expression\
    \ has a condition, but no block\n89 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpgcigwapq.rs:6:31\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |    ------------               ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for ch in s.chars() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp37ag725z.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for c in s.chars() {\n        if vowels.contains(&c)\
    \ {\n            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpnmhtu8bp.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_chars =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    for c in s.chars() {\n        if vowel_chars.contains(&c)\
    \ {\n            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp898cbsjd.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0, s.len())\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \ --> /tmp/tmp6hx5y6d6.rs:7:5\n  |\n7 |     vowels_count(s, 0, s.len())\n  | \
    \    ^^^^^^^^^^^^ -  -  ------- supplied 3 arguments\n  |     |\n  |     expected\
    \ 1 argument\n  |\nnote: function defined here\n --> /tmp/tmp6hx5y6d6.rs:6:4\n\
    \  |\n6 | fn vowels_count(s: String) -> isize {\n  |    ^^^^^^^^^^^^ ---------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    return vowel_count;\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpe2spo58t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' => vowel_count += 1,\n            'e' => vowel_count\
    \ += 1,\n            'i' => vowel_count += 1,\n            'o' => vowel_count\
    \ += 1,\n            'u' => vowel_count += 1,\n            _ => (),\n        }\n\
    \    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmphtao6sj6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:28\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                            ^^ no implementation for\
    \ `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:40\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:52\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \  ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp8izovvn9.rs:7:64\n  |\n7 |     s.chars().filter(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n  |                 \
    \                                               ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp8izovvn9.rs:7:76\n\
    \  |\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u').count()\n  |                                                  \
    \                          ^^ no implementation for `&char == char`\n  |\n  =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8izovvn9.rs:7:5\n  |\n6 | fn vowels_count(s:\
    \ String) -> isize {\n  |                               ----- expected `isize`\
    \ because of return type\n7 |     s.chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    let mut vowel_flag = false;\n\
    \    for c in s.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n            vowel_flag = true;\n        }\n        if c ==\
    \ 'y' && !vowel_flag {\n            vowel_flag = true;\n        }\n        if\
    \ vowel_flag {\n            vowel_count += 1;\n        }\n    }\n    return vowel_count;\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `2`', /tmp/tmplb00hops.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009111
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbc6kwf0u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747099
