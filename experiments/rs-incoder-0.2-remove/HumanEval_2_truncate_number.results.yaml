language: rs
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut integer_part);\n        decimal_part += integer_part\
    \ * 10.0;\n        integer_part = remainder;\n        remainder = 0.0;\n     \
    \   exponent -= 1;\n    }\n    decimal_part + integer_part + remainder\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpg1u29rlv.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpg1u29rlv.rs:11:29\n   |\n11 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal = f64::MIN;\n\
    \    let mut remainder = f64::MIN;\n    let mut exponent = 0;\n    while number\
    \ >= f64::MIN {\n        number -= f64::MIN;\n        decimal += 1;\n        remainder\
    \ += 1;\n        exponent = exponent + 1;\n    }\n    number + remainder\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `{integer}` to `f64`\n  --> /tmp/tmpcdnygkg7.rs:11:17\n\
    \   |\n11 |         decimal += 1;\n   |                 ^^ no implementation for\
    \ `f64 += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>` is not\
    \ implemented for `f64`\n\nerror[E0277]: cannot add-assign `{integer}` to `f64`\n\
    \  --> /tmp/tmpcdnygkg7.rs:12:19\n   |\n12 |         remainder += 1;\n   |   \
    \                ^^ no implementation for `f64 += {integer}`\n   |\n   = help:\
    \ the trait `AddAssign<{integer}>` is not implemented for `f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        leftover_part\
    \ += 1.0;\n        remainder -= 1.0;\n    }\n    while remainder > 0.1 {\n   \
    \     leftover_part += 0.1;\n        remainder -= 0.1;\n    }\n    while remainder\
    \ > 0.01 {\n        leftover_part += 0.01;\n        remainder -= 0.01;\n    }\n\
    \    while remainder > 0.001 {\n        leftover_part += 0.001;\n        remainder\
    \ -= 0.001;\n    }\n    while remainder > 0.0001 {\n        leftover_part += 0.0001;\n\
    \        remainder -= 0.0001;\n    }\n    while remainder > 0.00001 {\n      \
    \  leftover_part += 0.00001;\n        remainder -= 0.00001;\n    }\n    while\
    \ remainder > 0.000001 {\n        leftover_part += 0.000001;\n        remainder\
    \ -= 0.000001;\n    }\n    while remainder > 0.0000001 {\n        leftover_part\
    \ += 0.0000001;\n        remainder -= 0.0000001;\n    }\n    while remainder >\
    \ 0.00000001 {\n        leftover_part += 0.00000001;\n        remainder -= 0.00000001;\n\
    \    }\n    while remainder > 0.000000001 {\n        leftover_part += 0.000000001;\n\
    \        remainder -= 0.000000001;\n    }\n    while remainder > 0.0000000001\
    \ {\n        leftover_part += 0.0000000001;\n        remainder -= 0.0000000001;\n\
    \    }\n    while remainder > 0.00000000001 {\n        leftover_part += 0.00000000001;\n\
    \        remainder -= 0.00000000001;\n    }\n    while remainder > 0.000000000001\
    \ {\n        leftover_part += 0.000000000001;\n        remainder -= 0.000000000001;\n\
    \    }\n    while remainder > 0.0000000000001 {\n        leftover_part += 0.0000000000001;\n\
    \        remainder -= 0.0000000000001;\n    }\n    while remainder > 0.00000000000001\
    \ {\n        leftover_part += 0.00000000000001;\n        remainder -= 0.00000000000001;\n\
    \    }\n    while remainder > 0.000000000000001 {\n        leftover_part += 0.000000000000001;\n\
    \        remainder -= 0.000000000000001;\n    }\n    while remainder > 0.0000000000000001\
    \ {\n        leftover_part += 0.0000000000000001;\n        remainder -= 0.0000000000000001;\n\
    \    }\n\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ypdaq1m.rs:74:5\n   |\n\
    5  |   fn truncate_number(number: f64) -> f64 {\n   |                        \
    \              --- expected `f64` because of return type\n...\n74 | /     while\
    \ remainder > 0.0000000000000001 {\n75 | |         leftover_part += 0.0000000000000001;\n\
    76 | |         remainder -= 0.0000000000000001;\n77 | |     }\n   | |_____^ expected\
    \ `f64`, found `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    number\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3ixhhalm.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3ixhhalm.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3ixhhalm.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = 0.0;\n\n    // We will iterate over all significant digits of\
    \ the number and\n    // compute the decimal part and integer part and remainder\
    \ and exponent\n    // as we go.\n    while number > 0.0 {\n        let digit\
    \ = number % 10.0;\n        integer_part += digit as f64;\n        decimal_part\
    \ += digit as f64;\n        number /= 10.0;\n        remainder += number;\n  \
    \      exponent += 1;\n    }\n\n    // We now have all the parts we need. Let's\
    \ return them.\n    integer_part + decimal_part + remainder\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmp932jc99v.rs:20:18\n\
    \   |\n20 |         exponent += 1;\n   |                  ^^ no implementation\
    \ for `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>`\
    \ is not implemented for `{float}`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = 0;\n    let mut\
    \ max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n \
    \   let mut max_fraction = std::i32::MAX;\n    let mut min_fraction = std::i32::MIN;\n\
    \    let mut min_fraction_bits = std::i32::MAX;\n    let mut max_fraction_bits\
    \ = std::i32::MIN;\n    let mut min_exponent_bits = std::i32::MAX;\n    let mut\
    \ max_exponent_bits = std::i32::MIN;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = std::i32::MIN;\n\
    \    let mut max_exponent = std::i32::MAX;\n    let mut min_exponent = \n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpmcyybbmv.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpk7pwenbo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = number;\n    while remainder\
    \ > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n    }\n    while\
    \ remainder > 0.0 {\n        remainder -= 1.0;\n        integer += 1.0;\n    }\n\
    \    integer + decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp6by9fvjl.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    number\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3ixhhalm.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3ixhhalm.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3ixhhalm.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 0.0 {\n        let mut\
    \ quotient = remainder / 10.0;\n        integer_part += quotient;\n        leftover_part\
    \ += quotient * 10.0;\n        remainder = remainder % 10.0;\n        decimal_part\
    \ += remainder;\n    }\n    integer_part + decimal_part + leftover_part\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749627
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = number;\n    while remainder\
    \ > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n    }\n    while\
    \ remainder > 0.0 {\n        remainder -= 1.0;\n        integer += 1.0;\n    }\n\
    \    integer + decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp6by9fvjl.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut integer = number.floor();\n\
    \    let mut decimal = number - integer;\n    if decimal < 1.0 {\n        integer\
    \ = integer + 1;\n        decimal = decimal * 10.0;\n    }\n    decimal\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n --> /tmp/tmpnm8ex2kw.rs:9:27\n\
    \  |\n9 |         integer = integer + 1;\n  |                           ^ no implementation\
    \ for `f64 + {integer}`\n  |\n  = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut exponent = number.abs();\n    while exponent > 0.0 {\n        if\
    \ exponent % 2.0 == 0.0 {\n            decimals += 1.0;\n        }\n        exponent\
    \ /= 2.0;\n    }\n    number * decimals\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.0`,\n right: `0.5`', /tmp/tmpr08fhnkp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut remainder_power\
    \ = 0.0;\n    let mut remainder_power_neg = 0.0;\n    let mut remainder_power_neg_inv\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power = 0.0;\n    let mut remainder_power_neg_inv_power_neg\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv = 0.0;\n    let mut\
    \ remainder_power_neg_inv_power_neg_inv_power = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv = 0.0;\n\
    \    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power = 0.0;\n\
    \    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg = 0.0;\n\
    \    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv_power_neg_inv\
    \ = 0.0;\n    let mut remainder_power_neg_inv_power_neg_in\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_6vi8ypb.rs:30:49\n   |\n\
    30 |     let mut remainder_power_neg_inv_power_neg_in\n   |                  \
    \                               ^ help: add `;` here\n31 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_6vi8ypb.rs:5:36\n  |\n\
    5 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------         \
    \        ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        remainder += 1.0;\n\
    \        integer += remainder;\n        decimals += remainder;\n        exponent--;\n\
    \    }\n    number\n        / f64::powf(f64::from(integer), f64::from(decimals))\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp7jtb6jbb.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp7jtb6jbb.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        leftover_part\
    \ += 1.0;\n        remainder -= 1.0;\n    }\n    while remainder > 0.0 {\n   \
    \     integer_part += 1.0;\n        remainder -= 0.0;\n    }\n    integer_part\
    \ += leftover_part;\n    decimal_part = remainder;\n    integer_part * f64::from(decimal_part)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749627
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut exponent = number.abs();\n    while exponent > 0.0 {\n        if\
    \ exponent % 1.0 != 0.0 {\n            decimals += 1.0;\n        }\n        exponent\
    \ /= 1.0;\n    }\n    number * f64::from(decimals)\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749627
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    number\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3ixhhalm.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3ixhhalm.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3ixhhalm.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpk7pwenbo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal = f64::MIN;\n\
    \    let mut remainder = f64::MIN;\n    let mut exponent = 0;\n    let mut i =\
    \ 0;\n    while number >= f64::MIN {\n        number -= f64::MIN;\n        i +=\
    \ 1;\n    }\n    number = number.abs();\n    while number >= f64::EPSILON {\n\
    \        decimal += f64::EPSILON;\n        number -= f64::EPSILON;\n        i\
    \ += 1;\n    }\n    while number > f64::EPSILON {\n        remainder += f64::EPSILON;\n\
    \        number -= f64::EPSILON;\n        i += 1;\n    }\n    exponent += i;\n\
    \    decimal = decimal.round() as f64;\n    remainder = remainder.round() as f64;\n\
    \    exponent += f64::MIN;\n    exponent -= f64::MAX;\n    exponent += f64::MIN;\n\
    \    exponent -= f64::MAX;\n    exponent += f64::MIN;\n    exponent -= f64::MAX;\n\
    \    exponent += f64::MIN;\n    exponent -= f64::MAX;\n    exponent += f64::MIN;\n\
    \    exponent -= f64::MAX;\n    exponent += f64::MIN;\n    exponent -= f64::MAX;\n\
    \    exponent += f64::MIN;\n    exponent -= f64::MAX;\n    exponent += f64::MIN;\n\
    \    exponent -= f64::MAX;\n    exponent += f64::MIN;\n    exponent -= f64::MAX;\n\
    \    exponent += f64::MIN;\n    exponent -= f64::MAX;\n    exponent += f64::MIN;\n\
    \    exponent -= f64::MAX;\n    exponent += f64::MIN;\n    exponent -= f64::MAX;\n\
    \    exponent += f64::MIN;\n    exponent -= f64::MAX;\n    exponent += f64::MIN;\n\
    \    exponent -= f64::MAX;\n    exponent += f64::MIN;\n    exponent -= f64::MAX;\n\
    \    exponent += f64::MIN;\n    exponent -= f64::MAX;\n    exponent += f64::MIN;\n\
    \    exponent -= f64::MAX;\n    exponent += f64::MIN;\n    exponent -= f64::MAX;\n\
    \    exponent += f64::MIN;\n    exponent -= f64::MAX;\n    exponent += f64::MIN;\n\
    \    exponent -= f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `f64`\n  --> /tmp/tmpdk2c8a2c.rs:67:17\n\
    \   |\n67 |     exponent -= f64\n   |                 ^^^ not a value\n\nerror[E0277]:\
    \ cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmpdk2c8a2c.rs:28:14\n  \
    \ |\n28 |     exponent += f64::MIN;\n   |              ^^ no implementation for\
    \ `{integer} += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented\
    \ for `{integer}`\n\nerror[E0277]: cannot subtract-assign `f64` from `{integer}`\n\
    \  --> /tmp/tmpdk2c8a2c.rs:29:14\n   |\n29 |     exponent -= f64::MAX;\n   | \
    \             ^^ no implementation for `{integer} -= f64`\n   |\n   = help: the\
    \ trait `SubAssign<f64>` is not implemented for `{integer}`\n\nerror[E0277]: cannot\
    \ add-assign `f64` to `{integer}`\n  --> /tmp/tmpdk2c8a2c.rs:30:14\n   |\n30 |\
    \     exponent += f64::MIN;\n   |              ^^ no implementation for `{integer}\
    \ += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for\
    \ `{integer}`\n\nerror[E0277]: cannot subtract-assign `f64` from `{integer}`\n\
    \  --> /tmp/tmpdk2c8a2c.rs:31:14\n   |\n31 |     exponent -= f64::MAX;\n   | \
    \             ^^ no implementation for `{integer} -= f64`\n   |\n   = help: the\
    \ trait `SubAssign<f64>` is not implemented for `{integer}`\n\nerror[E0277]: cannot\
    \ add-assign `f64` to `{integer}`\n  --> /tmp/tmpdk2c8a2c.rs:32:14\n   |\n32 |\
    \     exponent += f64::MIN;\n   |              ^^ no implementation for `{integer}\
    \ += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for\
    \ `{integer}`\n\nerror[E0277]: cannot subtract-assign `f64` from `{integer}`\n\
    \  --> /tmp/tmpdk2c8a2c.rs:33:14\n   |\n33 |     exponent -= f64::MAX;\n   | \
    \             ^^ no implementation for `{integer} -= f64`\n   |\n   = help: the\
    \ trait `SubAssign<f64>` is not implemented for `{integer}`\n\nerror[E0277]: cannot\
    \ add-assign `f64` to `{integer}`\n  --> /tmp/tmpdk2c8a2c.rs:34:14\n   |\n34 |\
    \     exponent += f64::MIN;\n   |              ^^ no implementation for `{integer}\
    \ += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for\
    \ `{integer}`\n\nerror[E0277]: cannot subtract-assign `"
  stdout: ''
  timestamp: 1659749622
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut mantissa = number.fract();\n    while exponent > 0 {\n\
    \        if exponent & 1 == 1 {\n            mantissa *= 10.0;\n        }\n  \
    \      mantissa /= 10.0;\n        decimal_part += mantissa;\n        mantissa\
    \ = mantissa % 10.0;\n        exponent >>= 1;\n    }\n    decimal_part + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.5`', /tmp/tmplzed_ws8.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        remainder /= 10.0;\n  \
    \      exponent -= 1;\n    }\n    integer_part += remainder;\n    decimal_part\
    \ = number.fract();\n    integer_part += decimal_part;\n    integer_part as f64\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpa4pbldfc.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        remainder += number.remainder(&integer);\n\
    \        decimals += integer.to_f64();\n        integer -= remainder;\n      \
    \  exponent--;\n    }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpf52geqy9.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpf52geqy9.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpf52geqy9.rs:11:29\n   |\n11 |         remainder += number.remainder(&integer);\n\
    \   |                             ^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `{float}` in the current scope\n  -->\
    \ /tmp/tmpf52geqy9.rs:12:29\n   |\n12 |         decimals += integer.to_f64();\n\
    \   |                             ^^^^^^ method not found in `{float}`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    decimal_part +\
    \ remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpm06n6hln.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpm06n6hln.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpm06n6hln.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    let mut mantissa = number.mantissa();\n\n    while exponent > 0 {\n     \
    \   if exponent & 1 == 1 {\n            mantissa /= 10.0;\n        }\n       \
    \ mantissa *= 10.0;\n        exponent >>= 1;\n    }\n\n    while mantissa > 1.0\
    \ {\n        mantissa /= 10.0;\n        decimal_part += 1.0;\n    }\n\n    remainder\
    \ = mantissa;\n    decimal_part += remainder;\n    decimal_part - 1.0\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpsfdhoij0.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmpsfdhoij0.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut max_integer_part = 0.0;\n    let mut max_leftover_part = 0.0;\n \
    \   let mut max_decimal_part = 0.0;\n    let mut max_number = 0.0;\n    let mut\
    \ max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n   \
    \ let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n    let\
    \ mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n\
    \    let mut max_leftover_part_size = 0.0;\n    let mut max_number = 0.0;\n  \
    \  let mut max_decimal_part_size = 0.0;\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp90ylk3ef.rs:5:36\n  |\n5 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    while number >\
    \ 0.0 {\n        remainder = number % 10.0;\n        integer = integer + remainder;\n\
    \        decimals = decimals + remainder;\n        number = number / 10.0;\n \
    \   }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `remainder` is never read\n --> /tmp/tmpnauzqy9z.rs:8:13\n\
    \  |\n8 |     let mut remainder = 0.0;\n  |             ^^^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_assignments)]` on by default\n  = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `number`\n\
    \  --> /tmp/tmpnauzqy9z.rs:13:9\n   |\n5  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n13 |         number = number / 10.0;\n   |         ^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut max_integer_part = 0.0;\n    let mut max_leftover_part = 0.0;\n \
    \   let mut min_integer_part = 0.0;\n    let mut min_leftover_part = 0.0;\n  \
    \  let mut max_decimal_part = 0.0;\n    let mut min_decimal_part = 0.0;\n    let\
    \ mut max_number = 0.0;\n    let mut min_number = 0.0;\n    let mut max_fraction\
    \ = 0.0;\n    let mut min_fraction = 0.0;\n    let mut max_exponent = 0.0;\n \
    \   let mut min_exponent = 0.0;\n    let mut max_mantissa = 0.0;\n    let mut\
    \ min_mantissa = 0.0;\n    let mut max_exponent1 = 0.0;\n    let mut min_exponent1\
    \ = 0.0;\n    let mut max_mantissa1 = 0.0;\n    let mut min_mantissa1 = 0.0;\n\
    \    let mut max_exponent2 = 0.0;\n    let mut min_exponent2 = 0.0;\n    let mut\
    \ max_mantissa2 = 0.0;\n    let mut min_mantissa2 = 0.0;\n    let mut max_exponent3\
    \ = 0.0;\n    let mut min_exponent3 = 0.0;\n    let mut max_mantissa3 = 0.0;\n\
    \    let mut min_mantissa3 = 0.0;\n    let mut max_exponent4 = 0.0;\n    let mut\
    \ min_exponent4 = 0.0;\n    let mut max_mantissa4 = 0.0;\n    let mut min_mantissa4\
    \ = 0.0;\n    let mut max_exponent5 = 0.0;\n    let mut min_exponent5 = 0.0;\n\
    \    let mut max_mantissa5 = 0.0;\n    let mut min_mantissa5 = 0.0;\n    let mut\
    \ max_exponent6 = 0.0;\n    let mut min_exponent6 = 0.0;\n    let mut max_mantissa6\
    \ = 0.0;\n    let mut min_mantissa6 = 0.0;\n    let mut max_exponent7 = 0.0;\n\
    \    let mut min_exponent7 = 0.0;\n    let mut max_mantissa7 = 0.0;\n    let mut\
    \ min_mantissa7 = 0.0;\n    let mut max_exponent8 = 0.0;\n    let mut min_exponent8\
    \ = 0.0;\n    let mut max_mantissa8 = 0.0;\n    let mut min_mantissa8 = 0.0;\n\
    \    let mut max_exponent9 = 0.0;\n    let mut min_exponent9 = 0.0;\n    let mut\
    \ max_mantissa9 = 0.0;\n    let mut min_mantissa9 = 0.0;\n\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpo600tf2n.rs:5:36\n  |\n5 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut exponent = number.floor() as i32;\n    let mut remainder = number.fract();\n\
    \    while exponent > 0 {\n        if exponent & 1 == 1 {\n            result\
    \ += remainder;\n        }\n        remainder *= 10.0;\n        result *= 10.0;\n\
    \        exponent = exponent >> 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `100.0`,\n right: `0.5`', /tmp/tmpitapsuga.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent -= 1;\n    }\n    number\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp17lk19xf.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp17lk19xf.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    while exponent\
    \ > 0 {\n        last_digit = last_digit / 10.0;\n        decimal_part += last_digit;\n\
    \        exponent = exponent - 1;\n    }\n    remainder = number - decimal_part\
    \ * 10.0;\n    decimal_part += remainder;\n    decimal_part * 10.0\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `i32` by `{float}`\n  --> /tmp/tmpjimleqva.rs:11:33\n\
    \   |\n11 |         last_digit = last_digit / 10.0;\n   |                    \
    \             ^ no implementation for `i32 / {float}`\n   |\n   = help: the trait\
    \ `Div<{float}>` is not implemented for `i32`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror[E0277]: cannot add-assign\
    \ `i32` to `{float}`\n  --> /tmp/tmpjimleqva.rs:12:22\n   |\n12 |         decimal_part\
    \ += last_digit;\n   |                      ^^ no implementation for `{float}\
    \ += i32`\n   |\n   = help: the trait `AddAssign<i32>` is not implemented for\
    \ `{float}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.fract() * (10.0 as f64);\n\
    \        decimal_part += remainder;\n        number -= remainder;\n        exponent--;\n\
    \    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpyj2mvriw.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpyj2mvriw.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\n\
    \    if number < 0.0 {\n        leftover_part = -number;\n        number = -number;\n\
    \    }\n\n    if number < 1.0 {\n        integer_part = number;\n    } else {\n\
    \        let mut remainder = number;\n        while remainder >= 1.0 {\n     \
    \       integer_part += 1.0;\n            remainder -= 1.0;\n        }\n     \
    \   leftover_part = remainder;\n    }\n\n    integer_part + decimal_part + leftover_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmp77dknpwx.rs:6:9\n\
    \  |\n6 |     let mut decimal_part = 0.0;\n  |         ----^^^^^^^^^^^^\n  | \
    \        |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `number`\n\
    \  --> /tmp/tmp77dknpwx.rs:12:9\n   |\n5  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n12 |         number = -number;\n   |         ^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    let mut mantissa = number.mantissa();\n    while exponent > 0 {\n       \
    \ remainder += mantissa.pow(exponent);\n        mantissa = mantissa.div(10.0).unwrap();\n\
    \        exponent--;\n    }\n    mantissa.truncate();\n    decimal_part += remainder;\n\
    \    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpaiv5v446.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpaiv5v446.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmpaiv5v446.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut truncated = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n   \
    \ while exponent > 0 {\n        if exponent % 2 == 1 {\n            truncated\
    \ = truncated.checked_add(number.checked_mul(1.0 / 2.0).unwrap());\n        }\
    \ else {\n            truncated = truncated.checked_add(number.checked_mul(2.0).unwrap());\n\
    \        }\n        remainder = remainder.checked_add(number.checked_mul(2.0).unwrap());\n\
    \        exponent = exponent / 2;\n    }\n    truncated.checked_add(remainder).unwrap()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmp5di4cwgh.rs:8:41\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n8 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0 {\n  |                             \
    \            ~\n\nerror: invalid const generic expression\n  --> /tmp/tmp5di4cwgh.rs:9:5\n\
    \   |\n9  | /     while exponent > 0 {\n10 | |         if exponent % 2 == 1 {\n\
    11 | |             truncated = truncated.checked_add(number.checked_mul(1.0 /\
    \ 2.0).unwrap());\n12 | |         } else {\n...  |\n16 | |         exponent =\
    \ exponent / 2;\n17 | |     }\n   | |_____^\n   |\nhelp: expressions must be enclosed\
    \ in braces to be used as const generic arguments\n   |\n9  ~     { while exponent\
    \ > 0 {\n10 |         if exponent % 2 == 1 {\n11 |             truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 2.0).unwrap());\n12 |         } else {\n13 |             truncated = truncated.checked_add(number.checked_mul(2.0).unwrap());\n\
    14 |         }\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or\
    \ an operator, found `::`\n --> /tmp/tmp5di4cwgh.rs:8:34\n  |\n8 |     let mut\
    \ exponent = number.f64::exp();\n  |                                  ^^ expected\
    \ one of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to\
    \ 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remaining_exponent = exponent;\n    let mut remaining_exponents\
    \ = 1;\n    while remaining_exponent > 0 {\n        let mut next_exponent = exponent\
    \ + 1;\n        if next_exponent > remaining_exponents {\n            next_exponent\
    \ = remaining_exponents;\n        }\n        let mut next_remainder = remainder\
    \ * 10.0;\n        if next_exponent == remaining_exponent {\n            next_remainder\
    \ += number;\n        }\n        decimal_part += next_remainder;\n        remainder\
    \ = next_remainder;\n        remaining_exponent = next_exponent;\n        remaining_exponents\
    \ *= 10;\n        exponent = next_exponent;\n    }\n    decimal_part + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmpfulj_g4b.rs:23:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        remainder += 1.0;\n\
    \        integer += remainder;\n        remainder /= 10.0;\n        decimal +=\
    \ 1.0;\n        exponent--;\n    }\n    number - integer * decimal\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpgc57rivf.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find value `decimal` in this scope\n  --> /tmp/tmpgc57rivf.rs:14:9\n\
    \   |\n14 |         decimal += 1.0;\n   |         ^^^^^^^ help: a local variable\
    \ with a similar name exists: `decimals`\n\nerror[E0425]: cannot find value `decimal`\
    \ in this scope\n  --> /tmp/tmpgc57rivf.rs:17:24\n   |\n17 |     number - integer\
    \ * decimal\n   |                        ^^^^^^^ help: a local variable with a\
    \ similar name exists: `decimals`\n\nerror[E0599]: no method named `exponent`\
    \ found for type `f64` in the current scope\n --> /tmp/tmpgc57rivf.rs:9:31\n \
    \ |\n9 |     let mut exponent = number.exponent();\n  |                      \
    \         ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = number;\n    while remainder\
    \ > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n    }\n    while\
    \ remainder > 0.0 {\n        integer += remainder;\n        remainder -= 0.0;\n\
    \    }\n    integer += decimals;\n    integer\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976556
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        if exponent % 2 == 1 {\n            decimal_part\
    \ += remainder;\n        }\n        remainder *= 10.0;\n        exponent /= 2;\n\
    \    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpipvwphp1.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal = f64::MIN;\n\
    \    let mut remainder = f64::MIN;\n    let mut exponent = 0;\n    let mut mantissa\
    \ = number;\n    while mantissa > f64::MAX {\n        mantissa /= 10;\n      \
    \  exponent++;\n    }\n    while mantissa > f64::MIN && exponent < 64 {\n    \
    \    mantissa *= 10;\n        remainder *= 10;\n        exponent++;\n    }\n \
    \   exponent -= 64;\n    decimal += mantissa * remainder;\n    decimal\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp64k8agav.rs:12:17\n\
    \   |\n12 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n12 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n12 -\
    \         exponent++;\n12 +         exponent += 1;\n   | \n\nerror: Rust has no\
    \ postfix increment operator\n  --> /tmp/tmp64k8agav.rs:17:17\n   |\n17 |    \
    \     exponent++;\n   |                 ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n17 |         { let tmp = exponent; exponent +=\
    \ 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n17 -   \
    \      exponent++;\n17 +         exponent += 1;\n   | \n\nerror[E0277]: cannot\
    \ divide-assign `f64` by `{integer}`\n  --> /tmp/tmp64k8agav.rs:11:18\n   |\n\
    11 |         mantissa /= 10;\n   |                  ^^ no implementation for `f64\
    \ /= {integer}`\n   |\n   = help: the trait `DivAssign<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n11 |         mantissa /= 10.0;\n   |                       ++\n\n\
    error[E0277]: cannot multiply-assign `f64` by `{integer}`\n  --> /tmp/tmp64k8agav.rs:15:18\n\
    \   |\n15 |         mantissa *= 10;\n   |                  ^^ no implementation\
    \ for `f64 *= {integer}`\n   |\n   = help: the trait `MulAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `MulAssign<Rhs>`:\n             <f32 as MulAssign<&f32>>\n             <f32\
    \ as MulAssign>\n             <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n\
    \             <i128 as MulAssign<&i128>>\n         "
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        if exponent % 2 == 1 {\n            result *=\
    \ 10.0;\n        }\n        result += (number / 10.0);\n        remainder *= 10.0;\n\
    \        number /= 10.0;\n        exponent--;\n    }\n    result + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpsq7nf2pg.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmpsq7nf2pg.rs:13:19\n\
    \   |\n13 |         result += (number / 10.0);\n   |                   ^     \
    \        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n13 -         result += (number / 10.0);\n13 +     \
    \    result += number / 10.0;\n   | \n\nerror[E0599]: no method named `exponent`\
    \ found for type `f64` in the current scope\n --> /tmp/tmpsq7nf2pg.rs:8:31\n \
    \ |\n8 |     let mut exponent = number.exponent();\n  |                      \
    \         ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        integer_part\
    \ += number.mantissa() * (f64::pow(10.0, exponent) - 1.0);\n        remainder\
    \ += number.mantissa() * (f64::pow(10.0, exponent) - 1.0);\n        exponent -=\
    \ 1;\n    }\n    integer_part += remainder;\n    decimal_part = number.mantissa()\
    \ * (f64::pow(10.0, exponent) - 1.0);\n    integer_part += decimal_part;\n   \
    \ integer_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp2172n8ob.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp2172n8ob.rs:11:32\n   |\n11 |         integer_part += number.mantissa()\
    \ * (f64::pow(10.0, exponent) - 1.0);\n   |                                ^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no function or associated item named\
    \ `pow` found for type `f64` in the current scope\n  --> /tmp/tmp2172n8ob.rs:11:51\n\
    \   |\n11 |         integer_part += number.mantissa() * (f64::pow(10.0, exponent)\
    \ - 1.0);\n   |                                                   ^^^\n   |  \
    \                                                 |\n   |                    \
    \                               function or associated item not found in `f64`\n\
    \   |                                                   help: there is an associated\
    \ function with a similar name: `powf`\n\nerror[E0599]: no method named `mantissa`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp2172n8ob.rs:12:29\n\
    \   |\n12 |         remainder += number.mantissa() * (f64::pow(10.0, exponent)\
    \ - 1.0);\n   |                             ^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no function or associated item named `pow` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp2172n8ob.rs:12:48\n   |\n12 |         remainder\
    \ += number.mantissa() * (f64::pow(10.0, exponent) - 1.0);\n   |             \
    \                                   ^^^\n   |                                \
    \                |\n   |                                                function\
    \ or associated item not found in `f64`\n   |                                \
    \                help: there is an associated function with a similar name: `powf`\n\
    \nerror[E0599]: no method named `mantissa` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp2172n8ob.rs:16:27\n   |\n16 |     decimal_part = number.mantissa()\
    \ * (f64"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut exponent = number.floor() as i32;\n    if exponent < 0 {\n      \
    \  exponent = -exponent;\n    }\n    if exponent > 0 {\n        result = number.fract();\n\
    \    }\n    result + number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpgsv8zpvy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n\n  \
    \  // Truncate to integer part\n    if number < 0.0 {\n        integer_part =\
    \ number;\n        number = -number;\n    } else {\n        integer_part = number;\n\
    \    }\n\n    // Truncate to decimal part\n    if number < 1.0 {\n        decimal_part\
    \ = number;\n        number = number - 1.0;\n    } else {\n        decimal_part\
    \ = 0.0;\n    }\n\n    // Add remainder to decimal part\n    remainder = number\
    \ - decimal_part;\n\n    // Return truncated number\n    integer_part + decimal_part\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `decimal_part` is never read\n --> /tmp/tmprjm658il.rs:6:13\n\
    \  |\n6 |     let mut decimal_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_assignments)]` on by default\n  = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `integer_part`\
    \ is never read\n --> /tmp/tmprjm658il.rs:7:13\n  |\n7 |     let mut integer_part\
    \ = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n  = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `remainder` is never read\n\
    \ --> /tmp/tmprjm658il.rs:8:13\n  |\n8 |     let mut remainder = 0.0;\n  |   \
    \          ^^^^^^^^^\n  |\n  = help: maybe it is overwritten before being read?\n\
    \nerror[E0384]: cannot assign to immutable argument `number`\n  --> /tmp/tmprjm658il.rs:13:9\n\
    \   |\n5  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n13 | \
    \        number = -number;\n   |         ^^^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `number`\n  -->\
    \ /tmp/tmprjm658il.rs:21:9\n   |\n5  | fn truncate_number(number: f64) -> f64\
    \ {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n21 |         number = number - 1.0;\n   |         ^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to 2 previous errors;\
    \ 3 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 0.0 {\n        let mut\
    \ quotient = remainder / 10.0;\n        integer_part += quotient;\n        leftover_part\
    \ += quotient * 10.0;\n        remainder -= quotient * 10.0;\n        decimal_part\
    \ += remainder;\n    }\n    integer_part + decimal_part\n}\n\nfn main() {\n  \
    \  let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n  \
    \  assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.35`,\n right: `0.5`', /tmp/tmpifx8x6b3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    number\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3ixhhalm.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3ixhhalm.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3ixhhalm.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.fract() * (f64::powf(10.0,\
    \ exponent) - 1.0);\n        decimal_part += remainder;\n        exponent--;\n\
    \    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp2dmnv1tj.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp2dmnv1tj.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n --> /tmp/tmp2dmnv1tj.rs:9:20\n  |\n9\
    \ |     while exponent > 0 {\n  |                    ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n  |\n  = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\nhelp: consider using a floating-point literal\
    \ by writing it with `.0`\n  |\n9 |     while exponent > 0.0 {\n  |          \
    \             ++\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    decimal_part +\
    \ remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmptufvzzh0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    number\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3ixhhalm.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3ixhhalm.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3ixhhalm.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal = f64::MIN;\n\
    \    let mut remainder = f64::MIN;\n    let mut exponent = 0;\n    let mut mantissa\
    \ = number;\n    while mantissa > f64::MAX {\n        mantissa /= 10;\n      \
    \  exponent++;\n    }\n    while mantissa > f64::MIN && exponent < 10 {\n    \
    \    mantissa *= 10;\n        exponent++;\n    }\n    while mantissa > f64::MIN\
    \ && exponent > 0 {\n        remainder += mantissa % 10;\n        mantissa /=\
    \ 10;\n        exponent--;\n    }\n    exponent += 1;\n    exponent %= 10;\n \
    \   exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent %= 10;\n\
    \    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent %=\
    \ 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n    exponent += 1;\n    exponent\
    \ %= 10;\n    exponent += 1;\n    exponent %= 10;\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpcea9xx4u.rs:12:17\n\
    \   |\n12 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n12 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n12 -\
    \         exponent++;\n12 +         exponent += 1;\n   | \n\nerror: Rust has no\
    \ postfix increment operator\n  --> /tmp/tmpcea9xx4u.rs:16:17\n   |\n16 |    \
    \     exponent++;\n   |                 ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n16 |         { let tmp = exponent; exponent +=\
    \ 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n16 -   \
    \      exponent++;\n16 +         exponent += 1;\n   | \n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmpcea9xx4u.rs:21:19\n   |\n21 |         exponent--;\n\
    \   |                   ^ expected expression\n\nerror[E0277]: cannot divide-assign\
    \ `f64` by `{integer}`\n  --> /tmp/tmpcea9xx4u.rs:11:18\n   |\n11 |         mantissa\
    \ /= 10;\n   |                  ^^ no implementation for `f64 /= {integer}`\n\
    \   |\n   = help: the trait `DivAssign<{integer}>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `DivAssign<Rhs>`:\n    \
    \         <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n        \
    \     <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n            \
    \ <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n             <i16\
    \ as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and 20 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n   |\n\
    11 |         mantissa /= 10.0;\n   |                       ++\n\nerror[E0277]:\
    \ cannot multiply-assign `f64` by `{integer}`\n  --> /tmp/tmpcea9xx4u.rs:15:18\n\
    \   |\n15 |         mantissa *= 10;\n   |                  ^^ no implementation\
    \ for `f64 *= {integer}`\n   |\n   = help: the trait `MulAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `MulAssign<Rhs>`:\n             <f32 as MulAssign<&f32>>\n     "
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut quotient = number.floor();\n\
    \    while quotient != 0.0 {\n        remainder += quotient;\n        quotient\
    \ = quotient - remainder;\n        decimal_part += remainder;\n    }\n    decimal_part\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6.0`,\n right: `0.5`', /tmp/tmp0u7b5cqy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut exponent = number.f64::exp();\n    let mut fraction = number.f64::fract();\n\
    \    while exponent > 0.0 {\n        if exponent % 2.0 == 0.0 {\n            result\
    \ += fraction;\n        }\n        fraction *= 10.0;\n        exponent = exponent\
    \ / 2.0;\n    }\n    result + fraction\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmpedfh8xy5.rs:7:41\n  |\n7 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n7 |     let mut exponent\
    \ = number.f64::exp(), let mut fraction = number.f64::fract();\n  |          \
    \                               ~\n\nerror: expected one of `!`, `+`, `,`, `->`,\
    \ `::`, `:`, `=`, or `>`, found `;`\n --> /tmp/tmpedfh8xy5.rs:8:43\n  |\n8 | \
    \    let mut fraction = number.f64::fract();\n  |                            \
    \               ^ expected one of 8 possible tokens\n  |\nhelp: use a comma to\
    \ separate type parameters\n  |\n8 |     let mut fraction = number.f64::fract(),\
    \ while exponent > 0.0 {\n  |                                           ~\n\n\
    error: invalid const generic expression\n  --> /tmp/tmpedfh8xy5.rs:9:5\n   |\n\
    9  | /     while exponent > 0.0 {\n10 | |         if exponent % 2.0 == 0.0 {\n\
    11 | |             result += fraction;\n12 | |         }\n13 | |         fraction\
    \ *= 10.0;\n14 | |         exponent = exponent / 2.0;\n15 | |     }\n   | |_____^\n\
    \   |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n   |\n9  ~     { while exponent > 0.0 {\n10 |         if exponent\
    \ % 2.0 == 0.0 {\n11 |             result += fraction;\n12 |         }\n13 | \
    \        fraction *= 10.0;\n14 |         exponent = exponent / 2.0;\n ...\n\n\
    error: invalid const generic expression\n --> /tmp/tmpedfh8xy5.rs:8:5\n  |\n8\
    \ |     let mut fraction = number.f64::fract();\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n  |\n8 |     { let mut fraction = number.f64 }::fract();\n  |   \
    \  +                               +\n\nerror: expected one of `(`, `.`, `;`,\
    \ `?`, `else`, or an operator, found `::`\n --> /tmp/tmpedfh8xy5.rs:7:34\n  |\n\
    7 |     let mut exponent = number.f64::exp();\n  |                           \
    \       ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.fract() * (f64::powf(10.0,\
    \ exponent - 1));\n        decimals += remainder;\n        remainder = 0.0;\n\
    \        exponent -= 1;\n    }\n    decimals\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpiy6ohcd4.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut truncated = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = 0;\n    let mut last_digit\
    \ = number;\n    while last_digit > 0.0 {\n        let digit = last_digit % 10.0;\n\
    \        truncated = truncated * 10.0 + (digit as f64);\n        remainder = last_digit\
    \ - digit;\n        last_digit = truncated / 10.0;\n        exponent = exponent\
    \ + 1;\n    }\n    truncated + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `NaN`,\n right: `0.5`', /tmp/tmp2a30j_s9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.floor() as i32;\n\
    \    let mut remainder_exponent = exponent;\n    let mut remainder_power = 0.0;\n\
    \    let mut power = 0.0;\n    let mut exponent = number.floor() as i32;\n   \
    \ let mut power = 0.0;\n    let mut exponent = number.floor() as i32;\n    let\
    \ mut power = 0.0;\n    let mut exponent = number.floor() as i32;\n    let mut\
    \ power = 0.0;\n    let mut exponent = number.floor() as i32;\n    let mut power\
    \ = 0.0;\n    let mut exponent = number.floor() as i32;\n    let mut power = 0.0;\n\
    \    let mut exponent = number.floor() as i32;\n    let mut power = 0.0;\n   \
    \ let mut exponent = number.floor() as i32;\n    let mut power = 0.0;\n    let\
    \ mut exponent = number.floor() as i32;\n    let mut power = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut power = 0.0;\n    let mut exponent\
    \ = number.floor() as i32;\n    let mut power = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut power = 0.0;\n    let mut exponent = number.floor() as\
    \ i32;\n    let mut power = 0.0;\n    let mut exponent = number.floor() as i32;\n\
    \    let mut power = 0.0;\n    let mut exponent = number.floor() as i32;\n   \
    \ let mut power = 0.0;\n    let mut exponent = number.floor() as i32;\n    let\
    \ mut power = 0.0;\n    let mut exponent = number.floor() as i32;\n    let mut\
    \ power = 0.0;\n    let mut exponent = number.floor() as i32;\n    let mut power\
    \ = 0.0;\n    let mut exponent = number.floor() as i32;\n    let mut power = 0.0;\n\
    \    let mut exponent = number.floor() as i32;\n    let mut power = 0.0;\n   \
    \ let mut exponent = number.floor() as i32;\n    let mut power = 0.0;\n    let\
    \ mut exponent = number.floor() as i32;\n    let mut power = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut power = 0.0;\n    let mut exponent\
    \ = number.floor() as i32;\n    let mut power = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut power = 0.0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpbgxgl8pk.rs:61:1\n  \
    \ |\n61 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    while number >\
    \ 0.0 {\n        integer += number % 10.0;\n        decimals += number % 10.0;\n\
    \        number /= 10.0;\n        remainder += number;\n    }\n    integer +=\
    \ remainder;\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `integer` is assigned to, but never used\n --> /tmp/tmpn1ivrqeg.rs:7:13\n\
    \  |\n7 |     let mut integer = 0.0;\n  |             ^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_variables)]` on by default\n  = note: consider using `_integer`\
    \ instead\n\nwarning: value assigned to `integer` is never read\n  --> /tmp/tmpn1ivrqeg.rs:15:5\n\
    \   |\n15 |     integer += remainder;\n   |     ^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmpn1ivrqeg.rs:12:9\n\
    \   |\n5  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n12 | \
    \        number /= 10.0;\n   |         ^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    let mut last_digit\
    \ = number.floor() as i32;\n    let mut last_digit = number.floor() as i32;\n\
    \    let mut last_digit = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    let mut last_digit\
    \ = number.floor() as i32;\n    let mut last_digit = number.floor() as i32;\n\
    \    let mut last_digit = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    let mut last_digit\
    \ = number.floor() as i32;\n    let mut last_digit = number.floor() as i32;\n\
    \    let mut last_digit = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    let mut last_digit\
    \ = number.floor() as i32;\n    let mut last_digit = number.floor() as i32;\n\
    \    let mut last_digit = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    let mut last_digit\
    \ = number.floor() as i32;\n    let mut last_digit = number.floor() as i32;\n\
    \    let mut last_digit = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    let mut last_digit\
    \ = number.floor() as i32;\n    let mut last_digit = number.floor() as i32;\n\
    \    let mut last_digit = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    let mut last_digit\
    \ = number.floor() as i32;\n    let mut last_digit = number.floor() as i32;\n\
    \    let mut last_digit = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    let mut last_digit\
    \ = number.floor() as i32;\n    let mut last_digit = number.floor() as i32;\n\
    \    let mut last_digit = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    let mut last_digit\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpthz9beet.rs:49:23\n   |\n\
    49 |     let mut last_digit\n   |                       ^ help: add `;` here\n\
    50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpthz9beet.rs:5:36\n\
    \  |\n5 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------   \
    \              ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    let mut mantissa = number.mantissa();\n\
    \    while exponent > 0 {\n        remainder = mantissa % 10.0;\n        mantissa\
    \ /= 10.0;\n        integer_part += remainder;\n        decimal_part += 1.0;\n\
    \        exponent--;\n    }\n    integer_part + decimal_part\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpa9uiqlgb.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpa9uiqlgb.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpa9uiqlgb.rs:10:31\n   |\n10 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        leftover_part += 1.0;\n    }\n\n    while remainder > 1.0 {\n\
    \        remainder -= 1.0;\n        integer_part += 1.0;\n    }\n\n    integer_part\
    \ += remainder;\n    decimal_part = remainder - integer_part;\n\n    integer_part\
    \ + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpq36ky3sn.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut exponent = number.abs();\n    while exponent > 0.0 {\n        if\
    \ exponent % 1.0 != 0.0 {\n            result += 1.0;\n        }\n        result\
    \ *= 10.0;\n        exponent /= 10.0;\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `inf`,\n right: `0.5`', /tmp/tmpx5f99ani.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder_exponent = number.floor() as i32;\n    let mut\
    \ remainder_magnitude = number.floor() as i32;\n    let mut remainder_magnitude_bits\
    \ = 0.0;\n    let mut remainder_magnitude_bits_pos = 0.0;\n    let mut remainder_magnitude_bits_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_pos_neg = 0.0;\n    let mut remainder_magnitude_bits_neg_pos\
    \ = 0.0;\n    let mut remainder_magnitude_bits_pos_neg_neg = 0.0;\n    let mut\
    \ remainder_magnitude_bits_neg_pos_neg = 0.0;\n    let mut remainder_magnitude_bits_pos_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_neg_pos_neg_neg = 0.0;\n    let\
    \ mut remainder_magnitude_bits_pos_neg_neg_neg_neg = 0.0;\n    let mut remainder_magnitude_bits_neg_pos_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_pos_neg_neg_neg_neg = 0.0;\n  \
    \  let mut remainder_magnitude_bits_neg_pos_neg_neg_neg_neg = 0.0;\n    let mut\
    \ remainder_magnitude_bits_pos_neg_neg_neg_neg_neg = 0.0;\n    let mut remainder_magnitude_bits_neg_pos_neg_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_pos_neg_neg_neg_neg_neg_neg = 0.0;\n\
    \    let mut remainder_magnitude_bits_neg_pos_neg_neg_neg_neg_neg = 0.0;\n   \
    \ let mut remainder_magnitude_bits_pos_neg_neg_neg_neg_neg_neg = 0.0;\n    let\
    \ mut remainder_magnitude_bits_neg_pos_neg_neg_neg_neg_neg = 0.0;\n    let mut\
    \ remainder_magnitude_bits_pos_neg_neg_neg_neg_neg_neg = 0.0;\n    let mut remainder_magnitude_bits_neg_pos_neg_neg_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_pos_neg_neg_neg_neg_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_neg_pos_neg_neg_neg_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_pos_neg_neg_neg_neg_neg_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_neg_pos_neg_neg_neg_neg_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_pos_neg_neg_neg_neg_neg_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_neg_pos_neg_neg_neg_neg_neg_neg_neg\
    \ = 0.0;\n    let mut remainder_magnitude_bits_pos_neg_neg_neg_neg_neg_neg_\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpchpafhb6.rs:38:66\n   |\n\
    38 |     let mut remainder_magnitude_bits_pos_neg_neg_neg_neg_neg_neg_\n   | \
    \                                                                 ^ help: add\
    \ `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpchpafhb6.rs:5:36\n  |\n5 | fn truncate_number(number: f64) -> f64\
    \ {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.fract() * (f64::pow(10.0,\
    \ exponent) - 1.0);\n        result += (number - remainder).trunc();\n       \
    \ exponent--;\n    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpmc3bn0ug.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpmc3bn0ug.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no function or associated item named `pow` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpmc3bn0ug.rs:10:45\n   |\n10 |         remainder += number.fract()\
    \ * (f64::pow(10.0, exponent) - 1.0);\n   |                                  \
    \           ^^^\n   |                                             |\n   |    \
    \                                         function or associated item not found\
    \ in `f64`\n   |                                             help: there is an\
    \ associated function with a similar name: `powf`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut integer = 0.0;\n\
    \    let mut fraction = number.trunc();\n    while fraction > 1.0 {\n        integer\
    \ += 1.0;\n        fraction -= 1.0;\n    }\n    integer\n}\n\nfn main() {\n  \
    \  let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n  \
    \  assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.0`,\n right: `0.5`', /tmp/tmpcpfjgcds.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    let mut mantissa = number.mantissa();\n\
    \n    while exponent > 0 {\n        mantissa = mantissa * 10.0;\n        exponent\
    \ = exponent - 1;\n    }\n\n    while mantissa > 0.0 {\n        remainder = mantissa\
    \ % 10.0;\n        mantissa = mantissa / 10.0;\n        integer_part = integer_part\
    \ + remainder;\n    }\n\n    integer_part + decimal_part\n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpjd4qtqyb.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpjd4qtqyb.rs:10:31\n   |\n10 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    let mut mantissa = number.mantissa();\n\n    while exponent > 0 {\n     \
    \   mantissa = mantissa * 10.0;\n        exponent = exponent - 1;\n    }\n\n \
    \   while mantissa > 0.0 {\n        remainder = mantissa - remainder;\n      \
    \  mantissa = mantissa / 10.0;\n    }\n\n    decimal_part = remainder;\n    decimal_part\
    \ + 1.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpablj5yl1.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmpablj5yl1.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    let mut last_digit = number.digits().last().unwrap();\n    while exponent\
    \ > 0 {\n        if last_digit < 10 {\n            decimal_part += last_digit\
    \ as f64;\n            last_digit = last_digit as u8;\n        } else {\n    \
    \        decimal_part += last_digit as f64 / 10.0;\n            last_digit = last_digit\
    \ as u8 % 10;\n        }\n        exponent = exponent - 1;\n    }\n    remainder\
    \ += last_digit as f64;\n    decimal_part += remainder;\n    decimal_part\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp6r71idfm.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `digits` found for type `f64` in the current scope\n --> /tmp/tmp6r71idfm.rs:9:33\n\
    \  |\n9 |     let mut last_digit = number.digits().last().unwrap();\n  |     \
    \                            ^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut max_integer_part = 0.0;\n    let mut max_leftover_part = 0.0;\n \
    \   let mut max_decimal_part = 0.0;\n    let mut min_decimal_part = 0.0;\n   \
    \ let mut min_integer_part = 0.0;\n    let mut min_leftover_part = 0.0;\n    let\
    \ mut min_max_integer_part = 0.0;\n    let mut min_max_leftover_part = 0.0;\n\
    \    let mut min_max_decimal_part = 0.0;\n    let mut min_min_decimal_part = 0.0;\n\
    \    let mut min_min_integer_part = 0.0;\n    let mut min_min_leftover_part =\
    \ 0.0;\n    let mut min_min_max_integer_part = 0.0;\n    let mut min_min_max_leftover_part\
    \ = 0.0;\n    let mut min_min_max_decimal_part = 0.0;\n    let mut min_min_min_decimal_part\
    \ = 0.0;\n    let mut min_min_min_integer_part = 0.0;\n    let mut min_min_min_leftover_part\
    \ = 0.0;\n    let mut min_min_min_max_integer_part = 0.0;\n    let mut min_min_min_max_leftover_part\
    \ = 0.0;\n    let mut min_min_min_max_decimal_part = 0.0;\n    let mut min_min_min_min_decimal_part\
    \ = 0.0;\n    let mut min_min_min_min_integer_part = 0.0;\n    let mut min_min_min_leftover_part\
    \ = 0.0;\n    let mut min_min_min_max_integer_part = 0.0;\n    let mut min_min_min_max_leftover_part\
    \ = 0.0;\n    let mut min_min_min_max_decimal_part = 0.0;\n    let mut min_min_min_min_decimal_part\
    \ = 0.0;\n    let mut min_min_min_min_integer_part = 0.0;\n    let mut min_min_min_leftover_part\
    \ = 0.0;\n    let mut min_min_min_max_integer_part = 0.0;\n    let mut min_min_min_max_leftover_part\
    \ = 0.0;\n    let mut min_min_min_max_decimal_part = 0.0;\n    let mut min_min_min_min_decimal_part\
    \ = 0.0;\n    let mut min_min_min_min_integer_part = 0.0;\n    let mut min_min_min_leftover_part\
    \ = 0.0;\n    let mut min_min_min_max_integer_part = 0.0;\n    let mut min_min_min_max_leftover_part\
    \ = 0.0;\n    let mut min_min_min_max_decimal_part = 0.0;\n    let mut min_min_min_min_decimal_part\
    \ = 0.0;\n    let mut min_min_min_min_integer_part = 0.0;\n    let mut min_min_min_lef\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp49v4ep6o.rs:50:28\n   |\n\
    50 |     let mut min_min_min_lef\n   |                            ^ help: add\
    \ `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp49v4ep6o.rs:5:36\n  |\n5 | fn truncate_number(number: f64) -> f64\
    \ {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += 1.0;\n        decimal_part +=\
    \ remainder * f64::from(number.next_exponent());\n        exponent--;\n    }\n\
    \    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmphoas5327.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmphoas5327.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `next_exponent` found for type `f64` in the current scope\n\
    \  --> /tmp/tmphoas5327.rs:11:54\n   |\n11 |         decimal_part += remainder\
    \ * f64::from(number.next_exponent());\n   |                                 \
    \                     ^^^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        let mut remainder_power\
    \ = remainder;\n        let mut remainder_exponent = exponent;\n        while\
    \ remainder_exponent > 0 {\n            let mut power = remainder_exponent - 1;\n\
    \            let mut power = power.saturating_sub(1);\n            let mut power\
    \ = power.saturating_mul(10);\n            let mut power = power.saturating_mul(power);\n\
    \            let mut power = power.saturating_mul(power);\n            remainder_exponent\
    \ -= power;\n            remainder_power = remainder_power.saturating_add(power);\n\
    \        }\n        decimals = decimals.saturating_add(remainder_power);\n   \
    \     integer = integer.saturating_add(remainder);\n        remainder = remainder.saturating_mul(10.0);\n\
    \        exponent = exponent.saturating_sub(1);\n    }\n    number.truncate()\n\
    \        .saturating_mul(10.0)\n        .saturating_mul(decimals)\n        .saturating_mul(integer)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpy7p2x5kl.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0689]:\
    \ can't call method `saturating_add` on ambiguous numeric type `{float}`\n  -->\
    \ /tmp/tmpy7p2x5kl.rs:20:47\n   |\n20 |             remainder_power = remainder_power.saturating_add(power);\n\
    \   |                                               ^^^^^^^^^^^^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `f32`\n   |\n11 |         let\
    \ mut remainder_power: f32 = remainder;\n   |             ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `saturating_add` on ambiguous numeric type `{float}`\n\
    \  --> /tmp/tmpy7p2x5kl.rs:22:29\n   |\n22 |         decimals = decimals.saturating_add(remainder_power);\n\
    \   |                             ^^^^^^^^^^^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `f32`\n   |\n6  |     let mut decimals: f32 =\
    \ 0.0;\n   |         ~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `saturating_add`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmpy7p2x5kl.rs:23:27\n   |\n\
    23 |         integer = integer.saturating_add(remainder);\n   |              \
    \             ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for this binding,\
    \ like `f32`\n   |\n7  |     let mut integer: f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~~\n\
    \nerror[E0689]: can't call method `saturating_mul` on ambiguous numeric type `{float}`\n\
    \  --> /tmp/tmpy7p2x5kl.rs:24:31\n   |\n24 |         remainder = remainder.saturating_mul(10.0);\n\
    \   |                               ^^^^^^^^^^^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `f32`\n   |\n8  |     let mut remainder: f32 =\
    \ 0.0;\n   |         ~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `truncate`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpy7p2x5kl.rs:27:12\n\
    \   |\n27 |     number.truncate()\n   |            ^^^^^^^^ help: there is an\
    \ associated function with a similar name: `trunc`\n\nerror: aborting due to 6\
    \ previous erro"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = 0;\n    let mut\
    \ last_digit = 0.0;\n    let mut last_digit_index = 0;\n    let mut last_digit_index2\
    \ = 0;\n    let mut last_digit_index3 = 0;\n    let mut last_digit_index4 = 0;\n\
    \    let mut last_digit_index5 = 0;\n    let mut last_digit_index6 = 0;\n    let\
    \ mut last_digit_index7 = 0;\n    let mut last_digit_index8 = 0;\n    let mut\
    \ last_digit_index9 = 0;\n    let mut last_digit_index10 = 0;\n    let mut last_digit_index11\
    \ = 0;\n    let mut last_digit_index12 = 0;\n    let mut last_digit_index13 =\
    \ 0;\n    let mut last_digit_index14 = 0;\n    let mut last_digit_index15 = 0;\n\
    \    let mut last_digit_index16 = 0;\n    let mut last_digit_index17 = 0;\n  \
    \  let mut last_digit_index18 = 0;\n    let mut last_digit_index19 = 0;\n    let\
    \ mut last_digit_index20 = 0;\n    let mut last_digit_index21 = 0;\n    let mut\
    \ last_digit_index22 = 0;\n    let mut last_digit_index23 = 0;\n    let mut last_digit_index24\
    \ = 0;\n    let mut last_digit_index25 = 0;\n    let mut last_digit_index26 =\
    \ 0;\n    let mut last_digit_index27 = 0;\n    let mut last_digit_index28 = 0;\n\
    \    let mut last_digit_index29 = 0;\n    let mut last_digit_index30 = 0;\n  \
    \  let mut last_digit_index31 = 0;\n    let mut last_digit_index32 = 0;\n    let\
    \ mut last_digit_index33 = 0;\n    let mut last_digit_index34 = 0;\n    let mut\
    \ last_digit_index35 = 0;\n    let mut last_digit_index36 = 0;\n    let mut last_digit_index37\
    \ = 0;\n    let mut last_digit_index38 = 0;\n    let mut last_digit_index39 =\
    \ 0;\n    let mut last_digit_index40 = 0;\n    let mut last_digit_index41 = 0;\n\
    \    let mut last_digit_index42 = 0;\n    let mut last_digit_index43 = 0;\n  \
    \  let mut last_digit_index44 = 0;\n    let mut last_digit_index45 = 0;\n    let\
    \ mut last_digit_index46 = 0;\n    let mut last_digit_index47 = 0;\n    let mut\
    \ last_digit_index48 = 0;\n    let mut last_digit_index49 = 0;\n    let mut last_digit_index50\
    \ = 0;\n    let mut last_digit_index51 = 0;\n    let mut last_digit_index52 =\
    \ 0;\n    let mut last_digit_index53 = 0;\n    let mut last_digit_index54 = 0;\n\
    \    let \n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8e6r0erl.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n\n  \
    \  // Truncate to integer part\n    if number < 0.0 {\n        integer_part =\
    \ -number;\n        number = -number;\n    }\n\n    // Truncate to decimal part\n\
    \    if number < 1.0 {\n        decimal_part = number;\n        number = 0.0;\n\
    \    }\n\n    // Truncate to remainder\n    if number < 1.0 {\n        remainder\
    \ = number;\n        number = 0.0;\n    }\n\n    // Return integer part\n    integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `decimal_part` is assigned to, but never used\n --> /tmp/tmpvnef69xn.rs:6:13\n\
    \  |\n6 |     let mut decimal_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using\
    \ `_decimal_part` instead\n\nwarning: variable `remainder` is assigned to, but\
    \ never used\n --> /tmp/tmpvnef69xn.rs:8:13\n  |\n8 |     let mut remainder =\
    \ 0.0;\n  |             ^^^^^^^^^\n  |\n  = note: consider using `_remainder`\
    \ instead\n\nwarning: value assigned to `decimal_part` is never read\n  --> /tmp/tmpvnef69xn.rs:18:9\n\
    \   |\n18 |         decimal_part = number;\n   |         ^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `remainder` is\
    \ never read\n  --> /tmp/tmpvnef69xn.rs:24:9\n   |\n24 |         remainder = number;\n\
    \   |         ^^^^^^^^^\n   |\n   = help: maybe it is overwritten before being\
    \ read?\n\nwarning: value assigned to `number` is never read\n  --> /tmp/tmpvnef69xn.rs:25:9\n\
    \   |\n25 |         number = 0.0;\n   |         ^^^^^^\n   |\n   = help: maybe\
    \ it is overwritten before being read?\n\nerror[E0384]: cannot assign to immutable\
    \ argument `number`\n  --> /tmp/tmpvnef69xn.rs:13:9\n   |\n5  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n13 |         number = -number;\n   |         ^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror[E0384]: cannot assign to immutable\
    \ argument `number`\n  --> /tmp/tmpvnef69xn.rs:19:9\n   |\n5  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n19 |         number = 0.0;\n   |         ^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror[E0384]: cannot assign to immutable\
    \ argument `number`\n  --> /tmp/tmpvnef69xn.rs:25:9\n   |\n5  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n25 |         number "
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        integer_part += 1.0;\n        leftover_part += 1.0;\n    }\n\
    \    integer_part += leftover_part;\n    decimal_part = remainder - integer_part;\n\
    \    integer_part += 1.0;\n    decimal_part += integer_part;\n    decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpr_fwortj.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n\n  \
    \  while number > 0.0 {\n        let remainder = number % 10.0;\n        integer_part\
    \ += remainder;\n        decimal_part += remainder;\n        number /= 10.0;\n\
    \    }\n\n    integer_part + decimal_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `remainder`\n --> /tmp/tmpwm1fb1ak.rs:8:13\n\
    \  |\n8 |     let mut remainder = 0.0;\n  |             ^^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_remainder`\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/tmpwm1fb1ak.rs:8:9\n\
    \  |\n8 |     let mut remainder = 0.0;\n  |         ----^^^^^^^^^\n  |       \
    \  |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `number`\n\
    \  --> /tmp/tmpwm1fb1ak.rs:14:9\n   |\n5  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n14 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 2 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut truncated = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n   \
    \ while exponent > 0 {\n        if exponent % 2 == 1 {\n            truncated\
    \ = truncated.checked_add(number.checked_mul(1.0 / 2.0).unwrap());\n        }\
    \ else {\n            truncated = truncated.checked_add(number.checked_mul(2.0).unwrap());\n\
    \        }\n        remainder = remainder.checked_add(number.checked_mul(2.0).unwrap());\n\
    \        exponent = exponent >> 1;\n    }\n    truncated.checked_add(remainder).unwrap()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmpz8eqwjcb.rs:8:41\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n8 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0 {\n  |                             \
    \            ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpz8eqwjcb.rs:9:5\n\
    \   |\n9  | /     while exponent > 0 {\n10 | |         if exponent % 2 == 1 {\n\
    11 | |             truncated = truncated.checked_add(number.checked_mul(1.0 /\
    \ 2.0).unwrap());\n12 | |         } else {\n...  |\n16 | |         exponent =\
    \ exponent >> 1;\n17 | |     }\n   | |_____^\n   |\nhelp: expressions must be\
    \ enclosed in braces to be used as const generic arguments\n   |\n9  ~     { while\
    \ exponent > 0 {\n10 |         if exponent % 2 == 1 {\n11 |             truncated\
    \ = truncated.checked_add(number.checked_mul(1.0 / 2.0).unwrap());\n12 |     \
    \    } else {\n13 |             truncated = truncated.checked_add(number.checked_mul(2.0).unwrap());\n\
    14 |         }\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or\
    \ an operator, found `::`\n --> /tmp/tmpz8eqwjcb.rs:8:34\n  |\n8 |     let mut\
    \ exponent = number.f64::exp();\n  |                                  ^^ expected\
    \ one of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to\
    \ 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut exponent = number.exponent();\n    if exponent < 0 {\n        integer_part\
    \ = number;\n        leftover_part = 0.0;\n    } else {\n        integer_part\
    \ = number.trunc();\n        leftover_part = number.fract();\n    }\n    loop\
    \ {\n        if exponent < 0 {\n            decimal_part += leftover_part * 10.0;\n\
    \            exponent += 1;\n            leftover_part = 0.0;\n        } else\
    \ {\n            leftover_part *= 10.0;\n            exponent -= 1;\n        }\n\
    \        if exponent == 0 {\n            break;\n        }\n    }\n    integer_part\
    \ + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpaj17fj7o.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    number\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3ixhhalm.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3ixhhalm.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3ixhhalm.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 0.0 {\n        let mut\
    \ remainder_part = remainder % 10.0;\n        remainder /= 10.0;\n        integer_part\
    \ += remainder_part as f64;\n        leftover_part += remainder_part as f64;\n\
    \        decimal_part += remainder_part as f64;\n    }\n    integer_part += leftover_part\
    \ as f64;\n    decimal_part += integer_part as f64;\n    decimal_part\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11.666666666666666`,\n right: `0.5`', /tmp/tmp6422bxls.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut truncated = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n   \
    \ while exponent > 0.0 {\n        let mut digit = number.f64::fract();\n     \
    \   truncated = truncated.saturating_add(digit);\n        remainder = remainder.saturating_add(digit.powf(exponent));\n\
    \        exponent = exponent.saturating_sub(1);\n    }\n    truncated.round()\
    \ as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmpnzeh7hdh.rs:8:41\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n8 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n  |                           \
    \              ~\n\nerror: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`,\
    \ or `>`, found `;`\n  --> /tmp/tmpnzeh7hdh.rs:10:44\n   |\n10 |         let mut\
    \ digit = number.f64::fract();\n   |                                         \
    \   ^ expected one of 8 possible tokens\n   |\nhelp: use a comma to separate type\
    \ parameters\n   |\n10 |         let mut digit = number.f64::fract(), truncated\
    \ = truncated.saturating_add(digit);\n   |                                   \
    \         ~\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or an operator,\
    \ found `::`\n  --> /tmp/tmpnzeh7hdh.rs:10:35\n   |\n10 |         let mut digit\
    \ = number.f64::fract();\n   |                                   ^^ expected one\
    \ of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: invalid const generic\
    \ expression\n  --> /tmp/tmpnzeh7hdh.rs:9:5\n   |\n9  | /     while exponent >\
    \ 0.0 {\n10 | |         let mut digit = number.f64::fract();\n11 | |         truncated\
    \ = truncated.saturating_add(digit);\n12 | |         remainder = remainder.saturating_add(digit.powf(exponent));\n\
    13 | |         exponent = exponent.saturating_sub(1);\n14 | |     }\n   | |_____^\n\
    \   |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n   |\n9  ~     { while exponent > 0.0 {\n10 |         let mut digit\
    \ = number.f64::fract();\n11 |         truncated = truncated.saturating_add(digit);\n\
    12 |         remainder = remainder.saturating_add(digit.powf(exponent));\n13 |\
    \         exponent = exponent.saturating_sub(1);\n14 ~     } }\n   |\n\nerror:\
    \ expected one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n -->\
    \ /tmp/tmpnzeh7hdh.rs:8:34\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |      "
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpk7pwenbo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut mantissa = number.fract();\n    while exponent != 0 {\n\
    \        mantissa *= 10.0;\n        exponent--;\n    }\n    mantissa += remainder;\n\
    \    mantissa = mantissa.round() as f64;\n    decimal_part = mantissa;\n    remainder\
    \ = mantissa - decimal_part;\n    decimal_part += remainder;\n    decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp71dpc9jr.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        remainder *= 10.0;\n  \
    \      exponent -= 1;\n    }\n    integer_part += remainder;\n    decimal_part\
    \ = number.fract();\n    integer_part += decimal_part;\n    integer_part /= 10.0;\n\
    \    integer_part += 1.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpm8m4zmsd.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm8m4zmsd.rs:20:5\n   |\n5  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                                    --- expected `f64` because\
    \ of return type\n...\n20 |     integer_part += 1.0\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `()`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 0.0 {\n        let mut\
    \ digit = remainder % 10.0;\n        remainder = remainder / 10.0;\n        integer_part\
    \ += digit;\n        decimal_part += digit * 10.0;\n        leftover_part += digit;\n\
    \    }\n    integer_part += leftover_part;\n    decimal_part + integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `46.66666666666666`,\n right: `0.5`', /tmp/tmp_ds_30py.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = number;\n    while remainder\
    \ > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n    }\n    while\
    \ remainder > 0.0 {\n        remainder -= 1.0;\n        integer += 1.0;\n    }\n\
    \    integer + decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp6by9fvjl.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    while\
    \ number > 0.0 {\n        remainder = number % 10.0;\n        integer_part +=\
    \ remainder * 10.0;\n        decimal_part += remainder;\n        number /= 10.0;\n\
    \    }\n    integer_part += decimal_part;\n    integer_part\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: value assigned to `remainder` is never read\n --> /tmp/tmpk9te4huh.rs:8:13\n\
    \  |\n8 |     let mut remainder = 0.0;\n  |             ^^^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_assignments)]` on by default\n  = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `number`\n\
    \  --> /tmp/tmpk9te4huh.rs:13:9\n   |\n5  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n13 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut exponent = number.f64::exp();\n    if exponent < 0 {\n        exponent\
    \ = -exponent;\n        decimals = -number.f64::fract();\n    }\n    let mut result\
    \ = number.f64::trunc();\n    if exponent > 0 {\n        result = result / f64::pow(10.0,\
    \ exponent);\n    }\n    result + decimals\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmpwse978fx.rs:7:41\n  |\n7 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n7 |     let mut exponent\
    \ = number.f64::exp(), if exponent < 0 {\n  |                                \
    \         ~\n\nerror: expected one of `(`, `.`, `;`, `?`, `}`, or an operator,\
    \ found `::`\n  --> /tmp/tmpwse978fx.rs:10:31\n   |\n10 |         decimals = -number.f64::fract();\n\
    \   |                               ^^ expected one of `(`, `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: invalid const generic expression\n  --> /tmp/tmpwse978fx.rs:8:5\n\
    \   |\n8  | /     if exponent < 0 {\n9  | |         exponent = -exponent;\n10\
    \ | |         decimals = -number.f64::fract();\n11 | |     }\n   | |_____^\n \
    \  |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n   |\n8  ~     { if exponent < 0 {\n9  |         exponent = -exponent;\n\
    10 |         decimals = -number.f64::fract();\n11 ~     } }\n   |\n\nerror: expected\
    \ one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n --> /tmp/tmpwse978fx.rs:7:34\n\
    \  |\n7 |     let mut exponent = number.f64::exp();\n  |                     \
    \             ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\n\
    error: aborting due to 4 previous errors\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    let mut mantissa = number.mantissa();\n    while exponent\
    \ > 0 {\n        remainder += mantissa;\n        mantissa *= 10.0;\n        integer\
    \ += mantissa;\n        mantissa /= 10.0;\n        exponent--;\n    }\n    exponent\
    \ += 1;\n    decimals += remainder;\n    decimals /= 10.0;\n    integer\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp6qtv9jtb.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp6qtv9jtb.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp6qtv9jtb.rs:10:31\n   |\n10 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals: f64\
    \ = 0.0;\n    let mut remainder: f64 = 0.0;\n    let mut remainder_sign: f64 =\
    \ 1.0;\n    let mut exponent: f64 = 0.0;\n    let mut exponent_sign: f64 = 1.0;\n\
    \    let mut mantissa: f64 = 0.0;\n    let mut mantissa_sign: f64 = 1.0;\n   \
    \ let mut max_mantissa: f64 = 0.0;\n    let mut min_mantissa: f64 = 1.0;\n   \
    \ let mut min_exponent: f64 = 0.0;\n    let mut min_exponent_sign: f64 = 1.0;\n\
    \    let mut max_exponent: f64 = 0.0;\n    let mut max_exponent_sign: f64 = 1.0;\n\
    \    let mut min_decimals: f64 = 0.0;\n    let mut max_decimals: f64 = 1.0;\n\
    \    let mut min_decimals_sign: f64 = 1.0;\n    let mut max_decimals_sign: f64\
    \ = 0.0;\n    let mut min_exponent: f64 = 0.0;\n    let mut min_exponent_sign:\
    \ f64 = 1.0;\n    let mut max_exponent: f64 = 0.0;\n    let mut max_exponent_sign:\
    \ f64 = 1.0;\n    let mut min_mantissa: f64 = 0.0;\n    let mut min_mantissa_sign:\
    \ f64 = 1.0;\n    let mut max_mantissa: f64 = 0.0;\n    let mut max_mantissa_sign:\
    \ f64 = 1.0;\n    let mut min_decimals: f64 = 0.0;\n    let mut min_decimals_sign:\
    \ f64 = 1.0;\n    let mut max_decimals: f64 = 1.0;\n    let mut max_decimals_sign:\
    \ f64 = 0.0;\n    let mut min_exponent: f64 = 0.0;\n    let mut min_exponent_sign:\
    \ f64 = 1.0;\n    let mut max_exponent: f64 = 0.0;\n    let mut max_exponent_sign:\
    \ f64 = 1.0;\n    let mut min_mantissa: f64 = 0.0;\n    let mut min_mantissa_sign:\
    \ f64 = 1.0;\n    let mut max_mantissa: f64 = 0.0;\n    let mut max_mantissa_sign:\
    \ f64 = 1.0;\n    let mut min_decimals: f64 = 0.0;\n    let mut min_decimals_sign:\
    \ f64 = 1.0;\n    let mut max_decimals: f64 = 1.\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaevyi0jl.rs:45:35\n   |\n\
    45 |     let mut max_decimals: f64 = 1.\n   |                                \
    \   ^ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpaevyi0jl.rs:5:36\n  |\n5 | fn truncate_number(number: f64)\
    \ -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpk7pwenbo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    decimal_part +\
    \ remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpm06n6hln.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpm06n6hln.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpm06n6hln.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals: f64\
    \ = number;\n    let mut remainder: f64 = number;\n    while remainder > f64::from(0.1)\
    \ {\n        remainder -= f64::from(0.1);\n        decimals += f64::from(0.1);\n\
    \    }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6.89999999999999`,\n right: `0.5`', /tmp/tmpfyrnf4bk.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        decimal_part += remainder\
    \ * number.next_exponent();\n        exponent--;\n    }\n    integer_part + decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpinf9mb17.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpinf9mb17.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `next_exponent` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpinf9mb17.rs:13:44\n   |\n13 |         decimal_part += remainder\
    \ * number.next_exponent();\n   |                                            ^^^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.fract() * std::pow::<f64>(10.0,\
    \ exponent);\n        result -= remainder;\n        exponent--;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpp5kz2qhk.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find function `pow` in crate `std`\n  --> /tmp/tmpp5kz2qhk.rs:10:44\n\
    \   |\n10 |         remainder += number.fract() * std::pow::<f64>(10.0, exponent);\n\
    \   |                                            ^^^ not found in `std`\n\nerror[E0599]:\
    \ no method named `exponent` found for type `f64` in the current scope\n --> /tmp/tmpp5kz2qhk.rs:8:31\n\
    \  |\n8 |     let mut exponent = number.exponent();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n   \
    \ let mut last_digit = number.f64::fract();\n    while exponent > 0 {\n      \
    \  if exponent % 2 == 1 {\n            result *= 10.0;\n        }\n        result\
    \ += (last_digit as f64) / 10.0;\n        remainder *= 10.0;\n        last_digit\
    \ /= 10.0;\n        exponent = exponent / 2;\n    }\n    result + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmpd5dmy1mu.rs:8:41\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n8 |     let mut exponent\
    \ = number.f64::exp(), let mut last_digit = number.f64::fract();\n  |        \
    \                                 ~\n\nerror: expected one of `!`, `+`, `,`, `->`,\
    \ `::`, `:`, `=`, or `>`, found `;`\n --> /tmp/tmpd5dmy1mu.rs:9:45\n  |\n9 | \
    \    let mut last_digit = number.f64::fract();\n  |                          \
    \                   ^ expected one of 8 possible tokens\n  |\nhelp: use a comma\
    \ to separate type parameters\n  |\n9 |     let mut last_digit = number.f64::fract(),\
    \ while exponent > 0 {\n  |                                             ~\n\n\
    error: invalid const generic expression\n  --> /tmp/tmpd5dmy1mu.rs:10:5\n   |\n\
    10 | /     while exponent > 0 {\n11 | |         if exponent % 2 == 1 {\n12 | |\
    \             result *= 10.0;\n13 | |         }\n...  |\n17 | |         exponent\
    \ = exponent / 2;\n18 | |     }\n   | |_____^\n   |\nhelp: expressions must be\
    \ enclosed in braces to be used as const generic arguments\n   |\n10 ~     { while\
    \ exponent > 0 {\n11 |         if exponent % 2 == 1 {\n12 |             result\
    \ *= 10.0;\n13 |         }\n14 |         result += (last_digit as f64) / 10.0;\n\
    15 |         remainder *= 10.0;\n ...\n\nerror: invalid const generic expression\n\
    \ --> /tmp/tmpd5dmy1mu.rs:9:5\n  |\n9 |     let mut last_digit = number.f64::fract();\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: expressions must be enclosed\
    \ in braces to be used as const generic arguments\n  |\n9 |     { let mut last_digit\
    \ = number.f64 }::fract();\n  |     +                                 +\n\nerror:\
    \ expected one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n -->\
    \ /tmp/tmpd5dmy1mu.rs:8:34\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                  ^^ expected one of `(`, `.`, `;`, `?`, `else`,\
    \ or an operator\n\nerror[E0658]: `let`"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        remainder += 1.0;\n\
    \        integer += remainder;\n        remainder /= 10.0;\n        exponent--;\n\
    \    }\n    number - integer * remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpp4og2yji.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpp4og2yji.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = 0.0;\n\n    // We will always have one decimal digit.\n    let\
    \ mut decimal_digits = 1;\n\n    // We will always have one integer digit.\n \
    \   let mut integer_digits = 1;\n\n    // We will always have one exponent digit.\n\
    \    let mut exponent_digits = 1;\n\n    // We will always have one integer digit\
    \ and one decimal digit.\n    while number >= 10.0 {\n        number /= 10.0;\n\
    \        integer_digits += 1;\n        decimal_digits += 1;\n    }\n\n    // We\
    \ will always have one integer digit and one decimal digit.\n    while number\
    \ >= 1.0 {\n        number /= 10.0;\n        integer_digits += 1;\n        decimal_digits\
    \ += 1;\n    }\n\n    // We will always have one exponent digit.\n    while number\
    \ >= 10.0 {\n        number /= 10.0;\n        exponent_digits += 1;\n    }\n\n\
    \    // We will always have one exponent digit.\n    while number >= 1.0 {\n \
    \       number /= 10.0;\n        exponent_digits += 1;\n    }\n\n    // We will\
    \ always have one decimal digit.\n    while number >= 1.0 {\n        number /=\
    \ 10.0;\n        decimal_digits += 1;\n    }\n\n    // We will always have one\
    \ integer digit.\n    while number >= 1.0 {\n        number /= 10.0;\n       \
    \ integer_digits += 1;\n    }\n\n    // We will always have one decimal digit.\n\
    \    while number >= 1.0 {\n        number /= 10.0;\n        decimal_digits +=\
    \ 1;\n    }\n\n    // We will always have one exponent digit.\n    while number\
    \ >= 1.0 {\n        number /= 10.0;\n        exponent_digits += 1;\n    }\n\n\
    \    // We will always have one exponent digit.\n    while number >= 1.0 {\n \
    \       number /= 10.0;\n        exponent_digits += 1;\n    }\n\n    // We will\
    \ always have one decimal digit.\n    while number >= 1.0 {\n        number /=\
    \ 10.0;\n        decimal_digits += 1;\n    }\n\n    // We will always have one\
    \ integer digit.\n    while number >= 1.0 {\n        number /= 10.0;\n       \
    \ integer_digits += 1;\n    }\n\n    // We will always have one decimal digit.\n\
    \    while number >= 1.0 {\n        number /= 10.0;\n        decimal_digits +=\
    \ 1;\n    }\n\n    // We will always have one exponent digit.\n    while number\
    \ >= 1.0 {\n        number /= 10.0;\n        exponent_digits += 1;\n    }\n\n\
    \    // We will always have one exponent digit.\n    while \n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpgopd2nmw.rs:102:1\n\
    \    |\n101 |     while \n    |     ----- while parsing the condition of this\
    \ `while` expression\n102 | }\n    | ^ expected expression\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n   \
    \ while exponent > 0.0 {\n        let mut next_remainder = 0.0;\n        if exponent\
    \ % 2 == 1 {\n            next_remainder = remainder;\n        }\n        remainder\
    \ = remainder * 10.0 + (number % 10.0);\n        number = number / 10.0;\n   \
    \     exponent = exponent / 2.0;\n        result = result + next_remainder;\n\
    \    }\n    if number > 0.0 {\n        result = result + remainder;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmpqv9ja_e3.rs:8:41\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n8 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n  |                           \
    \              ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpqv9ja_e3.rs:9:5\n\
    \   |\n9  | /     while exponent > 0.0 {\n10 | |         let mut next_remainder\
    \ = 0.0;\n11 | |         if exponent % 2 == 1 {\n12 | |             next_remainder\
    \ = remainder;\n...  |\n17 | |         result = result + next_remainder;\n18 |\
    \ |     }\n   | |_____^\n   |\nhelp: expressions must be enclosed in braces to\
    \ be used as const generic arguments\n   |\n9  ~     { while exponent > 0.0 {\n\
    10 |         let mut next_remainder = 0.0;\n11 |         if exponent % 2 == 1\
    \ {\n12 |             next_remainder = remainder;\n13 |         }\n14 |      \
    \   remainder = remainder * 10.0 + (number % 10.0);\n ...\n\nerror: expected one\
    \ of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n --> /tmp/tmpqv9ja_e3.rs:8:34\n\
    \  |\n8 |     let mut exponent = number.f64::exp();\n  |                     \
    \             ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\n\
    error: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    let mut fraction = number.fraction();\n\
    \    while exponent > 0 {\n        integer_part += remainder;\n        remainder\
    \ *= 10.0;\n        exponent -= 1;\n    }\n    integer_part += remainder;\n  \
    \  decimal_part = fraction;\n    decimal_part *= 10.0;\n    integer_part += decimal_part;\n\
    \    integer_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp1atvlu1s.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `fraction` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp1atvlu1s.rs:10:31\n   |\n10 |     let mut fraction = number.fraction();\n\
    \   |                               ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `fract`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal = f64::MIN;\n\
    \    let mut remainder = f64::MIN;\n    let mut exponent = 0;\n    let mut mantissa\
    \ = number;\n    while mantissa > f64::MAX {\n        mantissa /= 10.0;\n    \
    \    exponent++;\n    }\n    while mantissa < f64::MIN {\n        mantissa *=\
    \ 10.0;\n        exponent--;\n    }\n    while exponent > 0 {\n        remainder\
    \ *= 10.0;\n        exponent--;\n    }\n    decimal += mantissa;\n    decimal\
    \ -= remainder;\n    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpr_bg_w8k.rs:12:17\n\
    \   |\n12 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n12 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n12 -\
    \         exponent++;\n12 +         exponent += 1;\n   | \n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmpr_bg_w8k.rs:16:19\n   |\n16 |         exponent--;\n\
    \   |                   ^ expected expression\n\nerror: expected expression, found\
    \ `;`\n  --> /tmp/tmpr_bg_w8k.rs:20:19\n   |\n20 |         exponent--;\n   | \
    \                  ^ expected expression\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.f64();\n    while exponent > 0.0 {\n        if exponent % 2 == 0 {\n\
    \            integer += remainder;\n        }\n        remainder *= 10.0;\n  \
    \      decimal += remainder;\n        exponent /= 2.0;\n    }\n    integer +=\
    \ decimal;\n    integer\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `decimal` in this scope\n  --> /tmp/tmpqt6lmh7i.rs:15:9\n\
    \   |\n15 |         decimal += remainder;\n   |         ^^^^^^^ help: a local\
    \ variable with a similar name exists: `decimals`\n\nerror[E0425]: cannot find\
    \ value `decimal` in this scope\n  --> /tmp/tmpqt6lmh7i.rs:18:16\n   |\n18 | \
    \    integer += decimal;\n   |                ^^^^^^^ help: a local variable with\
    \ a similar name exists: `decimals`\n\nerror[E0599]: no method named `f64` found\
    \ for type `f64` in the current scope\n --> /tmp/tmpqt6lmh7i.rs:9:31\n  |\n9 |\
    \     let mut exponent = number.f64();\n  |                               ^^^\
    \ method not found in `f64`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut exponent = number.floor();\n    while exponent != 0.0 {\n       \
    \ decimals += 1.0 * exponent / 10.0;\n        exponent = exponent % 10.0;\n  \
    \  }\n    number\n        - (decimals * std::f64::powf(10.0, decimals))\n    \
    \    .round()\n        .into()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `powf` in module `std::f64`\n  --> /tmp/tmpz1av307y.rs:13:33\n\
    \   |\n13 |         - (decimals * std::f64::powf(10.0, decimals))\n   |      \
    \                           ^^^^ not found in `std::f64`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    decimal_part +\
    \ remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmptufvzzh0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.fract() * (10.0 as f64);\n\
    \        decimal_part += remainder;\n        number -= remainder;\n        exponent--;\n\
    \    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpyj2mvriw.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpyj2mvriw.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        remainder /= 10.0;\n  \
    \      exponent -= 1;\n    }\n    integer_part += remainder;\n    decimal_part\
    \ = number.fract();\n    integer_part += decimal_part;\n    integer_part /= 10.0;\n\
    \    integer_part += remainder;\n    integer_part *= 10.0;\n    integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp9ct_nzkg.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut last_digit = number.floor();\n    loop {\n        integer_part +=\
    \ last_digit as f64;\n        leftover_part += last_digit as f64;\n        if\
    \ leftover_part < 1.0 {\n            break;\n        }\n        last_digit = number\
    \ - integer_part as f64;\n        decimal_part += last_digit as f64;\n    }\n\
    \    integer_part + decimal_part as f64\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976556
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        remainder /= 10.0;\n  \
    \      decimal_part += remainder;\n        remainder *= 10.0;\n        exponent\
    \ -= 1;\n    }\n    integer_part + decimal_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp4q8i56so.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.fract() * (f64::powf(10.0,\
    \ exponent) - 1.0);\n        decimal_part += remainder;\n        exponent--;\n\
    \    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp2dmnv1tj.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp2dmnv1tj.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n --> /tmp/tmp2dmnv1tj.rs:9:20\n  |\n9\
    \ |     while exponent > 0 {\n  |                    ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n  |\n  = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\nhelp: consider using a floating-point literal\
    \ by writing it with `.0`\n  |\n9 |     while exponent > 0.0 {\n  |          \
    \             ++\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0 * number.remainder(&mut integer_part);\n        decimal_part += 1.0 *\
    \ integer_part;\n        integer_part -= 1.0 * remainder;\n        exponent -=\
    \ 1;\n    }\n    decimal_part + integer_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpdfq0lmu1.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpdfq0lmu1.rs:11:35\n   |\n11 |         remainder += 1.0 * number.remainder(&mut\
    \ integer_part);\n   |                                   ^^^^^^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ let mut mantissa = number.mantissa();\n    while exponent > 0 {\n        if\
    \ exponent % 2 == 1 {\n            result += mantissa;\n        }\n        mantissa\
    \ *= 10.0;\n        exponent = exponent / 2;\n    }\n    result += mantissa;\n\
    \    result * 10.0 ** (-exponent)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpefaa97nb.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmpefaa97nb.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ let mut mantissa = number.mantissa();\n    while exponent > 0 {\n        if\
    \ exponent % 2 == 1 {\n            result *= 10.0;\n        }\n        result\
    \ += (mantissa * 10.0);\n        remainder *= 10.0;\n        mantissa = mantissa.next_mantissa();\n\
    \        exponent = exponent >> 1;\n    }\n    result + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpamp82m4t.rs:14:19\n\
    \   |\n14 |         result += (mantissa * 10.0);\n   |                   ^   \
    \            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n14 -         result += (mantissa * 10.0);\n\
    14 +         result += mantissa * 10.0;\n   | \n\nerror[E0599]: no method named\
    \ `exponent` found for type `f64` in the current scope\n --> /tmp/tmpamp82m4t.rs:8:31\n\
    \  |\n8 |     let mut exponent = number.exponent();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `mantissa` found for type `f64` in the current scope\n --> /tmp/tmpamp82m4t.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        remainder /= 10.0;\n  \
    \      decimal_part += remainder;\n        exponent--;\n    }\n    integer_part\
    \ + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmptsxydjeg.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmptsxydjeg.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        if exponent % 2 == 1 {\n            result +=\
    \ (number / 2.0).trunc();\n        }\n        number /= 2.0;\n        exponent\
    \ = exponent / 2;\n    }\n    result + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp7n9vjzfc.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut remainder_sign\
    \ = 1.0;\n    let mut exponent = number.exponent();\n    while exponent > 0 {\n\
    \        remainder += remainder_sign * remainder;\n        remainder_sign *= -1.0;\n\
    \        integer += remainder;\n        remainder *= 10.0;\n        decimal +=\
    \ remainder;\n        remainder *= 10.0;\n        exponent--;\n    }\n    number\n\
    \        / decimal\n        / integer\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpoqotj41j.rs:18:19\n\
    \   |\n18 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find value `decimal` in this scope\n  --> /tmp/tmpoqotj41j.rs:16:9\n\
    \   |\n16 |         decimal += remainder;\n   |         ^^^^^^^ help: a local\
    \ variable with a similar name exists: `decimals`\n\nerror[E0425]: cannot find\
    \ value `decimal` in this scope\n  --> /tmp/tmpoqotj41j.rs:21:11\n   |\n21 | \
    \        / decimal\n   |           ^^^^^^^ help: a local variable with a similar\
    \ name exists: `decimals`\n\nerror[E0599]: no method named `exponent` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpoqotj41j.rs:10:31\n   |\n10 |\
    \     let mut exponent = number.exponent();\n   |                            \
    \   ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut integer_part);\n        decimal_part += integer_part\
    \ * std::powf(10.0, exponent);\n        integer_part *= 10.0;\n        exponent--;\n\
    \    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpakotvytu.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find function `powf` in crate `std`\n  --> /tmp/tmpakotvytu.rs:12:45\n\
    \   |\n12 |         decimal_part += integer_part * std::powf(10.0, exponent);\n\
    \   |                                             ^^^^ not found in `std`\n\n\
    error[E0599]: no method named `exponent` found for type `f64` in the current scope\n\
    \ --> /tmp/tmpakotvytu.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpakotvytu.rs:11:29\n   |\n11 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        integer += number.mantissa()\
    \ * (10 ** (exponent - 1));\n        decimals += number.mantissa() * (10 ** (exponent\
    \ - 1));\n        remainder += number.mantissa() * (10 ** (exponent - 1));\n \
    \       exponent--;\n    }\n    decimals\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp9eqin7l6.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp9eqin7l6.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp9eqin7l6.rs:11:27\n   |\n11 |         integer += number.mantissa() *\
    \ (10 ** (exponent - 1));\n   |                           ^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `mantissa` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp9eqin7l6.rs:12:28\n   |\n12 |         decimals\
    \ += number.mantissa() * (10 ** (exponent - 1));\n   |                       \
    \     ^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `mantissa`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp9eqin7l6.rs:13:29\n\
    \   |\n13 |         remainder += number.mantissa() * (10 ** (exponent - 1));\n\
    \   |                             ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut exponent = number.is_negative() ? -number.abs().floor() as i32 :\
    \ number.abs().floor() as i32;\n    let mut remainder = number.abs().floor() as\
    \ f64;\n    while exponent > 0 {\n        decimals += remainder;\n        remainder\
    \ *= 10.0;\n        exponent--;\n    }\n    decimals\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n --> /tmp/tmp5hulxyol.rs:7:48\n\
    \  |\n7 |     let mut exponent = number.is_negative() ? -number.abs().floor()\
    \ as i32 : number.abs().floor() as i32;\n  |                                 \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^---------\n  |                    \
    \                                                       |\n  |               \
    \                                                            help: remove the\
    \ type ascription\n\nerror: expected expression, found `;`\n  --> /tmp/tmp5hulxyol.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0573]: expected type, found local variable `number`\n --> /tmp/tmp5hulxyol.rs:7:78\n\
    \  |\n7 |     let mut exponent = number.is_negative() ? -number.abs().floor()\
    \ as i32 : number.abs().floor() as i32;\n  |                                 \
    \                                             ^^^^^^ expecting a type here because\
    \ of type ascription\n\nwarning: use of deprecated associated function `core::f64::<impl\
    \ f64>::is_negative`: renamed to is_sign_negative\n --> /tmp/tmp5hulxyol.rs:7:31\n\
    \  |\n7 |     let mut exponent = number.is_negative() ? -number.abs().floor()\
    \ as i32 : number.abs().floor() as i32;\n  |                               ^^^^^^^^^^^\n\
    \  |\n  = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: the `?` operator\
    \ can only be applied to values that implement `Try`\n --> /tmp/tmp5hulxyol.rs:7:24\n\
    \  |\n7 |     let mut exponent = number.is_negative() ? -number.abs().floor()\
    \ as i32 : number.abs().floor() as i32;\n  |                        ^^^^^^^^^^^^^^^^^^^^^^\
    \ the `?` operator cannot be applied to type `bool`\n  |\n  = help: the trait\
    \ `Try` is not implemented for `bool`\n\nerror[E0277]: the `?` operator can only\
    \ be used in a function that returns `Result` or `Option` (or another type that\
    \ implements `FromResidual`)\n  --> /tmp/tmp5hulxyol.rs:7:45\n   |\n5  | / fn\
    \ truncate_number(number: f64) -> f64 {\n6  | |     let mut decimals = 0.0;\n\
    7  | |     let mut exponent = number.is_negative() ? -number.abs().floor() as\
    \ i32 :"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.fract() * (f64::powf(10.0,\
    \ exponent) - f64::powf(10.0, exponent - 1));\n        decimal_part += remainder;\n\
    \        remainder = 0.0;\n        exponent--;\n    }\n    decimal_part + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpn7lrql9x.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpn7lrql9x.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n --> /tmp/tmpn7lrql9x.rs:9:20\n  |\n9\
    \ |     while exponent > 0 {\n  |                    ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n  |\n  = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\nhelp: consider using a floating-point literal\
    \ by writing it with `.0`\n  |\n9 |     while exponent > 0.0 {\n  |          \
    \             ++\n\nerror[E0277]: cannot subtract `{integer}` from `f64`\n  -->\
    \ /tmp/tmpn7lrql9x.rs:10:93\n   |\n10 |         remainder += number.fract() *\
    \ (f64::powf(10.0, exponent) - f64::powf(10.0, exponent - 1));\n   |         \
    \                                                                            \
    \        ^ no implementation for `f64 - {integer}`\n   |\n   = help: the trait\
    \ `Sub<{integer}>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n    \
    \         <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n      \
    \       <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n          \
    \   <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a\
    \ isize as Sub<isize>>\n           and 48 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n10 |         remainder += number.fract()\
    \ * (f64::powf(10.0, exponent) - f64::powf(10.0, exponent - 1.0));\n   |     \
    \                                                               "
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.is_negative() ? -number.signum()\
    \ : number.signum();\n    let mut mantissa = number.to_f64();\n    while mantissa\
    \ > 1.0 {\n        remainder += 1.0;\n        mantissa /= 10.0;\n    }\n    while\
    \ mantissa < 1.0 {\n        result += mantissa;\n        mantissa *= 10.0;\n \
    \   }\n    result + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n --> /tmp/tmpefboyob3.rs:8:48\n\
    \  |\n8 |     let mut exponent = number.is_negative() ? -number.signum() : number.signum();\n\
    \  |                                                ^^^^^^^^^^^^^^^---------\n\
    \  |                                                               |\n  |    \
    \                                                           help: remove the type\
    \ ascription\n\nerror[E0573]: expected type, found local variable `number`\n -->\
    \ /tmp/tmpefboyob3.rs:8:66\n  |\n8 |     let mut exponent = number.is_negative()\
    \ ? -number.signum() : number.signum();\n  |                                 \
    \                                 ^^^^^^ expecting a type here because of type\
    \ ascription\n\nwarning: use of deprecated associated function `core::f64::<impl\
    \ f64>::is_negative`: renamed to is_sign_negative\n --> /tmp/tmpefboyob3.rs:8:31\n\
    \  |\n8 |     let mut exponent = number.is_negative() ? -number.signum() : number.signum();\n\
    \  |                               ^^^^^^^^^^^\n  |\n  = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0277]: the `?` operator can only be applied to values\
    \ that implement `Try`\n --> /tmp/tmpefboyob3.rs:8:24\n  |\n8 |     let mut exponent\
    \ = number.is_negative() ? -number.signum() : number.signum();\n  |          \
    \              ^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type\
    \ `bool`\n  |\n  = help: the trait `Try` is not implemented for `bool`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpefboyob3.rs:8:45\n\
    \   |\n5  | / fn truncate_number(number: f64) -> f64 {\n6  | |     let mut result\
    \ = 0.0;\n7  | |     let mut remainder = 0.0;\n8  | |     let mut exponent = number.is_negative()\
    \ ? -number.signum() : number.signum();\n   | |                              \
    \               ^ cannot use the `?` operator in a function that returns `f64`\n\
    ...  |\n18 | |     result + remainder\n19 | | }\n   | |_- this function should\
    \ return `Result` or `Option` to accept `?`\n   |\n   = help: th"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ let mut mantissa = number.mantissa();\n    while exponent > 0 {\n        if\
    \ exponent % 2 == 1 {\n            result *= 10.0;\n        }\n        result\
    \ += (mantissa * 10.0).trunc();\n        remainder *= 10.0;\n        mantissa\
    \ *= 10.0;\n        exponent = exponent / 2;\n    }\n    result + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpx6e13h7n.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmpx6e13h7n.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    loop {\n     \
    \   if exponent == 0 {\n            break;\n        }\n        last_digit = last_digit\
    \ / 10.0;\n        decimal_part += last_digit as f64;\n        remainder += last_digit\
    \ % 10.0;\n        exponent = exponent - 1;\n    }\n    decimal_part + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `i32` by `{float}`\n  --> /tmp/tmpx7xh98le.rs:14:33\n\
    \   |\n14 |         last_digit = last_digit / 10.0;\n   |                    \
    \             ^ no implementation for `i32 / {float}`\n   |\n   = help: the trait\
    \ `Div<{float}>` is not implemented for `i32`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror[E0277]: cannot mod `i32`\
    \ by `{float}`\n  --> /tmp/tmpx7xh98le.rs:16:33\n   |\n16 |         remainder\
    \ += last_digit % 10.0;\n   |                                 ^ no implementation\
    \ for `i32 % {float}`\n   |\n   = help: the trait `Rem<{float}>` is not implemented\
    \ for `i32`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.fract() * (1.0 / (f64::from(10.0)\
    \ ** exponent));\n        decimal_part += remainder;\n        exponent--;\n  \
    \  }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpmlcm411v.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpmlcm411v.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = 0.0;\n    let mut sign = 1.0;\n    let mut mantissa = number.to_f64();\n\
    \    while mantissa != 0.0 {\n        remainder = mantissa % 10.0;\n        mantissa\
    \ /= 10.0;\n        integer_part += remainder;\n        decimal_part += remainder;\n\
    \        exponent = exponent + 1;\n    }\n    sign * integer_part + decimal_part\
    \ * std::f64::powf(10.0, exponent)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `powf` in module `std::f64`\n  --> /tmp/tmpwrk88ig1.rs:19:52\n\
    \   |\n19 |     sign * integer_part + decimal_part * std::f64::powf(10.0, exponent)\n\
    \   |                                                    ^^^^ not found in `std::f64`\n\
    \nerror[E0599]: no method named `to_f64` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpwrk88ig1.rs:11:31\n   |\n11 |     let mut mantissa = number.to_f64();\n\
    \   |                               ^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ cannot add an integer to a float\n  --> /tmp/tmpwrk88ig1.rs:17:29\n   |\n17\
    \ |         exponent = exponent + 1;\n   |                             ^ no implementation\
    \ for `{float} + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not\
    \ implemented for `{float}`\n   = help: the following other types implement trait\
    \ `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n\
    \             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n  \
    \           <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n      \
    \       <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n        \
    \   and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        if exponent % 2 == 1 {\n            decimal_part\
    \ += number.fract();\n        }\n        number /= 10.0;\n        remainder +=\
    \ number.fract();\n        exponent = exponent / 2;\n    }\n    decimal_part +\
    \ remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpnun8y47p.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        let mut remainder_power\
    \ = remainder * 10.0;\n        if remainder_power < number {\n            integer\
    \ = remainder_power + integer;\n        } else {\n            integer = remainder\
    \ + integer;\n        }\n        decimals += remainder_power;\n        remainder\
    \ = number % remainder_power;\n        number /= remainder_power;\n        exponent--;\n\
    \    }\n    decimals + integer\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpu055w9z_.rs:20:19\n\
    \   |\n20 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpu055w9z_.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    number\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3ixhhalm.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3ixhhalm.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3ixhhalm.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    let mut max_exponent = std::i32::MAX;\n\
    \    let mut min_exponent = std::i32::MIN;\n    let mut max_fraction = std::i32::MAX;\n\
    \    let mut min_fraction = std::i32::MIN;\n    let mut max_fraction_bits = std::i32::MAX;\n\
    \    let mut min_fraction_bits = std::i32::MIN;\n    let mut max_fraction_bits2\
    \ = std::i32::MAX;\n    let mut min_fraction_bits2 = std::i32::MIN;\n    let mut\
    \ max_fraction_bits3 = std::i32::MAX;\n    let mut min_fraction_bits3 = std::i32::MIN;\n\
    \    let mut max_fraction_bits4 = std::i32::MAX;\n    let mut min_fraction_bits4\
    \ = std::i32::MIN;\n    let mut max_fraction_bits5 = std::i32::MAX;\n    let mut\
    \ min_fraction_bits5 = std::i32::MIN;\n    let mut max_fraction_bits6 = std::i32::MAX;\n\
    \    let mut min_fraction_bits6 = std::i32::MIN;\n    let mut max_fraction_bits7\
    \ = std::i32::MAX;\n    let mut min_fraction_bits7 = std::i32::MIN;\n    let mut\
    \ max_fraction_bits8 = std::i32::MAX;\n    let mut min_fraction_bits8 = std::i32::MIN;\n\
    \    let mut max_fraction_bits9 = std::i32::MAX;\n    let mut min_fraction_bits9\
    \ = std::i32::MIN;\n    let mut max_fraction_bits10 = std::i32::MAX;\n    let\
    \ mut min_fraction_bits10 = std::i32::MIN;\n    let mut max_fraction_bits11 =\
    \ std::i32::MAX;\n    let mut min_fraction_bits11 = std::i32::MIN;\n    let mut\
    \ max_fraction_bits12 = std::i32::MAX;\n    let mut min_fraction_bits12 = std::i32::MIN;\n\
    \    let mut max_fraction_bits13 = std::i32::MAX;\n    let mut min_fraction_bits13\
    \ = std::i32::MIN;\n    let mut max_fraction_bits14 = std::i32::MAX;\n    let\
    \ mut min_fraction_bits14 = std::i32::MIN;\n    let mut max_fraction_bits15 =\
    \ std::i32::MAX;\n    let mut min_fraction_bits15 = std::i32::MIN;\n    let mut\
    \ max_fraction_bits\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpguq2dn4a.rs:44:30\n   |\n\
    44 |     let mut max_fraction_bits\n   |                              ^ help:\
    \ add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0599]: no method named\
    \ `exponent` found for type `f64` in the current scope\n --> /tmp/tmpguq2dn4a.rs:9:31\n\
    \  |\n9 |     let mut exponent = number.exponent();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpguq2dn4a.rs:5:36\n  |\n5 | fn truncate_number(number: f64) -> f64\
    \ {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n\
    \    while exponent > 0.0 {\n        let mut remainder_part = remainder;\n   \
    \     let mut decimal_part = remainder_part + decimal_part * 10.0;\n        remainder\
    \ = number - remainder_part;\n        exponent = exponent - 1.0;\n    }\n    decimal_part\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmprpuebiuj.rs:8:41\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n8 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n  |                           \
    \              ~\n\nerror: invalid const generic expression\n  --> /tmp/tmprpuebiuj.rs:9:5\n\
    \   |\n9  | /     while exponent > 0.0 {\n10 | |         let mut remainder_part\
    \ = remainder;\n11 | |         let mut decimal_part = remainder_part + decimal_part\
    \ * 10.0;\n12 | |         remainder = number - remainder_part;\n13 | |       \
    \  exponent = exponent - 1.0;\n14 | |     }\n   | |_____^\n   |\nhelp: expressions\
    \ must be enclosed in braces to be used as const generic arguments\n   |\n9  ~\
    \     { while exponent > 0.0 {\n10 |         let mut remainder_part = remainder;\n\
    11 |         let mut decimal_part = remainder_part + decimal_part * 10.0;\n12\
    \ |         remainder = number - remainder_part;\n13 |         exponent = exponent\
    \ - 1.0;\n14 ~     } }\n   |\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`,\
    \ or an operator, found `::`\n --> /tmp/tmprpuebiuj.rs:8:34\n  |\n8 |     let\
    \ mut exponent = number.f64::exp();\n  |                                  ^^ expected\
    \ one of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to\
    \ 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    let mut last_digits\
    \ = 0.0;\n    while exponent > 0 {\n        let mut digit = last_digit as i32;\n\
    \        if digit == 9 {\n            last_digit = last_digit as i32;\n      \
    \      last_digits += 1;\n        }\n        digit /= 10;\n        remainder *=\
    \ 10.0;\n        remainder += digit;\n        decimal_part += remainder;\n   \
    \     exponent--;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp51ssrajg.rs:21:19\n\
    \   |\n21 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0277]: cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmp51ssrajg.rs:15:25\n\
    \   |\n15 |             last_digits += 1;\n   |                         ^^ no\
    \ implementation for `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0277]: cannot add-assign `i32` to `{float}`\n\
    \  --> /tmp/tmp51ssrajg.rs:19:19\n   |\n19 |         remainder += digit;\n   |\
    \                   ^^ no implementation for `{float} += i32`\n   |\n   = help:\
    \ the trait `AddAssign<i32>` is not implemented for `{float}`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpk7pwenbo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut exponent = number.abs().floor() as i32;\n    let mut remainder =\
    \ number.abs().floor() as f64;\n    while exponent > 0 {\n        if exponent\
    \ % 2 == 1 {\n            result -= remainder;\n        }\n        remainder *=\
    \ 10.0;\n        result += (exponent - 1) / 2;\n        exponent = exponent /\
    \ 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `i32` to `f64`\n  --> /tmp/tmprq21nlut.rs:14:16\n\
    \   |\n14 |         result += (exponent - 1) / 2;\n   |                ^^ no implementation\
    \ for `f64 += i32`\n   |\n   = help: the trait `AddAssign<i32>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut truncated = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.fract() * (f64::powf(10.0,\
    \ exponent));\n        truncated = remainder / f64::powf(10.0, exponent - 1);\n\
    \        remainder = remainder % f64::powf(10.0, exponent - 1);\n        exponent--;\n\
    \    }\n    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp8qa1fhlq.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp8qa1fhlq.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n --> /tmp/tmp8qa1fhlq.rs:9:20\n  |\n9\
    \ |     while exponent > 0 {\n  |                    ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n  |\n  = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\nhelp: consider using a floating-point literal\
    \ by writing it with `.0`\n  |\n9 |     while exponent > 0.0 {\n  |          \
    \             ++\n\nerror[E0277]: cannot subtract `{integer}` from `f64`\n  -->\
    \ /tmp/tmp8qa1fhlq.rs:11:58\n   |\n11 |         truncated = remainder / f64::powf(10.0,\
    \ exponent - 1);\n   |                                                       \
    \   ^ no implementation for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         truncated = remainder / f64::powf(10.0, exponent\
    \ - 1.0);\n   |                                                             ++\n\
    \nerror[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmp8qa1fhlq.rs:12:58\n\
    \   |\n12 |         remaind"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.is_negative()\
    \ ? -number.signum() : number.signum();\n    while exponent > 0 {\n        if\
    \ exponent % 2 == 1 {\n            decimal_part += remainder;\n        }\n   \
    \     remainder *= 10.0;\n        exponent /= 2;\n    }\n    decimal_part + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n --> /tmp/tmpknydkdif.rs:8:48\n\
    \  |\n8 |     let mut exponent = number.is_negative() ? -number.signum() : number.signum();\n\
    \  |                                                ^^^^^^^^^^^^^^^---------\n\
    \  |                                                               |\n  |    \
    \                                                           help: remove the type\
    \ ascription\n\nerror[E0573]: expected type, found local variable `number`\n -->\
    \ /tmp/tmpknydkdif.rs:8:66\n  |\n8 |     let mut exponent = number.is_negative()\
    \ ? -number.signum() : number.signum();\n  |                                 \
    \                                 ^^^^^^ expecting a type here because of type\
    \ ascription\n\nwarning: use of deprecated associated function `core::f64::<impl\
    \ f64>::is_negative`: renamed to is_sign_negative\n --> /tmp/tmpknydkdif.rs:8:31\n\
    \  |\n8 |     let mut exponent = number.is_negative() ? -number.signum() : number.signum();\n\
    \  |                               ^^^^^^^^^^^\n  |\n  = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0277]: the `?` operator can only be applied to values\
    \ that implement `Try`\n --> /tmp/tmpknydkdif.rs:8:24\n  |\n8 |     let mut exponent\
    \ = number.is_negative() ? -number.signum() : number.signum();\n  |          \
    \              ^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type\
    \ `bool`\n  |\n  = help: the trait `Try` is not implemented for `bool`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpknydkdif.rs:8:45\n\
    \   |\n5  | / fn truncate_number(number: f64) -> f64 {\n6  | |     let mut decimal_part\
    \ = 0.0;\n7  | |     let mut remainder = 0.0;\n8  | |     let mut exponent = number.is_negative()\
    \ ? -number.signum() : number.signum();\n   | |                              \
    \               ^ cannot use the `?` operator in a function that returns `f64`\n\
    ...  |\n16 | |     decimal_part + remainder\n17 | | }\n   | |_- this function\
    \ should return `Result` or `Option` to accept `?`\n   |\n "
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.remainder(&mut decimal_part);\n\
    \        number -= remainder;\n        exponent--;\n    }\n    decimal_part +\
    \ remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpm06n6hln.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpm06n6hln.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpm06n6hln.rs:10:29\n   |\n10 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut max_integer = 0.0;\n    let mut min_integer = 0.0;\n    let mut max_decimal\
    \ = 0.0;\n    let mut min_decimal = 0.0;\n    let mut max_leftover = 0.0;\n  \
    \  let mut min_leftover = 0.0;\n    let mut max_decimals = 0.0;\n    let mut min_decimals\
    \ = 0.0;\n    let mut max_leftovers = 0.0;\n    let mut min_leftovers = 0.0;\n\
    \    let mut max_decimals_count = 0.0;\n    let mut min_decimals_count = 0.0;\n\
    \    let mut max_leftovers_count = 0.0;\n    let mut min_leftovers_count = 0.0;\n\
    \    let mut max_decimals_count_in_decimals = 0.0;\n    let mut min_decimals_count_in_decimals\
    \ = 0.0;\n    let mut max_leftovers_count_in_decimals = 0.0;\n    let mut min_leftovers_count_in_decimals\
    \ = 0.0;\n    let mut max_decimals_count_in_leftovers = 0.0;\n    let mut min_decimals_count_in_leftovers\
    \ = 0.0;\n    let mut max_leftovers_count_in_leftovers = 0.0;\n    let mut min_leftovers_count_in_leftovers\
    \ = 0.0;\n    let mut max_decimals_count_in_decimals_count = 0.0;\n    let mut\
    \ min_decimals_count_in_decimals_count = 0.0;\n    let mut max_leftovers_count_in_decimals_count\
    \ = 0.0;\n    let mut min_leftovers_count_in_decimals_count = 0.0;\n    let mut\
    \ max_decimals_count_in_leftovers_count = 0.0;\n    let mut min_decimals_count_in_leftovers_count\
    \ = 0.0;\n    let mut max_leftovers_count_in_leftovers_count = 0.0;\n    let mut\
    \ min_leftovers_count_in_leftovers_count = 0.0;\n    let mut max_decimals_count_in_decimals_count_in_decimals\
    \ = 0.0;\n    let mut min_decimals_count_in_decimals_count_in_decimals = 0.0;\n\
    \    let mut max_leftovers_count_in_decimals_count_in_decimals = 0.0;\n    let\
    \ mut min_leftovers_count_in_decimals_count_in_decimals = 0.0;\n    let mut max_decimals_count_in_leftovers_count_in_decimals\
    \ = 0.0;\n    let mut min_decimals_count_in_lef\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2dhs_c8h.rs:44:38\n   |\n\
    44 |     let mut min_decimals_count_in_lef\n   |                             \
    \         ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp2dhs_c8h.rs:5:36\n  |\n5 | fn truncate_number(number:\
    \ f64) -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut exponent = number.floor() as i32;\n    let mut remainder = number.floor()\
    \ as f64;\n    while exponent > 0 {\n        remainder *= 10.0;\n        decimals\
    \ += remainder as f64;\n        exponent = exponent - 1;\n    }\n    decimals\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3330.0`,\n right: `0.5`', /tmp/tmpf7t0ur5m.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.floor() as i32;\n\
    \    let mut integer = number.floor() as i32;\n    while integer != 0 {\n    \
    \    remainder *= 10.0;\n        remainder += integer % 10.0;\n        integer\
    \ /= 10.0;\n        exponent--;\n    }\n    exponent += decimals;\n    exponent\
    \ += 1;\n    exponent as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpqpm18mrp.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0277]: cannot mod `i32` by `{float}`\n  --> /tmp/tmpqpm18mrp.rs:12:30\n\
    \   |\n12 |         remainder += integer % 10.0;\n   |                       \
    \       ^ no implementation for `i32 % {float}`\n   |\n   = help: the trait `Rem<{float}>`\
    \ is not implemented for `i32`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0277]: cannot divide-assign `i32` by `{float}`\n\
    \  --> /tmp/tmpqpm18mrp.rs:13:17\n   |\n13 |         integer /= 10.0;\n   |  \
    \               ^^ no implementation for `i32 /= {float}`\n   |\n   = help: the\
    \ trait `DivAssign<{float}>` is not implemented for `i32`\n   = help: the following\
    \ other types implement trait `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n\
    \             <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n    \
    \         <f64 as DivAssign>\n             <i128 as DivAssign<&i128>>\n      \
    \       <i128 as DivAssign>\n             <i16 as DivAssign<&i16>>\n         \
    \    <i16 as DivAssign>\n           and 20 others\n\nerror[E0277]: cannot add-assign\
    \ `{float}` to `i32`\n  --> /tmp/tmpqpm18mrp.rs:16:14\n   |\n16 |     exponent\
    \ += decimals;\n   |              ^^ no implementation for `i32 += {float}`\n\
    \   |\n   = help: the trait `AddAssign<{float}>` is not implemented for `i32`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           "
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\n\
    \    if number < 0.0 {\n        leftover_part = number;\n        number = -number;\n\
    \    }\n\n    if number < 1.0 {\n        integer_part = number;\n    } else {\n\
    \        let mut digits = number.trunc_f64();\n        integer_part = digits;\n\
    \        decimal_part = digits - integer_part;\n    }\n\n    leftover_part +=\
    \ integer_part - 1.0;\n    leftover_part += decimal_part - 1.0;\n\n    leftover_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmptw539y4c.rs:18:33\n   |\n18 |         let mut digits =\
    \ number.trunc_f64();\n   |                                 ^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `trunc`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    let mut mantissa = number.mantissa();\n\
    \    while exponent > 0 {\n        remainder = mantissa.truncate();\n        integer_part\
    \ += remainder;\n        mantissa = mantissa.next_power_of_two();\n        exponent\
    \ -= 1;\n    }\n    integer_part += mantissa.truncate();\n    decimal_part = remainder;\n\
    \    integer_part += 1.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpid8f6v8o.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpid8f6v8o.rs:10:31\n   |\n10 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpid8f6v8o.rs:19:5\n   |\n5  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                                    --- expected `f64` because\
    \ of return type\n...\n19 |     integer_part += 1.0\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.fract() * (10.0 as f64);\n        integer_part += remainder;\n   \
    \     remainder = 0.0;\n        exponent -= 1;\n    }\n    integer_part += remainder;\n\
    \    decimal_part = number.fract();\n    integer_part += decimal_part as f64;\n\
    \    integer_part as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpcut5_opv.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    let mut mantissa = number.mantissa();\n    while exponent > 0 {\n       \
    \ if exponent % 2 == 1 {\n            mantissa *= 10.0;\n        }\n        mantissa\
    \ /= 10.0;\n        decimal_part += mantissa;\n        remainder += mantissa;\n\
    \        exponent /= 2;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpwj8666hb.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmpwj8666hb.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut mantissa = number.fract();\n\n    while exponent > 0 {\n\
    \        mantissa = mantissa * 10.0;\n        exponent = exponent - 1;\n    }\n\
    \n    while mantissa.abs() > 1.0 {\n        mantissa = mantissa.trunc();\n   \
    \     decimal_part += 1.0;\n    }\n\n    remainder = mantissa.trunc();\n\n   \
    \ if remainder == 0.0 {\n        decimal_part += 1.0;\n    }\n\n    decimal_part\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976556
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ let mut mantissa = number.mantissa();\n    while exponent > 0 {\n        if\
    \ exponent % 2 == 1 {\n            result += (mantissa * 10.0).powi(exponent);\n\
    \        } else {\n            result += (mantissa * 10.0).powi(exponent - 1);\n\
    \        }\n        remainder += mantissa;\n        mantissa = mantissa.next_mantissa();\n\
    \        exponent = exponent >> 1;\n    }\n    result + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp6keo6sy7.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmp6keo6sy7.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        remainder += number.remainder(&mut\
    \ integer);\n        decimals += integer.to_f64();\n        exponent--;\n    }\n\
    \    remainder += number.remainder(&mut integer);\n    decimals += integer.to_f64();\n\
    \    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpzruto753.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpzruto753.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpzruto753.rs:11:29\n   |\n11 |         remainder += number.remainder(&mut\
    \ integer);\n   |                             ^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `to_f64` found for type `{float}` in the current\
    \ scope\n  --> /tmp/tmpzruto753.rs:12:29\n   |\n12 |         decimals += integer.to_f64();\n\
    \   |                             ^^^^^^ method not found in `{float}`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpzruto753.rs:15:25\n   |\n15 |     remainder += number.remainder(&mut\
    \ integer);\n   |                         ^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `to_f64` found for type `{float}` in the current\
    \ scope\n  --> /tmp/tmpzruto753.rs:16:25\n   |\n16 |     decimals += integer.to_f64();\n\
    \   |                         ^^^^^^ method not found in `{float}`\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        remainder /= 10.0;\n  \
    \      exponent -= 1;\n    }\n    integer_part += remainder;\n    integer_part\
    \ / 10.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpvhn1061h.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    while\
    \ number > 0.0 {\n        remainder = number % 10.0;\n        integer_part +=\
    \ remainder * 10.0;\n        decimal_part += remainder;\n        number /= 10.0;\n\
    \    }\n    integer_part += decimal_part;\n    integer_part\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: value assigned to `remainder` is never read\n --> /tmp/tmpk9te4huh.rs:8:13\n\
    \  |\n8 |     let mut remainder = 0.0;\n  |             ^^^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_assignments)]` on by default\n  = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `number`\n\
    \  --> /tmp/tmpk9te4huh.rs:13:9\n   |\n5  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n13 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = 0.0;\n    let mut sign = 1.0;\n\n    // We need to check that\
    \ the number is finite and positive.\n    // We also need to check that the number\
    \ is finite and non-zero.\n    // We also need to check that the number is finite\
    \ and non-negative.\n    // We also need to check that the number is finite and\
    \ non-infinite.\n    // We also need to check that the number is finite and non-NaN.\n\
    \    // We also need to check that the number is finite and non-infinite.\n  \
    \  // We also need to check that the number is finite and non-NaN.\n    // We\
    \ also need to check that the number is finite and non-infinite.\n    // We also\
    \ need to check that the number is finite and non-NaN.\n    // We also need to\
    \ check that the number is finite and non-infinite.\n    // We also need to check\
    \ that the number is finite and non-NaN.\n    // We also need to check that the\
    \ number is finite and non-infinite.\n    // We also need to check that the number\
    \ is finite and non-NaN.\n    // We also need to check that the number is finite\
    \ and non-infinite.\n    // We also need to check that the number is finite and\
    \ non-NaN.\n    // We also need to check that the number is finite and non-infinite.\n\
    \    // We also need to check that the number is finite and non-NaN.\n    // We\
    \ also need to check that the number is finite and non-infinite.\n    // We also\
    \ need to check that the number is finite and non-NaN.\n    // We also need to\
    \ check that the number is finite and non-infinite.\n    // We also need to check\
    \ that the number is finite and non-NaN.\n    // We also need to check that the\
    \ number is finite and non-infinite.\n    // We also need to check that the number\
    \ is finite and non-NaN.\n    // We also need to check that the number is finite\
    \ and non-infinite.\n    // We also need to check that the number is finite and\
    \ non-NaN.\n    // We also need to check that the number is finite and non-infinite.\n\
    \    // We also need to check that the number is finite and non-NaN.\n    // We\
    \ also need to check that the number is finite and non-infinite.\n    // We also\
    \ need to check that the number is finite and non-NaN.\n    // We also need to\
    \ check that the number is finite and non-infinite.\n    // We also need to check\
    \ that the number is finite and non-NaN.\n    // We also need to check that the\
    \ number is finite and non-infinite.\n    // We also need to check that the number\
    \ is finite and non-NaN.\n    // We also need to check that the number is finite\
    \ and non-infinite.\n    // We also need to check that the number is finite and\
    \ non-NaN.\n    // We also need to check that the number is finite and non-infinite.\n\
    \    // We also need to check that the number is finite \n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgggkv7d7.rs:5:36\n  |\n5 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut sign = 1.0;\n    let mut exponent = 1.0;\n    let mut mantissa =\
    \ 1.0;\n    let mut max_mantissa = 1.0;\n    let mut min_mantissa = 1.0;\n   \
    \ let mut max_exponent = 1.0;\n    let mut min_exponent = 1.0;\n    let mut max_integer\
    \ = 0.0;\n    let mut min_integer = 0.0;\n    let mut max_leftover_part = 0.0;\n\
    \    let mut min_leftover_part = 0.0;\n    let mut max_sign = 1.0;\n    let mut\
    \ min_sign = 1.0;\n    let mut max_exponent = 1.0;\n    let mut min_exponent =\
    \ 1.0;\n    let mut max_mantissa = 1.0;\n    let mut min_mantissa = 1.0;\n   \
    \ let mut max_leftover_part = 0.0;\n    let mut min_leftover_part = 0.0;\n   \
    \ let mut max_integer = 0.0;\n    let mut min_integer = 0.0;\n    let mut max_number\
    \ = 0.0;\n    let mut min_number = 0.0;\n    let mut max_exponent = 1.0;\n   \
    \ let mut min_exponent = 1.0;\n    let mut max_mantissa = 1.0;\n    let mut min_mantissa\
    \ = 1.0;\n    let mut max_leftover_part = 0.0;\n    let mut min_leftover_part\
    \ = 0.0;\n    let mut max_integer = 0.0;\n    let mut min_integer = 0.0;\n   \
    \ let mut max_number = 0.0;\n    let mut min_number = 0.0;\n    let mut max_exponent\
    \ = 1.0;\n    let mut min_exponent = 1.0;\n    let mut max_mantissa = 1.0;\n \
    \   let mut min_mantissa = 1.0;\n    let mut max_leftover_part = 0.0;\n    let\
    \ mut min_leftover_part = 0.0;\n    let mut max_integer = 0.0;\n    let mut min_integer\
    \ = 0.0;\n    let mut max_number = 0.0;\n    let mut min_number = 0.0;\n    let\
    \ mut max_exponent = 1.0;\n    let mut min_exponent = 1.0;\n    let mut max_mantissa\
    \ = 1.0;\n    let mut min_mantissa = 1.0;\n    let mut max_leftover_part = 0.0;\n\
    \    let mut min_leftover_part = 0.0;\n    let mut max_integer = 0.0;\n    let\
    \ mut \n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmprwp43_zh.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.fract() * (1.0 / (f64::from(10.0)\
    \ ** exponent));\n        decimal_part += remainder;\n        exponent--;\n  \
    \  }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpmlcm411v.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpmlcm411v.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut max_integer = 0.0;\n    let mut min_integer = 0.0;\n    let mut max_decimal\
    \ = 0.0;\n    let mut min_decimal = 0.0;\n    let mut max_leftover = 0.0;\n  \
    \  let mut min_leftover = 0.0;\n\n    // Find largest integer smaller than given\
    \ number\n    while number > max_integer {\n        max_integer += 1.0;\n    }\n\
    \    while number < min_integer {\n        min_integer -= 1.0;\n    }\n\n    //\
    \ Find largest decimal smaller than given number\n    while number > max_decimal\
    \ {\n        max_decimal += 1.0;\n    }\n    while number < min_decimal {\n  \
    \      min_decimal -= 1.0;\n    }\n\n    // Find largest leftover smaller than\
    \ given number\n    while number > max_leftover {\n        max_leftover += 1.0;\n\
    \    }\n    while number < min_leftover {\n        min_leftover -= 1.0;\n    }\n\
    \n    // Find smallest integer larger than given number\n    while integer_part\
    \ < number {\n        integer_part += 1.0;\n    }\n\n    // Find smallest decimal\
    \ larger than given number\n    while decimal_part < number {\n        decimal_part\
    \ += 1.0;\n    }\n\n    // Find smallest leftover larger than given number\n \
    \   while leftover_part < number {\n        leftover_part += 1.0;\n    }\n\n \
    \   // Return decimal part\n    decimal_part - leftover_part\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.0`,\n right: `0.5`', /tmp/tmp1sl183in.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut max_integer_part = 0.0;\n    let mut max_leftover_part = 0.0;\n \
    \   let mut max_decimal_part = 0.0;\n    let mut max_number = 0.0;\n    let mut\
    \ max_decimal_part_size = 0.0;\n    let mut max_integer_part_size = 0.0;\n   \
    \ let mut max_leftover_part_size = 0.0;\n    let mut max_number_size = 0.0;\n\
    \    let mut max_decimal_part_size_size = 0.0;\n    let mut max_integer_part_size_size\
    \ = 0.0;\n    let mut max_leftover_part_size_size = 0.0;\n    let mut max_number_size_size\
    \ = 0.0;\n    let mut max_decimal_part_size_number_size = 0.0;\n    let mut max_integer_part_size_number_size\
    \ = 0.0;\n    let mut max_leftover_part_size_number_size = 0.0;\n    let mut max_number_size_number_size\
    \ = 0.0;\n    let mut max_decimal_part_size_number_size_size = 0.0;\n    let mut\
    \ max_integer_part_size_number_size_size = 0.0;\n    let mut max_leftover_part_size_number_size_size\
    \ = 0.0;\n    let mut max_number_size_number_size_size = 0.0;\n    let mut max_decimal_part_size_number_size_number_size\
    \ = 0.0;\n    let mut max_integer_part_size_number_size_number_size = 0.0;\n \
    \   let mut max_leftover_part_size_number_size_number_size = 0.0;\n    let mut\
    \ max_number_size_number_size_number_size = 0.0;\n    let mut max_decimal_part_size_number_size_number_size_size\
    \ = 0.0;\n    let mut max_integer_part_size_number_size_number_size_size = 0.0;\n\
    \    let mut max_leftover_part_size_number_size_number_size_size = 0.0;\n    let\
    \ mut max_number_size_number_size_number_size_size = 0.0;\n    let mut max_decimal_part_size_number_size_number_size_number_size\
    \ = 0.0;\n    let mut max_integer_part_size_number_size_number_size_number_size_size\
    \ = 0.0;\n    let mut max_leftover_part_size_number_size_number_size_number_size_size\
    \ = 0.0;\n    let mut max_number_size_number_size_number_size_number_size_size\
    \ = 0.0;\n    let mut max_decimal_part_size_number_size_number_size_number_size_number_size\
    \ = 0.0;\n    let mut max_integer_part_size_number_size_number_size_number_size_number_size_size\
    \ = 0.0;\n    let mut max_leftover_part_size_number_size_number_size_number_size_number_size_number_size_size\
    \ = 0.0;\n    let mut max_number_size_number_size_number_size_number_size_number_size_number_\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkyuzy81o.rs:44:84\n   |\n\
    44 |     let mut max_number_size_number_size_number_size_number_size_number_size_number_\n\
    \   |                                                                        \
    \            ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpkyuzy81o.rs:5:36\n  |\n5 | fn truncate_number(number:\
    \ f64) -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut exponent = number.abs().floor() as usize;\n    let mut mantissa =\
    \ number.abs().floor() as f64;\n    while exponent > 0 {\n        mantissa *=\
    \ 10.0;\n        exponent--;\n    }\n    mantissa = mantissa.round() as f64;\n\
    \    decimals += mantissa;\n    decimals\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpfu4_dbri.rs:11:19\n\
    \   |\n11 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        decimal_part += remainder\
    \ * std::powf(10.0, exponent);\n        exponent -= 1;\n    }\n    integer_part\
    \ + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `powf` in crate `std`\n  --> /tmp/tmp4lx79z77.rs:13:42\n\
    \   |\n13 |         decimal_part += remainder * std::powf(10.0, exponent);\n \
    \  |                                          ^^^^ not found in `std`\n\nerror[E0599]:\
    \ no method named `exponent` found for type `f64` in the current scope\n --> /tmp/tmp4lx79z77.rs:9:31\n\
    \  |\n9 |     let mut exponent = number.exponent();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut integer_part);\n        decimal_part += integer_part\
    \ * 10.0;\n        integer_part *= 10.0;\n        exponent--;\n    }\n    decimal_part\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmptnddlc1z.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmptnddlc1z.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmptnddlc1z.rs:11:29\n   |\n11 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n\
    \    let mut mantissa = number.f64::mantissa();\n    while exponent > 0 {\n  \
    \      if exponent % 2 == 1 {\n            mantissa = mantissa * 10.0;\n     \
    \   }\n        mantissa = mantissa * 10.0;\n        exponent = exponent / 2;\n\
    \    }\n    mantissa = mantissa * remainder;\n    decimal_part = mantissa;\n \
    \   decimal_part - 1.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmp5lctjf5e.rs:8:41\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n8 |     let mut exponent\
    \ = number.f64::exp(), let mut mantissa = number.f64::mantissa();\n  |       \
    \                                  ~\n\nerror: expected one of `!`, `+`, `,`,\
    \ `->`, `::`, `:`, `=`, or `>`, found `;`\n --> /tmp/tmp5lctjf5e.rs:9:46\n  |\n\
    9 |     let mut mantissa = number.f64::mantissa();\n  |                      \
    \                        ^ expected one of 8 possible tokens\n  |\nhelp: use a\
    \ comma to separate type parameters\n  |\n9 |     let mut mantissa = number.f64::mantissa(),\
    \ while exponent > 0 {\n  |                                              ~\n\n\
    error: invalid const generic expression\n  --> /tmp/tmp5lctjf5e.rs:10:5\n   |\n\
    10 | /     while exponent > 0 {\n11 | |         if exponent % 2 == 1 {\n12 | |\
    \             mantissa = mantissa * 10.0;\n13 | |         }\n14 | |         mantissa\
    \ = mantissa * 10.0;\n15 | |         exponent = exponent / 2;\n16 | |     }\n\
    \   | |_____^\n   |\nhelp: expressions must be enclosed in braces to be used as\
    \ const generic arguments\n   |\n10 ~     { while exponent > 0 {\n11 |       \
    \  if exponent % 2 == 1 {\n12 |             mantissa = mantissa * 10.0;\n13 |\
    \         }\n14 |         mantissa = mantissa * 10.0;\n15 |         exponent =\
    \ exponent / 2;\n ...\n\nerror: invalid const generic expression\n --> /tmp/tmp5lctjf5e.rs:9:5\n\
    \  |\n9 |     let mut mantissa = number.f64::mantissa();\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n  |\n9 |     { let mut mantissa = number.f64 }::mantissa();\n  |\
    \     +                               +\n\nerror: expected one of `(`, `.`, `;`,\
    \ `?`, `else`, or an operator, found `::`\n --> /tmp/tmp5lctjf5e.rs:8:34\n  |\n\
    8 |     let mut exponent = number.f64::exp();\n  |                           \
    \       ^^ expected one of `(`,"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut truncated = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.fract() * (f64::powf(10.0,\
    \ exponent) - 1.0);\n        truncated = remainder;\n        remainder -= truncated;\n\
    \        exponent--;\n    }\n    truncated\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp6_7uen3_.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp6_7uen3_.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n --> /tmp/tmp6_7uen3_.rs:9:20\n  |\n9\
    \ |     while exponent > 0 {\n  |                    ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n  |\n  = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\nhelp: consider using a floating-point literal\
    \ by writing it with `.0`\n  |\n9 |     while exponent > 0.0 {\n  |          \
    \             ++\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut fraction = number.fract();\n    while exponent > 0 {\n\
    \        remainder += fraction;\n        fraction *= 10.0;\n        exponent--;\n\
    \    }\n    decimal_part += remainder;\n    decimal_part\n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp1pnsntke.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut remainder_power\
    \ = 0.0;\n    let mut remainder_power_power = 0.0;\n    let mut remainder_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power = 0.0;\n    let mut remainder_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut remainder_power_power_power_power_power_power_power_power_power_power_power_power_power_power_power\
    \ = 0.0;\n    let mut \n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjryb8b7_.rs:34:1\n\
    \   |\n34 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 0.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmptwjarobh.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ let mut mantissa = number.mantissa();\n    while exponent > 0 {\n        let\
    \ mut new_mantissa = mantissa;\n        let mut new_exponent = exponent;\n   \
    \     while new_exponent > 0 {\n            let mut new_mantissa = mantissa;\n\
    \            let mut new_exponent = exponent;\n            while new_exponent\
    \ > 0 {\n                new_mantissa <<= 1;\n                new_exponent -=\
    \ 1;\n            }\n            new_mantissa += remainder;\n            new_exponent\
    \ += 1;\n            remainder = 0;\n        }\n        result += new_mantissa;\n\
    \        mantissa = new_mantissa;\n        exponent = new_exponent;\n    }\n \
    \   result + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpp7qkr8ub.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmpp7qkr8ub.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp7qkr8ub.rs:22:25\n   |\n7  |     let mut remainder = 0.0;\n  \
    \ |                         --- expected due to this value\n...\n22 |        \
    \     remainder = 0;\n   |                         ^ expected floating-point number,\
    \ found integer\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.fract() * (1.0 / (1 <<\
    \ exponent));\n        decimal_part += remainder;\n        exponent--;\n    }\n\
    \    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmplxnmbqe5.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmplxnmbqe5.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut integer_part);\n        decimal_part += integer_part\
    \ * 10.0;\n        integer_part = 0.0;\n        exponent--;\n    }\n    decimal_part\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpzt761dzl.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpzt761dzl.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpzt761dzl.rs:11:29\n   |\n11 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut exponent = number.abs();\n    while exponent > 0.0 {\n        if\
    \ exponent % 2.0 == 0.0 {\n            result *= 10.0;\n            exponent /=\
    \ 2.0;\n        } else {\n            result *= 10.0;\n            exponent /=\
    \ 2.0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.0`,\n right: `0.5`', /tmp/tmp696xvjvw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut exponent = number.exponent();\n    while exponent > 0 {\n       \
    \ if exponent % 2 == 1 {\n            result -= number.fract();\n        }\n \
    \       number /= 10.0;\n        exponent = number.exponent();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmplqittl1c.rs:7:31\n  |\n7 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `exponent` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmplqittl1c.rs:13:27\n   |\n13 |         exponent = number.exponent();\n\
    \   |                           ^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\n\
    \    if number < 0.0 {\n        leftover_part = -number;\n        number = -number;\n\
    \    }\n\n    if number == 0.0 {\n        return 0.0;\n    }\n\n    if number\
    \ < 1.0 {\n        integer_part = number;\n        leftover_part = 0.0;\n    }\
    \ else {\n        let mut integer_part = number;\n        let mut decimal_part\
    \ = 0.0;\n\n        while integer_part > 1.0 {\n            integer_part -= 1.0;\n\
    \            decimal_part += 1.0;\n        }\n\n        integer_part -= 1.0;\n\
    \        leftover_part = integer_part - 1.0;\n    }\n\n    decimal_part + leftover_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `integer_part` is assigned to, but never used\n --> /tmp/tmp5nfigcdt.rs:7:13\n\
    \  |\n7 |     let mut integer_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using\
    \ `_integer_part` instead\n\nwarning: value assigned to `leftover_part` is never\
    \ read\n --> /tmp/tmp5nfigcdt.rs:8:13\n  |\n8 |     let mut leftover_part = 0.0;\n\
    \  |             ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_assignments)]` on\
    \ by default\n  = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `leftover_part` is never read\n  --> /tmp/tmp5nfigcdt.rs:11:9\n\
    \   |\n11 |         leftover_part = -number;\n   |         ^^^^^^^^^^^^^\n   |\n\
    \   = help: maybe it is overwritten before being read?\n\nwarning: value assigned\
    \ to `integer_part` is never read\n  --> /tmp/tmp5nfigcdt.rs:20:9\n   |\n20 |\
    \         integer_part = number;\n   |         ^^^^^^^^^^^^\n   |\n   = help:\
    \ maybe it is overwritten before being read?\n\nwarning: variable `decimal_part`\
    \ is assigned to, but never used\n  --> /tmp/tmp5nfigcdt.rs:24:17\n   |\n24 |\
    \         let mut decimal_part = 0.0;\n   |                 ^^^^^^^^^^^^\n   |\n\
    \   = note: consider using `_decimal_part` instead\n\nwarning: variable does not\
    \ need to be mutable\n --> /tmp/tmp5nfigcdt.rs:6:9\n  |\n6 |     let mut decimal_part\
    \ = 0.0;\n  |         ----^^^^^^^^^^^^\n  |         |\n  |         help: remove\
    \ this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmp5nfigcdt.rs:12:9\n\
    \   |\n5  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n12 | \
    \        number = -number;\n   |         ^^^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 6 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n\
    \    while exponent > 0.0 {\n        let mut remainder_part = remainder;\n   \
    \     let mut decimal_part = remainder_part * 10.0;\n        remainder = remainder_part\
    \ - decimal_part;\n        exponent = exponent - 1;\n    }\n    decimal_part +\
    \ remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmpxp342u1g.rs:8:41\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n8 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n  |                           \
    \              ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpxp342u1g.rs:9:5\n\
    \   |\n9  | /     while exponent > 0.0 {\n10 | |         let mut remainder_part\
    \ = remainder;\n11 | |         let mut decimal_part = remainder_part * 10.0;\n\
    12 | |         remainder = remainder_part - decimal_part;\n13 | |         exponent\
    \ = exponent - 1;\n14 | |     }\n   | |_____^\n   |\nhelp: expressions must be\
    \ enclosed in braces to be used as const generic arguments\n   |\n9  ~     { while\
    \ exponent > 0.0 {\n10 |         let mut remainder_part = remainder;\n11 |   \
    \      let mut decimal_part = remainder_part * 10.0;\n12 |         remainder =\
    \ remainder_part - decimal_part;\n13 |         exponent = exponent - 1;\n14 ~\
    \     } }\n   |\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or an operator,\
    \ found `::`\n --> /tmp/tmpxp342u1g.rs:8:34\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                  ^^ expected one of `(`, `.`, `;`, `?`, `else`,\
    \ or an operator\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        remainder += number.fract() * (f64::powf(10.0,\
    \ exponent) - 1.0);\n        decimal_part += remainder;\n        remainder = 0.0;\n\
    \        exponent -= 1;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp0fotu_ta.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n --> /tmp/tmp0fotu_ta.rs:9:20\n  |\n9\
    \ |     while exponent > 0 {\n  |                    ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n  |\n  = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\nhelp: consider using a floating-point literal\
    \ by writing it with `.0`\n  |\n9 |     while exponent > 0.0 {\n  |          \
    \             ++\n\nerror[E0277]: cannot subtract-assign `{integer}` from `f64`\n\
    \  --> /tmp/tmp0fotu_ta.rs:13:18\n   |\n13 |         exponent -= 1;\n   |    \
    \              ^^ no implementation for `f64 -= {integer}`\n   |\n   = help: the\
    \ trait `SubAssign<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n\
    \             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n    \
    \         <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n      \
    \       <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n         \
    \    <i16 as SubAssign>\n           and 20 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n13 |         exponent -= 1.0;\n   | \
    \                     ++\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut remaining = number;\n    while remaining > 1.0 {\n        remaining\
    \ -= 1.0;\n        decimals += 1.0;\n    }\n    remaining\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpdg0ndfo0.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    let mut mantissa = number.mantissa();\n    while exponent > 0 {\n       \
    \ let mut next_mantissa = mantissa;\n        let mut next_exponent = exponent;\n\
    \        while next_exponent > 0 {\n            next_exponent -= 1;\n        \
    \    next_mantissa <<= 1;\n        }\n        mantissa = next_mantissa;\n    \
    \    exponent = next_exponent;\n    }\n    mantissa\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpojov_7ch.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmpojov_7ch.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror[E0277]: no implementation\
    \ for `f64 <<= {integer}`\n  --> /tmp/tmpojov_7ch.rs:15:27\n   |\n15 |       \
    \      next_mantissa <<= 1;\n   |                           ^^^ no implementation\
    \ for `f64 <<= {integer}`\n   |\n   = help: the trait `ShlAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `ShlAssign<Rhs>`:\n             <i128 as ShlAssign<&i128>>\n             <i128\
    \ as ShlAssign<&i16>>\n             <i128 as ShlAssign<&i32>>\n             <i128\
    \ as ShlAssign<&i64>>\n             <i128 as ShlAssign<&i8>>\n             <i128\
    \ as ShlAssign<&isize>>\n             <i128 as ShlAssign<&u128>>\n           \
    \  <i128 as ShlAssign<&u16>>\n           and 280 others\nhelp: consider using\
    \ a floating-point literal by writing it with `.0`\n   |\n15 |             next_mantissa\
    \ <<= 1.0;\n   |                                ++\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut truncated = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.floor() as usize;\n\
    \    let mut last_digit = number.floor() as f64;\n    let mut last_digit = number.floor()\
    \ as f64;\n    while exponent > 0 {\n        let mut digit = last_digit % 10;\n\
    \        last_digit /= 10.0;\n        truncated = truncated.saturating_add(digit);\n\
    \        remainder = remainder.saturating_add(digit * 10.0);\n        exponent--;\n\
    \    }\n    truncated.saturating_add(remainder).round() as f64\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp58mhxy79.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmp58mhxy79.rs:12:36\n\
    \   |\n12 |         let mut digit = last_digit % 10;\n   |                   \
    \                 ^ no implementation for `f64 % {integer}`\n   |\n   = help:\
    \ the trait `Rem<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\nhelp: consider using a\
    \ floating-point literal by writing it with `.0`\n   |\n12 |         let mut digit\
    \ = last_digit % 10.0;\n   |                                        ++\n\nerror[E0689]:\
    \ can't call method `saturating_add` on ambiguous numeric type `{float}`\n  -->\
    \ /tmp/tmp58mhxy79.rs:14:31\n   |\n14 |         truncated = truncated.saturating_add(digit);\n\
    \   |                               ^^^^^^^^^^^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `f32`\n   |\n6  |     let mut truncated: f32 =\
    \ 0.0;\n   |         ~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `saturating_add`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmp58mhxy79.rs:15:31\n   |\n\
    15 |         remainder = remainder.saturating_add(digit * 10.0);\n   |       \
    \                        ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `f32`\n   |\n7  |     let mut remainder: f32 = 0.0;\n   |\
    \         ~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `saturating_add`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmp58mhxy79.rs:18:15\n   |\n\
    18 |     truncated.saturating_add(remainder).round() as f64\n   |            \
    \   ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `f32`\n   |\n6  |     let mut truncated: f32 = 0.0;\n "
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        integer_part\
    \ += number.digit(exponent - 1) as f64;\n        remainder += number.digit(exponent\
    \ - 1);\n        exponent = exponent - 1;\n    }\n    integer_part += remainder;\n\
    \    decimal_part = number.digit(exponent);\n    integer_part / f64::from(f64::from(decimal_part))\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpbutbylu5.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `digit` found for type `f64` in the current scope\n  --> /tmp/tmpbutbylu5.rs:11:32\n\
    \   |\n11 |         integer_part += number.digit(exponent - 1) as f64;\n   | \
    \                               ^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `digit` found for type `f64` in the current scope\n  --> /tmp/tmpbutbylu5.rs:12:29\n\
    \   |\n12 |         remainder += number.digit(exponent - 1);\n   |           \
    \                  ^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `digit` found for type `f64` in the current scope\n  --> /tmp/tmpbutbylu5.rs:16:27\n\
    \   |\n16 |     decimal_part = number.digit(exponent);\n   |                 \
    \          ^^^^^ method not found in `f64`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    while\
    \ number > 0.0 {\n        remainder = number % 10.0;\n        integer_part +=\
    \ remainder;\n        decimal_part += remainder;\n        number /= 10.0;\n  \
    \  }\n    integer_part += 0.0;\n    decimal_part += 0.0;\n    integer_part + decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `remainder` is never read\n --> /tmp/tmp7ql2rnqk.rs:8:13\n\
    \  |\n8 |     let mut remainder = 0.0;\n  |             ^^^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_assignments)]` on by default\n  = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `number`\n\
    \  --> /tmp/tmp7ql2rnqk.rs:13:9\n   |\n5  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n13 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpk7pwenbo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals: f64\
    \ = number.floor();\n    let mut remainder: f64 = number.fract();\n    while remainder\
    \ > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n    }\n    decimals\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp3qaqp_aj.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpk7pwenbo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749622
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut sign = 1.0;\n\n    if number < 0.0 {\n        sign = -1.0;\n        number\
    \ = -number;\n    }\n\n    if number == 0.0 {\n        return 0.0;\n    }\n\n\
    \    if number < 1.0 {\n        integer_part = number;\n        remainder = 0.0;\n\
    \    } else {\n        let mut tmp = number;\n        integer_part = 0.0;\n  \
    \      remainder = 0.0;\n        while tmp != 0.0 {\n            integer_part\
    \ += tmp % 10.0;\n            remainder += tmp / 10.0;\n            tmp /= 10.0;\n\
    \        }\n    }\n\n    decimal_part = remainder;\n    decimal_part *= sign;\n\
    \n    integer_part + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `decimal_part` is never read\n --> /tmp/tmpzgxihyao.rs:6:13\n\
    \  |\n6 |     let mut decimal_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_assignments)]` on by default\n  = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `integer_part`\
    \ is never read\n --> /tmp/tmpzgxihyao.rs:7:13\n  |\n7 |     let mut integer_part\
    \ = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n  = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `remainder` is never read\n\
    \ --> /tmp/tmpzgxihyao.rs:8:13\n  |\n8 |     let mut remainder = 0.0;\n  |   \
    \          ^^^^^^^^^\n  |\n  = help: maybe it is overwritten before being read?\n\
    \nerror[E0384]: cannot assign to immutable argument `number`\n  --> /tmp/tmpzgxihyao.rs:13:9\n\
    \   |\n5  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n13 | \
    \        number = -number;\n   |         ^^^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        leftover_part\
    \ += 1.0;\n        remainder -= 1.0;\n    }\n    while remainder > 0.0 {\n   \
    \     integer_part += 1.0;\n        remainder -= 0.0;\n    }\n    integer_part\
    \ += leftover_part;\n    decimal_part = remainder;\n    integer_part * f64::from(f64::from(decimal_part))\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976557
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        remainder += 1.0;\n\
    \        integer += remainder;\n        decimals += remainder;\n        remainder\
    \ /= 10.0;\n        exponent--;\n    }\n    decimals\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp2xvfjvu5.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp2xvfjvu5.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut exponent = number.floor() as i32;\n    let mut remainder = number.floor()\
    \ as f64;\n    while exponent > 0 {\n        remainder *= 10.0;\n        decimals\
    \ += remainder as f64;\n        remainder -= decimals as f64;\n        exponent\
    \ -= 1;\n    }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-270.0`,\n right: `0.5`', /tmp/tmpez836e2k.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut integer_part);\n        decimal_part += integer_part\
    \ * std::powf(10.0, exponent);\n        integer_part = 0.0;\n        exponent--;\n\
    \    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmph52ga8gn.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find function `powf` in crate `std`\n  --> /tmp/tmph52ga8gn.rs:12:45\n\
    \   |\n12 |         decimal_part += integer_part * std::powf(10.0, exponent);\n\
    \   |                                             ^^^^ not found in `std`\n\n\
    error[E0599]: no method named `exponent` found for type `f64` in the current scope\n\
    \ --> /tmp/tmph52ga8gn.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmph52ga8gn.rs:11:29\n   |\n11 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    decimal_part +\
    \ remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmptufvzzh0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = number;\n    while remainder\
    \ > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n    }\n    while\
    \ remainder > 0.0 {\n        integer += remainder;\n        remainder -= 0.0;\n\
    \    }\n    integer + decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976557
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        decimal_part += remainder\
    \ * number.next_exponent();\n        exponent--;\n    }\n    integer_part + decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpinf9mb17.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpinf9mb17.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `next_exponent` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpinf9mb17.rs:13:44\n   |\n13 |         decimal_part += remainder\
    \ * number.next_exponent();\n   |                                            ^^^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal = f64::MIN;\n\
    \    let mut remainder = f64::MIN;\n    let mut exponent = 0;\n    let mut mantissa\
    \ = number.abs();\n\n    while mantissa > f64::EPSILON {\n        let mantissa\
    \ = mantissa / 10.0;\n        exponent = exponent + 1;\n        remainder = remainder\
    \ * 10.0;\n    }\n\n    if exponent > 0 {\n        decimal = remainder / f64::pow(10.0,\
    \ exponent);\n    }\n\n    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `pow` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpqx23xy53.rs:18:36\n   |\n18 |    \
    \     decimal = remainder / f64::pow(10.0, exponent);\n   |                  \
    \                  ^^^\n   |                                    |\n   |      \
    \                              function or associated item not found in `f64`\n\
    \   |                                    help: there is an associated function\
    \ with a similar name: `powf`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n\n  \
    \  while number > 0.0 {\n        integer_part += number % 10.0;\n        number\
    \ /= 10.0;\n        remainder += number;\n    }\n\n    integer_part += remainder;\n\
    \    decimal_part = number - integer_part;\n\n    integer_part as f64\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `decimal_part` is assigned to, but never used\n --> /tmp/tmpnk20mt52.rs:6:13\n\
    \  |\n6 |     let mut decimal_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using\
    \ `_decimal_part` instead\n\nwarning: value assigned to `decimal_part` is never\
    \ read\n  --> /tmp/tmpnk20mt52.rs:17:5\n   |\n17 |     decimal_part = number -\
    \ integer_part;\n   |     ^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmpnk20mt52.rs:12:9\n\
    \   |\n5  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n12 | \
    \        number /= 10.0;\n   |         ^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = 0;\n    let mut\
    \ sign = 1.0;\n    let mut mantissa = number;\n    while mantissa > 0.0 {\n  \
    \      remainder += 1.0;\n        mantissa /= 10.0;\n        exponent++;\n   \
    \ }\n    if mantissa > 0.0 {\n        decimal_part = mantissa;\n    } else {\n\
    \        sign = -1.0;\n        mantissa = -mantissa;\n    }\n    sign * remainder\
    \ * 10.0 ** exponent\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpu1886z6m.rs:14:17\n\
    \   |\n14 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n14 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n14 -\
    \         exponent++;\n14 +         exponent += 1;\n   | \n\nerror[E0614]: type\
    \ `{integer}` cannot be dereferenced\n  --> /tmp/tmpu1886z6m.rs:22:30\n   |\n\
    22 |     sign * remainder * 10.0 ** exponent\n   |                           \
    \   ^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder_exponent = exponent as i32;\n    while remainder_exponent\
    \ > 0 {\n        let mut remainder_part = remainder * 10.0;\n        remainder\
    \ += remainder_part;\n        remainder_exponent -= 1;\n    }\n    decimal_part\
    \ += remainder;\n    decimal_part / 10.0\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.0`,\n right: `0.5`', /tmp/tmpwdh2o75b.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += 1.0;\n        decimal_part += remainder * f64::from(integer_part);\n\
    \        exponent -= 1;\n    }\n    integer_part += remainder;\n    decimal_part\
    \ * f64::from(integer_part)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpfyy_k9yx.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder_exponent = number.floor() as i32;\n\n    while\
    \ exponent > 0 {\n        let mut next_exponent = exponent - 1;\n        let mut\
    \ next_remainder = remainder;\n\n        while next_exponent > 0 {\n         \
    \   next_exponent -= 1;\n            next_remainder = next_remainder.saturating_sub(f64::powf(10.0,\
    \ next_exponent));\n        }\n\n        decimal_part += next_remainder;\n   \
    \     remainder = remainder.saturating_sub(f64::powf(10.0, exponent));\n     \
    \   exponent = next_exponent;\n    }\n\n    decimal_part + remainder\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `saturating_sub` on ambiguous numeric type\
    \ `{float}`\n  --> /tmp/tmpx32tbn87.rs:17:45\n   |\n17 |             next_remainder\
    \ = next_remainder.saturating_sub(f64::powf(10.0, next_exponent));\n   |     \
    \                                        ^^^^^^^^^^^^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `f32`\n   |\n13 |         let mut next_remainder:\
    \ f32 = remainder;\n   |             ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx32tbn87.rs:17:76\n   |\n17 |             next_remainder\
    \ = next_remainder.saturating_sub(f64::powf(10.0, next_exponent));\n   |     \
    \                                                                       ^^^^^^^^^^^^^\
    \ expected `f64`, found `i32`\n   |\nhelp: you can convert an `i32` to an `f64`,\
    \ producing the floating point representation of the integer\n   |\n17 |     \
    \        next_remainder = next_remainder.saturating_sub(f64::powf(10.0, next_exponent.into()));\n\
    \   |                                                                        \
    \                 +++++++\n\nerror[E0689]: can't call method `saturating_sub`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmpx32tbn87.rs:21:31\n   |\n\
    21 |         remainder = remainder.saturating_sub(f64::powf(10.0, exponent));\n\
    \   |                               ^^^^^^^^^^^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `f32`\n   |\n7  |     let mut remainder: f32 =\
    \ 0.0;\n   |         ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpx32tbn87.rs:21:62\n   |\n21 |         remainder = remainder.saturating_sub(f64::powf(10.0,\
    \ exponent));\n   |                                                          \
    \    ^^^^^^^^ expected `f64`, found `i32`\n   |\nhelp: you can convert an `i32`\
    \ to an `f64`, producing the floating point representation of the integer\n  \
    \ |\n21 |         remainder = remainder.saturating_sub(f64::powf(10.0, exponent.into()));\n\
    \   |                                                                      +++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed expla"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    let mut mantissa = number.mantissa();\n    while exponent > 0 {\n       \
    \ remainder += mantissa * 10.0;\n        mantissa *= 10.0;\n        exponent--;\n\
    \    }\n    decimal_part += remainder;\n    decimal_part / 10.0\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3w4231t6.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3w4231t6.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmp3w4231t6.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.exponent();\n    while exponent > 0 {\n        remainder += 1.0;\n\
    \        integer += remainder;\n        remainder /= 10.0;\n        decimal +=\
    \ 1.0;\n        exponent--;\n    }\n    number - integer * decimal\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpgc57rivf.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find value `decimal` in this scope\n  --> /tmp/tmpgc57rivf.rs:14:9\n\
    \   |\n14 |         decimal += 1.0;\n   |         ^^^^^^^ help: a local variable\
    \ with a similar name exists: `decimals`\n\nerror[E0425]: cannot find value `decimal`\
    \ in this scope\n  --> /tmp/tmpgc57rivf.rs:17:24\n   |\n17 |     number - integer\
    \ * decimal\n   |                        ^^^^^^^ help: a local variable with a\
    \ similar name exists: `decimals`\n\nerror[E0599]: no method named `exponent`\
    \ found for type `f64` in the current scope\n --> /tmp/tmpgc57rivf.rs:9:31\n \
    \ |\n9 |     let mut exponent = number.exponent();\n  |                      \
    \         ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut sign = 1.0;\n    let mut exponent = 1.0;\n    let mut mantissa =\
    \ 1.0;\n    let mut max_mantissa = 1.0;\n    let mut min_mantissa = 1.0;\n   \
    \ let mut max_exponent = 1.0;\n    let mut min_exponent = 1.0;\n    let mut max_integer\
    \ = 0.0;\n    let mut min_integer = 0.0;\n    let mut max_leftover_part = 0.0;\n\
    \    let mut min_leftover_part = 0.0;\n    let mut max_decimal = 0.0;\n    let\
    \ mut min_decimal = 0.0;\n    let mut max_exponent = 1.0;\n    let mut min_exponent\
    \ = 1.0;\n    let mut max_number = 0.0;\n    let mut min_number = 0.0;\n    let\
    \ mut max_leftover_part = 0.0;\n    let mut min_leftover_part = 0.0;\n    let\
    \ mut max_decimal = 0.0;\n    let mut min_decimal = 0.0;\n    let mut max_exponent\
    \ = 1.0;\n    let mut min_exponent = 1.0;\n    let mut max_number = 0.0;\n   \
    \ let mut min_number = 0.0;\n    let mut max_leftover_part = 0.0;\n    let mut\
    \ min_leftover_part = 0.0;\n    let mut max_decimal = 0.0;\n    let mut min_decimal\
    \ = 0.0;\n    let mut max_exponent = 1.0;\n    let mut min_exponent = 1.0;\n \
    \   let mut max_number = 0.0;\n    let mut min_number = 0.0;\n    let mut max_leftover_part\
    \ = 0.0;\n    let mut min_leftover_part = 0.0;\n    let mut max_decimal = 0.0;\n\
    \    let mut min_decimal = 0.0;\n    let mut max_exponent = 1.0;\n    let mut\
    \ min_exponent = 1.0;\n    let mut max_number = 0.0;\n    let mut min_number =\
    \ 0.0;\n    let mut max_leftover_part = 0.0;\n    let mut min_leftover_part =\
    \ 0.0;\n    let mut max_decimal = 0.0;\n    let mut min_decimal = 0.0;\n    let\
    \ mut max_exponent = 1.0;\n    let mut min_exponent = 1.0;\n    let mut max_number\
    \ = 0.0;\n    let mut min_number = 0.0;\n    let mut max_leftover_part = 0.0;\n\
    \    let mut min_leftover_part = 0.0;\n    let mut max_decimal = 0.0;\n    let\
    \ mut min_decimal = 0.0;\n    let mut max_\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprvs7wt6a.rs:62:17\n   |\n\
    62 |     let mut max_\n   |                 ^ help: add `;` here\n63 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmprvs7wt6a.rs:5:36\n\
    \  |\n5 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------   \
    \              ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 0.0 {\n        let mut\
    \ temp = remainder;\n        integer_part += temp;\n        leftover_part += temp;\n\
    \        remainder -= temp;\n        decimal_part += temp;\n    }\n    integer_part\
    \ += leftover_part;\n    decimal_part + integer_part\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10.5`,\n right: `0.5`', /tmp/tmpppdnyczt.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    while exponent > 0 {\n        if exponent % 2 == 1 {\n            decimal_part\
    \ += remainder;\n        }\n        remainder *= 10.0;\n        exponent /= 2;\n\
    \    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpipvwphp1.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut truncated = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += 1.0 * number.remainder(&mut truncated);\n\
    \        truncated = remainder;\n        exponent--;\n    }\n    truncated\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpch7wa3sa.rs:12:19\n\
    \   |\n12 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpch7wa3sa.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpch7wa3sa.rs:10:35\n   |\n10 |         remainder += 1.0 * number.remainder(&mut\
    \ truncated);\n   |                                   ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.is_negative()\
    \ ? 1 : 0;\n    while number >= 1.0 {\n        number -= 1.0;\n        decimal_part\
    \ += 1.0;\n        remainder += 1.0;\n    }\n    while number > 0.0 {\n      \
    \  number -= 1.0;\n        decimal_part += 1.0;\n        remainder += 1.0;\n \
    \       exponent += 1;\n    }\n    exponent -= 1;\n    decimal_part *= 10.0;\n\
    \    remainder *= 10.0;\n    decimal_part += remainder;\n    decimal_part / 10.0\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n\
    \ --> /tmp/tmpp2bngr0s.rs:8:47\n  |\n8 |     let mut exponent = number.is_negative()\
    \ ? 1 : 0;\n  |                                               ^ expected one of\
    \ `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut last_digit = number.floor() as i32;\n    loop {\n     \
    \   if exponent == 0 {\n            break;\n        }\n        let mut digit =\
    \ last_digit as i32;\n        last_digit = digit / 10;\n        decimal_part +=\
    \ digit % 10 * (remainder as f64 / 10.0);\n        remainder *= 10.0;\n      \
    \  exponent--;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp0_a49k6f.rs:18:19\n\
    \   |\n18 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0277]: cannot multiply `i32` by `f64`\n  --> /tmp/tmp0_a49k6f.rs:16:36\n\
    \   |\n16 |         decimal_part += digit % 10 * (remainder as f64 / 10.0);\n\
    \   |                                    ^ no implementation for `i32 * f64`\n\
    \   |\n   = help: the trait `Mul<f64>` is not implemented for `i32`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n   \
    \ let mut mantissa = number.f64::mantissa();\n    while exponent > 0 {\n     \
    \   remainder += mantissa;\n        mantissa *= 10.0;\n        exponent--;\n \
    \   }\n    result += remainder;\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmprs5x_p98.rs:8:41\n  |\n8 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n8 |     let mut exponent\
    \ = number.f64::exp(), let mut mantissa = number.f64::mantissa();\n  |       \
    \                                  ~\n\nerror: expected one of `!`, `+`, `,`,\
    \ `->`, `::`, `:`, `=`, or `>`, found `;`\n --> /tmp/tmprs5x_p98.rs:9:46\n  |\n\
    9 |     let mut mantissa = number.f64::mantissa();\n  |                      \
    \                        ^ expected one of 8 possible tokens\n  |\nhelp: use a\
    \ comma to separate type parameters\n  |\n9 |     let mut mantissa = number.f64::mantissa(),\
    \ while exponent > 0 {\n  |                                              ~\n\n\
    error: expected expression, found `;`\n  --> /tmp/tmprs5x_p98.rs:13:19\n   |\n\
    13 |         exponent--;\n   |                   ^ expected expression\n\nerror:\
    \ invalid const generic expression\n  --> /tmp/tmprs5x_p98.rs:10:5\n   |\n10 |\
    \ /     while exponent > 0 {\n11 | |         remainder += mantissa;\n12 | |  \
    \       mantissa *= 10.0;\n13 | |         exponent--;\n14 | |     }\n   | |_____^\n\
    \   |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n   |\n10 ~     { while exponent > 0 {\n11 |         remainder +=\
    \ mantissa;\n12 |         mantissa *= 10.0;\n13 |         exponent--;\n14 ~  \
    \   } }\n   |\n\nerror: invalid const generic expression\n --> /tmp/tmprs5x_p98.rs:9:5\n\
    \  |\n9 |     let mut mantissa = number.f64::mantissa();\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n  |\n9 |     { let mut mantissa = number.f64 }::mantissa();\n  |\
    \     +                               +\n\nerror: expected one of `(`, `.`, `;`,\
    \ `?`, `else`, or an operator, found `::`\n --> /tmp/tmprs5x_p98.rs:8:34\n  |\n\
    8 |     let mut exponent = number.f64::exp();\n  |                           \
    \       ^^ expected one of `(`, `.`, `;`, "
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    let mut mantissa = number.mantissa();\n\n    while exponent > 0 {\n     \
    \   if exponent % 2 == 1 {\n            mantissa /= 10.0;\n        }\n       \
    \ mantissa *= 10.0;\n        exponent /= 2;\n    }\n\n    while mantissa.abs()\
    \ > 1.0e-6 {\n        mantissa *= 10.0;\n        decimal_part += 1.0;\n    }\n\
    \n    remainder = mantissa.abs();\n\n    if remainder < 1.0e-6 {\n        decimal_part\
    \ += 1.0;\n    }\n\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp0s7oc66v.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmp0s7oc66v.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\
    \    let mut mantissa = number.mantissa();\n    while exponent > 0 {\n       \
    \ remainder += mantissa;\n        mantissa = mantissa * 10.0;\n        exponent--;\n\
    \    }\n    decimal_part += remainder;\n    decimal_part / 10.0\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp10ec72ia.rs:13:19\n\
    \   |\n13 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp10ec72ia.rs:8:31\n  |\n8 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n --> /tmp/tmp10ec72ia.rs:9:31\n\
    \  |\n9 |     let mut mantissa = number.mantissa();\n  |                     \
    \          ^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976552
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimals = 0.0;\n\
    \    let mut integer = 0.0;\n    let mut remainder = 0.0;\n    while number >\
    \ 0.0 {\n        remainder = number % 10.0;\n        integer = integer + remainder;\n\
    \        decimals = decimals + remainder;\n        number = number / 10.0;\n \
    \   }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `remainder` is never read\n --> /tmp/tmpnauzqy9z.rs:8:13\n\
    \  |\n8 |     let mut remainder = 0.0;\n  |             ^^^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_assignments)]` on by default\n  = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `number`\n\
    \  --> /tmp/tmpnauzqy9z.rs:13:9\n   |\n5  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n13 |         number = number / 10.0;\n   |         ^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976551
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        integer_part\
    \ += number.mantissa() * (f64::powf(10.0, exponent) - f64::powf(10.0, exponent\
    \ - 1));\n        decimal_part += number.mantissa() * (f64::powf(10.0, exponent\
    \ - 1) - f64::powf(10.0, exponent));\n        remainder += number.mantissa();\n\
    \        exponent--;\n    }\n    integer_part += remainder;\n    decimal_part\
    \ += remainder;\n    integer_part / f64::powf(10.0, exponent)\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpy652hc_g.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpy652hc_g.rs:9:31\n  |\n9 |     let mut exponent = number.exponent();\n\
    \  |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpy652hc_g.rs:11:32\n   |\n11 |         integer_part += number.mantissa()\
    \ * (f64::powf(10.0, exponent) - f64::powf(10.0, exponent - 1));\n   |       \
    \                         ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmpy652hc_g.rs:10:20\n   |\n\
    10 |     while exponent > 0 {\n   |                    ^ no implementation for\
    \ `f64 < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n10 |     while exponent > 0.0 {\n   |\
    \                       ++\n\nerror[E0277]: cannot subtract `{integer}` from `f64`\n\
    \  --> /tmp/tmpy652hc_g.rs:11:99\n   |\n11 |         integer_part += number.mantissa()\
    \ * (f64::powf(10.0, exponent) - f64::powf(10.0, exponent - 1));\n   |       \
    \                                                                            \
    \                ^ no implementation for `f64 - {integer}`\n   |\n   = help: the\
    \ trait `Sub<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'"
  stdout: ''
  timestamp: 1659976552
