language: rs
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_count = std::collections::HashSet::new();\n   \
    \ let mut max_word = String::new();\n    for word in words {\n        let mut\
    \ count = std::collections::HashSet::new();\n        for c in word.chars() {\n\
    \            count.insert(*c);\n        }\n        if count.len() > max_count.len()\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp_6kznief.rs:11:26\n\
    \   |\n11 |             count.insert(*c);\n   |                          ^^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_chars = String::new();\n    let mut max_word =\
    \ String::new();\n    let mut max_word_len = String::new();\n    for word in words\
    \ {\n        let mut chars = String::new();\n        for char in word.chars()\
    \ {\n            chars.push_str(char);\n        }\n        if chars.len() > max_chars.len()\
    \ {\n            max_chars = chars;\n            max_word = word;\n          \
    \  max_word_len = word.len();\n        }\n    }\n    if max_chars.len() == max_word_len\
    \ {\n        max_word\n    } else {\n        find_max(vec![max_word, String::new()])\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwfc_xykx.rs:12:28\n   |\n\
    12 |             chars.push_str(char);\n   |                            ^^^^ expected\
    \ `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwfc_xykx.rs:17:28\n\
    \   |\n17 |             max_word_len = word.len();\n   |                     \
    \       ^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                            |\n   |                            expected struct\
    \ `String`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwfc_xykx.rs:20:27\n\
    \   |\n20 |     if max_chars.len() == max_word_len {\n   |                   \
    \        ^^^^^^^^^^^^ expected `usize`, found struct `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_count = std::collections::HashSet::new();\n   \
    \ let mut max_word = String::new();\n    for word in words {\n        let count\
    \ = word.chars().filter(|c| !c.is_whitespace()).count();\n        if count > max_count.len()\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfmhl1kry.rs:11:25\n   |\n\
    11 |             max_count = count;\n   |                         ^^^^^ expected\
    \ struct `HashSet`, found `usize`\n   |\n   = note: expected struct `HashSet<_>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_count = words[0].chars().count();\n    let mut\
    \ max_word = words[0];\n    for word in words.iter() {\n        let count = word.chars().count();\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5sg4fvd_.rs:12:24\n   |\n\
    12 |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_count = words.iter().map(|word| word.chars().count()).max().unwrap();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_index = words.iter().filter(|word| word.chars().count() == max_count).count();\n\
    \    let mut max_word = words.iter().filter(|\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `|`, found `)`\n  --> /tmp/tmpmsu_ulgz.rs:28:1\n   |\n\
    27 |     let mut max_word = words.iter().filter(|\n   |                      \
    \                       - expected `|`\n28 | }\n   | ^ unexpected token\n\nerror:\
    \ mismatched closing delimiter: `}`\n  --> /tmp/tmpmsu_ulgz.rs:27:43\n   |\n5\
    \  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \                    - closing delimiter possibly meant for this\n...\n27 |  \
    \   let mut max_word = words.iter().filter(|\n   |                           \
    \                ^ unclosed delimiter\n28 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut counters = HashMap::new();\n    for word in words {\n\
    \        for c in word.chars() {\n            counters.entry(c).or_insert(0) +=\
    \ 1;\n        }\n    }\n    let mut max_counters = counters.clone();\n    let\
    \ mut max_key = String::new();\n    for (_, v) in max_counters.iter_mut() {\n\
    \        if v > max_counters.len() {\n            max_counters = HashMap::new();\n\
    \            max_key = String::new();\n        }\n        max_key = max_key.to_string();\n\
    \    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpwcitfnkk.rs:6:24\n  |\n6 |     let mut counters = HashMap::new();\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpwcitfnkk.rs:16:28\n\
    \   |\n16 |             max_counters = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n --> /tmp/tmpwcitfnkk.rs:9:44\n  |\n9 |      \
    \       counters.entry(c).or_insert(0) += 1;\n  |             ------------------------------\
    \ ^^\n  |             |\n  |             cannot assign to this expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut counter = HashMap::new();\n    for word in words {\n\
    \        for c in word.chars() {\n            counter.entry(c).or_insert(0) +=\
    \ 1;\n        }\n    }\n    let mut max_key = String::new();\n    let mut max_value\
    \ = counter.iter().max().unwrap();\n    for (_, value) in counter {\n        if\
    \ value == max_value {\n            max_key = String::from(\"\\\"\");\n      \
    \  }\n    }\n    max_key.push_str(\"\\\"\");\n    max_key\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp42v8rebq.rs:6:23\n  |\n6 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n --> /tmp/tmp42v8rebq.rs:9:43\n  |\n9\
    \ |             counter.entry(c).or_insert(0) += 1;\n  |             -----------------------------\
    \ ^^\n  |             |\n  |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut counters = HashMap::new();\n    for word in words {\n\
    \        for c in word.chars() {\n            counters.entry(c).or_insert(0) +=\
    \ 1;\n        }\n    }\n    let mut max_counters = counters.clone();\n    let\
    \ mut max_key = String::new();\n    for (_, v) in max_counters.iter() {\n    \
    \    if v > max_counters.get(&max_key).unwrap() {\n            max_counters.insert(max_key,\
    \ v);\n            max_key = String::new();\n        }\n    }\n    max_key\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpbn2balu0.rs:6:24\n  |\n6 |     let mut counters = HashMap::new();\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n --> /tmp/tmpbn2balu0.rs:9:44\n  |\n9\
    \ |             counters.entry(c).or_insert(0) += 1;\n  |             ------------------------------\
    \ ^^\n  |             |\n  |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut counters = HashMap::new();\n    for word in words {\n\
    \        for c in word.chars() {\n            counters.entry(c).or_insert(0) +=\
    \ 1;\n        }\n    }\n    let mut max_counters = counters.clone();\n    let\
    \ mut max_word = String::new();\n    for c in max_counters.keys() {\n        if\
    \ max_counters[c] > max_counters.len() {\n            max_counters = HashMap::new();\n\
    \            max_word = String::new();\n        }\n        if max_counters[c]\
    \ > 0 {\n            max_counters.entry(c).or_insert(0) -= 1;\n            if\
    \ max_counters[c] == 0 {\n                max_word = word;\n            }\n  \
    \      }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpn2tpa2je.rs:6:24\n  |\n6 |     let mut counters = HashMap::new();\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpn2tpa2je.rs:16:28\n\
    \   |\n16 |             max_counters = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]: cannot\
    \ find value `word` in this scope\n  --> /tmp/tmpn2tpa2je.rs:22:28\n   |\n22 |\
    \                 max_word = word;\n   |                            ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n --> /tmp/tmpn2tpa2je.rs:9:44\n  |\n9 |      \
    \       counters.entry(c).or_insert(0) += 1;\n  |             ------------------------------\
    \ ^^\n  |             |\n  |             cannot assign to this expression\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpn2tpa2je.rs:20:48\n\
    \   |\n20 |             max_counters.entry(c).or_insert(0) -= 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut counters = HashMap::new();\n    for word in words {\n\
    \        for c in word.chars() {\n            counters.entry(c).or_insert(0) +=\
    \ 1;\n        }\n    }\n    let mut max_counters = counters.clone();\n    let\
    \ mut max_word = String::new();\n    let mut max_word_len = String::new();\n \
    \   for c in max_counters.keys() {\n        if max_counters[c] > max_counters.len()\
    \ {\n            max_counters = HashMap::new();\n            max_word = String::new();\n\
    \            max_word_len = String::new();\n        }\n        if max_counters[c]\
    \ > max_counters.len() {\n            max_counters = HashMap::new();\n       \
    \     max_word = String::new();\n            max_word_len = String::new();\n \
    \       }\n        if max_counters[c] > max_counters.len() {\n            max_counters\
    \ = HashMap::new();\n            max_word = String::new();\n            max_word_len\
    \ = String::new();\n        }\n        if max_counters[c] > max_counters.len()\
    \ {\n            max_counters = HashMap::new();\n            max_word = String::new();\n\
    \            max_word_len = String::new();\n        }\n        if max_counters[c]\
    \ > max_counters.len() {\n            max_counters = HashMap::new();\n       \
    \     max_word = String::new();\n            max_word_len = String::new();\n \
    \       }\n        if max_counters[c] > max_counters.len() {\n            max_counters\
    \ = HashMap::new();\n            max_word = String::new();\n            max_word_len\
    \ = String::new();\n        }\n        if max_counters[c] > max_counters.len()\
    \ {\n            max_counters = HashMap::new();\n            max_word = String::new();\n\
    \            max_word_len = String::new();\n        }\n        if max_counters[c]\
    \ > max_counters.len() {\n            max_counters = HashMap::new();\n       \
    \     max_word = String::new();\n            max_word_len = String::new();\n \
    \       }\n        if max_counters[c] > max_counters.len() {\n            max_counters\
    \ = HashMap::new();\n            max_word = String::new();\n            max_word_len\
    \ = String::new();\n        }\n        if max_counters[c] > max_counters.len()\
    \ {\n            max_counters = HashMap::new();\n            max_word = String::new();\n\
    \            max_word_len = String::new();\n        }\n        if max_counters[c]\
    \ > max_counters.len() {\n            max_counters = HashMap::new();\n       \
    \     max_word = String::new();\n            max_word_len = String::new();\n \
    \       }\n        if max_counters[c] > max_counters.len() {\n            max_counters\
    \ = Hash\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp12_xnnu5.rs:87:3\n\
    \   |\n5  | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                           - unclosed delimiter\n...\n15 |     for c in max_counters.keys()\
    \ {\n   |                                  - unclosed delimiter\n...\n71 |   \
    \      if max_counters[c] > max_counters.len() {\n   |                       \
    \                          - this delimiter might not be properly closed...\n\
    72 |             max_counters = Hash\n73 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n87 | }\n   |   ^\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmp12_xnnu5.rs:6:24\n\
    \  |\n6 |     let mut counters = HashMap::new();\n  |                        ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashMap;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmp12_xnnu5.rs:17:28\n   |\n17 |  \
    \           max_counters = HashMap::new();\n   |                            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp12_xnnu5.rs:22:28\n   |\n22\
    \ |             max_counters = HashMap::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp12_xnnu5.rs:27:28\n   |\n27\
    \ |             max_counters = HashMap::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp12_xnnu5.rs:32:28\n   |\n32\
    \ |             max_counters = HashMap::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_count = words[0].chars().count();\n    let mut\
    \ max_word = words[0];\n    for word in words.iter() {\n        let count = word.chars().count();\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5sg4fvd_.rs:12:24\n   |\n\
    12 |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut counter = HashMap::new();\n    for word in words {\n\
    \        for c in word.chars() {\n            counter.entry(c).or_insert(0) +=\
    \ 1;\n        }\n    }\n    let mut max_key = String::new();\n    let mut max_value\
    \ = counter.iter().max().unwrap();\n    for (_, value) in counter {\n        if\
    \ value == max_value {\n            max_key = String::from(char::from(u8::from(c)));\n\
    \        }\n    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpftw2kmwy.rs:6:23\n  |\n6 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmpftw2kmwy.rs:16:56\n   |\n\
    16 |             max_key = String::from(char::from(u8::from(c)));\n   |      \
    \                                                  ^ not found in this scope\n\
    \nerror[E0067]: invalid left-hand side of assignment\n --> /tmp/tmpftw2kmwy.rs:9:43\n\
    \  |\n9 |             counter.entry(c).or_insert(0) += 1;\n  |             -----------------------------\
    \ ^^\n  |             |\n  |             cannot assign to this expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_chars = String::new();\n    let mut max_word =\
    \ String::new();\n    for word in words {\n        let mut chars = String::new();\n\
    \        for char in word.chars() {\n            chars.push_str(char);\n     \
    \   }\n        if chars.len() > max_chars.len() {\n            max_chars = chars;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptqde2e4e.rs:11:28\n   |\n\
    11 |             chars.push_str(char);\n   |                            ^^^^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 101
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_count = words.iter().map(|word| word.chars().count()).max().unwrap();\n\
    \    let mut max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3yxbaf3v.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748600
- exit_code: 101
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_count = words.iter().map(|word| word.chars().count()).max().unwrap();\n\
    \    let mut max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3yxbaf3v.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748600
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut counters = HashMap::new();\n    for word in words {\n\
    \        for c in word.chars() {\n            counters.entry(c).or_insert(0) +=\
    \ 1;\n        }\n    }\n    let mut max_counters = counters.clone();\n    let\
    \ mut max_key = String::new();\n    for (key, val) in max_counters {\n       \
    \ if val > max_counters.len() {\n            max_counters = HashMap::new();\n\
    \            max_key = key;\n        }\n    }\n    max_key\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp0zh8xcdi.rs:6:24\n  |\n6 |     let mut counters = HashMap::new();\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp0zh8xcdi.rs:16:28\n\
    \   |\n16 |             max_counters = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n --> /tmp/tmp0zh8xcdi.rs:9:44\n  |\n9 |      \
    \       counters.entry(c).or_insert(0) += 1;\n  |             ------------------------------\
    \ ^^\n  |             |\n  |             cannot assign to this expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut counter = HashMap::new();\n    for word in words {\n\
    \        for c in word.chars() {\n            counter.entry(c).or_insert(0) +=\
    \ 1;\n        }\n    }\n    let mut max_key = String::new();\n    let mut max_value\
    \ = counter.iter().max_by_key(|&(_, v)| v);\n    while let Some(key) = max_value\
    \ {\n        if counter[key] == max_value.1 {\n            max_value = counter.iter().max_by_key(|&(_,\
    \ v)| v);\n        } else {\n            max_key = key;\n            max_value\
    \ = counter.iter().max_by_key(|&(_, v)| v);\n        }\n    }\n    max_key\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp4ge24nnq.rs:6:23\n  |\n6 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n --> /tmp/tmp4ge24nnq.rs:9:43\n  |\n9\
    \ |             counter.entry(c).or_insert(0) += 1;\n  |             -----------------------------\
    \ ^^\n  |             |\n  |             cannot assign to this expression\n\n\
    error[E0609]: no field `1` on type `Option<_>`\n  --> /tmp/tmp4ge24nnq.rs:15:38\n\
    \   |\n15 |         if counter[key] == max_value.1 {\n   |                   \
    \                   ^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0067, E0433, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_count = words.iter().map(|word| word.chars().count()).max().unwrap();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).next();\n\
    \    while let Some(word) = max_word {\n        max_count = word.chars().count();\n\
    \        max_word = words.iter().filter(|word| word.chars().count() == max_count).next();\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxjr397pc.rs:12:5\n   |\n\
    5  | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n12 |     max_word\n\
    \   |     ^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<&String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut max_count = words.iter().map(|word| word.chars().count()).max().unwrap();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).max().unwrap();\n\
    \    let mut max_word = max_word.clone();\n    let mut max_count = words.iter().filter(|word|\
    \ word.chars().count() == max_count).count().unwrap();\n    loop {\n        if\
    \ max_count < words.iter().filter(|word| word.chars().count() == max_count).count()\
    \ {\n            max_word = words.iter().filter(|word| word.chars().count() ==\
    \ max_count).max().unwrap();\n            max_count = words.iter().filter(|word|\
    \ word.chars().count() == max_count).count().unwrap();\n        } else {\n   \
    \         break;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n --> /tmp/tmpxhhxqdbg.rs:9:95\n  |\n9 |     let mut max_count = words.iter().filter(|word|\
    \ word.chars().count() == max_count).count().unwrap();\n  |                  \
    \                                                                            \
    \ ^^^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxhhxqdbg.rs:12:24\n   |\n12 |             max_word = words.iter().filter(|word|\
    \ word.chars().count() == max_count).max().unwrap();\n   |                   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \      |\n   |                        expected struct `String`, found `&String`\n\
    \nerror[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpxhhxqdbg.rs:13:95\n   |\n13 |             max_count = words.iter().filter(|word|\
    \ word.chars().count() == max_count).count().unwrap();\n   |                 \
    \                                                                            \
    \  ^^^^^^ method not found in `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748599
- exit_code: 1
  program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\nfn find_max(words: Vec<String>)\
    \ -> String {\n    let mut counters = HashMap::new();\n    for word in words {\n\
    \        for c in word.chars() {\n            counters.entry(c).or_insert(0) +=\
    \ 1;\n        }\n    }\n    let mut max_counters = counters.clone();\n    let\
    \ mut max_key = String::new();\n    for (_, count) in max_counters.iter() {\n\
    \        if count > max_counters.get(&max_key).unwrap() {\n            max_counters.insert(max_key,\
    \ count);\n            max_key = String::new();\n        }\n    }\n    max_key\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpq_qrgvhx.rs:6:24\n  |\n6 |     let mut counters = HashMap::new();\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n --> /tmp/tmpq_qrgvhx.rs:9:44\n  |\n9\
    \ |             counters.entry(c).or_insert(0) += 1;\n  |             ------------------------------\
    \ ^^\n  |             |\n  |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748599
