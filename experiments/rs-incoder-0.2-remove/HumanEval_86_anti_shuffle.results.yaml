language: rs
name: HumanEval_86_anti_shuffle
results:
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.replace(\"a\", \"z\");\n    s.replace(\"\
    b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"d\", \"w\");\n   \
    \ s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n    s.replace(\"g\"\
    , \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\", \"r\");\n    s.replace(\"\
    j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"l\", \"o\");\n   \
    \ s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n    s.replace(\"o\"\
    , \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\", \"j\");\n    s.replace(\"\
    r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"t\", \"g\");\n   \
    \ s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n    s.replace(\"w\"\
    , \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\", \"b\");\n    s.replace(\"\
    z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpyx4yvdmd.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let\
    \ mut new_s_len5 = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let\
    \ mut new_s_len7 = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let\
    \ mut new_s_len9 = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let\
    \ mut new_s_len11 = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n   \
    \ let mut new_s_len13 = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n\
    \    let mut new_s_len15 = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n\
    \    let mut new_s_len17 = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n\
    \    let mut new_s_len19 = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n\
    \    let mut new_s_len21 = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n\
    \    let mut new_s_len23 = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n\
    \    let mut new_s_len25 = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n\
    \    let mut new_s_len27 = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n\
    \    let mut new_s_len29 = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n\
    \    let mut new_s_len31 = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n\
    \    let mut new_s_len33 = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n\
    \    let mut new_s_len35 = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n\
    \    let mut new_s_len37 = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n\
    \    let mut new_s_len39 = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp22sfetvu.rs:49:33\n   |\n\
    49 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp22sfetvu.rs:49:27\n   |\n49\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp22sfetvu.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) ->\
    \ String {\n  |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = String::new();\n        let mut new_word_len = 0;\n        for c\
    \ in word.chars() {\n            if c.is_ascii() {\n                new_word.push(c);\n\
    \                new_word_len += 1;\n            } else {\n                new_word.push(c.to_ascii_lowercase());\n\
    \                new_word_len += 2;\n            }\n        }\n        new_s.push_str(&new_word);\n\
    \        new_s.push_str(\" \");\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Hi \"`,\n right: `\"Hi\"`', /tmp/tmpx9wx4pup.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut\
    \ new_s_len5 = new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7\
    \ = new_s_len;\n    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 =\
    \ new_s_len;\n    let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 =\
    \ new_s_len;\n    let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 =\
    \ new_s_len;\n    let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 =\
    \ new_s_len;\n    let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 =\
    \ new_s_len;\n    let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 =\
    \ new_s_len;\n    let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 =\
    \ new_s_len;\n    let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 =\
    \ new_s_len;\n    let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 =\
    \ new_s_len;\n    let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 =\
    \ new_s_len;\n    let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 =\
    \ new_s_len;\n    let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 =\
    \ new_s_len;\n    let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 =\
    \ new_s_len;\n    let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 =\
    \ new_s_len;\n    let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 =\
    \ new_s_len;\n    let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 =\
    \ new_s_len;\n    let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 =\
    \ new_s_len;\n    let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 =\
    \ new_s_len;\n    let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 =\
    \ new_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplkj3xfo0.rs:54:31\n   |\n\
    54 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmplkj3xfo0.rs:54:27\n   |\n54 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmplkj3xfo0.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) -> String {\n\
    \  |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.replace(\"a\", \"z\");\n    s.replace(\"\
    b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"d\", \"w\");\n   \
    \ s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n    s.replace(\"g\"\
    , \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\", \"r\");\n    s.replace(\"\
    j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"l\", \"o\");\n   \
    \ s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n    s.replace(\"o\"\
    , \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\", \"j\");\n    s.replace(\"\
    r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"t\", \"g\");\n   \
    \ s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n    s.replace(\"w\"\
    , \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\", \"b\");\n    s.replace(\"\
    z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpyx4yvdmd.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut\
    \ new_s_len5 = new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7\
    \ = new_s_len;\n    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 =\
    \ new_s_len;\n    let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 =\
    \ new_s_len;\n    let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 =\
    \ new_s_len;\n    let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 =\
    \ new_s_len;\n    let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 =\
    \ new_s_len;\n    let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 =\
    \ new_s_len;\n    let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 =\
    \ new_s_len;\n    let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 =\
    \ new_s_len;\n    let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 =\
    \ new_s_len;\n    let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 =\
    \ new_s_len;\n    let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 =\
    \ new_s_len;\n    let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 =\
    \ new_s_len;\n    let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 =\
    \ new_s_len;\n    let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 =\
    \ new_s_len;\n    let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 =\
    \ new_s_len;\n    let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 =\
    \ new_s_len;\n    let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 =\
    \ new_s_len;\n    let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 =\
    \ new_s_len;\n    let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 =\
    \ new_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplkj3xfo0.rs:54:31\n   |\n\
    54 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmplkj3xfo0.rs:54:27\n   |\n54 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmplkj3xfo0.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) -> String {\n\
    \  |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    let mut new_words = new_s.split_whitespace();\n\
    \    let mut new_words_len = 0;\n    let mut new_words_len2 = 0;\n    let mut\
    \ new_words_len3 = 0;\n    let mut new_words_len4 = 0;\n    let mut new_words_len5\
    \ = 0;\n    let mut new_words_len6 = 0;\n    let mut new_words_len7 = 0;\n   \
    \ let mut new_words_len8 = 0;\n    let mut new_words_len9 = 0;\n    let mut new_words_len10\
    \ = 0;\n    let mut new_words_len11 = 0;\n    let mut new_words_len12 = 0;\n \
    \   let mut new_words_len13 = 0;\n    let mut new_words_len14 = 0;\n    let mut\
    \ new_words_len15 = 0;\n    let mut new_words_len16 = 0;\n    let mut new_words_len17\
    \ = 0;\n    let mut new_words_len18 = 0;\n    let mut new_words_len19 = 0;\n \
    \   let mut new_words_len20 = 0;\n    let mut new_words_len21 = 0;\n    let mut\
    \ new_words_len22 = 0;\n    let mut new_words_len23 = 0;\n    let mut new_words_len24\
    \ = 0;\n    let mut new_words_len25 = 0;\n    let mut new_words_len26 = 0;\n \
    \   let mut new_words_len27 = 0;\n    let mut new_words_len28 = 0;\n    let mut\
    \ new_words_len29 = 0;\n    let mut new_words_len30 = 0;\n    let mut new_words_len31\
    \ = 0;\n    let mut new_words_len32 = 0;\n    let mut new_words_len33 = 0;\n \
    \   let mut new_words_len34 = 0;\n    let mut new_words_len35 = 0;\n    let mut\
    \ new_words_len36 = 0;\n    let mut new_words_len37 = 0;\n    let mut new_words_len38\
    \ = 0;\n    let mut new_words_len39 = 0;\n    let mut new_words_len40 = 0;\n \
    \   let mut new_words_len41 = 0;\n    let mut new_words_len42 = 0;\n    let mut\
    \ new_words_len43 = 0;\n    let mut new_words_len44 = 0;\n    let mut new_words_len45\
    \ = 0;\n    let mut new_words_len46 = 0;\n    let mut new_words_len47 = 0;\n \
    \   let mut new_words_len48 = 0;\n    let mut new_words_len49 = 0;\n    let mut\
    \ new_words_len50 = 0;\n    let mut new_words_len51 = 0;\n    let mut new_words_len52\
    \ = 0;\n    let mut new_words_len53 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7o39ign_.rs:66:1\n  \
    \ |\n66 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n  \
    \          j = j + 1;\n        }\n        let mut k = j;\n        while k < new_s_len\
    \ && s[k] == ' ' {\n            k = k + 1;\n        }\n        let mut new_s_word\
    \ = String::new();\n        while j < new_s_len && k < new_s_len {\n         \
    \   let c = s[j].to_ascii_lowercase().unwrap();\n            let d = s[k].to_ascii_lowercase().unwrap();\n\
    \            if c < d {\n                new_s_word.push(s[j]);\n            \
    \    j = j + 1;\n            } else {\n                new_s_word.push(s[k]);\n\
    \                k = k + 1;\n            }\n        }\n        new_s.push(new_s_word);\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkcuq4kqt.rs:14:32\n\
    \   |\n14 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkcuq4kqt.rs:18:32\n\
    \   |\n18 |         while k < new_s_len && s[k] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkcuq4kqt.rs:23:21\n\
    \   |\n23 |             let c = s[j].to_ascii_lowercase().unwrap();\n   |    \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkcuq4kqt.rs:24:21\n\
    \   |\n24 |             let d = s[k].to_ascii_lowercase().unwrap();\n   |    \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkcuq4kqt.rs:26:33\n\
    \   |\n26 |                 new_s_word.push(s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpkcuq4kqt.rs:29:33\n   |\n\
    29 |                 new_s_word.push(s[k]);\n   |                            \
    \     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkcuq4kqt.rs:33:20\n\
    \   |\n33 |         new_s.push(new_s_word);\n   |                    ^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 7 previous\
    \ errors\n\nSome errors have detailed expl"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    for word in words {\n        let mut\
    \ new_word = String::from(word);\n        let mut new_words: Vec<String> = vec![];\n\
    \        for c in new_word.chars() {\n            let c = c.to_ascii_lowercase();\n\
    \            new_words.push(c);\n        }\n        let mut new_word = new_words.join(\"\
    \");\n        new_s = new_s.replace(&new_word, &new_word);\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph62a00qh.rs:16:28\n   |\n\
    16 |             new_words.push(c);\n   |                            ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.swap(i, i + 1);\n     \
    \   }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp0s3n_yg0.rs:11:15\n   |\n11 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.insert(i, ' ');\n     \
    \   } else {\n            s.insert(i, c.to_ascii_lowercase());\n        }\n  \
    \  });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpc01u1b87.rs:9:36\n   |\n9  |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     -                     -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n10 |     \
    \    if c.is_whitespace() {\n11 |             s.insert(i, ' ');\n   |        \
    \     - second borrow occurs due to use of `s` in closure\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    let mut new_words = Vec::new();\n   \
    \ let mut new_spaces = Vec::new();\n    let mut new_blanks = Vec::new();\n   \
    \ let mut new_blank_spaces = Vec::new();\n    let mut new_blank_spaces_count =\
    \ Vec::new();\n    let mut new_blank_spaces_count_max = Vec::new();\n    let mut\
    \ new_blank_spaces_count_max_index = Vec::new();\n    let mut new_blank_spaces_count_min\
    \ = Vec::new();\n    let mut new_blank_spaces_count_min_index = Vec::new();\n\
    \    let mut new_blank_spaces_count_max = Vec::new();\n    let mut new_blank_spaces_count_min_index\
    \ = Vec::new();\n    let mut new_blank_spaces_count_min = Vec::new();\n    let\
    \ mut new_blank_spaces_count_min_index = Vec::new();\n    let mut new_blank_spaces_count_max\
    \ = Vec::new();\n    let mut new_blank_spaces_count_min_index = Vec::new();\n\
    \    let mut new_blank_spaces_count_min = Vec::new();\n    let mut new_blank_spaces_count_min_index\
    \ = Vec::new();\n    let mut new_blank_spaces_count_max = Vec::new();\n    let\
    \ mut new_blank_spaces_count_min_index = Vec::new();\n    let mut new_blank_spaces_count_min\
    \ = Vec::new();\n    let mut new_blank_spaces_count_min_index = Vec::new();\n\
    \    let mut new_blank_spaces_count_max = Vec::new();\n    let mut new_blank_spaces_count_min_index\
    \ = Vec::new();\n    let mut new_blank_spaces_count_min = Vec::new();\n    let\
    \ mut new_blank_spaces_count_min_index = Vec::new();\n    let mut new_blank_spaces_count_max\
    \ = Vec::new();\n    let mut new_blank_spaces_count_min_index = Vec::new();\n\
    \    let mut new_blank_spaces_count_min = Vec::new();\n    let mut new_blank_spaces_count_min_index\
    \ = Vec::new();\n    let mut new_blank_spaces_count_max = Vec::new();\n    let\
    \ mut new_blank_spaces_count_min_index = Vec::new();\n    let mut new_blank_spaces_count_min\
    \ = Vec::new();\n    let mut new_blank_spaces_count_min\n}\n\nfn main() {\n  \
    \  let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0q5s3wlf.rs:43:39\n   |\n\
    43 |     let mut new_blank_spaces_count_min\n   |                            \
    \           ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp0q5s3wlf.rs:7:31\n  |\n7 | fn anti_shuffle(s:\
    \ String) -> String {\n  |    ------------               ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.replace(\"a\", \"z\");\n    s.replace(\"\
    b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"d\", \"w\");\n   \
    \ s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n    s.replace(\"g\"\
    , \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\", \"r\");\n    s.replace(\"\
    j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"l\", \"o\");\n   \
    \ s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n    s.replace(\"o\"\
    , \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\", \"j\");\n    s.replace(\"\
    r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"t\", \"g\");\n   \
    \ s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n    s.replace(\"w\"\
    , \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\", \"b\");\n    s.replace(\"\
    z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpyx4yvdmd.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    let mut new_words = Vec::new();\n   \
    \ let mut new_words_len = 0;\n    let mut i = 0;\n    while i < words.len() {\n\
    \        let mut j = i;\n        while j < words.len() {\n            if words[j].len()\
    \ < words[i].len() {\n                break;\n            }\n            if words[j].len()\
    \ > words[i].len() {\n                new_words.push(words[j]);\n            \
    \    new_words_len += words[j].len();\n                new_s.push(words[j].to_ascii_lowercase());\n\
    \                j += 1;\n            } else {\n                new_words.push(words[i]);\n\
    \                new_words_len += words[i].len();\n                new_s.push(words[i].to_ascii_lowercase());\n\
    \                i += 1;\n            }\n        }\n    }\n    new_s.push_str(&new_words.join(\"\
    \ \"));\n    new_s.push_str(\"\\n\");\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp3wi8o9zp.rs:14:21\n   |\n14 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmp3wi8o9zp.rs:16:25\n   |\n16 |         while j <\
    \ words.len() {\n   |                         ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp3wi8o9zp.rs:17:16\n   |\n17 |             if words[j].len() < words[i].len()\
    \ {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmp3wi8o9zp.rs:17:33\n   |\n17 |    \
    \         if words[j].len() < words[i].len() {\n   |                         \
    \        ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp3wi8o9zp.rs:20:16\n   |\n20 |             if words[j].len() > words[i].len()\
    \ {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmp3wi8o9zp.rs:20:33\n   |\n20 |    \
    \         if words[j].len() > words[i].len() {\n   |                         \
    \        ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp3wi8o9zp.rs:21:32\n   |\n21 |                 new_words.push(words[j]);\n\
    \   |                                ^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp3wi8o9zp.rs:22:34\n   |\n\
    22 |                 new_words_len += words[j].len();\n   |                  \
    \                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp3wi8o9zp.rs:23:28\n   |\n23 |                 new_s.push(words[j].to_ascii_lowercase());\n\
    \   |                            ^^^^^^^^\n\nerror[E0608]: cannot index into a\
    \ value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp3wi8o9zp.rs:26:32\n   |\n\
    26 |                 new_words.push(words[i])"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c.is_ascii() {\n            s.insert(c.to_ascii_lowercase(), c.to_ascii_lowercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo88fqdtk.rs:11:22\n   |\n\
    11 |             s.insert(c.to_ascii_lowercase(), c.to_ascii_lowercase());\n \
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len + 1;\n \
    \   let mut new_s_len3 = new_s_len2 + 1;\n    let mut new_s_len4 = new_s_len3\
    \ + 1;\n    let mut new_s_len5 = new_s_len4 + 1;\n    let mut new_s_len6 = new_s_len5\
    \ + 1;\n    let mut new_s_len7 = new_s_len6 + 1;\n    let mut new_s_len8 = new_s_len7\
    \ + 1;\n    let mut new_s_len9 = new_s_len8 + 1;\n    let mut new_s_len10 = new_s_len9\
    \ + 1;\n    let mut new_s_len11 = new_s_len10 + 1;\n    let mut new_s_len12 =\
    \ new_s_len11 + 1;\n    let mut new_s_len13 = new_s_len12 + 1;\n    let mut new_s_len14\
    \ = new_s_len13 + 1;\n    let mut new_s_len15 = new_s_len14 + 1;\n    let mut\
    \ new_s_len16 = new_s_len15 + 1;\n    let mut new_s_len17 = new_s_len16 + 1;\n\
    \    let mut new_s_len18 = new_s_len17 + 1;\n    let mut new_s_len19 = new_s_len18\
    \ + 1;\n    let mut new_s_len20 = new_s_len19 + 1;\n    let mut new_s_len21 =\
    \ new_s_len20 + 1;\n    let mut new_s_len22 = new_s_len21 + 1;\n    let mut new_s_len23\
    \ = new_s_len22 + 1;\n    let mut new_s_len24 = new_s_len23 + 1;\n    let mut\
    \ new_s_len25 = new_s_len24 + 1;\n    let mut new_s_len26 = new_s_len25 + 1;\n\
    \    let mut new_s_len27 = new_s_len26 + 1;\n    let mut new_s_len28 = new_s_len27\
    \ + 1;\n    let mut new_s_len29 = new_s_len28 + 1;\n    let mut new_s_len30 =\
    \ new_s_len29 + 1;\n    let mut new_s_len31 = new_s_len30 + 1;\n    let mut new_s_len32\
    \ = new_s_len31 + 1;\n    let mut new_s_len33 = new_s_len32 + 1;\n    let mut\
    \ new_s_len34 = new_s_len33 + 1;\n    let mut new_s_len35 = new_s_len34 + 1;\n\
    \    let mut new_s_len36 = new_s_len35 + 1;\n    let mut new_s_len37 = new_s_len36\
    \ + 1;\n    let mut new_s_len38 = new_s_len37 + 1;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw88hw2ay.rs:48:11\n   |\n\
    48 |     let mu\n   |           ^ help: add `;` here\n49 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpw88hw2ay.rs:7:31\n  |\n\
    7 | fn anti_shuffle(s: String) -> String {\n  |    ------------              \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len {\n            if s[i]\
    \ != s[j] {\n                break;\n            }\n            j += 1\n     \
    \   }\n        if j == new_s_len {\n            new_s.push(' ');\n        } else\
    \ {\n            new_s.push(s[j]);\n        }\n        i += 1;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_lwsk0ft.rs:15:16\n\
    \   |\n15 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_lwsk0ft.rs:15:24\n   |\n15 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_lwsk0ft.rs:23:24\n\
    \   |\n23 |             new_s.push(s[j]);\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"r\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"t\");\n    s.replace(\"\
    t\", \"s\");\n    s.replace(\"u\", \"v\");\n    s.replace(\"v\", \"w\");\n   \
    \ s.replace(\"w\", \"x\");\n    s.replace(\"x\", \"y\");\n    s.replace(\"y\"\
    , \"z\");\n    s.replace(\"z\", \"a\");\n    s.replace(\"  \", \" \");\n    s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp4a1dvd0l.rs:42:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_ascii() {\n            if i == 0 {\n                s\
    \ = &s[..i];\n            } else {\n                s = &s[..i] + &s[i .. s.len()];\n\
    \            }\n        }\n    });\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb2k_y0ym.rs:12:21\n   |\n\
    8  |     let mut s = String::from(s);\n   |                 --------------- expected\
    \ due to this value\n...\n12 |                 s = &s[..i];\n   |            \
    \         ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n12 |                 s = (&s[..i]).to_string();\n\
    \   |                     +       +++++++++++++\n\nerror[E0369]: cannot add `&str`\
    \ to `&str`\n  --> /tmp/tmpb2k_y0ym.rs:14:29\n   |\n14 |                 s = &s[..i]\
    \ + &s[i .. s.len()];\n   |                     ------- ^ ---------------- &str\n\
    \   |                     |       |\n   |                     |       `+` cannot\
    \ be used to concatenate two `&str` strings\n   |                     &str\n \
    \  |\n   = note: string concatenation requires an owned `String` on the left\n\
    help: remove the borrow to obtain an owned `String`\n   |\n14 -              \
    \   s = &s[..i] + &s[i .. s.len()];\n14 +                 s = s[..i] + &s[i ..\
    \ s.len()];\n   | \n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.replace(\"a\", \"z\");\n    s.replace(\"\
    b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"d\", \"w\");\n   \
    \ s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n    s.replace(\"g\"\
    , \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\", \"r\");\n    s.replace(\"\
    j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"l\", \"o\");\n   \
    \ s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n    s.replace(\"o\"\
    , \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\", \"j\");\n    s.replace(\"\
    r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"t\", \"g\");\n   \
    \ s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n    s.replace(\"w\"\
    , \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\", \"b\");\n    s.replace(\"\
    z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpyx4yvdmd.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut\
    \ new_s_len5 = new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7\
    \ = new_s_len;\n    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 =\
    \ new_s_len;\n    let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 =\
    \ new_s_len;\n    let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 =\
    \ new_s_len;\n    let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 =\
    \ new_s_len;\n    let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 =\
    \ new_s_len;\n    let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 =\
    \ new_s_len;\n    let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 =\
    \ new_s_len;\n    let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 =\
    \ new_s_len;\n    let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 =\
    \ new_s_len;\n    let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 =\
    \ new_s_len;\n    let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 =\
    \ new_s_len;\n    let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 =\
    \ new_s_len;\n    let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 =\
    \ new_s_len;\n    let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 =\
    \ new_s_len;\n    let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 =\
    \ new_s_len;\n    let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 =\
    \ new_s_len;\n    let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 =\
    \ new_s_len;\n    let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 =\
    \ new_s_len;\n    let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 =\
    \ new_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplkj3xfo0.rs:54:31\n   |\n\
    54 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmplkj3xfo0.rs:54:27\n   |\n54 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmplkj3xfo0.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) -> String {\n\
    \  |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    for word in words {\n        let mut\
    \ new_word = String::from(word);\n        for c in new_word.chars() {\n      \
    \      if c < 'a' || c > 'z' {\n                new_word.push(c);\n          \
    \  }\n        }\n        new_s += new_word;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_ul1ktwk.rs:18:18\n   |\n\
    18 |         new_s += new_word;\n   |                  ^^^^^^^^\n   |        \
    \          |\n   |                  expected `&str`, found struct `String`\n \
    \  |                  help: consider borrowing here: `&new_word`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.insert(i, ' ');\n     \
    \   } else {\n            let mut j = i;\n            while j > 0 && c.is_ascii_lowercase(j\
    \ - 1) {\n                s.swap(j, j - 1);\n                j -= 1;\n       \
    \     }\n        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp88lss718.rs:14:30\n     |\n14   |             while j > 0 &&\
    \ c.is_ascii_lowercase(j - 1) {\n     |                              ^^^^^^^^^^^^^^^^^^\
    \ ----- supplied 1 argument\n     |                              |\n     |   \
    \                           expected 0 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp88lss718.rs:15:19\n   |\n15 |          \
    \       s.swap(j, j - 1);\n   |                   ^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut\
    \ new_s_len5 = new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7\
    \ = new_s_len;\n    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 =\
    \ new_s_len;\n    let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 =\
    \ new_s_len;\n    let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 =\
    \ new_s_len;\n    let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 =\
    \ new_s_len;\n    let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 =\
    \ new_s_len;\n    let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 =\
    \ new_s_len;\n    let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 =\
    \ new_s_len;\n    let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 =\
    \ new_s_len;\n    let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 =\
    \ new_s_len;\n    let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 =\
    \ new_s_len;\n    let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 =\
    \ new_s_len;\n    let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 =\
    \ new_s_len;\n    let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 =\
    \ new_s_len;\n    let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 =\
    \ new_s_len;\n    let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 =\
    \ new_s_len;\n    let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 =\
    \ new_s_len;\n    let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 =\
    \ new_s_len;\n    let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 =\
    \ new_s_len;\n    let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 =\
    \ new_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplkj3xfo0.rs:54:31\n   |\n\
    54 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmplkj3xfo0.rs:54:27\n   |\n54 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmplkj3xfo0.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) -> String {\n\
    \  |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.sort_by_key(|&x| x.chars().count());\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpl79id9x5.rs:9:7\n  |\n9 |     s.sort_by_key(|&x|\
    \ x.chars().count());\n  |       ^^^^^^^^^^^ method not found in `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_word = \"\";\n    let mut new_word_len = 0;\n    let mut new_word_len2\
    \ = 0;\n    let mut new_word_len3 = 0;\n    let mut new_word_len4 = 0;\n    let\
    \ mut new_word_len5 = 0;\n    let mut new_word_len6 = 0;\n    let mut new_word_len7\
    \ = 0;\n    let mut new_word_len8 = 0;\n    let mut new_word_len9 = 0;\n    let\
    \ mut new_word_len10 = 0;\n    let mut new_word_len11 = 0;\n    let mut new_word_len12\
    \ = 0;\n    let mut new_word_len13 = 0;\n    let mut new_word_len14 = 0;\n   \
    \ let mut new_word_len15 = 0;\n    let mut new_word_len16 = 0;\n    let mut new_word_len17\
    \ = 0;\n    let mut new_word_len18 = 0;\n    let mut new_word_len19 = 0;\n   \
    \ let mut new_word_len20 = 0;\n    let mut new_word_len21 = 0;\n    let mut new_word_len22\
    \ = 0;\n    let mut new_word_len23 = 0;\n    let mut new_word_len24 = 0;\n   \
    \ let mut new_word_len25 = 0;\n    let mut new_word_len26 = 0;\n    let mut new_word_len27\
    \ = 0;\n    let mut new_word_len28 = 0;\n    let mut new_word_len29 = 0;\n   \
    \ let mut new_word_len30 = 0;\n    let mut new_word_len31 = 0;\n    let mut new_word_len32\
    \ = 0;\n    let mut new_word_len33 = 0;\n    let mut new_word_len34 = 0;\n   \
    \ let mut new_word_len35 = 0;\n    let mut new_word_len36 = 0;\n    let mut new_word_len37\
    \ = 0;\n    let mut new_word_len38 = 0;\n    let mut new_word_len39 = 0;\n   \
    \ let mut new_word_len40 = 0;\n    let mut new_word_len41 = 0;\n    let mut new_word_len42\
    \ = 0;\n    let mut new_word_len43 = 0;\n    let mut new_word_len44 = 0;\n   \
    \ let mut new_word_len45 = 0;\n    let mut new_word_len46 = 0;\n    let mut new_word_len47\
    \ = 0;\n    let mut new_word_len48 = 0;\n    let mut new_word_len49 = 0;\n   \
    \ let mut new_word_len50 = 0;\n    let mut new_word_len51 = 0;\n    let mut new_word_len52\
    \ = 0;\n    let mut new_word_len53 = 0;\n    let mut new_word_len54 = 0;\n   \
    \ let mut new_word_len55 = 0;\n\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpm2ewdwmo.rs:7:31\n  |\n7 |\
    \ fn anti_shuffle(s: String) -> String {\n  |    ------------               ^^^^^^\
    \ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::with_capacity(s.len());\n    for word in words {\n\
    \        let mut new_word = String::with_capacity(word.len());\n        for c\
    \ in word.chars() {\n            if c < 'a' || c > 'z' {\n                new_word.push(c);\n\
    \            } else {\n                new_word.push(c + 'a' - 'a');\n       \
    \     }\n        }\n        new_s.push(new_word);\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpic03wext.rs:17:33\n\
    \   |\n17 |                 new_word.push(c + 'a' - 'a');\n   |              \
    \                 - ^ --- char\n   |                               |\n   |   \
    \                            char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpic03wext.rs:20:20\n\
    \   |\n20 |         new_s.push(new_word);\n   |                    ^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.insert(i, ' ');\n     \
    \   } else {\n            let mut j = i;\n            while j > 0 && c.is_ascii_lowercase(j\
    \ - 1) {\n                s.swap(j, j - 1);\n                j -= 1;\n       \
    \     }\n        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp88lss718.rs:14:30\n     |\n14   |             while j > 0 &&\
    \ c.is_ascii_lowercase(j - 1) {\n     |                              ^^^^^^^^^^^^^^^^^^\
    \ ----- supplied 1 argument\n     |                              |\n     |   \
    \                           expected 0 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp88lss718.rs:15:19\n   |\n15 |          \
    \       s.swap(j, j - 1);\n   |                   ^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.sort_by_key(|&x|\
    \ x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n    s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n --> /tmp/tmp59f3a40t.rs:9:7\n  |\n9 |     s.sort_by_key(|&x|\
    \ x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n  |       ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().sort_by(|a,\
    \ b| a.cmp(b)).collect::<Vec<_>>().join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmp0kv73_yc.rs:9:15\n  |\n9 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b)).collect::<Vec<_>>().join(\" \")\n  |               ^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len {\n            if s[i]\
    \ == ' ' && s[j] != ' ' {\n                new_s.push_str(&s[j..i]);\n       \
    \         j = j + 1;\n            } else {\n                break;\n         \
    \   }\n        }\n        new_s.push_str(&s[i]);\n        i = i + 1;\n    }\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk0hduaax.rs:15:16\n\
    \   |\n15 |             if s[i] == ' ' && s[j] != ' ' {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk0hduaax.rs:15:31\n   |\n15 |             if s[i] == ' ' && s[j]\
    \ != ' ' {\n   |                               ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk0hduaax.rs:22:25\n   |\n22 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c != ' ' {\n            s.insert(c, c.to_ascii_lowercase());\n       \
    \ }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9860ou7h.rs:11:22\n   |\n\
    11 |             s.insert(c, c.to_ascii_lowercase());\n   |                  \
    \    ^ expected `usize`, found `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.replace(\"a\", \"z\");\n    s.replace(\"\
    b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"d\", \"w\");\n   \
    \ s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n    s.replace(\"g\"\
    , \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\", \"r\");\n    s.replace(\"\
    j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"l\", \"o\");\n   \
    \ s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n    s.replace(\"o\"\
    , \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\", \"r\");\n    s.replace(\"\
    r\", \"i\");\n    s.replace(\"s\", \"t\");\n    s.replace(\"t\", \"s\");\n   \
    \ s.replace(\"u\", \"o\");\n    s.replace(\"v\", \"h\");\n    s.replace(\"w\"\
    , \"d\");\n    s.replace(\"x\", \"f\");\n    s.replace(\"y\", \"g\");\n    s.replace(\"\
    z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp5ntvqslq.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_word = \"\";\n    for word in words {\n        let mut new_word\
    \ = \"\";\n        for c in word.chars() {\n            let ord = c.to_ascii_lowercase();\n\
    \            new_word.push(ord);\n        }\n        words = new_word.split_whitespace();\n\
    \    }\n    return words.join(\" \");\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpl1t2bx45.rs:15:22\n   |\n15 |             new_word.push(ord);\n\
    \   |                      ^^^^ method not found in `&str`\n\nerror[E0599]: no\
    \ method named `join` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpl1t2bx45.rs:19:18\n   |\n19 |     return words.join(\" \");\n \
    \  |                  ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c < ' ' {\n            s.insert(c, ' ');\n        }\n    });\n    let\
    \ mut words = s.split_whitespace();\n    let mut new_s = String::new();\n    let\
    \ mut new_words = Vec::new();\n    let mut new_words_len = Vec::new();\n    let\
    \ mut i = 0;\n    while i < words.len() {\n        let mut j = i;\n        while\
    \ j < words.len() {\n            if words[j].len() > words[i].len() {\n      \
    \          let mut new_word = words[j];\n                while new_word.len()\
    \ < words[i].len() {\n                    new_word.insert(new_word.len(), ' ');\n\
    \                }\n                new_words.insert(j, new_word);\n         \
    \       new_words_len.insert(j, new_word.len());\n                j += 1;\n  \
    \          } else {\n                j += 1;\n            }\n        }\n     \
    \   i += 1;\n    }\n    new_s = new_words.join(\" \");\n    new_s.chars().for_each(|c|\
    \ {\n        if c < ' ' {\n            new_s.insert(c, ' ');\n        }\n    });\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsn5_hw18.rs:11:22\n   |\n\
    11 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpsn5_hw18.rs:19:21\n   |\n19 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpsn5_hw18.rs:21:25\n   |\n21 |         while j <\
    \ words.len() {\n   |                         ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpsn5_hw18.rs:22:16\n   |\n22 |             if words[j].len() > words[i].len()\
    \ {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpsn5_hw18.rs:22:33\n   |\n22 |    \
    \         if words[j].len() > words[i].len() {\n   |                         \
    \        ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpsn5_hw18.rs:23:36\n   |\n23 |                 let mut new_word\
    \ = words[j];\n   |                                    ^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpsn5_hw18.rs:24:40\n\
    \   |\n24 |                 while new_word.len() < words[i].len() {\n   |    \
    \                                    ^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsn5_hw18.rs:39:26\n   |\n39 |             new_s.insert(c, ' ');\n\
    \   |                          ^ expected `usize`, found `char`\n\nerror: aborting\
    \ due to 8 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c != ' ' {\n            s.insert(c, c.to_ascii_lowercase());\n       \
    \ }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9860ou7h.rs:11:22\n   |\n\
    11 |             s.insert(c, c.to_ascii_lowercase());\n   |                  \
    \    ^ expected `usize`, found `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"r\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"j\");\n    s.replace(\"\
    t\", \"h\");\n    s.replace(\"u\", \"g\");\n    s.replace(\"v\", \"f\");\n   \
    \ s.replace(\"w\", \"e\");\n    s.replace(\"x\", \"d\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp2sst_r0w.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = String::new();\n        for c in word.chars() {\n            let\
    \ ord = c.to_ascii_lowercase();\n            new_word.push_str(&ord);\n      \
    \  }\n        new_s.push_str(&new_word);\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpywgxdbr7.rs:15:31\n   |\n\
    15 |             new_word.push_str(&ord);\n   |                              \
    \ ^^^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.sort_by_key(|&x| x.chars().count());\n\
    \    s.replace_indices(\"  \", \" \", |&i| {\n        match i {\n            0\
    \ => ' ',\n            1 => '_',\n            2 => '-',\n            3 => '~',\n\
    \            4 => '^',\n            5 => '&',\n            6 => '#',\n       \
    \     7 => '$',\n            8 => '*',\n            9 => '(',\n            10\
    \ => ')',\n            11 => '[',\n            12 => ']',\n            13 => '{',\n\
    \            14 => '}',\n            15 => '|',\n            16 => '~',\n    \
    \        17 => '^',\n            18 => '&',\n            19 => '#',\n        \
    \    20 => '$',\n            21 => '*',\n            22 => '(',\n            23\
    \ => ')',\n            24 => '[',\n            25 => ']',\n            26 => '{',\n\
    \            27 => '}',\n            28 => '|',\n            29 => '~',\n    \
    \        30 => '^',\n            31 => '&',\n            32 => '#',\n        \
    \    33 => '$',\n            34 => '*',\n            35 => '(',\n            36\
    \ => ')',\n            37 => '[',\n            38 => ']',\n            39 => '{',\n\
    \            40 => '}',\n            41 => '|',\n            42 => '~',\n    \
    \        43 => '^',\n            44 => '&',\n            45 => '#',\n        \
    \    46 => '$',\n            47 => '*',\n            48 => '(',\n            49\
    \ => ')',\n            50 => '[',\n            51 => ']',\n            52 => '{',\n\
    \            53 => '}',\n            54 => '|',\n            55 => '~',\n    \
    \        56 => '^',\n            57 => '&',\n            58 => '#',\n        \
    \    59 => '$',\n            60 => '*',\n            61 => '(',\n            62\
    \ => ')',\n            63 => '[',\n            64 => ']',\n            65 => '{',\n\
    \            66 => '}',\n            67 => '|',\n            68 => '~',\n    \
    \        69 => '^',\n            70 => '&',\n            71 => '#',\n        \
    \    72 => '$',\n            73 => '*\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp9vxq8ndq.rs:85:19\n\
    \   |\n85 |             73 => '*\n   |                   ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    for word in words {\n        let mut\
    \ new_word = String::from(word);\n        let mut new_word_len = new_word.len();\n\
    \        let mut new_word_len2 = new_word_len / 2;\n        let mut new_word_len3\
    \ = new_word_len2 / 2;\n        let mut new_word_len4 = new_word_len3 / 2;\n \
    \       let mut new_word_len5 = new_word_len4 / 2;\n        let mut new_word_len6\
    \ = new_word_len5 / 2;\n        let mut new_word_len7 = new_word_len6 / 2;\n \
    \       let mut new_word_len8 = new_word_len7 / 2;\n        let mut new_word_len9\
    \ = new_word_len8 / 2;\n        let mut new_word_len10 = new_word_len9 / 2;\n\
    \        let mut new_word_len11 = new_word_len10 / 2;\n        let mut new_word_len12\
    \ = new_word_len11 / 2;\n        let mut new_word_len13 = new_word_len12 / 2;\n\
    \        let mut new_word_len14 = new_word_len13 / 2;\n        let mut new_word_len15\
    \ = new_word_len14 / 2;\n        let mut new_word_len16 = new_word_len15 / 2;\n\
    \        let mut new_word_len17 = new_word_len16 / 2;\n        let mut new_word_len18\
    \ = new_word_len17 / 2;\n        let mut new_word_len19 = new_word_len18 / 2;\n\
    \        let mut new_word_len20 = new_word_len19 / 2;\n        let mut new_word_len21\
    \ = new_word_len20 / 2;\n        let mut new_word_len22 = new_word_len21 / 2;\n\
    \        let mut new_word_len23 = new_word_len22 / 2;\n        let mut new_word_len24\
    \ = new_word_len23 / 2;\n        let mut new_word_len25 = new_word_len24 / 2;\n\
    \        let mut new_word_len26 = new_word_len25 / 2;\n        let mut new_word_len27\
    \ = new_word_len26 / 2;\n        let mut new_word_len28 = new_word_len27 / 2;\n\
    \        let mut new_word_len29 = new_word_len28 / 2;\n        let mut new_word_len30\
    \ = new_word_len29 / 2;\n        let mut new_word_len31 = new_word_len30 / 2;\n\
    \        let mut new_word_len32 = new_word_len31 / 2;\n        let mut new_word_len33\
    \ = new_word_len32 / 2;\n        let mut new_word_len34 = new_word_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfesmxppq.rs:58:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n11 |     for word in words {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    47 | }\n   | - ...as it matches this but it has different indentation\n...\n58\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpfesmxppq.rs:46:43\n\
    \   |\n46 |         let mut new_word_len34 = new_word_\n   |                 \
    \                          ^ help: add `;` here\n47 | }\n   | - unexpected token\n\
    \nerror[E0425]: cannot find value `new_word_` in this scope\n  --> /tmp/tmpfesmxppq.rs:46:34\n\
    \   |\n46 |         let mut new_word_len34 = new_word_\n   |                 \
    \                 ^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `new_word`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfesmxppq.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().sort_by(|a,\
    \ b| a.cmp(b).unwrap()).for_each(|c| {\n        if c.is_whitespace() {\n     \
    \       s.insert(s.len(), ' ');\n        } else {\n            s.insert(s.len(),\
    \ c);\n        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmpk8gpzmkt.rs:9:15\n  |\n9 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b).unwrap()).for_each(|c| {\n  |               ^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = String::new();\n        let mut new_word_chars = String::new();\n\
    \        for c in word.chars() {\n            let ord = c.to_ascii_lowercase();\n\
    \            new_word_chars.push_str(&ord);\n        }\n        new_word.push_str(&new_word_chars);\n\
    \        new_s.push_str(&new_word);\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_0iq_irr.rs:16:37\n   |\n\
    16 |             new_word_chars.push_str(&ord);\n   |                        \
    \             ^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().sort_by(|a, b| a.cmp(b)).collect::<Vec<_>>().join();\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmpiim0_pxv.rs:9:15\n  |\n9 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b)).collect::<Vec<_>>().join();\n  |               ^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c < ' ' {\n            s.insert(c, ' ');\n        }\n    });\n\
    \    let mut words = s.split_whitespace();\n    let mut new_s = String::with_capacity(s.len());\n\
    \    words.sort_by(|a, b| a.cmp(b));\n    words.for_each(|word| {\n        new_s.push_str(word);\n\
    \        new_s.push(' ');\n    });\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7m2forj4.rs:11:22\n   |\n\
    11 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp7m2forj4.rs:16:11\n   |\n16 |     words.sort_by(|a,\
    \ b| a.cmp(b));\n   |           ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().sort_by(|a,\
    \ b| a.cmp(b));\n    s.chars().collect::<Vec<_>>().join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmpvc7ype9v.rs:9:15\n  |\n9 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b));\n  |               ^^^^^^^ method not found in `Chars<'_>`\n\n\
    error[E0599]: the method `join` exists for struct `Vec<char>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpvc7ype9v.rs:10:35\n   |\n10 |     s.chars().collect::<Vec<_>>().join(\"\
    \ \")\n   |                                   ^^^^ method cannot be called on\
    \ `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `[char]: Join<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_words = Vec::new();\n    for w in words {\n        let mut new_w\
    \ = w.to_string();\n        let mut new_w = new_w.chars().map(|c| c.to_ascii_lowercase()).collect::<String>();\n\
    \        new_words.push_str(new_w);\n    }\n    new_words.sort();\n    new_words.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_str` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmpgamvhoea.rs:14:19\n   |\n14 |         new_words.push_str(new_w);\n\
    \   |                   ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `push`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    for word in words {\n        let mut\
    \ new_word = String::from(word);\n        for c in new_word.chars() {\n      \
    \      if c < 'a' || c > 'z' {\n                new_word.push(c);\n          \
    \  }\n        }\n        new_s.push_str(&new_word);\n    }\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpxrhna7y_.rs:8:9\n\
    \  |\n8 |     let mut s = String::from(s);\n  |         ----^\n  |         |\n\
    \  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on\
    \ by default\n\nwarning: variable does not need to be mutable\n --> /tmp/tmpxrhna7y_.rs:9:9\n\
    \  |\n9 |     let mut words = s.split_whitespace();\n  |         ----^^^^^\n \
    \ |         |\n  |         help: remove this `mut`\n\nerror[E0505]: cannot move\
    \ out of `s` because it is borrowed\n  --> /tmp/tmpxrhna7y_.rs:10:34\n   |\n9\
    \  |     let mut words = s.split_whitespace();\n   |                     --------------------\
    \ borrow of `s` occurs here\n10 |     let mut new_s = String::from(s);\n   | \
    \                                 ^ move out of `s` occurs here\n11 |     for\
    \ word in words {\n   |                 ----- borrow later used here\n\nerror[E0502]:\
    \ cannot borrow `new_word` as mutable because it is also borrowed as immutable\n\
    \  --> /tmp/tmpxrhna7y_.rs:15:17\n   |\n13 |         for c in new_word.chars()\
    \ {\n   |                  ----------------\n   |                  |\n   |   \
    \               immutable borrow occurs here\n   |                  immutable\
    \ borrow later used here\n14 |             if c < 'a' || c > 'z' {\n15 |     \
    \            new_word.push(c);\n   |                 ^^^^^^^^^^^^^^^^ mutable\
    \ borrow occurs here\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\
    \nSome errors have detailed explanations: E0502, E0505.\nFor more information\
    \ about an error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.insert(i, ' ');\n     \
    \   } else {\n            s.insert(i, c.to_ascii_lowercase());\n        }\n  \
    \  });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpc01u1b87.rs:9:36\n   |\n9  |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     -                     -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n10 |     \
    \    if c.is_whitespace() {\n11 |             s.insert(i, ' ');\n   |        \
    \     - second borrow occurs due to use of `s` in closure\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c.is_ascii() {\n            s.insert(c.to_ascii_lowercase(), c.to_ascii_lowercase());\n\
    \        } else {\n            s.insert(c.to_ascii_uppercase(), c.to_ascii_uppercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplr8ty7vg.rs:11:22\n   |\n\
    11 |             s.insert(c.to_ascii_lowercase(), c.to_ascii_lowercase());\n \
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplr8ty7vg.rs:13:22\n   |\n13 |\
    \             s.insert(c.to_ascii_uppercase(), c.to_ascii_uppercase());\n   |\
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.replace(\"a\", \"z\");\n    s.replace(\"\
    b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"d\", \"w\");\n   \
    \ s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n    s.replace(\"g\"\
    , \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\", \"r\");\n    s.replace(\"\
    j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"l\", \"o\");\n   \
    \ s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n    s.replace(\"o\"\
    , \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\", \"j\");\n    s.replace(\"\
    r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"t\", \"g\");\n   \
    \ s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n    s.replace(\"w\"\
    , \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\", \"b\");\n    s.replace(\"\
    z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpyx4yvdmd.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let\
    \ mut new_s_len5 = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let\
    \ mut new_s_len7 = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let\
    \ mut new_s_len9 = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let\
    \ mut new_s_len11 = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n   \
    \ let mut new_s_len13 = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n\
    \    let mut new_s_len15 = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n\
    \    let mut new_s_len17 = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n\
    \    let mut new_s_len19 = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n\
    \    let mut new_s_len21 = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n\
    \    let mut new_s_len23 = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n\
    \    let mut new_s_len25 = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n\
    \    let mut new_s_len27 = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n\
    \    let mut new_s_len29 = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n\
    \    let mut new_s_len31 = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n\
    \    let mut new_s_len33 = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n\
    \    let mut new_s_len35 = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n\
    \    let mut new_s_len37 = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n\
    \    let mut new_s_len39 = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp22sfetvu.rs:49:33\n   |\n\
    49 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp22sfetvu.rs:49:27\n   |\n49\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp22sfetvu.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) ->\
    \ String {\n  |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = word;\n        let mut new_word_len = word.len();\n        let mut\
    \ i = 0;\n        while i < new_word_len {\n            let c = new_word[i];\n\
    \            let j = i;\n            while j > 0 && new_word[j - 1] > c {\n  \
    \              new_word[j] = new_word[j - 1];\n                j -= 1;\n     \
    \       }\n            new_word[j] = c;\n            i += 1;\n        }\n    \
    \    new_s += new_word;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpo5w68dq1.rs:16:21\n\
    \   |\n16 |             let c = new_word[i];\n   |                     ^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpo5w68dq1.rs:18:28\n   |\n18 |             while j > 0\
    \ && new_word[j - 1] > c {\n   |                            ^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpo5w68dq1.rs:19:17\n   |\n19 |                 new_word[j]\
    \ = new_word[j - 1];\n   |                 ^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpo5w68dq1.rs:19:31\n   |\n19 |                 new_word[j] = new_word[j\
    \ - 1];\n   |                               ^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpo5w68dq1.rs:22:13\n   |\n22 |             new_word[j] = c;\n   |   \
    \          ^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<st"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"r\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"j\");\n    s.replace(\"\
    t\", \"h\");\n    s.replace(\"u\", \"g\");\n    s.replace(\"v\", \"f\");\n   \
    \ s.replace(\"w\", \"e\");\n    s.replace(\"x\", \"d\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp2sst_r0w.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.insert(i, ' ');\n     \
    \   } else {\n            s.insert(i, c.to_ascii_lowercase());\n        }\n  \
    \  });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpc01u1b87.rs:9:36\n   |\n9  |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     -                     -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n10 |     \
    \    if c.is_whitespace() {\n11 |             s.insert(i, ' ');\n   |        \
    \     - second borrow occurs due to use of `s` in closure\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::with_capacity(s.len());\n    for word in words {\n\
    \        let mut new_word = String::with_capacity(word.len());\n        for c\
    \ in word.chars() {\n            new_word.push((c as u8).to_string());\n     \
    \   }\n        new_s.push_str(&new_word);\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy243c6mu.rs:14:27\n   |\n\
    14 |             new_word.push((c as u8).to_string());\n   |                 \
    \          ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    for word in words {\n        let mut\
    \ new_word = String::from(word);\n        for c in new_word.chars() {\n      \
    \      let i = c.as_bytes().iter().enumerate().find(|(_, c)| c.is_ascii()).unwrap();\n\
    \            new_word.insert(i, c.to_ascii_lowercase());\n        }\n        new_s.push_str(&new_word);\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4cf35r0p.rs:14:23\n   |\n14 |             let i = c.as_bytes().iter().enumerate().find(|(_,\
    \ c)| c.is_ascii()).unwrap();\n   |                       ^^^^^^^^ method not\
    \ found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n   \
    \     let mut j = i;\n        while j < s.len() {\n            if s[i] != s[j]\
    \ {\n                break;\n            }\n            j += 1\n        }\n  \
    \      let mut new_s_len = new_s_len + 1;\n        let mut new_s_char = String::new();\n\
    \        while j < s.len() {\n            new_s_char.push(s[j]);\n           \
    \ j += 1\n        }\n        new_s.push_str(&new_s_char);\n        i = j;\n  \
    \  }\n    new_s.push_str(&s[new_s_len..]);\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpoh_ovdkk.rs:15:16\n\
    \   |\n15 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpoh_ovdkk.rs:15:24\n   |\n15 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpoh_ovdkk.rs:23:29\n\
    \   |\n23 |             new_s_char.push(s[j]);\n   |                         \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: ab"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().sort_by(|a,\
    \ b| a.cmp(b).unwrap()).for_each(|c| {\n        if c.is_whitespace() {\n     \
    \       s.push_str(\" \");\n        } else {\n            s.push_str(&c.to_string());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmpp5k483q2.rs:9:15\n  |\n9 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b).unwrap()).for_each(|c| {\n  |               ^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.insert(i, ' ');\n     \
    \   } else {\n            s.insert(i, c.to_ascii_lowercase());\n        }\n  \
    \  });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpc01u1b87.rs:9:36\n   |\n9  |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     -                     -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n10 |     \
    \    if c.is_whitespace() {\n11 |             s.insert(i, ' ');\n   |        \
    \     - second borrow occurs due to use of `s` in closure\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n  \
    \          j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut k = i;\n        while k < new_s_len && s[k] == ' '\
    \ {\n            k = k + 1;\n        }\n        if k == new_s_len {\n        \
    \    break;\n        }\n        let mut new_word = String::new();\n        new_word.push_str(&s[i\
    \ .. k]);\n        new_word.push_str(&s[j..new_s_len]);\n        new_word.push_str(&s[new_s_len..k]);\n\
    \        new_word.push_str(&s[i .. new_s_len]);\n        new_word.push_str(&s[new_s_len..j]);\n\
    \        new_word.push_str(&s[k .. new_s_len]);\n        new_word.push_str(&s[new_s_len..new_s_len]);\n\
    \        new_word.push_str(&s[new_s_len..i]);\n        new_word.push_str(&s[i\
    \ .. new_s_len]);\n        new_word.push_str(&s[new_s_len..new_s_len]);\n    \
    \    new_word.push_str(&s[new_s_len..i]);\n        new_word.push_str(&s[i .. new_s_len]);\n\
    \        new_word.push_str(&s[new_s_len..new_s_len]);\n        new_word.push_str(&s[new_s_len..i]);\n\
    \        new_word.push_str(&s[i .. new_s_len]);\n        new_word.push_str(&s[new_s_len..new_s_len]);\n\
    \        new_word.push_str(&s[new_s_len..i]);\n        new_word.push_str(&s[i\
    \ .. new_s_len]);\n        new_word.push_str(&s[new_s_len..new_s_len]);\n    \
    \    new_word.push_str(&s[new_s_len..i]);\n        new_word.push_str(&s[i .. new_s_len]);\n\
    \        new_word.push_str(&s[new_s_len..new_s_len]);\n        new_word.push_str(&s[new_s_len..i]);\n\
    \        new_word.push_str(&s[i .. new_s_len]);\n        new_word.push_str(&s[new_s_len..new_s_len]);\n\
    \        new_word.push_str(&s[new_s_len..i]);\n        new_word.push_str(&s[i\
    \ .. new_s_len]);\n        new_word.push_str(&s[new_s_len..new_s_len]);\n    \
    \    new_word.push_str(&s[new_s_len..i]);\n\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzn4ddfb0.rs:69:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n12 |     while i < new_s_len {\n\
    \   |                         - this delimiter might not be properly closed...\n\
    ...\n58 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    69 | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzn4ddfb0.rs:14:32\n   |\n14 |         while j < new_s_len && s[j]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzn4ddfb0.rs:21:32\n   |\n21 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n --> /tmp/tmpzn4ddfb0.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no t"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    let mut new_words = String::new();\n\
    \    let mut new_spaces = String::new();\n    for word in words {\n        let\
    \ mut new_word = String::new();\n        let mut new_space = String::new();\n\
    \        for c in word.chars() {\n            if c.is_ascii() {\n            \
    \    new_word.push(c);\n            } else {\n                new_space.push(c);\n\
    \            }\n        }\n        new_s += new_word;\n        new_s += new_space;\n\
    \    }\n    new_s += new_words;\n    new_s += new_spaces;\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptehxc8ma.rs:23:18\n   |\n\
    23 |         new_s += new_word;\n   |                  ^^^^^^^^\n   |        \
    \          |\n   |                  expected `&str`, found struct `String`\n \
    \  |                  help: consider borrowing here: `&new_word`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptehxc8ma.rs:24:18\n   |\n24 |         new_s\
    \ += new_space;\n   |                  ^^^^^^^^^\n   |                  |\n  \
    \ |                  expected `&str`, found struct `String`\n   |            \
    \      help: consider borrowing here: `&new_space`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptehxc8ma.rs:26:14\n   |\n26 |     new_s += new_words;\n\
    \   |              ^^^^^^^^^\n   |              |\n   |              expected\
    \ `&str`, found struct `String`\n   |              help: consider borrowing here:\
    \ `&new_words`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptehxc8ma.rs:27:14\n\
    \   |\n27 |     new_s += new_spaces;\n   |              ^^^^^^^^^^\n   |     \
    \         |\n   |              expected `&str`, found struct `String`\n   |  \
    \            help: consider borrowing here: `&new_spaces`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c != ' ' {\n            s.insert(c.to_ascii_lowercase(), ' ');\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiggwq_x6.rs:11:22\n   |\n\
    11 |             s.insert(c.to_ascii_lowercase(), ' ');\n   |                \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    for word in words {\n        let mut\
    \ new_word = String::from(word);\n        let mut new_word_len = new_word.len();\n\
    \        let mut new_word_len2 = new_word_len / 2;\n        let mut new_word_len3\
    \ = new_word_len2 / 2;\n        let mut new_word_len4 = new_word_len3 / 2;\n \
    \       let mut new_word_len5 = new_word_len4 / 2;\n        let mut new_word_len6\
    \ = new_word_len5 / 2;\n        let mut new_word_len7 = new_word_len6 / 2;\n \
    \       let mut new_word_len8 = new_word_len7 / 2;\n        let mut new_word_len9\
    \ = new_word_len8 / 2;\n        let mut new_word_len10 = new_word_len9 / 2;\n\
    \        let mut new_word_len11 = new_word_len10 / 2;\n        let mut new_word_len12\
    \ = new_word_len11 / 2;\n        let mut new_word_len13 = new_word_len12 / 2;\n\
    \        let mut new_word_len14 = new_word_len13 / 2;\n        let mut new_word_len15\
    \ = new_word_len14 / 2;\n        let mut new_word_len16 = new_word_len15 / 2;\n\
    \        let mut new_word_len17 = new_word_len16 / 2;\n        let mut new_word_len18\
    \ = new_word_len17 / 2;\n        let mut new_word_len19 = new_word_len18 / 2;\n\
    \        let mut new_word_len20 = new_word_len19 / 2;\n        let mut new_word_len21\
    \ = new_word_len20 / 2;\n        let mut new_word_len22 = new_word_len21 / 2;\n\
    \        let mut new_word_len23 = new_word_len22 / 2;\n        let mut new_word_len24\
    \ = new_word_len23 / 2;\n        let mut new_word_len25 = new_word_len24 / 2;\n\
    \        let mut new_word_len26 = new_word_len25 / 2;\n        let mut new_word_len27\
    \ = new_word_len26 / 2;\n        let mut new_word_len28 = new_word_len27 / 2;\n\
    \        let mut new_word_len29 = new_word_len28 / 2;\n        let mut new_word_len30\
    \ = new_word_len29 / 2;\n        let mut new_word_len31 = new_word_len30 / 2;\n\
    \        let mut new_word_len32 = new_word_len31 / 2;\n        let mut new_word_len33\
    \ = new_word_len32 / 2;\n        let mut new_word_len34 = new_word_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfesmxppq.rs:58:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n11 |     for word in words {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    47 | }\n   | - ...as it matches this but it has different indentation\n...\n58\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpfesmxppq.rs:46:43\n\
    \   |\n46 |         let mut new_word_len34 = new_word_\n   |                 \
    \                          ^ help: add `;` here\n47 | }\n   | - unexpected token\n\
    \nerror[E0425]: cannot find value `new_word_` in this scope\n  --> /tmp/tmpfesmxppq.rs:46:34\n\
    \   |\n46 |         let mut new_word_len34 = new_word_\n   |                 \
    \                 ^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `new_word`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfesmxppq.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len {\n            if s[i]\
    \ != s[j] {\n                break;\n            }\n            j += 1\n     \
    \   }\n        let mut new_s_char = new_s[..j];\n        let mut new_s_char_len\
    \ = new_s_char.len();\n        let mut new_s_char_i = j;\n        while new_s_char_i\
    \ < new_s_char_len {\n            let mut new_s_char_j = new_s_char_i;\n     \
    \       while new_s_char_j < new_s_char_len {\n                new_s_char.swap(new_s_char[j],\
    \ new_s_char[j + 1]);\n                new_s_char_j += 1\n            }\n    \
    \        new_s_char_i += 1;\n        }\n        new_s_len = new_s_char.len();\n\
    \        new_s.push_str(&new_s_char);\n        i += 1;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5uetocaf.rs:15:16\n\
    \   |\n15 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5uetocaf.rs:15:24\n   |\n15 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp5uetocaf.rs:20:13\n   |\n20 |         let mut new_s_char = new_s[..j];\n\
    \   |             ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n \
    \  |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n20 |\
    \         let mut new_s_char = &new_s[..j];\n   |                            \
    \  +\n\nerror[E0599]: no method named `swap` found for type `str` in the current\
    \ scope\n  --> /tmp/tmp5uetocaf.rs:26:28\n   |\n26 |                 new_s_char.swa"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c < ' ' {\n            s.insert(c, ' ');\n        }\n    });\n\
    \    let mut words = s.split_whitespace();\n    let mut new_words = Vec::new();\n\
    \    for w in words {\n        let mut new_w = w.to_string();\n        new_w.chars().for_each(|c|\
    \ {\n            if c < 'a' || c > 'z' {\n                new_w.insert(c, ' ');\n\
    \            }\n        });\n        new_words.push(new_w);\n    }\n    new_words.sort();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.ded\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp706uuz05.rs:11:22\n   |\n\
    11 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp706uuz05.rs:20:30\n\
    \   |\n20 |                 new_w.insert(c, ' ');\n   |                      \
    \        ^ expected `usize`, found `char`\n\nerror[E0609]: no field `ded` on type\
    \ `Vec<String>`\n  --> /tmp/tmp706uuz05.rs:91:15\n   |\n91 |     new_words.ded\n\
    \   |               ^^^ unknown field\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    for word in words {\n        let mut\
    \ new_word = String::from(word);\n        for c in new_word.chars() {\n      \
    \      if c < 97 {\n                new_word.push(c);\n            }\n       \
    \ }\n        new_s += new_word;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprkq3vt75.rs:14:20\n   |\n\
    14 |             if c < 97 {\n   |                    ^^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprkq3vt75.rs:18:18\n  \
    \ |\n18 |         new_s += new_word;\n   |                  ^^^^^^^^\n   |   \
    \               |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&new_word`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_alphabetic() {\n            if i > 0 {\n            \
    \    s.swap(i-1, i);\n            }\n        }\n    });\n    s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpxmnouip2.rs:12:19\n   |\n12 |                 s.swap(i-1,\
    \ i);\n   |                   ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_word = \"\";\n    for word in words {\n        let mut new_word\
    \ = \"\";\n        for c in word.chars() {\n            if c < 'a' || c > 'z'\
    \ {\n                new_word += c;\n            }\n        }\n        words =\
    \ words.iter().filter(|&x| !x.is_whitespace()).collect();\n        words.insert(0,\
    \ new_word);\n    }\n    return words.join(\" \");\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpaj7xltbt.rs:15:17\n   |\n15 |                 new_word\
    \ += c;\n   |                 --------^^^^^\n   |                 |\n   |    \
    \             cannot use `+=` on type `&str`\n\nerror[E0599]: no method named\
    \ `iter` found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpaj7xltbt.rs:18:23\n\
    \   |\n18 |         words = words.iter().filter(|&x| !x.is_whitespace()).collect();\n\
    \   |                       ^^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error[E0599]: no method named `insert` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpaj7xltbt.rs:19:15\n   |\n19 |         words.insert(0,\
    \ new_word);\n   |               ^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `join` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpaj7xltbt.rs:21:18\n   |\n21 |     return words.join(\"\
    \ \");\n   |                  ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0368, E0599.\nFor more information about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = word;\n        let mut new_word_chars = new_word.chars();\n     \
    \   let mut new_word_chars_iter = new_word_chars.iter();\n        let mut new_word_chars_iter2\
    \ = new_word_chars.iter();\n        let mut new_word_chars_iter3 = new_word_chars.iter();\n\
    \        let mut new_word_chars_iter4 = new_word_chars.iter();\n        let mut\
    \ new_word_chars_iter5 = new_word_chars.iter();\n        let mut new_word_chars_iter6\
    \ = new_word_chars.iter();\n        let mut new_word_chars_iter7 = new_word_chars.iter();\n\
    \        let mut new_word_chars_iter8 = new_word_chars.iter();\n        let mut\
    \ new_word_chars_iter9 = new_word_chars.iter();\n        let mut new_word_chars_iter10\
    \ = new_word_chars.iter();\n        let mut new_word_chars_iter11 = new_word_chars.iter();\n\
    \        let mut new_word_chars_iter12 = new_word_chars.iter();\n        let mut\
    \ new_word_chars_iter13 = new_word_chars.iter();\n        let mut new_word_chars_iter14\
    \ = new_word_chars.iter();\n        let mut new_word_chars_iter15 = new_word_chars.iter();\n\
    \        let mut new_word_chars_iter16 = new_word_chars.iter();\n        let mut\
    \ new_word_chars_iter17 = new_word_chars.iter();\n        let mut new_word_chars_iter18\
    \ = new_word_chars.iter();\n        let mut new_word_chars_iter19 = new_word_chars.iter();\n\
    \        let mut new_word_chars_iter20 = new_word_chars.iter();\n        let mut\
    \ new_word_chars_iter21 = new_word_chars.iter();\n        let mut new_word_chars_iter22\
    \ = new_word_chars.iter();\n        let mut new_word_chars_iter23 = new_word_chars.iter();\n\
    \        let mut new_word_chars_iter24 = new_word_chars.iter();\n        let mut\
    \ new_word_chars_iter25 = new_word_chars.iter();\n        let mut new_word_chars_iter26\
    \ = new_word_chars.iter();\n        let mut new_word_chars_iter27 = new_word_chars.iter();\n\
    \        let mut new_word_chars_iter28 = new_word_chars.iter();\n        let mut\
    \ new_word_chars_iter29 = new_word_chars.iter\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu_12nj0v.rs:54:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n11 |     for word in words {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    43 | }\n   | - ...as it matches this but it has different indentation\n...\n54\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpu_12nj0v.rs:42:60\n\
    \   |\n42 |         let mut new_word_chars_iter29 = new_word_chars.iter\n   |\
    \                                                            ^ help: add `;` here\n\
    43 | }\n   | - unexpected token\n\nerror[E0599]: no method named `iter` found\
    \ for struct `Chars` in the current scope\n  --> /tmp/tmpu_12nj0v.rs:14:54\n \
    \  |\n14 |         let mut new_word_chars_iter = new_word_chars.iter();\n   |\
    \                                                      ^^^^ private field, not\
    \ a method\n\nerror[E0599]: no method named `iter` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpu_12nj0v.rs:15:55\n   |\n15 |         let mut\
    \ new_word_chars_iter2 = new_word_chars.iter();\n   |                        \
    \                               ^^^^ private field, not a method\n\nerror[E0599]:\
    \ no method named `iter` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpu_12nj0v.rs:16:55\n   |\n16 |         let mut new_word_chars_iter3 =\
    \ new_word_chars.iter();\n   |                                               \
    \        ^^^^ private field, not a method\n\nerror[E0599]: no method named `iter`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmpu_12nj0v.rs:17:55\n\
    \   |\n17 |         let mut new_word_chars_iter4 = new_word_chars.iter();\n  \
    \ |                                                       ^^^^ private field,\
    \ not a method\n\nerror[E0599]: no method named `iter` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpu_12nj0v.rs:18:55\n   |\n18 |         let\
    \ mut new_word_chars_iter5 = new_word_chars.iter();\n   |                    \
    \                                   ^^^^ private field, not a method\n\nerror["
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut\
    \ new_s_len5 = new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7\
    \ = new_s_len;\n    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 =\
    \ new_s_len;\n    let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 =\
    \ new_s_len;\n    let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 =\
    \ new_s_len;\n    let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 =\
    \ new_s_len;\n    let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 =\
    \ new_s_len;\n    let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 =\
    \ new_s_len;\n    let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 =\
    \ new_s_len;\n    let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 =\
    \ new_s_len;\n    let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 =\
    \ new_s_len;\n    let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 =\
    \ new_s_len;\n    let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 =\
    \ new_s_len;\n    let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 =\
    \ new_s_len;\n    let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 =\
    \ new_s_len;\n    let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 =\
    \ new_s_len;\n    let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 =\
    \ new_s_len;\n    let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 =\
    \ new_s_len;\n    let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 =\
    \ new_s_len;\n    let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 =\
    \ new_s_len;\n    let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 =\
    \ new_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplkj3xfo0.rs:54:31\n   |\n\
    54 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmplkj3xfo0.rs:54:27\n   |\n54 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmplkj3xfo0.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) -> String {\n\
    \  |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    let mut new_words = new_s.split_whitespace();\n\
    \    let mut new_words_len = 0;\n    let mut new_words_len2 = 0;\n    let mut\
    \ new_words_len3 = 0;\n    let mut new_words_len4 = 0;\n    let mut new_words_len5\
    \ = 0;\n    let mut new_words_len6 = 0;\n    let mut new_words_len7 = 0;\n   \
    \ let mut new_words_len8 = 0;\n    let mut new_words_len9 = 0;\n    let mut new_words_len10\
    \ = 0;\n    let mut new_words_len11 = 0;\n    let mut new_words_len12 = 0;\n \
    \   let mut new_words_len13 = 0;\n    let mut new_words_len14 = 0;\n    let mut\
    \ new_words_len15 = 0;\n    let mut new_words_len16 = 0;\n    let mut new_words_len17\
    \ = 0;\n    let mut new_words_len18 = 0;\n    let mut new_words_len19 = 0;\n \
    \   let mut new_words_len20 = 0;\n    let mut new_words_len21 = 0;\n    let mut\
    \ new_words_len22 = 0;\n    let mut new_words_len23 = 0;\n    let mut new_words_len24\
    \ = 0;\n    let mut new_words_len25 = 0;\n    let mut new_words_len26 = 0;\n \
    \   let mut new_words_len27 = 0;\n    let mut new_words_len28 = 0;\n    let mut\
    \ new_words_len29 = 0;\n    let mut new_words_len30 = 0;\n    let mut new_words_len31\
    \ = 0;\n    let mut new_words_len32 = 0;\n    let mut new_words_len33 = 0;\n \
    \   let mut new_words_len34 = 0;\n    let mut new_words_len35 = 0;\n    let mut\
    \ new_words_len36 = 0;\n    let mut new_words_len37 = 0;\n    let mut new_words_len38\
    \ = 0;\n    let mut new_words_len39 = 0;\n    let mut new_words_len40 = 0;\n \
    \   let mut new_words_len41 = 0;\n    let mut new_words_len42 = 0;\n    let mut\
    \ new_words_len43 = 0;\n    let mut new_words_len44 = 0;\n    let mut new_words_len45\
    \ = 0;\n    let mut new_words_len46 = 0;\n    let mut new_words_len47 = 0;\n \
    \   let mut new_words_len48 = 0;\n    let mut new_words_len49 = 0;\n    let mut\
    \ new_words_len50 = 0;\n    let mut new_words_len51 = 0;\n    let mut new_words_len52\
    \ = 0;\n    let mut new_words_len53 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7o39ign_.rs:66:1\n  \
    \ |\n66 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::with_capacity(s.len());\n    for word in words {\n\
    \        let mut new_word = String::with_capacity(word.len());\n        for c\
    \ in word.chars() {\n            if c.is_ascii() {\n                new_word.push(c);\n\
    \            } else {\n                new_word.push(c.to_ascii_uppercase());\n\
    \            }\n        }\n        new_s.push_str(&new_word);\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpw6xidh4b.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut\
    \ new_s_len5 = new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7\
    \ = new_s_len;\n    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 =\
    \ new_s_len;\n    let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 =\
    \ new_s_len;\n    let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 =\
    \ new_s_len;\n    let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 =\
    \ new_s_len;\n    let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 =\
    \ new_s_len;\n    let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 =\
    \ new_s_len;\n    let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 =\
    \ new_s_len;\n    let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 =\
    \ new_s_len;\n    let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 =\
    \ new_s_len;\n    let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 =\
    \ new_s_len;\n    let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 =\
    \ new_s_len;\n    let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 =\
    \ new_s_len;\n    let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 =\
    \ new_s_len;\n    let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 =\
    \ new_s_len;\n    let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 =\
    \ new_s_len;\n    let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 =\
    \ new_s_len;\n    let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 =\
    \ new_s_len;\n    let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 =\
    \ new_s_len;\n    let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 =\
    \ new_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplkj3xfo0.rs:54:31\n   |\n\
    54 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmplkj3xfo0.rs:54:27\n   |\n54 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmplkj3xfo0.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) -> String {\n\
    \  |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c >= ' ' {\n            s.insert(c, c.to_ascii_lowercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmxq25grl.rs:11:22\n   |\n\
    11 |             s.insert(c, c.to_ascii_lowercase());\n   |                  \
    \    ^ expected `usize`, found `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let\
    \ mut new_s_len5 = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let\
    \ mut new_s_len7 = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let\
    \ mut new_s_len9 = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let\
    \ mut new_s_len11 = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n   \
    \ let mut new_s_len13 = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n\
    \    let mut new_s_len15 = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n\
    \    let mut new_s_len17 = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n\
    \    let mut new_s_len19 = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n\
    \    let mut new_s_len21 = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n\
    \    let mut new_s_len23 = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n\
    \    let mut new_s_len25 = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n\
    \    let mut new_s_len27 = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n\
    \    let mut new_s_len29 = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n\
    \    let mut new_s_len31 = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n\
    \    let mut new_s_len33 = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n\
    \    let mut new_s_len35 = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n\
    \    let mut new_s_len37 = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n\
    \    let mut new_s_len39 = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp22sfetvu.rs:49:33\n   |\n\
    49 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp22sfetvu.rs:49:27\n   |\n49\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp22sfetvu.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) ->\
    \ String {\n  |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = word;\n        let mut new_word_len = 0;\n        for c in word.chars()\
    \ {\n            if c.is_ascii() {\n                new_word.push(c);\n      \
    \          new_word_len += 1;\n            }\n        }\n        new_word.truncate(new_word_len);\n\
    \        new_s += new_word + \" \";\n    }\n    new_s.trim();\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpro5nwl0u.rs:16:26\n   |\n16 |                 new_word.push(c);\n\
    \   |                          ^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `truncate` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpro5nwl0u.rs:20:18\n   |\n20 |         new_word.truncate(new_word_len);\n\
    \   |                  ^^^^^^^^ method not found in `&str`\n\nerror[E0369]: cannot\
    \ add `&str` to `&str`\n  --> /tmp/tmpro5nwl0u.rs:21:27\n   |\n21 |         new_s\
    \ += new_word + \" \";\n   |                  -------- ^ --- &str\n   |      \
    \            |        |\n   |                  |        `+` cannot be used to\
    \ concatenate two `&str` strings\n   |                  &str\n   |\n   = note:\
    \ string concatenation requires an owned `String` on the left\nhelp: create an\
    \ owned `String` from a string reference\n   |\n21 |         new_s += new_word.to_owned()\
    \ + \" \";\n   |                          +++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = word;\n        let mut new_word_ord = String::new();\n        for\
    \ c in word.chars() {\n            new_word_ord.push((c as i32).to_string());\n\
    \        }\n        new_word.clear();\n        new_word.push_str(new_word_ord);\n\
    \        new_s.push_str(new_word);\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1_wijr3e.rs:15:31\n   |\n\
    15 |             new_word_ord.push((c as i32).to_string());\n   |            \
    \                   ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0599]: no method named `clear` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmp1_wijr3e.rs:17:18\n   |\n17 |         new_word.clear();\n\
    \   |                  ^^^^^ method not found in `&str`\n\nerror[E0599]: no method\
    \ named `push_str` found for reference `&str` in the current scope\n  --> /tmp/tmp1_wijr3e.rs:18:18\n\
    \   |\n18 |         new_word.push_str(new_word_ord);\n   |                  ^^^^^^^^\
    \ method not found in `&str`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    let mut new_words = new_s.split_whitespace();\n\
    \    let mut new_words_len = new_words.len();\n    let mut i = 0;\n    while i\
    \ < new_words_len {\n        let mut j = i;\n        while j < new_words_len &&\
    \ new_words[j].len() < new_words[i].len() {\n            j = j + 1;\n        }\n\
    \        let mut k = i;\n        while k < new_words_len && new_words[k].len()\
    \ > new_words[i].len() {\n            k = k + 1;\n        }\n        if k > i\
    \ {\n            new_words[k] = new_words[k].to_string();\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[j]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[j]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[j]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[j]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[j]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[j]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[j]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[j]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[j]);\n\
    \            new_words[k].push(' ');\n            new_words[k].push_str(&new_words[i]);\n\
    \            new_words[k].push(' ');\n            new_\n}\n\nfn main() {\n   \
    \ let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbtkbcwoy.rs:75:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     while i < new_words_len\
    \ {\n   |                             - unclosed delimiter\n...\n23 |        \
    \ if k > i {\n   |                  - this delimiter might not be properly closed...\n\
    ...\n64 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    75 | }\n   |   ^\n\nerror[E0425]: cannot find value `new_` in this scope\n  -->\
    \ /tmp/tmpbtkbcwoy.rs:63:13\n   |\n63 |             new_\n   |             ^^^^\
    \ help: a local variable with a similar name exists: `new_s`\n\nerror[E0599]:\
    \ no method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpbtkbcwoy.rs:12:39\n   |\n12 |     let mut new_words_len = new_words.len();\n\
    \   |                                       ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpbtkbcwoy.rs:16:36\n   |\n16 |         while j < new_words_len && new_words[j].len()\
    \ < new_words[i].len() {\n   |                                    ^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpbtkbcwoy.rs:16:57\n   |\n16 |         while j < new_words_len && new_words[j].len()\
    \ < new_words[i].len() {\n   |                                               \
    \          ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpbtkbcwoy.rs:20:36\n   |\n20 |         while k < new_words_len &&\
    \ new_words[k].len() > new_words[i].len() {\n   |                            \
    \        ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpbtkbcwoy.rs:20:57\n   |\n20 |         while k < new_words_len &&\
    \ new_words[k].len() > new_words[i].len() {\n   |                            \
    \                             ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpbtkbcwoy.r"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let mut new_word = String::from(word);\n        for c in word.chars()\
    \ {\n            let mut new_c = c;\n            if c.is_ascii() {\n         \
    \       new_c += 1;\n            }\n            new_word.push(new_c.to_string());\n\
    \        }\n        new_s += new_word + \" \";\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpbxa1jgoc.rs:11:28\n   |\n11 |     for (i,\
    \ word) in words.iter().enumerate() {\n   |                            ^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbxa1jgoc.rs:20:18\n   |\n20 |         new_s += new_word + \" \";\n \
    \  |                  ^^^^^^^^^^^^^^\n   |                  |\n   |          \
    \        expected `&str`, found struct `String`\n   |                  help: consider\
    \ borrowing here: `&(new_word + \" \")`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len {\n            if s[i]\
    \ != ' ' && s[j] != ' ' {\n                let mut new_word = String::new();\n\
    \                new_word.push_str(&s[j..]);\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[j..]);\n\
    \                new_word.push_str(&' ');\n                new_word.push_str(&s[i]);\n\
    \                new_word.push_str(&' ');\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1bhwi_q4.rs:83:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n12 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n13 |         let mut j = i;\n\
    14 |         while j < new_s_len {\n   |                             - unclosed\
    \ delimiter\n15 |             if s[i] != ' ' && s[j] != ' ' {\n   |          \
    \                                 - this delimiter might not be properly closed...\n\
    ...\n72 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    83 | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1bhwi_q4.rs:15:16\n   |\n15 |             if s[i] != ' ' && s[j]\
    \ != ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1bhwi_q4.rs:15:31\n   |\n15 |             if s[i] != ' ' && s[j]\
    \ != ' ' {\n   |                               ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String`"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = String::new();\n        let mut new_word_len = String::new();\n \
    \       let mut new_word_len_value = String::new();\n        for c in word.chars()\
    \ {\n            new_word_len.push(c);\n            new_word_len_value.push(*c);\n\
    \        }\n        let mut new_word_len = new_word_len.chars().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.chars().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_word_len_value.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_word_len_value = new_\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3pgt9y9x.rs:48:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n11 |     for word in words {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    37 | }\n   | - ...as it matches this but it has different indentation\n...\n48\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp3pgt9y9x.rs:36:42\n\
    \   |\n36 |         let mut new_word_len_value = new_\n   |                  \
    \                        ^ help: add `;` here\n37 | }\n   | - unexpected token\n\
    \nerror[E0425]: cannot find value `new_` in this scope\n  --> /tmp/tmp3pgt9y9x.rs:36:38\n\
    \   |\n36 |         let mut new_word_len_value = new_\n   |                  \
    \                    ^^^^ help: a local variable with a similar name exists: `new_s`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp3pgt9y9x.rs:17:37\n\
    \   |\n17 |             new_word_len_value.push(*c);\n   |                   \
    \                  ^^\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3pgt9y9x.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.swap(i, i + 1);\n     \
    \   }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp0s3n_yg0.rs:11:15\n   |\n11 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c != ' ' {\n            s.insert(c, c.to_ascii_lowercase());\n       \
    \ }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9860ou7h.rs:11:22\n   |\n\
    11 |             s.insert(c, c.to_ascii_lowercase());\n   |                  \
    \    ^ expected `usize`, found `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    let mut new_words = Vec::new();\n   \
    \ let mut new_words_len = 0;\n    let mut new_words_len2 = 0;\n    let mut new_words_len3\
    \ = 0;\n    let mut new_words_len4 = 0;\n    let mut new_words_len5 = 0;\n   \
    \ let mut new_words_len6 = 0;\n    let mut new_words_len7 = 0;\n    let mut new_words_len8\
    \ = 0;\n    let mut new_words_len9 = 0;\n    let mut new_words_len10 = 0;\n  \
    \  let mut new_words_len11 = 0;\n    let mut new_words_len12 = 0;\n    let mut\
    \ new_words_len13 = 0;\n    let mut new_words_len14 = 0;\n    let mut new_words_len15\
    \ = 0;\n    let mut new_words_len16 = 0;\n    let mut new_words_len17 = 0;\n \
    \   let mut new_words_len18 = 0;\n    let mut new_words_len19 = 0;\n    let mut\
    \ new_words_len20 = 0;\n    let mut new_words_len21 = 0;\n    let mut new_words_len22\
    \ = 0;\n    let mut new_words_len23 = 0;\n    let mut new_words_len24 = 0;\n \
    \   let mut new_words_len25 = 0;\n    let mut new_words_len26 = 0;\n    let mut\
    \ new_words_len27 = 0;\n    let mut new_words_len28 = 0;\n    let mut new_words_len29\
    \ = 0;\n    let mut new_words_len30 = 0;\n    let mut new_words_len31 = 0;\n \
    \   let mut new_words_len32 = 0;\n    let mut new_words_len33 = 0;\n    let mut\
    \ new_words_len34 = 0;\n    let mut new_words_len35 = 0;\n    let mut new_words_len36\
    \ = 0;\n    let mut new_words_len37 = 0;\n    let mut new_words_len38 = 0;\n \
    \   let mut new_words_len39 = 0;\n    let mut new_words_len40 = 0;\n    let mut\
    \ new_words_len41 = 0;\n    let mut new_words_len42 = 0;\n    let mut new_words_len43\
    \ = 0;\n    let mut new_words_len44 = 0;\n    let mut new_words_len45 = 0;\n \
    \   let mut new_words_len46 = 0;\n    let mut new_words_len47 = 0;\n    let mut\
    \ new_words_len48 = 0;\n    let mut new_words_len49 = 0;\n    let mut new_words_len50\
    \ = 0;\n    let mut new_words_len51 = 0;\n    let mut new_words_len52 = 0;\n \
    \   let mut new_words_len53 = 0;\n    let mut new_words_\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpudd_oo08.rs:65:23\n   |\n\
    65 |     let mut new_words_\n   |                       ^ help: add `;` here\n\
    66 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpudd_oo08.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.insert(i, ' ');\n     \
    \   } else {\n            s.insert(i, c.to_ascii_lowercase());\n        }\n  \
    \  });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpc01u1b87.rs:9:36\n   |\n9  |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     -                     -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n10 |     \
    \    if c.is_whitespace() {\n11 |             s.insert(i, ' ');\n   |        \
    \     - second borrow occurs due to use of `s` in closure\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s = String::from(s);\n    let mut \n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmppd1m3vw6.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    let mut new_words = Vec::new();\n   \
    \ let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let\
    \ mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let mut\
    \ new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words\
    \ = Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words =\
    \ Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n\
    \    let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n  \
    \  let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let\
    \ mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let mut\
    \ new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words\
    \ = Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words =\
    \ Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n\
    \    let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n  \
    \  let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let\
    \ mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let mut\
    \ new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words\
    \ = Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words =\
    \ Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n\
    \    let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n  \
    \  let mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let\
    \ mut new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let mut\
    \ new_words = Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words\
    \ = Vec::new();\n    let mut new_words = Vec::new();\n    let mut new_words =\
    \ Vec::\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpnfrcst7j.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c < ' ' {\n            s.insert(c, ' ');\n        }\n    });\n    s.chars().for_each(|c|\
    \ {\n        if c >= ' ' {\n            s.insert(c, ' ');\n        }\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4_179qh1.rs:11:22\n   |\n\
    11 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4_179qh1.rs:16:22\n\
    \   |\n16 |             s.insert(c, ' ');\n   |                      ^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_words = Vec::new();\n    let mut new_s = String::new();\n   \
    \ for word in words {\n        let mut new_word = String::from(word);\n      \
    \  let mut new_word_len = new_word.len();\n        for c in new_word {\n     \
    \       if c != ' ' {\n                new_word_len += 1;\n            }\n   \
    \     }\n        new_word.truncate(new_word_len);\n        new_words.push(new_word);\n\
    \    }\n    for new_word in new_words {\n        let mut new_word_len = new_word.len();\n\
    \        for c in new_word {\n            if c != ' ' {\n                new_word_len\
    \ += 1;\n            }\n        }\n        new_word.truncate(new_word_len);\n\
    \        new_s += new_word + \" \";\n    }\n    new_s.trim();\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp98zlwn9m.rs:15:18\n\
    \   |\n15 |         for c in new_word {\n   |                  ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp98zlwn9m.rs:25:18\n   |\n25 |   \
    \      for c in new_word {\n   |                  ^^^^^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp98zlwn9m.rs:31:18\n   |\n31 |         new_s += new_word + \" \"\
    ;\n   |                  ^^^^^^^^^^^^^^\n   |                  |\n   |       \
    \           expected `&str`, found struct `String`\n   |                  help:\
    \ consider borrowing here: `&(new_word + \" \")`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_words = Vec::new();\n    for word in words {\n        let mut\
    \ new_word = String::from(word);\n        let mut new_word_chars = new_word.chars();\n\
    \        let mut new_word_chars_iter = new_word_chars.iter();\n        let mut\
    \ new_word_chars_len = new_word_chars.len();\n        let mut new_word_chars_sorted\
    \ = new_word_chars.sorted();\n        let mut new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n\
    \        let mut new_word_chars_sorted_len = new_word_chars_sorted.len();\n  \
    \      let mut new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n  \
    \      let mut new_word_chars_sorted_len = new_word_chars_sorted.len();\n    \
    \    let mut new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n    \
    \    let mut new_word_chars_sorted_len = new_word_chars_sorted.len();\n      \
    \  let mut new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n      \
    \  let mut new_word_chars_sorted_len = new_word_chars_sorted.len();\n        let\
    \ mut new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n        let\
    \ mut new_word_chars_sorted_len = new_word_chars_sorted.len();\n        let mut\
    \ new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n        let mut\
    \ new_word_chars_sorted_len = new_word_chars_sorted.len();\n        let mut new_word_chars_sorted_iter\
    \ = new_word_chars_sorted.iter();\n        let mut new_word_chars_sorted_len =\
    \ new_word_chars_sorted.len();\n        let mut new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n\
    \        let mut new_word_chars_sorted_len = new_word_chars_sorted.len();\n  \
    \      let mut new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n  \
    \      let mut new_word_chars_sorted_len = new_word_chars_sorted.len();\n    \
    \    let mut new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n    \
    \    let mut new_word_chars_sorted_len = new_word_chars_sorted.len();\n      \
    \  let mut new_word_chars_sorted_iter = new_word_chars_sorted.iter();\n      \
    \  let mut new_word_chars_sorted_len = new_word_chars_sorted.len();\n        let\
    \ mut new_word_chars_sorted_iter = new_word_chars_sor\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmqlhs18h.rs:51:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n11 |     for word in words {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    40 | }\n   | - ...as it matches this but it has different indentation\n...\n51\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpmqlhs18h.rs:39:64\n\
    \   |\n39 |         let mut new_word_chars_sorted_iter = new_word_chars_sor\n\
    \   |                                                                ^ help: add\
    \ `;` here\n40 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_word_chars_sor` in this scope\n  --> /tmp/tmpmqlhs18h.rs:39:46\n   |\n\
    39 |         let mut new_word_chars_sorted_iter = new_word_chars_sor\n   |   \
    \                                           ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `new_word_chars_iter`\n\nerror[E0599]: no method\
    \ named `iter` found for struct `Chars` in the current scope\n  --> /tmp/tmpmqlhs18h.rs:14:54\n\
    \   |\n14 |         let mut new_word_chars_iter = new_word_chars.iter();\n   |\
    \                                                      ^^^^ private field, not\
    \ a method\n\nerror[E0599]: no method named `len` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpmqlhs18h.rs:15:53\n   |\n15 |         let mut\
    \ new_word_chars_len = new_word_chars.len();\n   |                           \
    \                          ^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `sorted` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpmqlhs18h.rs:16:56\n   |\n16 |         let mut new_word_chars_sorted\
    \ = new_word_chars.sorted();\n   |                                           \
    \             ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpmqlhs18h.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) ->\
    \ String {\n  |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its "
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let\
    \ mut new_s_len5 = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let\
    \ mut new_s_len7 = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let\
    \ mut new_s_len9 = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let\
    \ mut new_s_len11 = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n   \
    \ let mut new_s_len13 = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n\
    \    let mut new_s_len15 = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n\
    \    let mut new_s_len17 = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n\
    \    let mut new_s_len19 = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n\
    \    let mut new_s_len21 = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n\
    \    let mut new_s_len23 = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n\
    \    let mut new_s_len25 = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n\
    \    let mut new_s_len27 = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n\
    \    let mut new_s_len29 = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n\
    \    let mut new_s_len31 = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n\
    \    let mut new_s_len33 = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n\
    \    let mut new_s_len35 = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n\
    \    let mut new_s_len37 = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n\
    \    let mut new_s_len39 = new_s_len38;\n    let mut new_s_len\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp34lupodv.rs:49:22\n   |\n\
    49 |     let mut new_s_len\n   |                      ^ help: add `;` here\n50\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp34lupodv.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    for word in words {\n        let mut\
    \ new_word = String::from(word);\n        for c in new_word.chars() {\n      \
    \      if c < 'a' || c > 'z' {\n                new_word.push(c);\n          \
    \  }\n        }\n        new_s.push_str(&new_word);\n    }\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpxrhna7y_.rs:8:9\n\
    \  |\n8 |     let mut s = String::from(s);\n  |         ----^\n  |         |\n\
    \  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on\
    \ by default\n\nwarning: variable does not need to be mutable\n --> /tmp/tmpxrhna7y_.rs:9:9\n\
    \  |\n9 |     let mut words = s.split_whitespace();\n  |         ----^^^^^\n \
    \ |         |\n  |         help: remove this `mut`\n\nerror[E0505]: cannot move\
    \ out of `s` because it is borrowed\n  --> /tmp/tmpxrhna7y_.rs:10:34\n   |\n9\
    \  |     let mut words = s.split_whitespace();\n   |                     --------------------\
    \ borrow of `s` occurs here\n10 |     let mut new_s = String::from(s);\n   | \
    \                                 ^ move out of `s` occurs here\n11 |     for\
    \ word in words {\n   |                 ----- borrow later used here\n\nerror[E0502]:\
    \ cannot borrow `new_word` as mutable because it is also borrowed as immutable\n\
    \  --> /tmp/tmpxrhna7y_.rs:15:17\n   |\n13 |         for c in new_word.chars()\
    \ {\n   |                  ----------------\n   |                  |\n   |   \
    \               immutable borrow occurs here\n   |                  immutable\
    \ borrow later used here\n14 |             if c < 'a' || c > 'z' {\n15 |     \
    \            new_word.push(c);\n   |                 ^^^^^^^^^^^^^^^^ mutable\
    \ borrow occurs here\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\
    \nSome errors have detailed explanations: E0502, E0505.\nFor more information\
    \ about an error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words = s.split_whitespace();\n    let mut\
    \ result = String::new();\n    let mut new_word = \"\";\n    for word in words\
    \ {\n        let mut new_word = new_word.clone();\n        for c in word.chars()\
    \ {\n            if c.is_ascii() {\n                new_word.push(c);\n      \
    \      } else {\n                new_word.push(c.to_ascii_lowercase());\n    \
    \        }\n        }\n        result.push(new_word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpcrvqrwvq.rs:15:26\n   |\n15 |                 new_word.push(c);\n\
    \   |                          ^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `push` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpcrvqrwvq.rs:17:26\n   |\n17 |                 new_word.push(c.to_ascii_lowercase());\n\
    \   |                          ^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcrvqrwvq.rs:20:21\n   |\n20 |         result.push(new_word);\n\
    \   |                     ^^^^^^^^ expected `char`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.replace(\"a\", \"z\");\n    s.replace(\"\
    b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"d\", \"w\");\n   \
    \ s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n    s.replace(\"g\"\
    , \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\", \"r\");\n    s.replace(\"\
    j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"l\", \"o\");\n   \
    \ s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n    s.replace(\"o\"\
    , \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\", \"j\");\n    s.replace(\"\
    r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"t\", \"g\");\n   \
    \ s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n    s.replace(\"w\"\
    , \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\", \"b\");\n    s.replace(\"\
    z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpyx4yvdmd.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c != ' ' {\n            s.insert(c.to_ascii_lowercase(), ' ');\n     \
    \   }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1cz4_kaq.rs:11:22\n   |\n\
    11 |             s.insert(c.to_ascii_lowercase(), ' ');\n   |                \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"r\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"t\");\n    s.replace(\"\
    t\", \"s\");\n    s.replace(\"u\", \"o\");\n    s.replace(\"v\", \"h\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"f\");\n    s.replace(\"y\"\
    , \"g\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp_gmkk80y.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len {\n            if s[i]\
    \ == ' ' || s[i] == '\\n' || s[i] == '\\r' {\n                j += 1;\n      \
    \          continue;\n            }\n            if s[j] < s[i] {\n          \
    \      new_s.push_str(&s[j..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n                new_s.push_str(&s[0..i]);\n\
    \                new_s.push_str(&s[0..i]);\n\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpklo9s2dj.rs:75:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n12 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n13 |         let mut j = i;\n\
    14 |         while j < new_s_len {\n   |                             - unclosed\
    \ delimiter\n...\n19 |             if s[j] < s[i] {\n   |                    \
    \        - this delimiter might not be properly closed...\n...\n64 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n75 | }\n   |  \
    \ ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpklo9s2dj.rs:15:16\n\
    \   |\n15 |             if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\r' {\n \
    \  |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpklo9s2dj.rs:15:31\n   |\n15 |             if s[i] == ' ' || s[i]\
    \ == '\\n' || s[i] == '\\r' {\n   |                               ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type "
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c < ' ' {\n            s.insert(c, ' ');\n        }\n    });\n\
    \    s.chars().for_each(|c| {\n        if c > ' ' {\n            s.insert(c, '\
    \ ');\n        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp511jvxyy.rs:11:22\n   |\n\
    11 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp511jvxyy.rs:16:22\n\
    \   |\n16 |             s.insert(c, ' ');\n   |                      ^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c.is_whitespace() {\n            s.insert(s.len(), ' ');\n        } else\
    \ {\n            s.insert(s.len(), c.to_ascii_lowercase());\n        }\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpfm90hrp5.rs:9:24\n   |\n9  |     s.chars().for_each(|c|\
    \ {\n   |     --------- -------- ^^^ mutable borrow occurs here\n   |     |  \
    \       |\n   |     |         immutable borrow later used by call\n   |     immutable\
    \ borrow occurs here\n10 |         if c.is_whitespace() {\n11 |             s.insert(s.len(),\
    \ ' ');\n   |             - second borrow occurs due to use of `s` in closure\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c.is_whitespace() {\n            s.push_str(\"_\");\n        }\
    \ else {\n            s.push_str(&c.to_ascii_lowercase());\n        }\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpblprrhkj.rs:13:24\n   |\n\
    13 |             s.push_str(&c.to_ascii_lowercase());\n   |                  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_ascii() {\n            let mut c = c.to_ascii_lowercase();\n\
    \            c.swap(0, 1);\n            s.insert(i, c);\n        }\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpwujmiwxy.rs:12:15\n   |\n12 |             c.swap(0, 1);\n\
    \   |               ^^^^ method not found in `char`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_alphabetic() {\n            if i > 0 {\n            \
    \    s.insert(i, ' ');\n            }\n            s.insert(i, c.to_ascii_lowercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpu_vhgztw.rs:9:36\n   |\n9  |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     ---------             -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n...\n12 |\
    \                 s.insert(i, ' ');\n   |                 - second borrow occurs\
    \ due to use of `s` in closure\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_ascii() {\n            s.insert(i, c.to_ascii_lowercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp984muba2.rs:9:36\n   |\n9  |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     ---------             -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n10 |     \
    \    if c.is_ascii() {\n11 |             s.insert(i, c.to_ascii_lowercase());\n\
    \   |             - second borrow occurs due to use of `s` in closure\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.sort_by_key(|&x| x.chars().count());\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpl79id9x5.rs:9:7\n  |\n9 |     s.sort_by_key(|&x|\
    \ x.chars().count());\n  |       ^^^^^^^^^^^ method not found in `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().sort_by(|a,\
    \ b| a.cmp(b));\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmpd6recyyl.rs:9:15\n  |\n9 |     s.chars().sort_by(|a,\
    \ b| a.cmp(b));\n  |               ^^^^^^^ method not found in `Chars<'_>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_word = \"\";\n    let mut new_word_len = 0;\n    let mut i =\
    \ 0;\n    while i < words.len() {\n        let mut j = i;\n        while j < words.len()\
    \ {\n            if words[j].len() > new_word_len {\n                new_word_len\
    \ = words[j].len();\n            }\n            if words[j].len() < new_word_len\
    \ {\n                break;\n            }\n            j += 1\n        }\n  \
    \      new_word += &words[i .. j];\n        i += j - i;\n    }\n    new_word +=\
    \ &words[i .. words.len()];\n    return new_word;\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpe09jk_xq.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpe09jk_xq.rs:15:25\n   |\n15 |         while j <\
    \ words.len() {\n   |                         ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpe09jk_xq.rs:16:16\n   |\n16 |             if words[j].len() > new_word_len\
    \ {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpe09jk_xq.rs:17:32\n   |\n17 |    \
    \             new_word_len = words[j].len();\n   |                           \
    \     ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpe09jk_xq.rs:19:16\n   |\n19 |             if words[j].len() < new_word_len\
    \ {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpe09jk_xq.rs:24:22\n   |\n24 |    \
    \     new_word += &words[i .. j];\n   |                      ^^^^^^^^^^^^^\n\n\
    error[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpe09jk_xq.rs:27:35\n   |\n27 |     new_word += &words[i\
    \ .. words.len()];\n   |                                   ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpe09jk_xq.rs:27:18\n   |\n27 |     new_word\
    \ += &words[i .. words.len()];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe09jk_xq.rs:28:12\n   |\n7  |\
    \ fn anti_shuffle(s: String) -> String {\n   |                               ------\
    \ expected `String` because of return type\n...\n28 |     return new_word;\n \
    \  |            ^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |            |\n   |            "
  stdout: ''
  timestamp: 1659976521
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"r\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpfl5kn402.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = String::new();\n        for c in word.chars() {\n            if c\
    \ < 'a' || c > 'z' {\n                new_word.push(c);\n            } else {\n\
    \                new_word.push(c - 'a' + 1);\n            }\n        }\n     \
    \   new_s += new_word;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp5_484z23.rs:17:33\n\
    \   |\n17 |                 new_word.push(c - 'a' + 1);\n   |                \
    \               - ^ --- char\n   |                               |\n   |     \
    \                          char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5_484z23.rs:20:18\n\
    \   |\n20 |         new_s += new_word;\n   |                  ^^^^^^^^\n   | \
    \                 |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&new_word`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = String::new();\n    let mut new_s_len2 = String::new();\n\
    \    let mut new_s_len3 = String::new();\n    let mut new_s_len4 = String::new();\n\
    \    let mut new_s_len5 = String::new();\n    let mut new_s_len6 = String::new();\n\
    \    let mut new_s_len7 = String::new();\n    let mut new_s_len8 = String::new();\n\
    \    let mut new_s_len9 = String::new();\n    let mut new_s_len10 = String::new();\n\
    \    let mut new_s_len11 = String::new();\n    let mut new_s_len12 = String::new();\n\
    \    let mut new_s_len13 = String::new();\n    let mut new_s_len14 = String::new();\n\
    \    let mut new_s_len15 = String::new();\n    let mut new_s_len16 = String::new();\n\
    \    let mut new_s_len17 = String::new();\n    let mut new_s_len18 = String::new();\n\
    \    let mut new_s_len19 = String::new();\n    let mut new_s_len20 = String::new();\n\
    \    let mut new_s_len21 = String::new();\n    let mut new_s_len22 = String::new();\n\
    \    let mut new_s_len23 = String::new();\n    let mut new_s_len24 = String::new();\n\
    \    let mut new_s_len25 = String::new();\n    let mut new_s_len26 = String::new();\n\
    \    let mut new_s_len27 = String::new();\n    let mut new_s_len28 = String::new();\n\
    \    let mut new_s_len29 = String::new();\n    let mut new_s_len30 = String::new();\n\
    \    let mut new_s_len31 = String::new();\n    let mut new_s_len32 = String::new();\n\
    \    let mut new_s_len33 = String::new();\n    let mut new_s_len34 = String::new();\n\
    \    let mut new_s_len35 = String::new();\n    let mut new_s_len36 = String::new();\n\
    \    let mut new_s_len37 = String::new();\n    let mut new_s_len38 = String::new();\n\
    \    let mut new_s_len39 = String::new();\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprgo8ta4f.rs:49:11\n   |\n\
    49 |     let mu\n   |           ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmprgo8ta4f.rs:7:31\n  |\n\
    7 | fn anti_shuffle(s: String) -> String {\n  |    ------------              \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_ascii() {\n            let mut j = i;\n            while\
    \ j > 0 && c.is_ascii() {\n                s[j] = s[j - 1];\n                j\
    \ -= 1;\n            }\n            s[j] = c;\n        }\n    });\n    s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpku73w7fj.rs:13:17\n\
    \   |\n13 |                 s[j] = s[j - 1];\n   |                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpku73w7fj.rs:13:24\n   |\n13 |                 s[j] = s[j - 1];\n\
    \   |                        ^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpku73w7fj.rs:16:13\n   |\n16 |             s[j] = c;\n   |     \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 pr"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n  \
    \          j = j + 1;\n        }\n        let mut new_word = String::new();\n\
    \        let mut new_word_len = j - i;\n        while new_word_len > 0 {\n   \
    \         let mut new_char = 0;\n            let mut new_char_len = 0;\n     \
    \       while new_char_len < new_word_len {\n                new_char = new_char\
    \ + s[j + new_char_len].as_byte().unwrap();\n                new_char_len = new_char_len\
    \ + 1;\n            }\n            new_word.push((new_char as char).to_string());\n\
    \            new_word_len = new_word_len - 1;\n        }\n        new_s.push(new_word);\n\
    \        i = j + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_1keq8v3.rs:14:32\n\
    \   |\n14 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_1keq8v3.rs:23:39\n   |\n23 |                 new_char = new_char\
    \ + s[j + new_char_len].as_byte().unwrap();\n   |                            \
    \           ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_1keq8v3.rs:26:27\n   |\n26 |             new_word.push((new_char\
    \ as char).to_string());\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp_1keq8v3.rs:29:20\n   |\n29 |         new_s.push(new_word);\n  \
    \ |                    ^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `{integer}`\n  --> /tmp/tmp_1keq8v3.rs:26:27\n\
    \   |\n26 |             new_word.push((new_char as char).to_string());\n   | \
    \          "
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.sort_by_key(|&x| x.chars().map(|c|\
    \ c.to_ascii_lowercase()).collect::<Vec<_>>());\n    s\n}\n\nfn main() {\n   \
    \ let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpxium6rzo.rs:9:7\n  |\n9 |     s.sort_by_key(|&x|\
    \ x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n  |       ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c < ' ' {\n            s.insert(c, ' ');\n        } else {\n \
    \           s.insert(c, ' ');\n            s.insert(c, ' ');\n        }\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp82c9d5zg.rs:11:22\n   |\n\
    11 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82c9d5zg.rs:13:22\n\
    \   |\n13 |             s.insert(c, ' ');\n   |                      ^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82c9d5zg.rs:14:22\n\
    \   |\n14 |             s.insert(c, ' ');\n   |                      ^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    let mut new_words = Vec::new();\n   \
    \ let mut new_words_len = 0;\n    let mut new_words_len2 = 0;\n    let mut new_words_len3\
    \ = 0;\n    let mut new_words_len4 = 0;\n    let mut new_words_len5 = 0;\n   \
    \ let mut new_words_len6 = 0;\n    let mut new_words_len7 = 0;\n    let mut new_words_len8\
    \ = 0;\n    let mut new_words_len9 = 0;\n    let mut new_words_len10 = 0;\n  \
    \  let mut new_words_len11 = 0;\n    let mut new_words_len12 = 0;\n    let mut\
    \ new_words_len13 = 0;\n    let mut new_words_len14 = 0;\n    let mut new_words_len15\
    \ = 0;\n    let mut new_words_len16 = 0;\n    let mut new_words_len17 = 0;\n \
    \   let mut new_words_len18 = 0;\n    let mut new_words_len19 = 0;\n    let mut\
    \ new_words_len20 = 0;\n    let mut new_words_len21 = 0;\n    let mut new_words_len22\
    \ = 0;\n    let mut new_words_len23 = 0;\n    let mut new_words_len24 = 0;\n \
    \   let mut new_words_len25 = 0;\n    let mut new_words_len26 = 0;\n    let mut\
    \ new_words_len27 = 0;\n    let mut new_words_len28 = 0;\n    let mut new_words_len29\
    \ = 0;\n    let mut new_words_len30 = 0;\n    let mut new_words_len31 = 0;\n \
    \   let mut new_words_len32 = 0;\n    let mut new_words_len33 = 0;\n    let mut\
    \ new_words_len34 = 0;\n    let mut new_words_len35 = 0;\n    let mut new_words_len36\
    \ = 0;\n    let mut new_words_len37 = 0;\n    let mut new_words_len38 = 0;\n \
    \   let mut new_words_len39 = 0;\n    let mut new_words_len40 = 0;\n    let mut\
    \ new_words_len41 = 0;\n    let mut new_words_len42 = 0;\n    let mut new_words_len43\
    \ = 0;\n    let mut new_words_len44 = 0;\n    let mut new_words_len45 = 0;\n \
    \   let mut new_words_len46 = 0;\n    let mut new_words_len47 = 0;\n    let mut\
    \ new_words_len48 = 0;\n    let mut new_words_len49 = 0;\n    let mut new_words_len50\
    \ = 0;\n    let mut new_words_len51 = 0;\n    let mut new_words_len52 = 0;\n \
    \   let mut new_words_len53 = 0;\n    let mut new_words_\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpudd_oo08.rs:65:23\n   |\n\
    65 |     let mut new_words_\n   |                       ^ help: add `;` here\n\
    66 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpudd_oo08.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c.is_ascii() {\n            s.insert(c.to_ascii_lowercase(), c.to_ascii_lowercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo88fqdtk.rs:11:22\n   |\n\
    11 |             s.insert(c.to_ascii_lowercase(), c.to_ascii_lowercase());\n \
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n   \
    \     let mut j = i;\n        while j < s.len() {\n            let c = s[j];\n\
    \            if c != ' ' {\n                new_s[new_s_len] = c;\n          \
    \      new_s_len += 1;\n            }\n            j += 1\n        }\n       \
    \ let mut k = i;\n        while k < s.len() {\n            let c = s[k];\n   \
    \         if c == ' ' {\n                new_s[new_s_len] = c;\n             \
    \   new_s_len += 1;\n            }\n            k += 1\n        }\n        i +=\
    \ 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnhoaegek.rs:15:21\n\
    \   |\n15 |             let c = s[j];\n   |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpnhoaegek.rs:17:17\n   |\n17 |                 new_s[new_s_len]\
    \ = c;\n   |                 ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnhoaegek.rs:24:21\n   |\n24 |             let c = s[k];\n   | \
    \                    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.sort_by_key(|&x| x.chars().count());\n\
    \    s.replace(\"  \", \" \");\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n --> /tmp/tmphzc3muvh.rs:9:7\n  |\n9 |     s.sort_by_key(|&x|\
    \ x.chars().count());\n  |       ^^^^^^^^^^^ method not found in `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c < ' ' {\n            s.insert(c, ' ');\n        }\n    });\n\
    \    let mut words = s.split_whitespace();\n    words.sort_by_key(|&x| x.chars().map(|c|\
    \ c.to_ascii_lowercase()).collect::<Vec<_>>());\n    words.join(\" \")\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfnhfgjq0.rs:11:22\n   |\n\
    11 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror[E0599]: no method named `sort_by_key` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmpfnhfgjq0.rs:15:11\n  \
    \ |\n15 |     words.sort_by_key(|&x| x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n\
    \   |           ^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `join` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpfnhfgjq0.rs:16:11\n   |\n16 |     words.join(\" \")\n   |     \
    \      ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    let mut new_words = new_s.split_whitespace();\n\
    \    let mut new_words_len = new_words.len();\n    let mut new_words_len2 = new_words_len\
    \ / 2;\n    let mut new_words_len3 = new_words_len2 / 2;\n    let mut new_words_len4\
    \ = new_words_len3 / 2;\n    let mut new_words_len5 = new_words_len4 / 2;\n  \
    \  let mut new_words_len6 = new_words_len5 / 2;\n    let mut new_words_len7 =\
    \ new_words_len6 / 2;\n    let mut new_words_len8 = new_words_len7 / 2;\n    let\
    \ mut new_words_len9 = new_words_len8 / 2;\n    let mut new_words_len10 = new_words_len9\
    \ / 2;\n    let mut new_words_len11 = new_words_len10 / 2;\n    let mut new_words_len12\
    \ = new_words_len11 / 2;\n    let mut new_words_len13 = new_words_len12 / 2;\n\
    \    let mut new_words_len14 = new_words_len13 / 2;\n    let mut new_words_len15\
    \ = new_words_len14 / 2;\n    let mut new_words_len16 = new_words_len15 / 2;\n\
    \    let mut new_words_len17 = new_words_len16 / 2;\n    let mut new_words_len18\
    \ = new_words_len17 / 2;\n    let mut new_words_len19 = new_words_len18 / 2;\n\
    \    let mut new_words_len20 = new_words_len19 / 2;\n    let mut new_words_len21\
    \ = new_words_len20 / 2;\n    let mut new_words_len22 = new_words_len21 / 2;\n\
    \    let mut new_words_len23 = new_words_len22 / 2;\n    let mut new_words_len24\
    \ = new_words_len23 / 2;\n    let mut new_words_len25 = new_words_len24 / 2;\n\
    \    let mut new_words_len26 = new_words_len25 / 2;\n    let mut new_words_len27\
    \ = new_words_len26 / 2;\n    let mut new_words_len28 = new_words_len27 / 2;\n\
    \    let mut new_words_len29 = new_words_len28 / 2;\n    let mut new_words_len30\
    \ = new_words_len29 / 2;\n    let mut new_words_len31 = new_words_len30 / 2;\n\
    \    let mut new_words_len32 = new_words_len31 / 2;\n    let mut new_words_len33\
    \ = new_words_len32 / 2;\n    let mut new_words_len34 = new_words_len33 / 2;\n\
    \n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpj1zxzmt8.rs:12:39\n   |\n12 |     let mut\
    \ new_words_len = new_words.len();\n   |                                     \
    \  ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpj1zxzmt8.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) -> String\
    \ {\n  |    ------------               ^^^^^^ expected struct `String`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    let mut new_words = Vec::new();\n   \
    \ let mut new_words_len = 0;\n    let mut i = 0;\n    while i < words.len() {\n\
    \        let mut new_word = String::new();\n        let mut new_word_len = 0;\n\
    \        let mut j = 0;\n        while j < words.len() {\n            if i ==\
    \ j {\n                new_word.push_str(words[j]);\n                new_word_len\
    \ += words[j].len();\n            } else {\n                new_word.push_str(words[j]);\n\
    \                new_word_len += words[j].len();\n            }\n            j\
    \ += 1\n        }\n        new_words.push_back(new_word);\n        new_words_len\
    \ += new_word.len();\n        i += 1;\n    }\n    new_s.push_str(new_words[0]);\n\
    \    for word in &new_words[1..] {\n        new_s.push_str(&word);\n    }\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpz6ppfnip.rs:14:21\n   |\n14 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpz6ppfnip.rs:18:25\n   |\n18 |         while j <\
    \ words.len() {\n   |                         ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpz6ppfnip.rs:20:35\n   |\n20 |                 new_word.push_str(words[j]);\n\
    \   |                                   ^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpz6ppfnip.rs:21:33\n\
    \   |\n21 |                 new_word_len += words[j].len();\n   |            \
    \                     ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpz6ppfnip.rs:23:35\n   |\n23 |         \
    \        new_word.push_str(words[j]);\n   |                                  \
    \ ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpz6ppfnip.rs:24:33\n   |\n24 |                 new_word_len += words[j].len();\n\
    \   |                                 ^^^^^^^^\n\nerror[E0599]: no method named\
    \ `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpz6ppfnip.rs:28:19\n\
    \   |\n28 |         new_words.push_back(new_word);\n   |                   ^^^^^^^^^\
    \ method not found in `Vec<_>`\n\nerror: aborting due to 7 previous errors\n\n\
    Some errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c.is_ascii() {\n            s.insert(c.to_ascii_lowercase(), c.to_ascii_lowercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo88fqdtk.rs:11:22\n   |\n\
    11 |             s.insert(c.to_ascii_lowercase(), c.to_ascii_lowercase());\n \
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_alphabetic() {\n            let mut j = i;\n        \
    \    while j > 0 && c.is_alphabetic() {\n                s[j - 1] = s[j];\n  \
    \              j -= 1;\n            }\n            s[j] = c;\n        }\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8ar__qof.rs:13:17\n\
    \   |\n13 |                 s[j - 1] = s[j];\n   |                 ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8ar__qof.rs:13:28\n   |\n13 |                 s[j - 1] = s[j];\n\
    \   |                            ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8ar__qof.rs:16:13\n   |\n16 |             s[j] = c;\n   |     \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to "
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len {\n            if s[i]\
    \ != ' ' && s[i] != ' ' && s[i] != ' ' {\n                new_s.push_str(&s[j]);\n\
    \                j += 1;\n            } else {\n                new_s.push_str(&s[i]);\n\
    \                i += 1;\n            }\n        }\n    }\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwqbc2zvw.rs:15:16\n\
    \   |\n15 |             if s[i] != ' ' && s[i] != ' ' && s[i] != ' ' {\n   | \
    \               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwqbc2zvw.rs:15:31\n   |\n15 |             if s[i] != ' ' && s[i]\
    \ != ' ' && s[i] != ' ' {\n   |                               ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwqbc2zvw.rs:15:46\n   |\n15 |             if s[i] != ' ' && s[i]\
    \ != ' ' && s[i] != ' ' {\n   |                                              ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = String::new();\n    let mut new_s_len2 = String::new();\n\
    \    let mut new_s_len3 = String::new();\n    let mut new_s_len4 = String::new();\n\
    \    let mut new_s_len5 = String::new();\n    let mut new_s_len6 = String::new();\n\
    \    let mut new_s_len7 = String::new();\n    let mut new_s_len8 = String::new();\n\
    \    let mut new_s_len9 = String::new();\n    let mut new_s_len10 = String::new();\n\
    \    let mut new_s_len11 = String::new();\n    let mut new_s_len12 = String::new();\n\
    \    let mut new_s_len13 = String::new();\n    let mut new_s_len14 = String::new();\n\
    \    let mut new_s_len15 = String::new();\n    let mut new_s_len16 = String::new();\n\
    \    let mut new_s_len17 = String::new();\n    let mut new_s_len18 = String::new();\n\
    \    let mut new_s_len19 = String::new();\n    let mut new_s_len20 = String::new();\n\
    \    let mut new_s_len21 = String::new();\n    let mut new_s_len22 = String::new();\n\
    \    let mut new_s_len23 = String::new();\n    let mut new_s_len24 = String::new();\n\
    \    let mut new_s_len25 = String::new();\n    let mut new_s_len26 = String::new();\n\
    \    let mut new_s_len27 = String::new();\n    let mut new_s_len28 = String::new();\n\
    \    let mut new_s_len29 = String::new();\n    let mut new_s_len30 = String::new();\n\
    \    let mut new_s_len31 = String::new();\n    let mut new_s_len32 = String::new();\n\
    \    let mut new_s_len33 = String::new();\n    let mut new_s_len34 = String::new();\n\
    \    let mut new_s_len35 = String::new();\n    let mut new_s_len36 = String::new();\n\
    \    let mut new_s_len37 = String::new();\n    let mut new_s_len38 = String::new();\n\
    \    let mut new_s_len39 = String::new();\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprgo8ta4f.rs:49:11\n   |\n\
    49 |     let mu\n   |           ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmprgo8ta4f.rs:7:31\n  |\n\
    7 | fn anti_shuffle(s: String) -> String {\n  |    ------------              \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_words = Vec::new();\n    let mut new_s = String::new();\n   \
    \ for word in words {\n        let mut new_word = String::from(word);\n      \
    \  let mut new_word_len = new_word.len();\n        let mut new_word_len2 = new_word_len\
    \ as usize;\n        let mut new_word_len3 = new_word_len2 as usize;\n       \
    \ let mut new_word_len4 = new_word_len3 as usize;\n        let mut new_word_len5\
    \ = new_word_len4 as usize;\n        let mut new_word_len6 = new_word_len5 as\
    \ usize;\n        let mut new_word_len7 = new_word_len6 as usize;\n        let\
    \ mut new_word_len8 = new_word_len7 as usize;\n        let mut new_word_len9 =\
    \ new_word_len8 as usize;\n        let mut new_word_len10 = new_word_len9 as usize;\n\
    \        let mut new_word_len11 = new_word_len10 as usize;\n        let mut new_word_len12\
    \ = new_word_len11 as usize;\n        let mut new_word_len13 = new_word_len12\
    \ as usize;\n        let mut new_word_len14 = new_word_len13 as usize;\n     \
    \   let mut new_word_len15 = new_word_len14 as usize;\n        let mut new_word_len16\
    \ = new_word_len15 as usize;\n        let mut new_word_len17 = new_word_len16\
    \ as usize;\n        let mut new_word_len18 = new_word_len17 as usize;\n     \
    \   let mut new_word_len19 = new_word_len18 as usize;\n        let mut new_word_len20\
    \ = new_word_len19 as usize;\n        let mut new_word_len21 = new_word_len20\
    \ as usize;\n        let mut new_word_len22 = new_word_len21 as usize;\n     \
    \   let mut new_word_len23 = new_word_len22 as usize;\n        let mut new_word_len24\
    \ = new_word_len23 as usize;\n        let mut new_word_len25 = new_word_len24\
    \ as usize;\n        let mut new_word_len26 = new_word_len25 as usize;\n     \
    \   let mut new_word_len27 = new_word_len26 as usize;\n        let mut new_word_len28\
    \ = new_word_len27 as usize;\n        let mut new_word_len29 = new_word_len28\
    \ as usize;\n        let mut new_word_len30 = new_word_len29 as usize;\n     \
    \   let mut new_word_len31 = new_word_len30 as \n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnt1pukss.rs:56:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n12 |     for word in words {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    45 | }\n   | - ...as it matches this but it has different indentation\n...\n56\
    \ | }\n   |   ^\n\nerror: expected type, found `}`\n  --> /tmp/tmpnt1pukss.rs:45:1\n\
    \   |\n45 | }\n   | ^ expected type\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnt1pukss.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = String::new();\n    let mut new_s_len2 = String::new();\n\
    \    let mut new_s_len3 = String::new();\n    let mut new_s_len4 = String::new();\n\
    \    let mut new_s_len5 = String::new();\n    let mut new_s_len6 = String::new();\n\
    \    let mut new_s_len7 = String::new();\n    let mut new_s_len8 = String::new();\n\
    \    let mut new_s_len9 = String::new();\n    let mut new_s_len10 = String::new();\n\
    \    let mut new_s_len11 = String::new();\n    let mut new_s_len12 = String::new();\n\
    \    let mut new_s_len13 = String::new();\n    let mut new_s_len14 = String::new();\n\
    \    let mut new_s_len15 = String::new();\n    let mut new_s_len16 = String::new();\n\
    \    let mut new_s_len17 = String::new();\n    let mut new_s_len18 = String::new();\n\
    \    let mut new_s_len19 = String::new();\n    let mut new_s_len20 = String::new();\n\
    \    let mut new_s_len21 = String::new();\n    let mut new_s_len22 = String::new();\n\
    \    let mut new_s_len23 = String::new();\n    let mut new_s_len24 = String::new();\n\
    \    let mut new_s_len25 = String::new();\n    let mut new_s_len26 = String::new();\n\
    \    let mut new_s_len27 = String::new();\n    let mut new_s_len28 = String::new();\n\
    \    let mut new_s_len29 = String::new();\n    let mut new_s_len30 = String::new();\n\
    \    let mut new_s_len31 = String::new();\n    let mut new_s_len32 = String::new();\n\
    \    let mut new_s_len33 = String::new();\n    let mut new_s_len34 = String::new();\n\
    \    let mut new_s_len35 = String::new();\n    let mut new_s_len36 = String::new();\n\
    \    let mut new_s_len37 = String::new();\n    let mut new_s_len38 = String::new();\n\
    \    let mut new_s_len39 = String::new();\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprgo8ta4f.rs:49:11\n   |\n\
    49 |     let mu\n   |           ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmprgo8ta4f.rs:7:31\n  |\n\
    7 | fn anti_shuffle(s: String) -> String {\n  |    ------------              \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.replace(\"a\", \"z\");\n    s.replace(\"\
    b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"d\", \"w\");\n   \
    \ s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n    s.replace(\"g\"\
    , \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\", \"r\");\n    s.replace(\"\
    j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"l\", \"o\");\n   \
    \ s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n    s.replace(\"o\"\
    , \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\", \"r\");\n    s.replace(\"\
    r\", \"i\");\n    s.replace(\"s\", \"t\");\n    s.replace(\"t\", \"s\");\n   \
    \ s.replace(\"u\", \"p\");\n    s.replace(\"v\", \"o\");\n    s.replace(\"w\"\
    , \"n\");\n    s.replace(\"x\", \"m\");\n    s.replace(\"y\", \"b\");\n    s.replace(\"\
    z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpct2bxmfq.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c != ' ' {\n            s.insert(c, 1);\n        }\n    });\n    s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmputre2b4n.rs:11:22\n   |\n\
    11 |             s.insert(c, 1);\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmputre2b4n.rs:11:25\n\
    \   |\n11 |             s.insert(c, 1);\n   |                         ^ expected\
    \ `char`, found `u8`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len + 1;\n \
    \   let mut new_s_len3 = new_s_len2 + 1;\n    let mut new_s_len4 = new_s_len3\
    \ + 1;\n    let mut new_s_len5 = new_s_len4 + 1;\n    let mut new_s_len6 = new_s_len5\
    \ + 1;\n    let mut new_s_len7 = new_s_len6 + 1;\n    let mut new_s_len8 = new_s_len7\
    \ + 1;\n    let mut new_s_len9 = new_s_len8 + 1;\n    let mut new_s_len10 = new_s_len9\
    \ + 1;\n    let mut new_s_len11 = new_s_len10 + 1;\n    let mut new_s_len12 =\
    \ new_s_len11 + 1;\n    let mut new_s_len13 = new_s_len12 + 1;\n    let mut new_s_len14\
    \ = new_s_len13 + 1;\n    let mut new_s_len15 = new_s_len14 + 1;\n    let mut\
    \ new_s_len16 = new_s_len15 + 1;\n    let mut new_s_len17 = new_s_len16 + 1;\n\
    \    let mut new_s_len18 = new_s_len17 + 1;\n    let mut new_s_len19 = new_s_len18\
    \ + 1;\n    let mut new_s_len20 = new_s_len19 + 1;\n    let mut new_s_len21 =\
    \ new_s_len20 + 1;\n    let mut new_s_len22 = new_s_len21 + 1;\n    let mut new_s_len23\
    \ = new_s_len22 + 1;\n    let mut new_s_len24 = new_s_len23 + 1;\n    let mut\
    \ new_s_len25 = new_s_len24 + 1;\n    let mut new_s_len26 = new_s_len25 + 1;\n\
    \    let mut new_s_len27 = new_s_len26 + 1;\n    let mut new_s_len28 = new_s_len27\
    \ + 1;\n    let mut new_s_len29 = new_s_len28 + 1;\n    let mut new_s_len30 =\
    \ new_s_len29 + 1;\n    let mut new_s_len31 = new_s_len30 + 1;\n    let mut new_s_len32\
    \ = new_s_len31 + 1;\n    let mut new_s_len33 = new_s_len32 + 1;\n    let mut\
    \ new_s_len34 = new_s_len33 + 1;\n    let mut new_s_len35 = new_s_len34 + 1;\n\
    \    let mut new_s_len36 = new_s_len35 + 1;\n    let mut new_s_len37 = new_s_len36\
    \ + 1;\n    let mut new_s_len38 = new_s_len37 + 1;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw88hw2ay.rs:48:11\n   |\n\
    48 |     let mu\n   |           ^ help: add `;` here\n49 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpw88hw2ay.rs:7:31\n  |\n\
    7 | fn anti_shuffle(s: String) -> String {\n  |    ------------              \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_words: Vec<String> = Vec::new();\n    let mut new_s = String::new();\n\
    \    for word in words {\n        let mut new_word = word;\n        let mut new_word_len\
    \ = word.len();\n        while new_word_len > 0 {\n            let mut new_word_len\
    \ = 0;\n            for c in new_word {\n                if c < 'a' || c > 'z'\
    \ {\n                    new_word_len += 1;\n                }\n            }\n\
    \            new_word += 'z' - 'a' + 1;\n            new_word_len += 1;\n    \
    \        new_words.push(new_word);\n        }\n    }\n    for new_word in new_words\
    \ {\n        new_s += new_word;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmp9fdxv8_t.rs:17:22\n\
    \   |\n17 |             for c in new_word {\n   |                      ^^^^^^^^\
    \ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   =\
    \ help: the trait `Iterator` is not implemented for `&str`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&str`\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmp9fdxv8_t.rs:22:29\n   |\n\
    22 |             new_word += 'z' - 'a' + 1;\n   |                         ---\
    \ ^ --- char\n   |                         |\n   |                         char\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9fdxv8_t.rs:24:28\n   |\n24 |\
    \             new_words.push(new_word);\n   |                            ^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9fdxv8_t.rs:28:18\n\
    \   |\n28 |         new_s += new_word;\n   |                  ^^^^^^^^\n   | \
    \                 |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&new_word`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    let mut new_words = String::new();\n\
    \    for word in words {\n        let mut new_word = String::new();\n        let\
    \ mut new_word_len = String::new();\n        for c in word.chars() {\n       \
    \     new_word.push(c);\n            new_word_len.push((c as i32).to_string());\n\
    \        }\n        new_word.push(\" \");\n        new_word_len.push(\"0\");\n\
    \        new_s += new_word;\n        new_s += new_word_len;\n        new_s +=\
    \ \" \";\n    }\n    new_s.trim();\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphjflybjf.rs:17:31\n   |\n\
    17 |             new_word_len.push((c as i32).to_string());\n   |            \
    \                   ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphjflybjf.rs:19:23\n   |\n19 |\
    \         new_word.push(\" \");\n   |                       ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n19 |         new_word.push(' ');\n   |                       ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphjflybjf.rs:20:27\n   |\n20 |\
    \         new_word_len.push(\"0\");\n   |                           ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n20 |         new_word_len.push('0');\n   |            \
    \               ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphjflybjf.rs:21:18\n\
    \   |\n21 |         new_s += new_word;\n   |                  ^^^^^^^^\n   | \
    \                 |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&new_word`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphjflybjf.rs:22:18\n   |\n22 |         new_s\
    \ += new_word_len;\n   |                  ^^^^^^^^^^^^\n   |                 \
    \ |\n   |                  expected `&str`, found struct `String`\n   |      \
    \            help: consider borrowing here: `&new_word_len`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n  \
    \          j = j + 1;\n        }\n        let mut k = i;\n        while k < new_s_len\
    \ && s[k] == ' ' {\n            k = k + 1;\n        }\n        if j > k {\n  \
    \          let mut new_word = String::new();\n            new_word.push_str(&s[i\
    \ .. (j - 1)]);\n            new_word.push_str(&s[(j + 1) .. (k)]);\n        \
    \    new_word.push_str(&s[(k)..]);\n            new_word.push_str(&s[i .. (k +\
    \ 1)]);\n            new_word.push_str(&s[(j + 1) .. (new_s_len)]);\n        \
    \    new_word.push_str(&s[(new_s_len + 1) ..]);\n            new_word.push_str(&s[i\
    \ .. (new_s_len)]);\n            new_word.push_str(&s[(new_s_len + 1) ..]);\n\
    \            new_word.push_str(&s[(j + 1) .. (new_s_len)]);\n            new_word.push_str(&s[(new_s_len\
    \ + 1) ..]);\n            new_word.push_str(&s[(j + 1) .. (new_s_len)]);\n   \
    \         new_word.push_str(&s[(new_s_len + 1) ..]);\n            new_word.push_str(&s[(j\
    \ + 1) .. (new_s_len)]);\n            new_word.push_str(&s[(new_s_len + 1) ..]);\n\
    \            new_word.push_str(&s[(j + 1) .. (new_s_len)]);\n            new_word.push_str(&s[(new_s_len\
    \ + 1) ..]);\n            new_word.push_str(&s[(j + 1) .. (new_s_len)]);\n   \
    \         new_word.push_str(&s[(new_s_len + 1) ..]);\n            new_word.push_str(&s[(j\
    \ + 1) .. (new_s_len)]);\n            new_word.push_str(&s[(new_s_len + 1) ..]);\n\
    \            new_word.push_str(&s[(j + 1) .. (new_s_len)]);\n            new_word.push_str(&s[(new_s_len\
    \ + 1) ..]);\n            new_word.push_str(&s[(j + 1) .. (new_s_len)]);\n   \
    \         new_word.push_str(&s[(new_s_len + 1) ..]);\n            new_word.push_str(&s[(j\
    \ + 1) .. (new_s_len)]);\n            new_word.push_str(&s[(new_s_len + 1) ..]);\n\
    \            new_word.push_str(&s[\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvgp0ztth.rs:61:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n12 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n21 |         if j > k\
    \ {\n   |                  - this delimiter might not be properly closed...\n\
    ...\n50 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    61 | }\n   |   ^\n\nerror: expected expression, found `]`\n  --> /tmp/tmpvgp0ztth.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpvgp0ztth.rs:49:33\n   |\n7  | fn anti_shuffle(s: String)\
    \ -> String {\n   |                                      - closing delimiter possibly\
    \ meant for this\n...\n49 |             new_word.push_str(&s[\n   |          \
    \                       ^ unclosed delimiter\n50 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvgp0ztth.rs:14:32\n   |\n14 |         while j < new_s_len && s[j]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvgp0ztth.rs:18:32\n   |\n18 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n   \
    \     let mut j = i;\n        while j < s.len() {\n            if s[j] == ' '\
    \ {\n                j += 1;\n                continue;\n            }\n     \
    \       if s[j] < 97 {\n                s[j] = s[j] + 1;\n            } else {\n\
    \                s[j] = s[j] - 1;\n            }\n            new_s[new_s_len]\
    \ = s[j];\n            new_s_len += 1;\n            j += 1;\n        }\n     \
    \   i += 1;\n    }\n    new_s.truncate(new_s_len);\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp00dk4el1.rs:15:16\n\
    \   |\n15 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp00dk4el1.rs:19:16\n   |\n19 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp00dk4el1.rs:20:17\n   |\n20 |                 s[j] = s[j] + 1;\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` can"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    let mut new_words = new_s.split_whitespace();\n\
    \    for word in words {\n        let mut new_word = String::from(word);\n   \
    \     let mut new_word_len = new_word.len();\n        let mut i = 0;\n       \
    \ while i < new_word_len {\n            let mut j = i;\n            while j +\
    \ 1 < new_word_len && new_word[j].is_ascii_lowercase() &&\n                new_word[j\
    \ + 1].is_ascii_uppercase() {\n                j += 1;\n            }\n      \
    \      if j == new_word_len {\n                new_word.push('_');\n         \
    \       new_word_len += 1;\n            } else {\n                new_word.push(new_word[j]);\n\
    \                new_word_len += 1;\n            }\n            i += 1;\n    \
    \    }\n        new_words.push(new_word);\n    }\n    new_words.sort();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\
    \    new_words.dedup();\n    new_words.dedup();\n    new_words.dedup();\n\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp3fkutyf.rs:18:43\n\
    \   |\n18 |             while j + 1 < new_word_len && new_word[j].is_ascii_lowercase()\
    \ &&\n   |                                           ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp3fkutyf.rs:19:17\n   |\n19 |                 new_word[j + 1].is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp3fkutyf.rs:26:31\n   |\n26 |                 new_word.push(new_word[j]);\n\
    \   |                               ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut\
    \ new_s_len5 = new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7\
    \ = new_s_len;\n    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 =\
    \ new_s_len;\n    let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 =\
    \ new_s_len;\n    let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 =\
    \ new_s_len;\n    let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 =\
    \ new_s_len;\n    let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 =\
    \ new_s_len;\n    let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 =\
    \ new_s_len;\n    let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 =\
    \ new_s_len;\n    let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 =\
    \ new_s_len;\n    let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 =\
    \ new_s_len;\n    let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 =\
    \ new_s_len;\n    let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 =\
    \ new_s_len;\n    let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 =\
    \ new_s_len;\n    let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 =\
    \ new_s_len;\n    let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 =\
    \ new_s_len;\n    let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 =\
    \ new_s_len;\n    let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 =\
    \ new_s_len;\n    let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 =\
    \ new_s_len;\n    let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 =\
    \ new_s_len;\n    let mut new_s_len44 = new_s_len;\n    let mut new_s_\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8sawf1j5.rs:54:19\n   |\n\
    54 |     let mut new_s_\n   |                   ^ help: add `;` here\n55 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8sawf1j5.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c != ' ' {\n            s.insert(s.chars().filter(|c| c != ' ').min_by_key(|c|\
    \ c.to_ascii_lowercase()).unwrap().unwrap(), c);\n        }\n    });\n    s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp29adqpi6.rs:11:45\n\
    \   |\n11 |             s.insert(s.chars().filter(|c| c != ' ').min_by_key(|c|\
    \ c.to_ascii_lowercase()).unwrap().unwrap(), c);\n   |                       \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp29adqpi6.rs:11:101\n\
    \   |\n11 |             s.insert(s.chars().filter(|c| c != ' ').min_by_key(|c|\
    \ c.to_ascii_lowercase()).unwrap().unwrap(), c);\n   |                       \
    \                                                                            \
    \  ^^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_ascii() {\n            let j = s.chars().enumerate().find(|(_,\
    \ c)| c == c).unwrap();\n            let mut j = j;\n            if j != i {\n\
    \                s.swap(i, j);\n            }\n        }\n    });\n    s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqpxr1lmb.rs:13:21\n   |\n\
    13 |             if j != i {\n   |                     ^ expected tuple, found\
    \ `usize`\n   |\n   = note: expected tuple `(usize, char)`\n               found\
    \ type `usize`\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpqpxr1lmb.rs:14:19\n   |\n14 |          \
    \       s.swap(i, j);\n   |                   ^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    let mut new_words = new_s.split_whitespace();\n\
    \    for word in words {\n        let mut new_word = String::from(word);\n   \
    \     let mut new_word_len = new_word.len();\n        let mut i = 0;\n       \
    \ while i < new_word_len {\n            let mut j = i;\n            while j <\
    \ new_word_len && new_word[j] == ' ' {\n                j += 1;\n            }\n\
    \            if j > i {\n                new_word.swap(i, j);\n            }\n\
    \            i += 1;\n        }\n        new_words.swap(i, new_words.len());\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjs6wfu0y.rs:18:39\n\
    \   |\n18 |             while j < new_word_len && new_word[j] == ' ' {\n   | \
    \                                      ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpjs6wfu0y.rs:22:26\n   |\n22 |          \
    \       new_word.swap(i, j);\n   |                          ^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `swap` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpjs6wfu0y.rs:26:19\n   |\n26 |         new_words.swap(i,\
    \ new_words.len());\n   |                   ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpjs6wfu0y.rs:26:37\n   |\n26 |         new_words.swap(i,\
    \ new_words.len());\n   |                                     ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().for_each(|c|\
    \ {\n        if c < ' ' {\n            s.insert(c, ' ');\n        } else {\n \
    \           let mut i = 1;\n            while i < s.len() {\n                if\
    \ s.chars().any(|c| c == i && c != ' ') {\n                    s.insert(i, ' ');\n\
    \                    break;\n                }\n                i += 1;\n    \
    \        }\n        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo84i5z0z.rs:11:22\n   |\n\
    11 |             s.insert(c, ' ');\n   |                      ^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo84i5z0z.rs:15:43\n\
    \   |\n15 |                 if s.chars().any(|c| c == i && c != ' ') {\n   | \
    \                                          ^ expected `char`, found `usize`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = word;\n        let mut new_word_ord = String::new();\n        for\
    \ c in word.chars() {\n            new_word_ord.push((c as u32).to_string());\n\
    \        }\n        new_word.push_str(new_word_ord);\n        new_s.push_str(new_word);\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwfokzbxk.rs:15:31\n   |\n\
    15 |             new_word_ord.push((c as u32).to_string());\n   |            \
    \                   ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0599]: no method named `push_str` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpwfokzbxk.rs:17:18\n   |\n17 |         new_word.push_str(new_word_ord);\n\
    \   |                  ^^^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    let mut new_words = new_s.split_whitespace();\n\
    \    let mut new_words_len = 0;\n    let mut i = 0;\n    while i < words.len()\
    \ {\n        let mut j = i;\n        while j < words.len() {\n            if words[j].len()\
    \ < words[i].len() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if words[j].len() > words[i].len() {\n           \
    \     let mut new_word = String::from(\"\");\n                for c in words[j].chars()\
    \ {\n                    if c < words[i].len() {\n                        new_word.push(c);\n\
    \                    }\n                }\n                new_words.insert(new_words_len,\
    \ new_word);\n                new_words_len = new_words_len + 1;\n           \
    \     j = j + 1;\n                continue;\n            }\n            if words[j].len()\
    \ == words[i].len() {\n                let mut new_word = String::from(\"\");\n\
    \                for c in words[j].chars() {\n                    if c > words[i].len()\
    \ {\n                        new_word.push(c);\n                    }\n      \
    \          }\n                new_words.insert(new_words_len, new_word);\n   \
    \             new_words_len = new_words_len + 1;\n                j = j + 1;\n\
    \                continue;\n            }\n            j = j + 1;\n        }\n\
    \        i = i + 1;\n    }\n    new_s = new_words.join(\" \");\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpeby1qm9y.rs:14:21\n   |\n14 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpeby1qm9y.rs:16:25\n   |\n16 |         while j <\
    \ words.len() {\n   |                         ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpeby1qm9y.rs:17:16\n   |\n17 |             if words[j].len() < words[i].len()\
    \ {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpeby1qm9y.rs:17:33\n   |\n17 |    \
    \         if words[j].len() < words[i].len() {\n   |                         \
    \        ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpeby1qm9y.rs:21:16\n   |\n21 |             if words[j].len() > words[i].len()\
    \ {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpeby1qm9y.rs:21:33\n   |\n21 |    \
    \         if words[j].len() > words[i].len() {\n   |                         \
    \        ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpeby1qm9y.rs:23:26\n   |\n23 |                 for c in words[j].chars()\
    \ {\n   |                          ^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpeby1qm9y.rs:24:28\n   |\n\
    24 |                     if c < words[i].len() {\n   |                       \
    \     ^^^^^^^^\n\nerror[E0599]: no method named `insert` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpeby1qm9y.rs:28:27\n   |\n28 |          \
    \       new_words.insert(new_words_len, new_word);\n   |                     \
    \      ^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0608]: cannot\
    \ index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpeby1qm9y.rs:33:16\n\
    \ "
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut\
    \ new_s_len5 = new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7\
    \ = new_s_len;\n    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 =\
    \ new_s_len;\n    let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 =\
    \ new_s_len;\n    let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 =\
    \ new_s_len;\n    let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 =\
    \ new_s_len;\n    let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 =\
    \ new_s_len;\n    let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 =\
    \ new_s_len;\n    let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 =\
    \ new_s_len;\n    let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 =\
    \ new_s_len;\n    let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 =\
    \ new_s_len;\n    let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 =\
    \ new_s_len;\n    let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 =\
    \ new_s_len;\n    let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 =\
    \ new_s_len;\n    let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 =\
    \ new_s_len;\n    let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 =\
    \ new_s_len;\n    let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 =\
    \ new_s_len;\n    let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 =\
    \ new_s_len;\n    let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 =\
    \ new_s_len;\n    let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 =\
    \ new_s_len;\n    let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 =\
    \ new_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplkj3xfo0.rs:54:31\n   |\n\
    54 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmplkj3xfo0.rs:54:27\n   |\n54 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmplkj3xfo0.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) -> String {\n\
    \  |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.chars().for_each(|c| {\n    \
    \    if c >= 'a' && c <= 'z' {\n            s.insert(c, c.to_ascii_lowercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz0b43jzr.rs:11:22\n   |\n\
    11 |             s.insert(c, c.to_ascii_lowercase());\n   |                  \
    \    ^ expected `usize`, found `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words = s.split_whitespace();\n    let mut\
    \ new_s = String::new();\n    for word in words {\n        let mut new_word =\
    \ String::new();\n        for c in word.chars() {\n            new_word.push((c.to_ascii_lowercase()\
    \ + c.to_ascii_uppercase()).to_string());\n        }\n        new_s.push_str(&new_word);\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpkq0pe4zg.rs:13:51\n\
    \   |\n13 |             new_word.push((c.to_ascii_lowercase() + c.to_ascii_uppercase()).to_string());\n\
    \   |                            ---------------------- ^ ----------------------\
    \ char\n   |                            |\n   |                            char\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let\
    \ mut new_s_len5 = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let\
    \ mut new_s_len7 = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let\
    \ mut new_s_len9 = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let\
    \ mut new_s_len11 = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n   \
    \ let mut new_s_len13 = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n\
    \    let mut new_s_len15 = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n\
    \    let mut new_s_len17 = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n\
    \    let mut new_s_len19 = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n\
    \    let mut new_s_len21 = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n\
    \    let mut new_s_len23 = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n\
    \    let mut new_s_len25 = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n\
    \    let mut new_s_len27 = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n\
    \    let mut new_s_len29 = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n\
    \    let mut new_s_len31 = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n\
    \    let mut new_s_len33 = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n\
    \    let mut new_s_len35 = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n\
    \    let mut new_s_len37 = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n\
    \    let mut new_s_len39 = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp22sfetvu.rs:49:33\n   |\n\
    49 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp22sfetvu.rs:49:27\n   |\n49\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp22sfetvu.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) ->\
    \ String {\n  |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.swap(i, i + 1);\n     \
    \   }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp0s3n_yg0.rs:11:15\n   |\n11 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    let mut new_words = Vec::new();\n   \
    \ let mut new_words_map = HashMap::new();\n    let mut new_words_map_copy = HashMap::new();\n\
    \    let mut new_words_map_copy2 = HashMap::new();\n    let mut new_words_map_copy3\
    \ = HashMap::new();\n    let mut new_words_map_copy4 = HashMap::new();\n    let\
    \ mut new_words_map_copy5 = HashMap::new();\n    let mut new_words_map_copy6 =\
    \ HashMap::new();\n    let mut new_words_map_copy7 = HashMap::new();\n    let\
    \ mut new_words_map_copy8 = HashMap::new();\n    let mut new_words_map_copy9 =\
    \ HashMap::new();\n    let mut new_words_map_copy10 = HashMap::new();\n    let\
    \ mut new_words_map_copy11 = HashMap::new();\n    let mut new_words_map_copy12\
    \ = HashMap::new();\n    let mut new_words_map_copy13 = HashMap::new();\n    let\
    \ mut new_words_map_copy14 = HashMap::new();\n    let mut new_words_map_copy15\
    \ = HashMap::new();\n    let mut new_words_map_copy16 = HashMap::new();\n    let\
    \ mut new_words_map_copy17 = HashMap::new();\n    let mut new_words_map_copy18\
    \ = HashMap::new();\n    let mut new_words_map_copy19 = HashMap::new();\n    let\
    \ mut new_words_map_copy20 = HashMap::new();\n    let mut new_words_map_copy21\
    \ = HashMap::new();\n    let mut new_words_map_copy22 = HashMap::new();\n    let\
    \ mut new_words_map_copy23 = HashMap::new();\n    let mut new_words_map_copy24\
    \ = HashMap::new();\n    let mut new_words_map_copy25 = HashMap::new();\n    let\
    \ mut new_words_map_copy26 = HashMap::new();\n    let mut new_words_map_copy27\
    \ = HashMap::new();\n    let mut new_words_map_copy28 = HashMap::new();\n    let\
    \ mut new_words_map_copy29 = HashMap::new();\n    let mut new_words_map_copy30\
    \ = HashMap::new();\n    let mut new_words_map_copy31 = HashMap::new();\n    let\
    \ mut new_words_map_copy32 = HashMap::new\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphk3v5zyc.rs:44:48\n   |\n\
    44 |     let mut new_words_map_copy32 = HashMap::new\n   |                   \
    \                             ^ help: add `;` here\n45 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmphk3v5zyc.rs:44:36\n   |\n44 |     let mut new_words_map_copy32\
    \ = HashMap::new\n   |                                    ^^^^^^^ use of undeclared\
    \ type `HashMap`\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmphk3v5zyc.rs:12:29\n   |\n12 |     let mut new_words_map = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmphk3v5zyc.rs:13:34\n   |\n13 |     let mut new_words_map_copy = HashMap::new();\n\
    \   |                                  ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmphk3v5zyc.rs:14:35\n   |\n14 |     let mut new_words_map_copy2 =\
    \ HashMap::new();\n   |                                   ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmphk3v5zyc.rs:15:35\n   |\n15 |     let mut new_words_map_copy3 =\
    \ HashMap::new();\n   |                                   ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmphk3v5zyc.rs:16:35\n   |\n16 |     let mut new_words_map_copy4 =\
    \ HashMap::new();\n   |                                   ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_ascii() {\n            s.insert(i, c.to_ascii_lowercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp984muba2.rs:9:36\n   |\n9  |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     ---------             -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n10 |     \
    \    if c.is_ascii() {\n11 |             s.insert(i, c.to_ascii_lowercase());\n\
    \   |             - second borrow occurs due to use of `s` in closure\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::from(s);\n    let mut new_words = new_s.split_whitespace();\n\
    \    let mut new_words_len = new_words.len();\n    let mut new_words_len2 = new_words.len();\n\
    \    let mut new_words_len3 = new_words.len();\n    let mut new_words_len4 = new_words.len();\n\
    \    let mut new_words_len5 = new_words.len();\n    let mut new_words_len6 = new_words.len();\n\
    \    let mut new_words_len7 = new_words.len();\n    let mut new_words_len8 = new_words.len();\n\
    \    let mut new_words_len9 = new_words.len();\n    let mut new_words_len10 =\
    \ new_words.len();\n    let mut new_words_len11 = new_words.len();\n    let mut\
    \ new_words_len12 = new_words.len();\n    let mut new_words_len13 = new_words.len();\n\
    \    let mut new_words_len14 = new_words.len();\n    let mut new_words_len15 =\
    \ new_words.len();\n    let mut new_words_len16 = new_words.len();\n    let mut\
    \ new_words_len17 = new_words.len();\n    let mut new_words_len18 = new_words.len();\n\
    \    let mut new_words_len19 = new_words.len();\n    let mut new_words_len20 =\
    \ new_words.len();\n    let mut new_words_len21 = new_words.len();\n    let mut\
    \ new_words_len22 = new_words.len();\n    let mut new_words_len23 = new_words.len();\n\
    \    let mut new_words_len24 = new_words.len();\n    let mut new_words_len25 =\
    \ new_words.len();\n    let mut new_words_len26 = new_words.len();\n    let mut\
    \ new_words_len27 = new_words.len();\n    let mut new_words_len28 = new_words.len();\n\
    \    let mut new_words_len29 = new_words.len();\n    let mut new_words_len30 =\
    \ new_words.len();\n    let mut new_words_len31 = new_words.len();\n    let mut\
    \ new_words_len32 = new_words.len();\n    let mut new_words_len33 = new_words.len();\n\
    \    let mut new_words_len34 = new_words.len();\n    let mut new_words_len35 =\
    \ new_words.len();\n    let mut new_words_len36 = new_words.len();\n    let mut\
    \ new_words_len37 = new_words.len();\n    let mut new_words_len38 = new_words.len();\n\
    \    let mut new_words_len39 = new_words.len();\n    let mut new_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb7wh10hj.rs:51:17\n   |\n\
    51 |     let mut new_\n   |                 ^ help: add `;` here\n52 | }\n   |\
    \ - unexpected token\n\nerror[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpb7wh10hj.rs:12:39\n   |\n12 |     let mut\
    \ new_words_len = new_words.len();\n   |                                     \
    \  ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named\
    \ `len` found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpb7wh10hj.rs:13:40\n\
    \   |\n13 |     let mut new_words_len2 = new_words.len();\n   |              \
    \                          ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpb7wh10hj.rs:14:40\n   |\n14 |     let mut new_words_len3 = new_words.len();\n\
    \   |                                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpb7wh10hj.rs:15:40\n   |\n15 |     let mut new_words_len4\
    \ = new_words.len();\n   |                                        ^^^ method not\
    \ found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `len` found\
    \ for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpb7wh10hj.rs:16:40\n\
    \   |\n16 |     let mut new_words_len5 = new_words.len();\n   |              \
    \                          ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpb7wh10hj.rs:17:40\n   |\n17 |     let mut new_words_len6 = new_words.len();\n\
    \   |                                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpb7wh10hj.rs:18:40\n   |\n18 |     let mut new_words_len7\
    \ = new_words.len();\n   |                                        ^^^ method not\
    \ found in `SplitWhites"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words = s.split_whitespace();\n    let mut\
    \ new_s = String::new();\n    let mut new_words = Vec::new();\n    let mut new_words_len\
    \ = 0;\n    let mut i = 0;\n    while i < words.len() {\n        let mut new_word\
    \ = String::new();\n        let mut new_word_len = 0;\n        let mut j = 0;\n\
    \        while j < words[i].len() {\n            let c = words[i][j];\n      \
    \      if c != ' ' {\n                new_word.push(c);\n                new_word_len\
    \ += 1;\n            }\n            j += 1\n        }\n        new_words.insert(new_words_len,\
    \ new_word);\n        new_words_len += 1;\n        i += 1;\n    }\n    new_words.sort_by_key(|x|\
    \ x.len());\n    new_s.push_str(&new_words[0]);\n    for word in &new_words[1..]\
    \ {\n        new_s.push_str(&\" \");\n        new_s.push_str(&word);\n    }\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp2ut0h4rk.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp2ut0h4rk.rs:17:19\n   |\n17 |         while j < words[i].len() {\n \
    \  |                   ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmp2ut0h4rk.rs:18:21\n   |\n18 |    \
    \         let c = words[i][j];\n   |                     ^^^^^^^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut\
    \ new_s_len5 = new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7\
    \ = new_s_len;\n    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 =\
    \ new_s_len;\n    let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 =\
    \ new_s_len;\n    let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 =\
    \ new_s_len;\n    let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 =\
    \ new_s_len;\n    let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 =\
    \ new_s_len;\n    let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 =\
    \ new_s_len;\n    let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 =\
    \ new_s_len;\n    let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 =\
    \ new_s_len;\n    let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 =\
    \ new_s_len;\n    let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 =\
    \ new_s_len;\n    let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 =\
    \ new_s_len;\n    let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 =\
    \ new_s_len;\n    let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 =\
    \ new_s_len;\n    let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 =\
    \ new_s_len;\n    let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 =\
    \ new_s_len;\n    let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 =\
    \ new_s_len;\n    let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 =\
    \ new_s_len;\n    let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 =\
    \ new_s_len;\n    let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 =\
    \ new_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplkj3xfo0.rs:54:31\n   |\n\
    54 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmplkj3xfo0.rs:54:27\n   |\n54 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmplkj3xfo0.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) -> String {\n\
    \  |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_ascii() {\n            if let Some(j) = (i + 1) % s.len()\
    \ {\n                s.swap(i, j);\n            }\n        }\n    });\n    s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvx4rgwy6.rs:11:20\n   |\n\
    11 |             if let Some(j) = (i + 1) % s.len() {\n   |                  \
    \  ^^^^^^^   ----------------- this expression has type `usize`\n   |        \
    \            |\n   |                    expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<_>`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpvx4rgwy6.rs:12:19\n   |\n12 |                 s.swap(i,\
    \ j);\n   |                   ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n  \
    \          j = j + 1;\n        }\n        let mut k = j;\n        while k < new_s_len\
    \ && s[k] == ' ' {\n            k = k + 1;\n        }\n        let mut new_s_char\
    \ = s[k..k + j - i].to_ascii_lowercase();\n        new_s_char.insert(0, s[j..j\
    \ + i].to_ascii_lowercase());\n        new_s.insert(0, new_s_char);\n        i\
    \ = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz_cmxg89.rs:14:32\n\
    \   |\n14 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz_cmxg89.rs:18:32\n   |\n18 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_cmxg89.rs:22:30\n\
    \   |\n22 |         new_s_char.insert(0, s[j..j + i].to_ascii_lowercase());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_cmxg89.rs:23:25\n\
    \   |\n23 |         new_s.insert(0, new_s_char);\n   |                       \
    \  ^^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len {\n            if s[i]\
    \ != ' ' && s[j] != ' ' {\n                let mut new_s_char = new_s[..j];\n\
    \                let mut new_s_char_len = new_s_char.len();\n                while\
    \ new_s_char_len > 0 {\n                    let mut new_s_char_char = new_s_char[..new_s_char_len\
    \ - 1];\n                    let mut new_s_char_char_len = new_s_char_char.len();\n\
    \                    while new_s_char_char_len > 0 {\n                       \
    \ let mut new_s_char_char_char = new_s_char_char[..new_s_char_char_len - 1];\n\
    \                        let mut new_s_char_char_char_len = new_s_char_char_char.len();\n\
    \                        while new_s_char_char_char_len > 0 {\n              \
    \              let mut new_s_char_char_char_char = new_s_char_char_char_char[..new_s_char_char_char_char_len\
    \ - 1];\n                            new_s_char_char_char_char_char.push(new_s_char_char_char_char.chars().next().unwrap());\n\
    \                            new_s_char_char_char_char_len -= 1;\n           \
    \             }\n                        new_s_char_char_char_char.push(new_s_char_char_char_char.chars().next().unwrap());\n\
    \                        new_s_char_char_char_len -= 1;\n                    }\n\
    \                    new_s_char_char_char.push(new_s_char_char_char.chars().next().unwrap());\n\
    \                    new_s_char_char_len -= 1;\n                }\n          \
    \      new_s_char.push(new_s_char.chars().next().unwrap());\n                new_s_char_len\
    \ -= 1;\n            }\n            j += 1;\n        }\n        new_s.push(new_s_char.chars().next().unwrap());\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `new_s_char_char_char_char` in this scope\n\
    \  --> /tmp/tmpevhqh51_.rs:25:65\n   |\n25 | ...                   let mut new_s_char_char_char_char\
    \ = new_s_char_char_char_char[..new_s_char_char_char_char_len - 1];\n   |    \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `new_s_char_char_char_len`\n\
    \nerror[E0425]: cannot find value `new_s_char_char_char_char_len` in this scope\n\
    \  --> /tmp/tmpevhqh51_.rs:25:93\n   |\n25 | ...                   let mut new_s_char_char_char_char\
    \ = new_s_char_char_char_char[..new_s_char_char_char_char_len - 1];\n   |    \
    \                                                                            \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `new_s_char_char_char_len`\n\nerror[E0425]: cannot find value `new_s_char_char_char_char_char`\
    \ in this scope\n  --> /tmp/tmpevhqh51_.rs:26:29\n   |\n26 | ...             \
    \      new_s_char_char_char_char_char.push(new_s_char_char_char_char.chars().next().unwrap());\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `new_s_char_char_char_char`\n\nerror[E0425]: cannot\
    \ find value `new_s_char_char_char_char_len` in this scope\n  --> /tmp/tmpevhqh51_.rs:27:29\n\
    \   |\n27 | ...                   new_s_char_char_char_char_len -= 1;\n   |  \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `new_s_char_char_char_char`\n\nerror[E0425]: cannot find\
    \ value `new_s_char_char_char_char` in this scope\n  --> /tmp/tmpevhqh51_.rs:29:25\n\
    \   |\n29 |                         new_s_char_char_char_char.push(new_s_char_char_char_char.chars().next().unwrap());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `new_s_char_char_char_len`\n\nerror[E0425]: cannot\
    \ find value `new_s_char_char_char_char` in this scope\n  --> /tmp/tmpevhqh51_.rs:29:56\n\
    \   |\n29 |                         new_s_char_char_cha"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_alphabetic() {\n            let mut j = i;\n        \
    \    while j > 0 && c.is_alphabetic() {\n                s[j - 1] = s[j];\n  \
    \              j -= 1;\n            }\n            s[j - 1] = c;\n        }\n\
    \    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1_nw73dv.rs:13:17\n\
    \   |\n13 |                 s[j - 1] = s[j];\n   |                 ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1_nw73dv.rs:13:28\n   |\n13 |                 s[j - 1] = s[j];\n\
    \   |                            ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1_nw73dv.rs:16:13\n   |\n16 |             s[j - 1] = c;\n   | \
    \            ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_alphabetic() {\n            if let Some(j) = (i + 1)\
    \ % s.len() {\n                s.swap(i, j);\n            }\n        }\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps28js650.rs:11:20\n   |\n\
    11 |             if let Some(j) = (i + 1) % s.len() {\n   |                  \
    \  ^^^^^^^   ----------------- this expression has type `usize`\n   |        \
    \            |\n   |                    expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<_>`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmps28js650.rs:12:19\n   |\n12 |                 s.swap(i,\
    \ j);\n   |                   ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let\
    \ mut new_s_len3 = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let\
    \ mut new_s_len5 = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let\
    \ mut new_s_len7 = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let\
    \ mut new_s_len9 = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let\
    \ mut new_s_len11 = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n   \
    \ let mut new_s_len13 = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n\
    \    let mut new_s_len15 = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n\
    \    let mut new_s_len17 = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n\
    \    let mut new_s_len19 = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n\
    \    let mut new_s_len21 = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n\
    \    let mut new_s_len23 = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n\
    \    let mut new_s_len25 = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n\
    \    let mut new_s_len27 = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n\
    \    let mut new_s_len29 = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n\
    \    let mut new_s_len31 = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n\
    \    let mut new_s_len33 = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n\
    \    let mut new_s_len35 = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n\
    \    let mut new_s_len37 = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n\
    \    let mut new_s_len39 = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp22sfetvu.rs:49:33\n   |\n\
    49 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp22sfetvu.rs:49:27\n   |\n49\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp22sfetvu.rs:7:31\n  |\n7 | fn anti_shuffle(s: String) ->\
    \ String {\n  |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = String::new();\n    let mut new_s_len2 = String::new();\n\
    \    let mut new_s_len3 = String::new();\n    let mut new_s_len4 = String::new();\n\
    \    let mut new_s_len5 = String::new();\n    let mut new_s_len6 = String::new();\n\
    \    let mut new_s_len7 = String::new();\n    let mut new_s_len8 = String::new();\n\
    \    let mut new_s_len9 = String::new();\n    let mut new_s_len10 = String::new();\n\
    \    let mut new_s_len11 = String::new();\n    let mut new_s_len12 = String::new();\n\
    \    let mut new_s_len13 = String::new();\n    let mut new_s_len14 = String::new();\n\
    \    let mut new_s_len15 = String::new();\n    let mut new_s_len16 = String::new();\n\
    \    let mut new_s_len17 = String::new();\n    let mut new_s_len18 = String::new();\n\
    \    let mut new_s_len19 = String::new();\n    let mut new_s_len20 = String::new();\n\
    \    let mut new_s_len21 = String::new();\n    let mut new_s_len22 = String::new();\n\
    \    let mut new_s_len23 = String::new();\n    let mut new_s_len24 = String::new();\n\
    \    let mut new_s_len25 = String::new();\n    let mut new_s_len26 = String::new();\n\
    \    let mut new_s_len27 = String::new();\n    let mut new_s_len28 = String::new();\n\
    \    let mut new_s_len29 = String::new();\n    let mut new_s_len30 = String::new();\n\
    \    let mut new_s_len31 = String::new();\n    let mut new_s_len32 = String::new();\n\
    \    let mut new_s_len33 = String::new();\n    let mut new_s_len34 = String::new();\n\
    \    let mut new_s_len35 = String::new();\n    let mut new_s_len36 = String::new();\n\
    \    let mut new_s_len37 = String::new();\n    let mut new_s_len38 = String::new();\n\
    \    let mut new_s_len39 = String::new();\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprgo8ta4f.rs:49:11\n   |\n\
    49 |     let mu\n   |           ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmprgo8ta4f.rs:7:31\n  |\n\
    7 | fn anti_shuffle(s: String) -> String {\n  |    ------------              \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976520
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = String::new();\n        let mut new_word_len = 0;\n        for c\
    \ in word.chars() {\n            if c.is_ascii() {\n                new_word.push(c);\n\
    \                new_word_len += 1;\n            } else {\n                new_word.push(c.to_ascii_lowercase());\n\
    \                new_word_len += 2;\n            }\n        }\n        new_s +=\
    \ new_word.to_string();\n        if new_word_len > 0 {\n            new_s += \"\
    \ \";\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplaeciewh.rs:23:18\n   |\n\
    23 |         new_s += new_word.to_string();\n   |                  ^^^^^^^^^^^^^^^^^^^^\n\
    \   |                  |\n   |                  expected `&str`, found struct\
    \ `String`\n   |                  help: consider borrowing here: `&new_word.to_string()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len + 1;\n \
    \   let mut new_s_len3 = new_s_len2 + 1;\n    let mut new_s_len4 = new_s_len3\
    \ + 1;\n    let mut new_s_len5 = new_s_len4 + 1;\n    let mut new_s_len6 = new_s_len5\
    \ + 1;\n    let mut new_s_len7 = new_s_len6 + 1;\n    let mut new_s_len8 = new_s_len7\
    \ + 1;\n    let mut new_s_len9 = new_s_len8 + 1;\n    let mut new_s_len10 = new_s_len9\
    \ + 1;\n    let mut new_s_len11 = new_s_len10 + 1;\n    let mut new_s_len12 =\
    \ new_s_len11 + 1;\n    let mut new_s_len13 = new_s_len12 + 1;\n    let mut new_s_len14\
    \ = new_s_len13 + 1;\n    let mut new_s_len15 = new_s_len14 + 1;\n    let mut\
    \ new_s_len16 = new_s_len15 + 1;\n    let mut new_s_len17 = new_s_len16 + 1;\n\
    \    let mut new_s_len18 = new_s_len17 + 1;\n    let mut new_s_len19 = new_s_len18\
    \ + 1;\n    let mut new_s_len20 = new_s_len19 + 1;\n    let mut new_s_len21 =\
    \ new_s_len20 + 1;\n    let mut new_s_len22 = new_s_len21 + 1;\n    let mut new_s_len23\
    \ = new_s_len22 + 1;\n    let mut new_s_len24 = new_s_len23 + 1;\n    let mut\
    \ new_s_len25 = new_s_len24 + 1;\n    let mut new_s_len26 = new_s_len25 + 1;\n\
    \    let mut new_s_len27 = new_s_len26 + 1;\n    let mut new_s_len28 = new_s_len27\
    \ + 1;\n    let mut new_s_len29 = new_s_len28 + 1;\n    let mut new_s_len30 =\
    \ new_s_len29 + 1;\n    let mut new_s_len31 = new_s_len30 + 1;\n    let mut new_s_len32\
    \ = new_s_len31 + 1;\n    let mut new_s_len33 = new_s_len32 + 1;\n    let mut\
    \ new_s_len34 = new_s_len33 + 1;\n    let mut new_s_len35 = new_s_len34 + 1;\n\
    \    let mut new_s_len36 = new_s_len35 + 1;\n    let mut new_s_len37 = new_s_len36\
    \ + 1;\n    let mut new_s_len38 = new_s_len37 + 1;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw88hw2ay.rs:48:11\n   |\n\
    48 |     let mu\n   |           ^ help: add `;` here\n49 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpw88hw2ay.rs:7:31\n  |\n\
    7 | fn anti_shuffle(s: String) -> String {\n  |    ------------              \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3\
    \ = 0;\n    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut\
    \ new_s_len6 = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n\
    \    let mut new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11\
    \ = 0;\n    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut\
    \ new_s_len14 = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n\
    \    let mut new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19\
    \ = 0;\n    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut\
    \ new_s_len22 = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n\
    \    let mut new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27\
    \ = 0;\n    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut\
    \ new_s_len30 = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n\
    \    let mut new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35\
    \ = 0;\n    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut\
    \ new_s_len38 = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n\
    \    let mut new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43\
    \ = 0;\n    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut\
    \ new_s_len46 = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n\
    \    let mut new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51\
    \ = 0;\n    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut\
    \ new_s_len54 = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp558ate8_.rs:65:22\n   |\n\
    65 |     let mut new_s_len\n   |                      ^ help: add `;` here\n66\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp558ate8_.rs:7:31\n\
    \  |\n7 | fn anti_shuffle(s: String) -> String {\n  |    ------------        \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749396
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len {\n            if s[i]\
    \ == ' ' {\n                j += 1;\n                continue;\n            }\n\
    \            if s[j] > s[i] {\n                let tmp = s[j];\n             \
    \   s[j] = s[i];\n                s[i] = tmp;\n                j += 1;\n     \
    \           continue;\n            }\n            break;\n        }\n        new_s.push_str(&s[i\
    \ .. j]);\n        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppuiv7yqp.rs:15:16\n\
    \   |\n15 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppuiv7yqp.rs:19:16\n   |\n19 |             if s[j] > s[i] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppuiv7yqp.rs:19:23\n   |\n19 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String`"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_alphabetic() {\n            let mut j = i;\n        \
    \    while j > 0 && c.is_alphabetic() {\n                s[j - 1] = s[j];\n  \
    \              j -= 1;\n            }\n            s[j - 1] = c;\n        }\n\
    \    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1_nw73dv.rs:13:17\n\
    \   |\n13 |                 s[j - 1] = s[j];\n   |                 ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1_nw73dv.rs:13:28\n   |\n13 |                 s[j - 1] = s[j];\n\
    \   |                            ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1_nw73dv.rs:16:13\n   |\n16 |             s[j - 1] = c;\n   | \
    \            ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace_indices(\"\
    abcdefghijklmnopqrstuvwxyz\", |i| {\n        let mut j = i;\n        j.chars().enumerate().for_each(|(i,\
    \ c)| {\n            if c.is_alphabetic() {\n                j = j.replace(c);\n\
    \            }\n        });\n        j\n    });\n    s\n}\n\nfn main() {\n   \
    \ let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `replace_indices` found for struct `String`\
    \ in the current scope\n --> /tmp/tmptnxaioie.rs:9:7\n  |\n9 |     s.replace_indices(\"\
    abcdefghijklmnopqrstuvwxyz\", |i| {\n  |       ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `replacen`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_whitespace() {\n            s.swap(i, i + 1);\n     \
    \   }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp0s3n_yg0.rs:11:15\n   |\n11 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut words = s.split_whitespace();\n\
    \    let mut new_s = String::new();\n    for word in words {\n        let mut\
    \ new_word = word;\n        let mut new_word_len = 0;\n        for c in word.chars()\
    \ {\n            if c.is_ascii() {\n                new_word.push(c);\n      \
    \          new_word_len += 1;\n            }\n        }\n        if new_word_len\
    \ > 0 {\n            new_s += new_word.to_string();\n        }\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpjgfq11b4.rs:16:26\n   |\n16 |                 new_word.push(c);\n\
    \   |                          ^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjgfq11b4.rs:21:22\n   |\n21 |             new_s\
    \ += new_word.to_string();\n   |                      ^^^^^^^^^^^^^^^^^^^^\n \
    \  |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&new_word.to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    s.sort_by_key(|x| x.chars().map(|c|\
    \ c.to_ascii_lowercase()).collect::<Vec<String>>());\n    s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpnjtnn207.rs:9:7\n  |\n9 |     s.sort_by_key(|x|\
    \ x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<String>>());\n  |  \
    \     ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.replace(\"a\",\
    \ \"z\");\n    s.replace(\"b\", \"y\");\n    s.replace(\"c\", \"x\");\n    s.replace(\"\
    d\", \"w\");\n    s.replace(\"e\", \"v\");\n    s.replace(\"f\", \"u\");\n   \
    \ s.replace(\"g\", \"t\");\n    s.replace(\"h\", \"s\");\n    s.replace(\"i\"\
    , \"r\");\n    s.replace(\"j\", \"q\");\n    s.replace(\"k\", \"p\");\n    s.replace(\"\
    l\", \"o\");\n    s.replace(\"m\", \"n\");\n    s.replace(\"n\", \"m\");\n   \
    \ s.replace(\"o\", \"l\");\n    s.replace(\"p\", \"k\");\n    s.replace(\"q\"\
    , \"j\");\n    s.replace(\"r\", \"i\");\n    s.replace(\"s\", \"h\");\n    s.replace(\"\
    t\", \"g\");\n    s.replace(\"u\", \"f\");\n    s.replace(\"v\", \"e\");\n   \
    \ s.replace(\"w\", \"d\");\n    s.replace(\"x\", \"c\");\n    s.replace(\"y\"\
    , \"b\");\n    s.replace(\"z\", \"a\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjoiq83ud.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749397
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n   \
    \     let mut j = i;\n        while j < s.len() {\n            if s[j] != ' '\
    \ {\n                new_s.push(*j);\n                break;\n            }\n\
    \            j += 1;\n        }\n        new_s.push(' ');\n        new_s_len +=\
    \ 1;\n        while j < s.len() {\n            if s[j] != ' ' {\n            \
    \    new_s.push(*j);\n                break;\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy942_2j1.rs:15:16\n\
    \   |\n15 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpy942_2j1.rs:16:28\n\
    \   |\n16 |                 new_s.push(*j);\n   |                            ^^\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy942_2j1.rs:24:16\n\
    \   |\n24 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpy942_2j1.rs:25:28\n\
    \   |\n25 |                 new_s.push(*j);\n   |                            ^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    s.chars().enumerate().for_each(|(i,\
    \ c)| {\n        if c.is_alphabetic() {\n            s.insert(i, c.to_ascii_lowercase());\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp2jg4bj5j.rs:9:36\n   |\n9  |     s.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     ---------             -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                     |\n   |     |                     immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n10 |     \
    \    if c.is_alphabetic() {\n11 |             s.insert(i, c.to_ascii_lowercase());\n\
    \   |             - second borrow occurs due to use of `s` in closure\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976521
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n\
    \    let mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len\
    \ {\n        let mut j = i;\n        while j < new_s_len {\n            if s[i]\
    \ == ' ' && s[j] != ' ' {\n                s[j] = s[j].to_ascii_lowercase();\n\
    \                j += 1;\n            } else {\n                break;\n     \
    \       }\n        }\n        new_s.push_str(&s[..j]);\n        new_s.push_str(&s[j..]);\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_muou3ad.rs:15:16\n\
    \   |\n15 |             if s[i] == ' ' && s[j] != ' ' {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_muou3ad.rs:15:31\n   |\n15 |             if s[i] == ' ' && s[j]\
    \ != ' ' {\n   |                               ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_muou3ad.rs:16:17\n   |\n16 |                 s[j] = s[j].to_ascii_lowercase();\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n   "
  stdout: ''
  timestamp: 1659976521
