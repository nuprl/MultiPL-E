language: rs
name: HumanEval_44_change_base
results:
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base10 = base.to_string();\n\
    \    let mut digits_base = digits.chars().collect::<Vec<_>>();\n    let mut base10_base\
    \ = base10.chars().collect::<Vec<_>>();\n    let mut base10_digits = base10_base.len();\n\
    \    let mut base10_digits_base = base10_digits.chars().collect::<Vec<_>>();\n\
    \    let mut base10_digits_base2 = base10_digits_base.len();\n    let mut base10_digits_base3\
    \ = base10_digits_base2.chars().collect::<Vec<_>>();\n    let mut base10_digits_base4\
    \ = base10_digits_base3.chars().collect::<Vec<_>>();\n    let mut base10_digits_base5\
    \ = base10_digits_base4.chars().collect::<Vec<_>>();\n    let mut base10_digits_base6\
    \ = base10_digits_base5.chars().collect::<Vec<_>>();\n    let mut base10_digits_base7\
    \ = base10_digits_base6.chars().collect::<Vec<_>>();\n    let mut base10_digits_base8\
    \ = base10_digits_base7.chars().collect::<Vec<_>>();\n    let mut base10_digits_base9\
    \ = base10_digits_base8.chars().collect::<Vec<_>>();\n    let mut base10_digits_base10\
    \ = base10_digits_base9.chars().collect::<Vec<_>>();\n    let mut base10_digits_base11\
    \ = base10_digits_base10.chars().collect::<Vec<_>>();\n    let mut base10_digits_base12\
    \ = base10_digits_base11.chars().collect::<Vec<_>>();\n    let mut base10_digits_base13\
    \ = base10_digits_base12.chars().collect::<Vec<_>>();\n    let mut base10_digits_base14\
    \ = base10_digits_base13.chars().collect::<Vec<_>>();\n    let mut base10_digits_base15\
    \ = base10_digits_base14.chars().collect::<Vec<_>>();\n    let mut base10_digits_base16\
    \ = base10_digits_base15.chars().collect::<Vec<_>>();\n    let mut base10_digits_base17\
    \ = base10_digits_base16.chars().collect::<Vec<_>>();\n    let mut base10_digits_base18\
    \ = base10_digits_base17.chars().collect\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkslb57kc.rs:28:72\n   |\n\
    28 |     let mut base10_digits_base18 = base10_digits_base17.chars().collect\n\
    \   |                                                                        ^\
    \ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0599]: no method\
    \ named `chars` found for type `usize` in the current scope\n  --> /tmp/tmpkslb57kc.rs:11:48\n\
    \   |\n11 |     let mut base10_digits_base = base10_digits.chars().collect::<Vec<_>>();\n\
    \   |                                                ^^^^^ method not found in\
    \ `usize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpkslb57kc.rs:4:42\n \
    \ |\n4 | fn change_base(x: isize, base: isize) -> String {\n  |    -----------\
    \                           ^^^^^^ expected struct `String`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    let mut\
    \ i = 0;\n    while i < x.len() {\n        let digit = x.chars().nth(i).unwrap();\n\
    \        if digit < '0' || digit > '9' {\n            break;\n        }\n    \
    \    remainder = digit - '0';\n        if base == 10 {\n            digits.push_str(&format!(\"\
    {}\", remainder));\n        } else {\n            digits.push_str(&format!(\"\
    {}{}\", remainder, base));\n        }\n        i += 1;\n    }\n    s += digits;\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n --> /tmp/tmpkka640fi.rs:9:17\n  |\n9 |     while i < x.len() {\n  |\
    \                 ^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `chars` found for type `isize` in the current scope\n  --> /tmp/tmpkka640fi.rs:10:23\n\
    \   |\n10 |         let digit = x.chars().nth(i).unwrap();\n   |             \
    \          ^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkka640fi.rs:22:10\n   |\n22 |     s += digits;\n   |          ^^^^^^\n\
    \   |          |\n   |          expected `&str`, found struct `String`\n   | \
    \         help: consider borrowing here: `&digits`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while power.is_positive()\
    \ {\n        if digits.len() > base.to_digits().len() {\n            digits.truncate(base.to_digits().len());\n\
    \        }\n        if digits.len() < base.to_digits().len() {\n            digits\
    \ = digits.pad(base.to_digits().len());\n        }\n        let mut digit = digits.chars().nth(base.to_digits().len()).unwrap();\n\
    \        if digit >= '0' && digit <= '9' {\n            digit -= '0';\n      \
    \  } else {\n            digit -= 'a' - 10;\n        }\n        power = power.pow(base);\n\
    \        s += digit.to_string();\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `is_positive` on ambiguous numeric type\
    \ `{integer}`\n --> /tmp/tmp5w3sy3nh.rs:8:17\n  |\n8 |     while power.is_positive()\
    \ {\n  |                 ^^^^^^^^^^^\n  |\nhelp: you must specify a type for this\
    \ binding, like `i32`\n  |\n7 |     let mut power: i32 = 1;\n  |         ~~~~~~~~~~~~~~\n\
    \nerror[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n --> /tmp/tmp5w3sy3nh.rs:9:32\n  |\n9 |         if digits.len() > base.to_digits().len()\
    \ {\n  |                                ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5w3sy3nh.rs:10:34\n   |\n10 |             digits.truncate(base.to_digits().len());\n\
    \   |                                  ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5w3sy3nh.rs:12:32\n   |\n12 |         if digits.len() <\
    \ base.to_digits().len() {\n   |                                ^^^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `pad` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp5w3sy3nh.rs:13:29\n   |\n13 | \
    \            digits = digits.pad(base.to_digits().len());\n   |              \
    \               ^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `to_digits` found for type `isize` in the current scope\n  --> /tmp/tmp5w3sy3nh.rs:13:38\n\
    \   |\n13 |             digits = digits.pad(base.to_digits().len());\n   |   \
    \                                   ^^^^^^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5w3sy3nh.rs:15:49\n   |\n15 |         let mut digit = digits.chars().nth(base.to_digits().len()).unwrap();\n\
    \   |                                                 ^^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmp5w3sy3nh.rs:17:13\n   |\n17 |             digit\
    \ -= '0';\n   |          "
  stdout: ''
  timestamp: 1659748755
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.chars().nth(digits.length() - 1).unwrap();\n\
    \        if base == 10 {\n            s.push_str(&digit);\n        } else {\n\
    \            let mut new_digit = digit;\n            if digit == '0' {\n     \
    \           remainder = 0;\n            } else {\n                remainder =\
    \ digit as isize - base;\n                new_digit = digit as isize;\n      \
    \      }\n            s.push_str(&new_digit.to_string());\n        }\n       \
    \ digits = digits.chars().nth(digits.length() - 1).unwrap();\n    }\n    if remainder\
    \ != 0 {\n        s.push_str(&remainder.to_string());\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpxtn777dj.rs:9:47\n  |\n9 |         let digit = digits.chars().nth(digits.length()\
    \ - 1).unwrap();\n  |                                               ^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtn777dj.rs:11:24\n\
    \   |\n11 |             s.push_str(&digit);\n   |                        ^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxtn777dj.rs:18:29\n   |\n18 |                 new_digit = digit as isize;\n\
    \   |                             ^^^^^^^^^^^^^^ expected `char`, found `isize`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpxtn777dj.rs:22:44\n   |\n22 |         digits = digits.chars().nth(digits.length()\
    \ - 1).unwrap();\n   |                                            ^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtn777dj.rs:22:18\n\
    \   |\n22 |         digits = digits.chars().nth(digits.length() - 1).unwrap();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |\n   |\
    \                  expected struct `String`, found `char`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.size() {\n        if base == 0 {\n            s.push_str(&digits[i]);\n\
    \            i += 1;\n        } else {\n            let mut j = i;\n         \
    \   while j < digits.size() && base == 0 {\n                s.push_str(&digits[j]);\n\
    \                j += 1;\n            }\n            let mut base = base.to_string().chars().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6h4mbxeg.rs:69:3\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n9  |     while\
    \ i < digits.size() {\n   |                             - unclosed delimiter\n\
    ...\n13 |         } else {\n   |                - this delimiter might not be\
    \ properly closed...\n...\n53 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n69 | }\n   |   ^\n\nerror[E0599]: no method named `size` found\
    \ for struct `Vec<char>` in the current scope\n --> /tmp/tmp6h4mbxeg.rs:9:22\n\
    \  |\n9 |     while i < digits.size() {\n  |                      ^^^^ method\
    \ not found in `Vec<char>`\n\nerror[E0277]: can't compare `Vec<char>` with `{integer}`\n\
    \  --> /tmp/tmp6h4mbxeg.rs:10:17\n   |\n10 |         if base == 0 {\n   |    \
    \             ^^ no implementation for `Vec<char> == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `Vec<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6h4mbxeg.rs:11:24\n   |\n11 |             s.push_str(&digits[i]);\n\
    \   |                        ^^^^^^^^^^ expected `str`, found `char`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&char`\n\n\
    error[E0599]: no method named `size` found for struct `Vec<char>` in the current\
    \ scope\n  --> /tmp/tmp6h4mbxeg.rs:15:30\n   |\n15 |             while j < digits.size()\
    \ && base == 0 {\n   |                              ^^^^ method not found in `Vec<char>`\n\
    \nerror[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmp6h4mbxeg.rs:15:45\n\
    \   |\n15 |             while j < digits.size() && base == 0 {\n   |         \
    \                                    ^^ no implementation for `Vec<char> == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `Vec<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6h4mbxeg.rs:16:28\n   |\n16 |\
    \                 s.push_str(&digits[j]);\n   |                            ^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected ref"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > base {\n      \
    \  digits = &digits[..(digits.len() - base)];\n    }\n    s += &digits[..];\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjieplaki.rs:7:26\n  |\n7 |\
    \     while digits.len() > base {\n  |                          ^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n7 |     while digits.len() >\
    \ base.try_into().unwrap() {\n  |                          ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpjieplaki.rs:8:44\n  |\n8 |    \
    \     digits = &digits[..(digits.len() - base)];\n  |                        \
    \                    ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ subtract `isize` from `usize`\n --> /tmp/tmpjieplaki.rs:8:42\n  |\n8 |     \
    \    digits = &digits[..(digits.len() - base)];\n  |                         \
    \                 ^ no implementation for `usize - isize`\n  |\n  = help: the\
    \ trait `Sub<isize>` is not implemented for `usize`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpjieplaki.rs:8:18\n  |\n8 |         digits = &digits[..(digits.len()\
    \ - base)];\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n  |\nhelp: try using a conversion method\n  |\n8 | \
    \        digits = (&digits[..(digits.len() - base)]).to_string();\n  |       \
    \           +                                +++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > 0 {\n        let\
    \ digit = digits.chars().nth(base).unwrap();\n        digits = digits.chars().nth(base\
    \ - 1).unwrap() + digit;\n        s += digit;\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpds31yvj1.rs:8:40\n  |\n8 |\
    \         let digit = digits.chars().nth(base).unwrap();\n  |                \
    \                        ^^^^ expected `usize`, found `isize`\n  |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n  |\n8 |         let digit = digits.chars().nth(base.try_into().unwrap()).unwrap();\n\
    \  |                                        ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpds31yvj1.rs:9:37\n  |\n9 |         digits = digits.chars().nth(base\
    \ - 1).unwrap() + digit;\n  |                                     ^^^^^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |         digits = digits.chars().nth((base\
    \ - 1).try_into().unwrap()).unwrap() + digit;\n  |                           \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0369]: cannot add `char` to\
    \ `char`\n --> /tmp/tmpds31yvj1.rs:9:56\n  |\n9 |         digits = digits.chars().nth(base\
    \ - 1).unwrap() + digit;\n  |                  -------------------------------------\
    \ ^ ----- char\n  |                  |\n  |                  char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpds31yvj1.rs:10:14\n   |\n10 |         s += digit;\n\
    \   |              ^^^^^ expected `&str`, found `char`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > 0 {\n        let\
    \ mut digit = digits.chars().nth(digits.len() - 1);\n        if digit < '0' {\n\
    \            digit += '0';\n        }\n        if digit > '9' {\n            digit\
    \ += '0';\n        }\n        digits = digits.chars().nth(digits.len() - 1);\n\
    \        s += digit;\n    }\n    let mut digits = base.to_string();\n    while\
    \ digits.len() > 0 {\n        let mut digit = digits.chars().nth(digits.len()\
    \ - 1);\n        if digit < '0' {\n            digit += '0';\n        }\n    \
    \    if digit > '9' {\n            digit += '0';\n        }\n        digits =\
    \ digits.chars().nth(digits.len() - 1);\n        s += digit;\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc_o13uxf.rs:9:20\n  |\n9 |\
    \         if digit < '0' {\n  |                    ^^^\n  |                  \
    \  |\n  |                    expected enum `Option`, found `char`\n  |       \
    \             help: try using a variant of the expected enum: `Some('0')`\n  |\n\
    \  = note: expected enum `Option<char>`\n             found type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<char>`\n\
    \  --> /tmp/tmpc_o13uxf.rs:10:13\n   |\n10 |             digit += '0';\n   | \
    \            -----^^^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_o13uxf.rs:12:20\n\
    \   |\n12 |         if digit > '9' {\n   |                    ^^^\n   |      \
    \              |\n   |                    expected enum `Option`, found `char`\n\
    \   |                    help: try using a variant of the expected enum: `Some('9')`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Option<char>`\n\
    \  --> /tmp/tmpc_o13uxf.rs:13:13\n   |\n13 |             digit += '0';\n   | \
    \            -----^^^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_o13uxf.rs:15:18\n\
    \   |\n15 |         digits = digits.chars().nth(digits.len() - 1);\n   |     \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_o13uxf.rs:16:14\n\
    \   |\n16 |         s += digit;\n   |              ^^^^^ expected `&str`, found\
    \ enum `Option`\n   |\n   = note: expected reference `&str`\n                \
    \   found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_o13uxf.rs:21:20\n\
    \   |\n21 |         if digit < '0' {\n   |                    ^^^\n   |      \
    \              |\n   |                    expected enum `Option`, found `char`\n\
    \   |         "
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        if digits.len() > base {\n            digits = &digits[..(digits.len()\
    \ - base)];\n            power = power * base;\n        }\n        s += digits[digits.len()\
    \ - 1];\n        digits = &digits[..digits.len() - 1];\n    }\n    format!(\"\
    {}\", power)\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmputmuuwhv.rs:9:27\n  |\n9 |\
    \         if digits.len() > base {\n  |                           ^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |         if digits.len() >\
    \ base.try_into().unwrap() {\n  |                           ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmputmuuwhv.rs:10:48\n   |\n10 |\
    \             digits = &digits[..(digits.len() - base)];\n   |               \
    \                                 ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmputmuuwhv.rs:10:46\n   |\n\
    10 |             digits = &digits[..(digits.len() - base)];\n   |            \
    \                                  ^ no implementation for `usize - isize`\n \
    \  |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmputmuuwhv.rs:10:22\n   |\n10 |             digits\
    \ = &digits[..(digits.len() - base)];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n10 |             digits = (&digits[..(digits.len() - base)]).to_string();\n\
    \   |                      +                                +++++++++++++\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmputmuuwhv.rs:13:14\n\
    \   |\n13 |         s += digits[digits.len() - 1];\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmputmuuwhv.rs:14:18\n\
    \   |\n14 |         digits = &digits[..digits.len() - 1];\n   |              \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n14 |         digits = (&digits[..digits.len()\
    \ - 1]).to_string();\n   |                  +                           +++++++++++++\n\
    \nerror: aborting due to 6 previous error"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let mut digit = digits.pop().unwrap();\n        if digit >= base\
    \ {\n            digit -= base;\n            power = 1;\n        } else {\n  \
    \          power <<= 1;\n        }\n        s += digit.to_string();\n    }\n \
    \   format!(\"{}\", power)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpee0j1fpg.rs:10:21\n   |\n\
    10 |         if digit >= base {\n   |                     ^^^^ expected `char`,\
    \ found `isize`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpee0j1fpg.rs:11:13\n   |\n11 |             digit\
    \ -= base;\n   |             -----^^^^^^^^\n   |             |\n   |         \
    \    cannot use `-=` on type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpee0j1fpg.rs:16:14\n\
    \   |\n16 |         s += digit.to_string();\n   |              ^^^^^^^^^^^^^^^^^\n\
    \   |              |\n   |              expected `&str`, found struct `String`\n\
    \   |              help: consider borrowing here: `&digit.to_string()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihc6psaf.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpihc6psaf.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpihc6psaf.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x /= base;\n    }\n    if x > 0 {\n        remainder += x;\n    }\n \
    \   s += format!(\"{}\", remainder);\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_w0znppe.rs:14:10\n   |\n\
    14 |     s += format!(\"{}\", remainder);\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ i = 0;\n    while remainder > 0 {\n        remainder = remainder % base;\n \
    \       digits.push(&format!(\"{}\", remainder));\n        i += 1;\n    }\n  \
    \  digits.push(&format!(\"{}\", remainder));\n    s += &digits[..i];\n    s +=\
    \ &digits[..i].to_string();\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpest03p_l.rs:11:21\n   |\n\
    11 |         digits.push(&format!(\"{}\", remainder));\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpest03p_l.rs:14:17\n   |\n14 |     digits.push(&format!(\"\
    {}\", remainder));\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ quotient = x;\n    while remainder > 0 {\n        remainder /= base;\n     \
    \   digits.push_str(&format!(\"{}\", quotient));\n        quotient *= base;\n\
    \    }\n    digits.push_str(&format!(\"{}\", quotient));\n    s += &digits;\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82472\"`,\n right: `\"22\"`', /tmp/tmpl3u2bezi.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    for digit in digits\
    \ {\n        s.push(digit);\n    }\n    String::from(s)\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqws7pmy_.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: `String` is not an iterator\n\
    \   --> /tmp/tmpqws7pmy_.rs:13:18\n    |\n13  |     for digit in digits {\n  \
    \  |                  ^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base10: Vec<_> = digits.iter().map(|x| x.to_digit(base)).collect();\n    let\
    \ mut base10_len = base10.len();\n    let mut base10_pow = base10_len.powf(base);\n\
    \    let mut base10_pow2 = base10_pow.clone();\n    let mut base10_pow2_len =\
    \ base10_pow2.len();\n    let mut base10_pow2_pow = base10_pow2.powf(2);\n   \
    \ let mut base10_pow2_pow2 = base10_pow2_pow.clone();\n    let mut base10_pow2_pow2_len\
    \ = base10_pow2_pow2.len();\n    let mut base10_pow2_pow2_pow = base10_pow2_pow2.powf(2);\n\
    \    let mut base10_pow2_pow2_pow2 = base10_pow2_pow2_pow.clone();\n    let mut\
    \ base10_pow2_pow2_pow2_len = base10_pow2_pow2_pow2.len();\n    let mut base10_pow2_pow2_pow2_pow\
    \ = base10_pow2_pow2_pow2.powf(2);\n    let mut base10_pow2_pow2_pow2_pow2 = base10_pow2_pow2_pow2_pow.clone();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_len = base10_pow2_pow2_pow2_pow2.len();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow = base10_pow2_pow2_pow2_pow2.powf(2);\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2 = base10_pow2_pow2_pow2_pow2_pow.clone();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_len = base10_pow2_pow2_pow2_pow2_pow2.len();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_pow = base10_pow2_pow2_pow2_pow2_pow2.powf(2);\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_pow2 = base10_pow2_pow2_pow2_pow2_pow2_pow.clone();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_pow2_len = base10_pow2_pow2_pow2_pow2_pow2_pow2.len();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_pow2_pow = \n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp77d0jmg5.rs:28:1\n\
    \   |\n28 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp77d0jmg5.rs:7:63\n  |\n7 |     let mut base10: Vec<_> = digits.iter().map(|x|\
    \ x.to_digit(base)).collect();\n  |                                          \
    \                     ^^^^ expected `u32`, found `isize`\n  |\nhelp: you can convert\
    \ an `isize` to a `u32` and panic if the converted value doesn't fit\n  |\n7 |\
    \     let mut base10: Vec<_> = digits.iter().map(|x| x.to_digit(base.try_into().unwrap())).collect();\n\
    \  |                                                               ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0599]: no method named `powf` found for type `usize` in the current scope\n\
    \ --> /tmp/tmp77d0jmg5.rs:9:37\n  |\n9 |     let mut base10_pow = base10_len.powf(base);\n\
    \  |                                     ^^^^ help: there is an associated function\
    \ with a similar name: `pow`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihc6psaf.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpihc6psaf.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpihc6psaf.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let digit = digits.chars().nth(base.len()\
    \ - 1).unwrap();\n        s += digit;\n        digits = digits.chars().skip_while(|c|\
    \ c != digit).collect();\n        base = base.chars().skip_while(|c| c != digit).collect();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbg_u9r2.rs:10:14\n   |\n\
    10 |         s += digit;\n   |              ^^^^^ expected `&str`, found `char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjbg_u9r2.rs:11:50\n\
    \   |\n11 |         digits = digits.chars().skip_while(|c| c != digit).collect();\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjbg_u9r2.rs:12:46\n\
    \   |\n12 |         base = base.chars().skip_while(|c| c != digit).collect();\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder += x % base;\n        x /= base;\n    }\n    s\
    \ += digits[remainder];\n    while x > 0 {\n        remainder += x % base;\n \
    \       x /= base;\n        s += digits[remainder];\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmp2ylr0qs_.rs:12:10\n\
    \   |\n12 |     s += digits[remainder];\n   |          ^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `isize`\n   |\n   = help: the trait `Index<isize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp2ylr0qs_.rs:16:14\n   |\n16 |         s += digits[remainder];\n\
    \   |              ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n \
    \  |\n   = help: the trait `Index<isize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ digit = 0;\n    while remainder > 0 {\n        digit = remainder % base;\n \
    \       remainder = remainder / base;\n        digits.push_str(&format!(\"{}\"\
    , digit));\n    }\n    digits.push_str(&format!(\"{}\", digit));\n    s += &digits;\n\
    \    while remainder > 0 {\n        digit = remainder % base;\n        remainder\
    \ = remainder / base;\n        digits.push_str(&format!(\"{}\", digit));\n   \
    \ }\n    digits.push_str(&format!(\"{}\", digit));\n    s += &digits;\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"2222222\"`,\n right: `\"22\"`', /tmp/tmpgukdrinn.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    while digits.len()\
    \ > 0 {\n        let mut digit = digits.remove(0);\n        if digit == \"0\"\
    \ {\n            digits.push('1');\n        } else {\n            digits.push('0');\n\
    \        }\n    }\n    s + digits.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2pncy1t6.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp2pncy1t6.rs:15:21\n   |\n15 |         if digit == \"0\" {\n   |\
    \                     ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant\
    \ to write a `char` literal, use single quotes\n   |\n15 |         if digit ==\
    \ '0' {\n   |                     ~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2pncy1t6.rs:21:9\n   |\n21 |     s + digits.to_string()\n   |      \
    \   ^^^^^^^^^^^^^^^^^^\n   |         |\n   |         expected `&str`, found struct\
    \ `String`\n   |         help: consider borrowing here: `&digits.to_string()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ basedigits = base.to_string().chars().collect::<Vec<_>>();\n    let mut i =\
    \ 0;\n    while i < digits.len() {\n        if digits[i] >= basedigits[i] {\n\
    \            s.push_str(&basedigits[digits[i] - basedigits[i]]);\n           \
    \ i += 1;\n        } else {\n            s.push_str(&digits[i]);\n           \
    \ i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpjyvaxr72.rs:11:46\n\
    \   |\n11 |             s.push_str(&basedigits[digits[i] - basedigits[i]]);\n\
    \   |                                    --------- ^ ------------- char\n   |\
    \                                    |\n   |                                 \
    \   char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjyvaxr72.rs:14:24\n\
    \   |\n14 |             s.push_str(&digits[i]);\n   |                        ^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpz7gwz44y.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_len = digits.length();\n    let mut base_len = base.length();\n\
    \    let mut i = 0;\n    while i < digits_len {\n        if digits[i] > base {\n\
    \            digits = digits.chars().filter(|&c| c != '0').collect();\n      \
    \      base = base.chars().filter(|&c| c != '0').collect();\n            digits_len\
    \ = digits.length();\n            base_len = base.length();\n        }\n     \
    \   i += 1;\n    }\n    digits = digits.chars().filter(|&c| c != '0').collect();\n\
    \    s = digits.join(\"\");\n    s = s.chars().filter(|&c| c != '0').collect();\n\
    \    s = s.join(\"\");\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpim3isn3l.rs:8:33\n  |\n8 |     let mut digits_len\
    \ = digits.length();\n  |                                 ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n --> /tmp/tmpim3isn3l.rs:9:29\n\
    \  |\n9 |     let mut base_len = base.length();\n  |                         \
    \    ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpim3isn3l.rs:12:12\n\
    \   |\n12 |         if digits[i] > base {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpim3isn3l.rs:15:33\n   |\n15 |          \
    \   digits_len = digits.length();\n   |                                 ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpim3isn3l.rs:16:29\n   |\n16 |             base_len = base.length();\n\
    \   |                             ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: no method named `join` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpim3isn3l.rs:21:16\n   |\n\
    21 |     s = digits.join(\"\");\n   |                ^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `join` found for struct `String` i"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.len() {\n        if base == 1 {\n            s.push('1');\n\
    \            i += 1;\n            continue;\n        }\n        if base == 10\
    \ {\n            s.push('0');\n            i += 1;\n            continue;\n  \
    \      }\n        if base == 16 {\n            s.push('x');\n            i +=\
    \ 1;\n            continue;\n        }\n        if base == 8 {\n            s.push('b');\n\
    \            i += 1;\n            continue;\n        }\n        if base == 2 {\n\
    \            s.push('o');\n            i += 1;\n            continue;\n      \
    \  }\n        if base == 16 {\n            s.push('h');\n            i += 1;\n\
    \            continue;\n        }\n        if base == 8 {\n            s.push('o');\n\
    \            i += 1;\n            continue;\n        }\n        if base == 2 {\n\
    \            s.push('l');\n            i += 1;\n            continue;\n      \
    \  }\n        if base == 16 {\n            s.push('l');\n            i += 1;\n\
    \            continue;\n        }\n        if base == 8 {\n            s.push('l');\n\
    \            i += 1;\n            continue;\n        }\n        if base == 2 {\n\
    \            s.push('l');\n            i += 1;\n            continue;\n      \
    \  }\n        if base == 16 {\n            s.push('l');\n            i += 1;\n\
    \            continue;\n        }\n        if base == 8 {\n            s.push('l');\n\
    \            i += 1;\n            continue;\n        }\n        if base == 2 {\n\
    \            s.push('l');\n            i += 1;\n            continue;\n      \
    \  }\n        if base == 16 {\n            s.push('l');\n            i += 1;\n\
    \            continue;\n        }\n        if base == 8 {\n            s.push('l');\n\
    \            i += 1;\n            continue;\n        }\n        if base == 2 {\n\
    \            s.push('l');\n            i += 1;\n            continue;\n      \
    \  }\n        if base == 16 {\n            s.push('l');\n            i += 1;\n\
    \            continue;\n        }\n        if base == 8 {\n            s.push('l');\n\
    \            i += 1;\n            continue;\n        }\n        if base == 2 {\n\
    \            s.push('l');\n            i += 1;\n            continue;\n      \
    \  }\n        if base == 16 {\n            s.push('l');\n            i += 1;\n\
    \            continue;\n        }\n        if base == 8 {\n            s.push('l');\n\
    \            i += 1;\n            continue;\n        }\n        if base == \n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp57tupsol.rs:137:3\n\
    \    |\n4   | fn change_base(x: isize, base: isize) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n9   |  \
    \   while i < digits.len() {\n    |                            - this delimiter\
    \ might not be properly closed...\n...\n121 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n137 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp57tupsol.rs:121:1\n    |\n121 | }\n  \
    \  | ^ expected expression\n\nerror[E0277]: can't compare `Vec<char>` with `{integer}`\n\
    \  --> /tmp/tmp57tupsol.rs:10:17\n   |\n10 |         if base == 1 {\n   |    \
    \             ^^ no implementation for `Vec<char> == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `Vec<char>`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <Vec<T,\
    \ A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n\
    \             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut\
    \ [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A>\
    \ as PartialEq<[U]>>\n\nerror[E0277]: can't compare `Vec<char>` with `{integer}`\n\
    \  --> /tmp/tmp57tupsol.rs:15:17\n   |\n15 |         if base == 10 {\n   |   \
    \              ^^ no implementation for `Vec<char> == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `Vec<char>`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <Vec<T,\
    \ A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n\
    \             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut\
    \ [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A>\
    \ as PartialEq<[U]>>\n\nerror[E0277]: can't compare `Vec<char>` with `{integer}`\n\
    \  --> /tmp/tmp57tupsol.rs:20:17\n   |\n20 |         if base == 16 {\n   |   \
    \              ^^ no implementation for `Vec<char> == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder += x / base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x %= base;\n    }\n    digits.push(format!(\"{}\", x));\n\
    \    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgv7uqnsb.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpgv7uqnsb.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgv7uqnsb.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        if digits.len() > base {\n            digits = &digits[..(digits.len()\
    \ - base)];\n            power = power / base;\n        }\n        s += digits[digits.len()\
    \ - 1];\n        digits = &digits[..digits.len() - 1];\n    }\n    format!(\"\
    {}\", power)\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7gwewb1e.rs:9:27\n  |\n9 |\
    \         if digits.len() > base {\n  |                           ^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |         if digits.len() >\
    \ base.try_into().unwrap() {\n  |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7gwewb1e.rs:10:48\n   |\n10 |\
    \             digits = &digits[..(digits.len() - base)];\n   |               \
    \                                 ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmp7gwewb1e.rs:10:46\n   |\n\
    10 |             digits = &digits[..(digits.len() - base)];\n   |            \
    \                                  ^ no implementation for `usize - isize`\n \
    \  |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7gwewb1e.rs:10:22\n   |\n6  |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n10 |\
    \             digits = &digits[..(digits.len() - base)];\n   |               \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n10 |             digits = (&digits[..(digits.len()\
    \ - base)]).to_string();\n   |                      +                        \
    \        +++++++++++++\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmp7gwewb1e.rs:13:14\n   |\n13 |         s += digits[digits.len()\
    \ - 1];\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = h"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03zito6r.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp03zito6r.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpf_bpqjci.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let mut digit = digits.chars().nth(digits.len() - 1);\n     \
    \   if digit == '0' {\n            digits.pop();\n        } else {\n         \
    \   digit = digit.to_string();\n        }\n        if digit < base.to_string()\
    \ {\n            digit += '0';\n        }\n        s += digit;\n        power\
    \ *= base;\n    }\n    format!(\"{}\", power)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppr8nsr3k.rs:10:21\n   |\n\
    10 |         if digit == '0' {\n   |                     ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n10 |       \
    \  if digit == Some('0') {\n   |                     +++++   +\n\nerror[E0599]:\
    \ `Option<char>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmppr8nsr3k.rs:13:27\n\
    \    |\n13  |               digit = digit.to_string();\n    |                \
    \             ^^^^^^^^^ `Option<char>` cannot be formatted with the default formatter\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<char>: std::fmt::Display`\n            which is required by `Option<char>:\
    \ ToString`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppr8nsr3k.rs:15:20\n\
    \   |\n15 |         if digit < base.to_string() {\n   |                    ^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `String`\n   |\n   = note: expected enum\
    \ `Option<char>`\n            found struct `String`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Option<char>`\n  --> /tmp/tmppr8nsr3k.rs:16:13\n\
    \   |\n16 |             digit += '0';\n   |             -----^^^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `Option<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppr8nsr3k.rs:18:14\n   |\n18 |         s += digit;\n\
    \   |              ^^^^^ expected `&str`, found enum `Option`\n   |\n   = note:\
    \ expected reference `&str`\n                   found enum `Option<char>`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.chars().nth(digits.length() - 1).unwrap();\n\
    \        remainder = remainder * base + digit;\n        digits = digits.chars().nth(digits.length()\
    \ - 1).unwrap();\n    }\n    remainder.to_string()\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpf7r2_0rk.rs:9:47\n  |\n9 |         let digit = digits.chars().nth(digits.length()\
    \ - 1).unwrap();\n  |                                               ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ cannot add `char` to `isize`\n  --> /tmp/tmpf7r2_0rk.rs:10:38\n   |\n10 |  \
    \       remainder = remainder * base + digit;\n   |                          \
    \            ^ no implementation for `isize + char`\n   |\n   = help: the trait\
    \ `Add<char>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n          \
    \   <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n            \
    \ <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a\
    \ i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize\
    \ as Add<isize>>\n           and 48 others\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpf7r2_0rk.rs:11:44\n\
    \   |\n11 |         digits = digits.chars().nth(digits.length() - 1).unwrap();\n\
    \   |                                            ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpf7r2_0rk.rs:11:18\n   |\n6  |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n11 |\
    \         digits = digits.chars().nth(digits.length() - 1).unwrap();\n   |   \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                  |\n   |         \
    \         expected struct `String`, found `char`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = 1;\n    while remainder > 0\
    \ {\n        remainder %= base;\n        digits += 1;\n    }\n    for _ in 0..digits\
    \ {\n        s.push('0');\n    }\n    s.push((x as usize).to_string());\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_q6exveq.rs:15:12\n   |\n\
    15 |     s.push((x as usize).to_string());\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > 0 {\n        let\
    \ digit = digits.chars().nth(digits.len() - 1);\n        if digit == '0' {\n \
    \           digits.pop();\n        } else {\n            s.push_str(&digits[digits.len()\
    \ - 1]);\n            digits.truncate(digits.len() - 1);\n        }\n    }\n \
    \   let mut digits = base.to_string();\n    while digits.len() > 0 {\n       \
    \ let digit = digits.chars().nth(digits.len() - 1);\n        if digit == '0' {\n\
    \            digits.pop();\n        } else {\n            s.push_str(&digits[digits.len()\
    \ - 1]);\n            digits.truncate(digits.len() - 1);\n        }\n    }\n \
    \   s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpi3z9moyn.rs:9:21\n  |\n9 |\
    \         if digit == '0' {\n  |                     ^^^ expected enum `Option`,\
    \ found `char`\n  |\n  = note: expected enum `Option<char>`\n             found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n  |\n9 |         if\
    \ digit == Some('0') {\n  |                     +++++   +\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpi3z9moyn.rs:12:25\n\
    \   |\n12 |             s.push_str(&digits[digits.len() - 1]);\n   |         \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi3z9moyn.rs:19:21\n\
    \   |\n19 |         if digit == '0' {\n   |                     ^^^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n    \
    \          found type `char`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n19 |         if digit == Some('0') {\n   |                     +++++   +\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpi3z9moyn.rs:22:25\n\
    \   |\n22 |             s.push_str(&digits[digits.len() - 1]);\n   |         \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<Ra"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    let mut\
    \ digits_len = digits.length();\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", digits, digit);\n        digits_len -= 1;\n    }\n    if digits_len >\
    \ 0 {\n        s = format!(\"{}\", digits);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpa2dupezw.rs:8:33\n  |\n8 |     let mut digits_len\
    \ = digits.length();\n  |                                 ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ i = 0;\n    while remainder > 0 {\n        remainder %= base;\n        s.push((digits[i\
    \ as usize] as char) + char::from_digit(base as u8, remainder as u8));\n     \
    \   i += 1;\n        remainder /= base;\n    }\n    s.push((digits[i as usize]\
    \ as char) + char::from_digit(base as u8, 0));\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2zl1g0xv.rs:11:17\n\
    \   |\n11 |         s.push((digits[i as usize] as char) + char::from_digit(base\
    \ as u8, remainder as u8));\n   |                 ^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2zl1g0xv.rs:11:64\n\
    \   |\n11 |         s.push((digits[i as usize] as char) + char::from_digit(base\
    \ as u8, remainder as u8));\n   |                                            \
    \                    ^^^^^^^^^^ expected `u32`, found `u8`\n   |\nhelp: you can\
    \ convert a `u8` to a `u32`\n   |\n11 |         s.push((digits[i as usize] as\
    \ char) + char::from_digit((base as u8).into(), remainder as u8));\n   |     \
    \                                                           +          ++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2zl1g0xv.rs:11:76\n   |\n11 |\
    \         s.push((digits[i as usize] as char) + char::from_digit(base as u8, remainder\
    \ as u8));\n   |                                                             \
    \               ^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n   |\nhelp: you can\
    \ convert a `u8` to a `u32`\n   |\n11 |         s.push((digits[i as usize] as\
    \ char) + char::from_digit(base as u8, (remainder as u8).into()));\n   |     \
    \                                                                       +    \
    \           ++++++++\n\nerror[E0369]: cannot add `Option<char>` to `char`\n  -->\
    \ /tmp/tmp2zl1g0xv.rs:11:45\n   |\n11 |         s.push((digits[i as usize] as\
    \ char) + char::from_digit(base as u8, remainder as u8));\n   |              \
    \  ------------------"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        s.push((digits[..1] as char).to_string()\
    \ + &\"0\".to_string());\n    }\n    s.push((digits[..1] as char).to_string()\
    \ + &\"0\".to_string());\n    &s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpax2zjqht.rs:10:16\n   |\n\
    10 |         s.push((digits[..1] as char).to_string() + &\"0\".to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpax2zjqht.rs:12:12\n\
    \   |\n12 |     s.push((digits[..1] as char).to_string() + &\"0\".to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpax2zjqht.rs:13:5\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n13 |     &s\n   |     ^^ expected struct `String`, found `&String`\n   |\n\
    help: consider removing the borrow\n   |\n13 -     &s\n13 +     s\n   | \n\nerror[E0605]:\
    \ non-primitive cast: `str` as `char`\n  --> /tmp/tmpax2zjqht.rs:10:16\n   |\n\
    10 |         s.push((digits[..1] as char).to_string() + &\"0\".to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used\
    \ to convert between primitive types or to coerce to a specific trait object\n\
    \nerror[E0605]: non-primitive cast: `str` as `char`\n  --> /tmp/tmpax2zjqht.rs:12:12\n\
    \   |\n12 |     s.push((digits[..1] as char).to_string() + &\"0\".to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to\
    \ convert between primitive types or to coerce to a specific trait object\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0605.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    let mut\
    \ quotient = 0;\n    let mut remainder_digits = String::new();\n    let mut quotient_digits\
    \ = String::new();\n    let mut digits_len = String::new();\n    let mut remainder_digits_len\
    \ = String::new();\n    let mut quotient_digits_len = String::new();\n    let\
    \ mut digits_len = String::new();\n    let mut remainder_digits_len = String::new();\n\
    \    let mut quotient_digits_len = String::new();\n    let mut digits_len = String::new();\n\
    \    let mut remainder_digits_len = String::new();\n    let mut quotient_digits_len\
    \ = String::new();\n    let mut digits_len = String::new();\n    let mut remainder_digits_len\
    \ = String::new();\n    let mut quotient_digits_len = String::new();\n    let\
    \ mut digits_len = String::new();\n    let mut remainder_digits_len = String::new();\n\
    \    let mut quotient_digits_len = String::new();\n    let mut digits_len = String::new();\n\
    \    let mut remainder_digits_len = String::new();\n    let mut quotient_digits_len\
    \ = String::new();\n    let mut digits_len = String::new();\n    let mut remainder_digits_len\
    \ = String::new();\n    let mut quotient_digits_len = String::new();\n    let\
    \ mut digits_len = String::new();\n    let mut remainder_digits_len = String::new();\n\
    \    let mut quotient_digits_len = String::new();\n    let mut digits_len = String::new();\n\
    \    let mut remainder_digits_len = String::new();\n    let mut quotient_digits_len\
    \ = String::new();\n    let mut digits_len = String::new();\n    let mut remainder_digits_len\
    \ = String::new();\n    let mut quotient_digits_len = String::new();\n    let\
    \ mut digits_len = String::new();\n    let mut remainder_digits_len = String::new();\n\
    \    let mut quotient_digits_len = String::new();\n    let mut digits_len = String::new();\n\
    \    let mut remainder_digits_len = String::new();\n    let mut quotient_digits_len\
    \ = String::new();\n    let mut digits_len = String::new();\n\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppq4fta4r.rs:4:42\n  |\n4 |\
    \ fn change_base(x: isize, base: isize) -> String {\n  |    -----------      \
    \                     ^^^^^^ expected struct `String`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpks0qj8er.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digit.len() - 1);\n   \
    \     digit = digit.to_string().chars().nth(digit.len() - 1);\n        digit =\
    \ digit.to_string().chars().nth(digit.len() - 1);\n        digit = digit.to_string().chars().nth(digit.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digit.len() - 1);\n   \
    \     digit = digit.to_string().chars().nth(digit.len() - 1);\n        digit =\
    \ digit.to_string().chars().nth(digit.len() - 1);\n        digit = digit.to_string().chars().nth(digit.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digit.len() - 1);\n   \
    \     digit = digit.to_string().chars().nth(digit.len() - 1);\n        digit =\
    \ digit.to_string().chars().nth(digit.len() - 1);\n        digit = digit.to_string().chars().nth(digit.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digit.len() - 1);\n   \
    \     digit = digit.to_string().chars().nth(digit.len() - 1);\n        digit =\
    \ digit.to_string().chars().nth(digit.len() - 1);\n        digit = digit.to_string().chars().nth(digit.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digit.len() - 1);\n   \
    \     digit = digit.to_string().chars().nth(digit.len() - 1);\n        digit =\
    \ digit.to_string().chars().nth(digit.len() - 1);\n        digit = digit.to_string().chars().nth(digit.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digit.len() - 1);\n   \
    \     digit = digit.to_string().chars().nth(digit.len() - 1);\n        digit =\
    \ digit.to_string().chars().nth(digit.len() - 1);\n        digit = digit.to_string().chars().nth(digit.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digit.len() - 1);\n   \
    \     digit = digit.to_string().chars().nth(digit.len() - 1);\n        digit =\
    \ digit.to_string().chars().nth(digit.len() - 1);\n        digit = digit.to_string\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbc9z3grr.rs:54:3\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n8  |     while\
    \ base.len() > 0 {\n   |                          - this delimiter might not be\
    \ properly closed...\n...\n38 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n54 | }\n   |   ^\n\nerror[E0599]: `Option<char>` doesn't implement\
    \ `std::fmt::Display`\n   --> /tmp/tmpbc9z3grr.rs:10:23\n    |\n10  |        \
    \   digit = digit.to_string().chars().nth(digit.len() - 1);\n    |           \
    \              ^^^^^^^^^ `Option<char>` cannot be formatted with the default formatter\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<char>: std::fmt::Display`\n            which is required by `Option<char>:\
    \ ToString`\n\nerror[E0599]: no method named `len` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpbc9z3grr.rs:10:53\n   |\n10 |         digit\
    \ = digit.to_string().chars().nth(digit.len() - 1);\n   |                    \
    \                                 ^^^ method not found in `Option<char>`\n\nerror[E0599]:\
    \ `Option<char>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmpbc9z3grr.rs:11:23\n\
    \    |\n11  |           digit = digit.to_string().chars().nth(digit.len() - 1);\n\
    \    |                         ^^^^^^^^^ `Option<char>` cannot be formatted with\
    \ the default formatter\n    |\n    = note: the following trait bounds were not\
    \ satisfied:\n            `Option<char>: std::fmt::Display`\n            which\
    \ is required by `Option<char>: ToString`\n\nerror[E0599]: no method named `len`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpbc9z3grr.rs:11:53\n\
    \   |\n11 |         digit = digit.to_string().chars().nth(digit.len() - 1);\n\
    \   |                                                     ^^^ method not found\
    \ in `Option<char>`\n\nerror[E0599]: `Option<char>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmpbc9z3grr.rs:12:23\n    |\n12  |           digit = digit.to_string().chars().nt"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0; 10];\n    let mut carry = 0;\n    while x >= base\
    \ {\n        digits[10 - base] += 1;\n        x -= base;\n    }\n    digits[10\
    \ - base] += 1;\n    for d in digits {\n        s += if carry > 0 {\n        \
    \    '0'\n        } else {\n            '1'\n        };\n        carry = d / 10;\n\
    \        d %= 10;\n    }\n    s += if carry > 0 {\n        '0'\n    } else {\n\
    \        '1'\n    };\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n -->\
    \ /tmp/tmpyo117upg.rs:9:9\n  |\n9 |         digits[10 - base] += 1;\n  |     \
    \    ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \  |\n  = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpyo117upg.rs:12:5\n\
    \   |\n12 |     digits[10 - base] += 1;\n   |     ^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyo117upg.rs:15:13\n   |\n15 |             '0'\n   |             ^^^\
    \ expected `&str`, found `char`\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n15 |             \"0\"\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyo117upg.rs:17:13\n   |\n17 |             '1'\n   |   \
    \          ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n17 |             \"1\"\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyo117upg.rs:23:9\n   |\n23 |         '0'\n \
    \  |         ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n23 |         \"0\"\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyo117upg.rs:25:9\n   |\n25 |         '1'\n \
    \  |         ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n25 |         \"1\"\n   |\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", s, digits[digit]);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpzse3v3jr.rs:11:32\n\
    \   |\n11 |         s = format!(\"{}{}\", s, digits[digit]);\n   |           \
    \                     ^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n  \
    \ |\n   = help: the trait `Index<isize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0u8; base];\n    let mut x = x;\n    while x >= base\
    \ {\n        digits[x - base] = 1;\n        x /= base;\n    }\n    while x >=\
    \ 10 {\n        digits[x - 10] = 1;\n        x /= 10;\n    }\n    digits[x - 1]\
    \ = 0;\n    for i in 0..digits.len() {\n        s += &format!(\"{}\", digits[i]);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9atrn01u.rs:6:32\n  |\n6 |\
    \     let mut digits = vec![0u8; base];\n  |                                ^^^^\
    \ expected `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n  |\n6 |     let mut digits\
    \ = vec![0u8; base.try_into().unwrap()];\n  |                                \
    \    ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot be indexed by\
    \ `isize`\n --> /tmp/tmp9atrn01u.rs:9:9\n  |\n9 |         digits[x - base] = 1;\n\
    \  |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \  |\n  = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\n\
    error[E0277]: the type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmp9atrn01u.rs:13:9\n\
    \   |\n13 |         digits[x - 10] = 1;\n   |         ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp9atrn01u.rs:16:5\n   |\n16 |     digits[x - 1] = 0;\n\
    \   |     ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_base = digits.chars().collect::<Vec<_>>();\n    let mut base_base\
    \ = base.chars().collect::<Vec<_>>();\n    let mut digits_base_base = digits_base.iter().zip(base_base.iter()).map(|(a,\
    \ b)| {\n        a.to_digits() + b.to_digits()\n    }).collect::<Vec<_>>();\n\
    \    let mut digits_base_base_iter = digits_base_base.iter();\n    let mut digits_base_base_iter\
    \ = digits_base_base_iter.map(|&(a, b)| {\n        a.to_digits() + b.to_digits()\n\
    \    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(a,\
    \ b)| {\n        a.to_digits() + b.to_digits()\n    });\n    let mut digits_base_base_iter\
    \ = digits_base_base_iter.map(|&(a, b)| {\n        a.to_digits() + b.to_digits()\n\
    \    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(a,\
    \ b)| {\n        a.to_digits() + b.to_digits()\n    });\n    let mut digits_base_base_iter\
    \ = digits_base_base_iter.map(|&(a, b)| {\n        a.to_digits() + b.to_digits()\n\
    \    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(a,\
    \ b)| {\n        a.to_digits() + b.to_digits()\n    });\n    let mut digits_base_base_iter\
    \ = digits_base_base_iter.map(|&(a, b)| {\n        a.to_digits() + b.to_digits()\n\
    \    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(a,\
    \ b)| {\n        a.to_digits() + b.to_digits()\n    });\n    let mut digits_base_base_iter\
    \ = digits_base_base_iter.map(|&(a, b)| {\n        a.to_digits() + b.to_digits()\n\
    \    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(a,\
    \ b)| {\n        a.to_digits() + b.to_digits()\n    });\n    let mut digits_base_base_iter\
    \ = digits_base_base_iter.map(|&(a, b)| {\n        a.to_digits() + b.to_digits()\n\
    \    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(a,\
    \ b)| {\n        a.to_digits() + b.to_digits()\n\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpat9d8f24.rs:66:3\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n47 |     let\
    \ mut digits_base_base_iter = digits_base_base_iter.map(|&(a, b)| {\n   |    \
    \                                                          - unclosed delimiter\n\
    ...\n66 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator,\
    \ found keyword `fn`\n  --> /tmp/tmpat9d8f24.rs:52:1\n   |\n50 | }\n   |  - expected\
    \ one of `)`, `,`, `.`, `?`, or an operator\n51 | \n52 | fn main() {\n   | ^^\
    \ unexpected token\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0u8; 10];\n    let mut carry = 0;\n    while x >= base\
    \ {\n        digits[10 - base] += 1;\n        x -= base;\n    }\n    while x >=\
    \ 10 {\n        digits[10] += 1;\n        x -= 10;\n    }\n    while carry !=\
    \ 0 {\n        digits[10] += 1;\n        carry += 1;\n    }\n    for &d in &digits[0..10]\
    \ {\n        s += char::from_u32(d as u32).unwrap();\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[u8]` cannot be indexed by `isize`\n --> /tmp/tmpu7c4pl9s.rs:9:9\n\
    \  |\n9 |         digits[10 - base] += 1;\n  |         ^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `isize`\n  = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu7c4pl9s.rs:21:14\n\
    \   |\n21 |         s += char::from_u32(d as u32).unwrap();\n   |            \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut power = 1;\n    while x >= base\
    \ {\n        digits.push(format!(\"{}\", x % base));\n        x /= base;\n   \
    \     power += 1;\n    }\n    if x != 0 {\n        digits.push(format!(\"{}\"\
    , x));\n    }\n    for i in 0..power {\n        s.push('0');\n    }\n    for i\
    \ in 0..digits.len() {\n        s.push(digits[i]);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq980_49r.rs:9:21\n  |\n9 |\
    \         digits.push(format!(\"{}\", x % base));\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n  |\n  = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq980_49r.rs:14:21\n \
    \  |\n14 |         digits.push(format!(\"{}\", x));\n   |                    \
    \ ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n   = note: this\
    \ error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq980_49r.rs:20:16\n   |\n20 |         s.push(digits[i]);\n   |\
    \                ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.length() {\n        if base < 10 {\n\
    \            s.push_str(&digits[i..i + 1]);\n            i += 1;\n        } else\
    \ {\n            let mut new_base = base.to_string();\n            new_base.push_str(&digits[i..i\
    \ + 1]);\n            s.push_str(&new_base);\n            i += 1;\n        }\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpyt53b1a7.rs:9:22\n  |\n9 |     while i < digits.length()\
    \ {\n  |                      ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyt53b1a7.rs:10:19\n\
    \   |\n10 |         if base < 10 {\n   |                   ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                   |\n   |        \
    \           expected struct `String`, found integer\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut digits_len = String::new();\n\
    \    let mut digits_len2 = String::new();\n    let mut digits_len3 = String::new();\n\
    \    let mut digits_len4 = String::new();\n    let mut digits_len5 = String::new();\n\
    \    let mut digits_len6 = String::new();\n    let mut digits_len7 = String::new();\n\
    \    let mut digits_len8 = String::new();\n    let mut digits_len9 = String::new();\n\
    \    let mut digits_len10 = String::new();\n    let mut digits_len11 = String::new();\n\
    \    let mut digits_len12 = String::new();\n    let mut digits_len13 = String::new();\n\
    \    let mut digits_len14 = String::new();\n    let mut digits_len15 = String::new();\n\
    \    let mut digits_len16 = String::new();\n    let mut digits_len17 = String::new();\n\
    \    let mut digits_len18 = String::new();\n    let mut digits_len19 = String::new();\n\
    \    let mut digits_len20 = String::new();\n    let mut digits_len21 = String::new();\n\
    \    let mut digits_len22 = String::new();\n    let mut digits_len23 = String::new();\n\
    \    let mut digits_len24 = String::new();\n    let mut digits_len25 = String::new();\n\
    \    let mut digits_len26 = String::new();\n    let mut digits_len27 = String::new();\n\
    \    let mut digits_len28 = String::new();\n    let mut digits_len29 = String::new();\n\
    \    let mut digits_len30 = String::new();\n    let mut digits_len31 = String::new();\n\
    \    let mut digits_len32 = String::new();\n    let mut digits_len33 = String::new();\n\
    \    let mut digits_len34 = String::new();\n    let mut digits_len35 = String::new();\n\
    \    let mut digits_len36 = String::new();\n    let mut digits_len37 = String::new();\n\
    \    let mut digits_len38 = String::new();\n    let mut digits_len39 = String::new();\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4fzvn97z.rs:4:42\n  |\n4 |\
    \ fn change_base(x: isize, base: isize) -> String {\n  |    -----------      \
    \                     ^^^^^^ expected struct `String`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder += x % base;\n        x /= base;\n    }\n    digits.push(&remainder);\n\
    \    while x > 0 {\n        remainder += x % base;\n        x /= base;\n     \
    \   digits.push(&remainder);\n    }\n    s += digits.reverse();\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnz6fykrp.rs:12:17\n   |\n\
    12 |     digits.push(&remainder);\n   |                 ^^^^^^^^^^ expected `char`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnz6fykrp.rs:16:21\n\
    \   |\n16 |         digits.push(&remainder);\n   |                     ^^^^^^^^^^\
    \ expected `char`, found `&isize`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpnz6fykrp.rs:18:17\n\
    \   |\n18 |     s += digits.reverse();\n   |                 ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while digits.len()\
    \ > 0 {\n        remainder = digits.len() % base;\n        s = format!(\"{}{}\"\
    , s, digits[..(remainder as usize)].to_string());\n        digits = &digits[(remainder\
    \ as usize)..];\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpct7yacwv.rs:9:36\n  |\n9 |\
    \         remainder = digits.len() % base;\n  |                              \
    \      ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot mod `usize`\
    \ by `isize`\n --> /tmp/tmpct7yacwv.rs:9:34\n  |\n9 |         remainder = digits.len()\
    \ % base;\n  |                                  ^ no implementation for `usize\
    \ % isize`\n  |\n  = help: the trait `Rem<isize>` is not implemented for `usize`\n\
    \  = help: the following other types implement trait `Rem<Rhs>`:\n           \
    \ <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n            <&'a i128\
    \ as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n\
    \            <&'a i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n        \
    \    <&'a isize as Rem<isize>>\n          and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpct7yacwv.rs:11:18\n   |\n6  |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n11 |\
    \         digits = &digits[(remainder as usize)..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n11 |         digits = (&digits[(remainder as usize)..]).to_string();\n\
    \   |                  +                               +++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpim1y41bh.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.chars().nth(digits.len() - 1);\n        let\
    \ digit = digit.to_string();\n        if digit == \"0\" {\n            power =\
    \ 1;\n        } else {\n            power = power * base;\n        }\n       \
    \ s += digit;\n        digits = digits.chars().skip_while(|c| c != '0').collect();\n\
    \    }\n    power.to_string()\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<char>` doesn't implement `std::fmt::Display`\n  \
    \ --> /tmp/tmpa65sm_sh.rs:10:27\n    |\n10  |           let digit = digit.to_string();\n\
    \    |                             ^^^^^^^^^ `Option<char>` cannot be formatted\
    \ with the default formatter\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Option<char>: std::fmt::Display`\n            which\
    \ is required by `Option<char>: ToString`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpa65sm_sh.rs:17:50\n   |\n17 |         digits = digits.chars().skip_while(|c|\
    \ c != '0').collect();\n   |                                                 \
    \ ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut basedigits = digits.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n    basedigits = basedigits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < basedigits.len() {\n        let mut digit =\
    \ basedigits[i];\n        if digit == '0' {\n            digit = digits[(i + 1)\
    \ % basedigits.len()].to_string();\n        }\n        i += 1;\n        if digit\
    \ == '0' {\n            digit = digits[(i + 1) % basedigits.len()].to_string();\n\
    \        }\n        i += 1;\n        if digit == '0' {\n            digit = digits[(i\
    \ + 1) % basedigits.len()].to_string();\n        }\n        i += 1;\n        if\
    \ digit == '0' {\n            digit = digits[(i + 1) % basedigits.len()].to_string();\n\
    \        }\n        i += 1;\n        if digit == '0' {\n            digit = digits[(i\
    \ + 1) % basedigits.len()].to_string();\n        }\n        i += 1;\n        if\
    \ digit == '0' {\n            digit = digits[(i + 1) % basedigits.len()].to_string();\n\
    \        }\n        i += 1;\n        if digit == '0' {\n            digit = digits[(i\
    \ + 1) % basedigits.len()].to_string();\n        }\n        i += 1;\n        if\
    \ digit == '0' {\n            digit = digits[(i + 1) % basedigits.len()].to_string();\n\
    \        }\n        i += 1;\n        if digit == '0' {\n            digit = digits[(i\
    \ + 1) % basedigits.len()].to_string();\n        }\n        i += 1;\n        if\
    \ digit == '0' {\n            digit = digits[(i + 1) % basedigits.len()].to_string();\n\
    \        }\n        i += 1;\n        if digit == '0' {\n            digit = digits[(i\
    \ + 1) % basedigits.len()].to_string();\n        }\n        i += 1;\n        if\
    \ digit == '0' {\n            digit = digits[(i + 1) % basedigits.len()].to_string();\n\
    \        }\n        i += 1;\n        if digit == '0' {\n            digit = digits[(i\
    \ + 1) % basedigits.len()].to_string();\n        }\n        i += 1;\n        if\
    \ digit == '0' {\n            digit = digits[(i + 1) % basedigits.len()].to_string();\n\
    \        }\n        i += 1;\n        if digit == '0' {\n            digit = digits[(i\
    \ + 1) % basedigits.len()].to_string();\n        }\n        i += 1;\n        if\
    \ digit == '0' {\n            digit = digit\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpeeijg8js.rs:90:3\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n10 |     while\
    \ i < basedigits.len() {\n   |                                - unclosed delimiter\n\
    ...\n72 |         if digit == '0' {\n   |                         - this delimiter\
    \ might not be properly closed...\n73 |             digit = digit\n74 | }\n  \
    \ | - ...as it matches this but it has different indentation\n...\n90 | }\n  \
    \ |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpeeijg8js.rs:13:21\n   |\n13 |             digit = digits[(i + 1) % basedigits.len()].to_string();\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeeijg8js.rs:17:21\n   |\n17 |             digit = digits[(i + 1)\
    \ % basedigits.len()].to_string();\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: "
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut power = 1;\n    let mut digit\
    \ = x;\n    while digit > 0 {\n        digits.push_str(&format!(\"{:0>2}\", digit));\n\
    \        digit /= base;\n        power += 1;\n    }\n    digits.push_str(&format!(\"\
    {:0>2}\", power));\n    digits.push_str(\"1\");\n    s += &digits;\n    s += &\"\
    0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n\
    \    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s\
    \ += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"\
    0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n\
    \    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s\
    \ += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"\
    0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n\
    \    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s\
    \ += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"\
    0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n\
    \    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s\
    \ += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"\
    0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n    s += &\"0\";\n\
    \    s += &\"0\";\n    s += &\"0\";\n    s += &\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpikrvcgep.rs:77:1\n\
    \   |\n77 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        s += &digits[..(remainder as usize)];\n\
    \    }\n    s += &digits[..(remainder as usize)];\n    s\n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 2 is out of bounds of `8`'', library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, base.to_string());\n\
    \    }\n    digits.insert(0, remainder.to_string());\n    s += &digits;\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphl4z7bcg.rs:10:26\n   |\n\
    10 |         digits.insert(0, base.to_string());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphl4z7bcg.rs:12:22\n   |\n12 |     digits.insert(0, remainder.to_string());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpim1y41bh.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut bases = base.to_string();\n\
    \    let mut i = 0;\n    while i < digits.len() {\n        if digits[i] == bases[i]\
    \ {\n            i += 1;\n        } else {\n            s.push_str(&digits[i]);\n\
    \            i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9ybj9dc6.rs:10:12\n\
    \   |\n10 |         if digits[i] == bases[i] {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9ybj9dc6.rs:10:25\n   |\n10 |         if digits[i] == bases[i]\
    \ {\n   |                         ^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9ybj9dc6.rs:13:25\n   |\n13 |             s.push_str(&digits[i]);\n\
    \   |                         ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ In"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let digit = digits[digits.len() - 1];\n        if digit < '0'\
    \ {\n            power = power / base;\n        }\n        if digit >= '0' &&\
    \ digit < '9' {\n            power = power * base + digit - '0';\n        }\n\
    \        digits = &digits[..digits.len() - 1];\n    }\n    if power < 10 {\n \
    \       s = format!(\"{}\", power);\n    } else {\n        s = format!(\"{}\"\
    , power);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp4tbzmmmp.rs:9:21\n\
    \  |\n9 |         let digit = digits[digits.len() - 1];\n  |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n  =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n  = help: the\
    \ following other types implement trait `Index<Idx>`:\n            <String as\
    \ Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n       \
    \     <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4tbzmmmp.rs:16:18\n   |\n6  |     let mut digits\
    \ = x.to_string();\n   |                      ------------- expected due to this\
    \ value\n...\n16 |         digits = &digits[..digits.len() - 1];\n   |       \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n16 |         digits = (&digits[..digits.len()\
    \ - 1]).to_string();\n   |                  +                           +++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > base {\n      \
    \  digits = &digits[..(digits.len() - base)];\n    }\n    s += &digits[..digits.len()\
    \ - base];\n    s += &digits[digits.len() - base..];\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8s7fwrft.rs:7:26\n  |\n7 |\
    \     while digits.len() > base {\n  |                          ^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n7 |     while digits.len() >\
    \ base.try_into().unwrap() {\n  |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp8s7fwrft.rs:8:44\n  |\n8 |    \
    \     digits = &digits[..(digits.len() - base)];\n  |                        \
    \                    ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ subtract `isize` from `usize`\n --> /tmp/tmp8s7fwrft.rs:8:42\n  |\n8 |     \
    \    digits = &digits[..(digits.len() - base)];\n  |                         \
    \                 ^ no implementation for `usize - isize`\n  |\n  = help: the\
    \ trait `Sub<isize>` is not implemented for `usize`\n  = help: the following other\
    \ types implement trait `Sub<Rhs>`:\n            <&'a f32 as Sub<f32>>\n     \
    \       <&'a f64 as Sub<f64>>\n            <&'a i128 as Sub<i128>>\n         \
    \   <&'a i16 as Sub<i16>>\n            <&'a i32 as Sub<i32>>\n            <&'a\
    \ i64 as Sub<i64>>\n            <&'a i8 as Sub<i8>>\n            <&'a isize as\
    \ Sub<isize>>\n          and 48 others\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp8s7fwrft.rs:8:18\n  |\n6 |     let mut digits = x.to_string();\n  |\
    \                      ------------- expected due to this value\n7 |     while\
    \ digits.len() > base {\n8 |         digits = &digits[..(digits.len() - base)];\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n  |\nhelp: try using a conversion method\n  |\n8 |         digits\
    \ = (&digits[..(digits.len() - base)]).to_string();\n  |                  +  \
    \                              +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8s7fwrft.rs:10:35\n   |\n10 |     s += &digits[..digits.len() -\
    \ base];\n   |                                   ^^^^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmp8s7fwrft.rs:10:"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpim1y41bh.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        s.push((digits[..1] as char).to_string()\
    \ + &\"0\".to_string());\n    }\n    s.push((digits[..1] as char).to_string()\
    \ + &\"0\".to_string());\n    &s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpax2zjqht.rs:10:16\n   |\n\
    10 |         s.push((digits[..1] as char).to_string() + &\"0\".to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpax2zjqht.rs:12:12\n\
    \   |\n12 |     s.push((digits[..1] as char).to_string() + &\"0\".to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpax2zjqht.rs:13:5\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n13 |     &s\n   |     ^^ expected struct `String`, found `&String`\n   |\n\
    help: consider removing the borrow\n   |\n13 -     &s\n13 +     s\n   | \n\nerror[E0605]:\
    \ non-primitive cast: `str` as `char`\n  --> /tmp/tmpax2zjqht.rs:10:16\n   |\n\
    10 |         s.push((digits[..1] as char).to_string() + &\"0\".to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used\
    \ to convert between primitive types or to coerce to a specific trait object\n\
    \nerror[E0605]: non-primitive cast: `str` as `char`\n  --> /tmp/tmpax2zjqht.rs:12:12\n\
    \   |\n12 |     s.push((digits[..1] as char).to_string() + &\"0\".to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to\
    \ convert between primitive types or to coerce to a specific trait object\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0605.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.len() {\n        if digits[i] > base {\n            digits[i]\
    \ -= base;\n        } else {\n            digits[i] += base;\n        }\n    \
    \    i += 1;\n    }\n    for i in 0..digits.len() {\n        s += digits[i].to_string();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_wj0v38q.rs:10:24\n   |\n\
    10 |         if digits[i] > base {\n   |                        ^^^^ expected\
    \ `char`, found struct `Vec`\n   |\n   = note: expected type `char`\n        \
    \    found struct `Vec<char>`\n\nerror[E0368]: binary assignment operation `-=`\
    \ cannot be applied to type `char`\n  --> /tmp/tmp_wj0v38q.rs:11:13\n   |\n11\
    \ |             digits[i] -= base;\n   |             ---------^^^^^^^^\n   | \
    \            |\n   |             cannot use `-=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmp_wj0v38q.rs:13:13\n\
    \   |\n13 |             digits[i] += base;\n   |             ---------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_wj0v38q.rs:18:14\n   |\n18 |         s += digits[i].to_string();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^\n   |              |\n   |          \
    \    expected `&str`, found struct `String`\n   |              help: consider\
    \ borrowing here: `&digits[i].to_string()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_base = digits.chars().collect::<Vec<_>>();\n    let mut base_base\
    \ = base.chars().collect::<Vec<_>>();\n    let mut digits_base_base = digits_base.chars().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    while i < digits_base.len() {\n        let mut digit\
    \ = digits_base[i];\n        let mut base = base_base[i];\n        if base < 10\
    \ {\n            digit = digit.to_string().to_digit(base).unwrap();\n        }\n\
    \        i += 1;\n        if digit < 10 {\n            s.push_str(&digit.to_string());\n\
    \        } else {\n            s.push_str(&digit.to_string().to_digit(10).unwrap());\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp289hjny5.rs:10:44\n   |\n10 |     let mut digits_base_base\
    \ = digits_base.chars().collect::<Vec<_>>();\n   |                           \
    \                 ^^^^^ method not found in `Vec<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp289hjny5.rs:15:19\n   |\n15 |         if base < 10 {\n\
    \   |                   ^^ expected `char`, found `u8`\n\nerror[E0599]: no method\
    \ named `to_digit` found for struct `String` in the current scope\n  --> /tmp/tmp289hjny5.rs:16:39\n\
    \   |\n16 |             digit = digit.to_string().to_digit(base).unwrap();\n \
    \  |                                       ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp289hjny5.rs:19:20\n   |\n19 |\
    \         if digit < 10 {\n   |                    ^^ expected `char`, found `u8`\n\
    \nerror[E0599]: no method named `to_digit` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp289hjny5.rs:22:43\n   |\n22 |             s.push_str(&digit.to_string().to_digit(10).unwrap());\n\
    \   |                                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut basedigits = digits.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n    basedigits.reverse();\n    let mut i =\
    \ 0;\n    while i < basedigits.len() {\n        let mut j = i;\n        while\
    \ j < basedigits.len() && basedigits[j] == basedigits[i] {\n            j += 1\n\
    \        }\n        if j == basedigits.len() {\n            break;\n        }\n\
    \        let mut digit = basedigits[i];\n        basedigits[i] = basedigits[j];\n\
    \        basedigits[j] = digit;\n        i += 1;\n    }\n    basedigits.reverse();\n\
    \    for i in basedigits.iter() {\n        if i > 0 {\n            s.push_str(&format!(\"\
    {}\", i));\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpokvxnkk3.rs:25:16\n   |\n\
    25 |         if i > 0 {\n   |                ^ expected `&char`, found integer\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihc6psaf.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpihc6psaf.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpihc6psaf.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut digits_base = digits.clone();\n\
    \    let mut digits_base2 = digits.clone();\n    let mut digits_base3 = digits.clone();\n\
    \    let mut digits_base4 = digits.clone();\n    let mut digits_base5 = digits.clone();\n\
    \    let mut digits_base6 = digits.clone();\n    let mut digits_base7 = digits.clone();\n\
    \    let mut digits_base8 = digits.clone();\n    let mut digits_base9 = digits.clone();\n\
    \    let mut digits_base10 = digits.clone();\n    let mut digits_base11 = digits.clone();\n\
    \    let mut digits_base12 = digits.clone();\n    let mut digits_base13 = digits.clone();\n\
    \    let mut digits_base14 = digits.clone();\n    let mut digits_base15 = digits.clone();\n\
    \    let mut digits_base16 = digits.clone();\n    let mut digits_base17 = digits.clone();\n\
    \    let mut digits_base18 = digits.clone();\n    let mut digits_base19 = digits.clone();\n\
    \    let mut digits_base20 = digits.clone();\n    let mut digits_base21 = digits.clone();\n\
    \    let mut digits_base22 = digits.clone();\n    let mut digits_base23 = digits.clone();\n\
    \    let mut digits_base24 = digits.clone();\n    let mut digits_base25 = digits.clone();\n\
    \    let mut digits_base26 = digits.clone();\n    let mut digits_base27 = digits.clone();\n\
    \    let mut digits_base28 = digits.clone();\n    let mut digits_base29 = digits.clone();\n\
    \    let mut digits_base30 = digits.clone();\n    let mut digits_base31 = digits.clone();\n\
    \    let mut digits_base32 = digits.clone();\n    let mut digits_base33 = digits.clone();\n\
    \    let mut digits_base34 = digits.clone();\n    let mut digits_base35 = digits.clone();\n\
    \    let mut digits_base36 = digits.clone();\n    let mut digits_base37 = digits.clone();\n\
    \    let mut digits_base38 = digits.clone();\n    let mut digits_base39 = digits.clone();\n\
    \    let mut digits_base40 = digits.clone();\n    let mut digits_base41 = digits.clone();\n\
    \    let mut digits_base42 = digits.clone();\n    let mut digits_base43 = digits.clone();\n\
    \    let mut digits_base44 = digits.clone();\n    let mut digits_base45 = digits.clone();\n\
    \    let mut digits_base46 = digits.clone();\n    let \n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpotm3ins9.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.remove(0);\n        power = power.pow(base);\n\
    \        if digit < base {\n            s += digit.to_string();\n        } else\
    \ {\n            s += digit.to_string() + &format!(\"{}\", power);\n        }\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmptqoaxlpt.rs:10:23\n   |\n10 |         power = power.pow(base);\n\
    \   |                       ^^^\n   |\nhelp: you must specify a type for this\
    \ binding, like `i32`\n   |\n7  |     let mut power: i32 = 1;\n   |         ~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptqoaxlpt.rs:11:20\n   |\n11 |\
    \         if digit < base {\n   |                    ^^^^ expected `char`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqoaxlpt.rs:12:18\n\
    \   |\n12 |             s += digit.to_string();\n   |                  ^^^^^^^^^^^^^^^^^\n\
    \   |                  |\n   |                  expected `&str`, found struct\
    \ `String`\n   |                  help: consider borrowing here: `&digit.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptqoaxlpt.rs:14:18\n   |\n14 |\
    \             s += digit.to_string() + &format!(\"{}\", power);\n   |        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                  |\n\
    \   |                  expected `&str`, found struct `String`\n   |          \
    \        help: consider borrowing here: `&(digit.to_string() + &format!(\"{}\"\
    , power))`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0689.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    while digits.length()\
    \ > 0 {\n        let digit = digits.pop().unwrap();\n        if digit != \"0\"\
    .to_string() {\n            s.push(digit);\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnhi5ogmv.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpnhi5ogmv.rs:13:18\n\
    \   |\n13 |     while digits.length() > 0 {\n   |                  ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnhi5ogmv.rs:15:21\n   |\n15 |         if digit\
    \ != \"0\".to_string() {\n   |                     ^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_len = digits.length();\n    let mut base_len = base.length();\n\
    \    while digits_len > 0 && base_len > 0 {\n        let mut digit = digits[digits_len\
    \ - 1];\n        let mut base = base[base_len - 1];\n        if digit == base\
    \ {\n            digits.pop();\n            base_len -= 1;\n        } else {\n\
    \            s += digit.to_string();\n            digits_len -= 1;\n         \
    \   base_len -= 1;\n        }\n    }\n    if base_len > 0 {\n        s += base.to_string();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp6l6kg4s3.rs:8:33\n  |\n8 |     let mut digits_len\
    \ = digits.length();\n  |                                 ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n --> /tmp/tmp6l6kg4s3.rs:9:29\n\
    \  |\n9 |     let mut base_len = base.length();\n  |                         \
    \    ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6l6kg4s3.rs:23:14\n   |\n23 |\
    \         s += base.to_string();\n   |              ^^^^^^^^^^^^^^^^\n   |   \
    \           |\n   |              expected `&str`, found struct `String`\n   |\
    \              help: consider borrowing here: `&base.to_string()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        s.push((digits[remainder as usize]\
    \ as char).to_string());\n    }\n    s.push((digits[remainder as usize] as char).to_string());\n\
    \    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptyy82mqe.rs:10:17\n\
    \   |\n10 |         s.push((digits[remainder as usize] as char).to_string());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptyy82mqe.rs:10:16\n\
    \   |\n10 |         s.push((digits[remainder as usize] as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmptyy82mqe.rs:12:13\n   |\n12 |     s.push((digits[remainder\
    \ as usize] as char).to_string());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptyy82mqe.rs:12:12\n\
    \   |\n12 |     s.push((digits[remainder as usize] as char).to_string());\n  \
    \ |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more inf"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    let mut i =\
    \ 0;\n    while i < digits.len() {\n        let mut digit = digits[i] - '0';\n\
    \        if digit >= base {\n            digit -= base;\n        }\n        s\
    \ += digit.to_string();\n        power = power * base;\n        i += 1;\n    }\n\
    \    format!(\"{}\", power)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz5n78y6c.rs:10:25\n\
    \   |\n10 |         let mut digit = digits[i] - '0';\n   |                   \
    \      ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        let digit = digits.chars().nth(i).unwrap();\n\
    \        if base == 10 {\n            s.push_str(digit);\n            i += 1;\n\
    \        } else {\n            let mut digit = digit.to_string();\n          \
    \  let mut digit = digit.chars().nth(digit.len() - 1).unwrap();\n            digit\
    \ = digit.to_string();\n            s.push_str(digit);\n            i += 1;\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmpf39yxqas.rs:11:17\n\
    \   |\n11 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf39yxqas.rs:12:24\n\
    \   |\n12 |             s.push_str(digit);\n   |                        ^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf39yxqas.rs:17:21\n\
    \   |\n16 |             let mut digit = digit.chars().nth(digit.len() - 1).unwrap();\n\
    \   |                             -------------------------------------------\
    \ expected due to this value\n17 |             digit = digit.to_string();\n  \
    \ |                     ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf39yxqas.rs:18:24\n   |\n18 |\
    \             s.push_str(digit);\n   |                        ^^^^^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihc6psaf.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpihc6psaf.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpihc6psaf.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    for digit in digits.iter()\
    \ {\n        s.push(*digit);\n    }\n    String::from(s)\n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5u5kr375.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp5u5kr375.rs:13:25\n\
    \   |\n13 |     for digit in digits.iter() {\n   |                         ^^^^\
    \ method not found in `String`\n   |\nhelp: because of the in-memory representation\
    \ of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n13 |     for digit in digits.chars() {\n   |                         ~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    for digit in digits.iter()\
    \ {\n        s.push(*digit);\n    }\n    String::from(s)\n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5u5kr375.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp5u5kr375.rs:13:25\n\
    \   |\n13 |     for digit in digits.iter() {\n   |                         ^^^^\
    \ method not found in `String`\n   |\nhelp: because of the in-memory representation\
    \ of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n13 |     for digit in digits.chars() {\n   |                         ~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    for d in digits.chars() {\n        if d == '0' {\n            continue;\n\
    \        }\n        s += &d;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ziovt5p.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp1ziovt5p.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1ziovt5p.rs:18:14\n   |\n18 |         s += &d;\n   |          \
    \    ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0u8; 10];\n    let mut carry = 0;\n    let mut digit\
    \ = x;\n    while digit > 0 {\n        digits[digit] = digit % base;\n       \
    \ digit /= base;\n    }\n    for digit in digits {\n        if digit > 0 {\n \
    \           s.push_str(&format!(\"{}\", digit));\n        }\n    }\n    if carry\
    \ != 0 {\n        s.push_str(&format!(\"{}\", carry));\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmpeocykp7_.rs:10:9\n\
    \   |\n10 |         digits[digit] = digit % base;\n   |         ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[u8]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ i = 0;\n    while remainder > 0 {\n        remainder, remainder = remainder\
    \ / base, &remainder % base;\n        digits.push(&format!(\"{}\", i));\n    \
    \    i += 1;\n    }\n    digits.push(&format!(\"{}\", i));\n    s += digits.clone();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpi2gce59j.rs:10:18\n   |\n10 |         remainder, remainder\
    \ = remainder / base, &remainder % base;\n   |                  ^ expected one\
    \ of 8 possible tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi2gce59j.rs:14:17\n\
    \   |\n14 |     digits.push(&format!(\"{}\", i));\n   |                 ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi2gce59j.rs:15:10\n\
    \   |\n15 |     s += digits.clone();\n   |          ^^^^^^^^^^^^^^\n   |     \
    \     |\n   |          expected `&str`, found struct `String`\n   |          help:\
    \ consider borrowing here: `&digits`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > 0 {\n        let\
    \ digit = digits.chars().nth(digits.len() - 1);\n        if digit >= '0' && digit\
    \ <= '9' {\n            s.push_str(&digit - '0');\n        } else {\n        \
    \    s.push_str(&digit - 'a' + 10);\n        }\n        digits = digits.chars().nth(digits.len()\
    \ - 1);\n    }\n    if base < 10 {\n        s.push_str(&base + '0');\n    } else\
    \ {\n        s.push_str(&base + 'a');\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1veyjwxe.rs:9:21\n  |\n9 |\
    \         if digit >= '0' && digit <= '9' {\n  |                     ^^^ expected\
    \ enum `Option`, found `char`\n  |\n  = note: expected enum `Option<char>`\n \
    \            found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \  |\n9 |         if digit >= Some('0') && digit <= '9' {\n  |               \
    \      +++++   +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1veyjwxe.rs:9:37\n\
    \  |\n9 |         if digit >= '0' && digit <= '9' {\n  |                     \
    \                ^^^ expected enum `Option`, found `char`\n  |\n  = note: expected\
    \ enum `Option<char>`\n             found type `char`\nhelp: try wrapping the\
    \ expression in `Some`\n  |\n9 |         if digit >= '0' && digit <= Some('9')\
    \ {\n  |                                     +++++   +\n\nerror[E0369]: cannot\
    \ subtract `char` from `&Option<char>`\n  --> /tmp/tmp1veyjwxe.rs:10:31\n   |\n\
    10 |             s.push_str(&digit - '0');\n   |                        ------\
    \ ^ --- char\n   |                        |\n   |                        &Option<char>\n\
    \nerror[E0369]: cannot subtract `char` from `&Option<char>`\n  --> /tmp/tmp1veyjwxe.rs:12:31\n\
    \   |\n12 |             s.push_str(&digit - 'a' + 10);\n   |                 \
    \       ------ ^ --- char\n   |                        |\n   |               \
    \         &Option<char>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1veyjwxe.rs:14:18\n\
    \   |\n6  |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n14 |         digits = digits.chars().nth(digits.len()\
    \ - 1);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<char>`\n\nerror[E0277]: cannot add `char` to\
    \ `&isize`\n  --> /tmp/tmp1veyjwxe.rs:17:26\n   |\n17 |         s.push_str(&base\
    \ + '0');\n   |                          ^ no implementation for `&isize + char`\n\
    \   |\n   = help: the trait `Add<char>` is not implemented for `&isize`\n   =\
    \ help: the following other types im"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.pop().unwrap();\n        remainder *= base;\n\
    \        remainder += digit;\n    }\n    if remainder < 10 {\n        remainder\
    \ *= base;\n        remainder += 1;\n    }\n    format!(\"{}\", remainder)\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `char` to `isize`\n  --> /tmp/tmpcmieo7pb.rs:11:19\n\
    \   |\n11 |         remainder += digit;\n   |                   ^^ no implementation\
    \ for `isize += char`\n   |\n   = help: the trait `AddAssign<char>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > 0 {\n        let\
    \ digit = digits[digits.length() - 1];\n        if digit >= base {\n         \
    \   digits.remove(digits.length() - 1);\n        } else {\n            s += digit;\n\
    \            break;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpfsd27iqe.rs:8:35\n  |\n8 |         let digit = digits[digits.length()\
    \ - 1];\n  |                                   ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpfsd27iqe.rs:10:34\n\
    \   |\n10 |             digits.remove(digits.length() - 1);\n   |            \
    \                      ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror[E0277]: can't compare `&str` with `isize`\n --> /tmp/tmpfsd27iqe.rs:9:18\n\
    \  |\n9 |         if digit >= base {\n  |                  ^^ no implementation\
    \ for `&str < isize` and `&str > isize`\n  |\n  = help: the trait `PartialOrd<isize>`\
    \ is not implemented for `&str`\n  = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n            String\n            str\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut bases = base.to_string();\n\
    \    while digits.len() > 0 {\n        let mut digit = digits.chars().nth(digits.len()\
    \ - 1);\n        if digit == bases.chars().nth(bases.len() - 1) {\n          \
    \  digits.remove(digits.len() - 1);\n            bases.remove(bases.len() - 1);\n\
    \        } else {\n            digits.remove(digits.len() - 1);\n        }\n \
    \       s += digit;\n    }\n    s += bases\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ymypdw3.rs:16:14\n   |\n\
    16 |         s += digit;\n   |              ^^^^^ expected `&str`, found enum\
    \ `Option`\n   |\n   = note: expected reference `&str`\n                   found\
    \ enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ymypdw3.rs:18:10\n\
    \   |\n18 |     s += bases\n   |          ^^^^^\n   |          |\n   |       \
    \   expected `&str`, found struct `String`\n   |          help: consider borrowing\
    \ here: `&bases`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ymypdw3.rs:18:5\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n18 |     s += bases\n   |     ^^^^^^^^^^ expected struct `String`, found\
    \ `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut digits_len = String::new();\n\
    \    let mut digits_len_len = String::new();\n    let mut digits_len_len_len =\
    \ String::new();\n    let mut digits_len_len_len_len = String::new();\n    let\
    \ mut digits_len_len_len_len_len = String::new();\n    let mut digits_len_len_len_len_len_len\
    \ = String::new();\n    let mut digits_len_len_len_len_len_len_len = String::new();\n\
    \    let mut digits_len_len_len_len_len_len_len_len = String::new();\n    let\
    \ mut digits_len_len_len_len_len_len_len_len_len = String::new();\n    let mut\
    \ digits_len_len_len_len_len_len_len_len_len_len = String::new();\n    let mut\
    \ digits_len_len_len_len_len_len_len_len_len_len = String::new();\n    let mut\
    \ digits_len_len_len_len_len_len_len_len_len_len_len = String::new();\n    let\
    \ mut digits_len_len_len_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len_len = String::new();\n\
    \    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len_len_len =\
    \ String::new();\n    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut digits_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mu\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpry_qnv6e.rs:31:11\n   |\n\
    31 |     let mu\n   |           ^ help: add `;` here\n32 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpry_qnv6e.rs:4:42\n  |\n\
    4 | fn change_base(x: isize, base: isize) -> String {\n  |    -----------    \
    \                       ^^^^^^ expected struct `String`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut digits_base = digits.chars().nth(base);\n\
    \    let mut digits_base_len = digits_base.len();\n    let mut digits_base_len\
    \ = digits_base_len.saturating_sub(1);\n    let mut digits_base_len = digits_base_len.saturating_sub(1);\n\
    \    let mut digits_base_len = digits_base_len.saturating_sub(1);\n    let mut\
    \ digits_base_len = digits_base_len.saturating_sub(1);\n    let mut digits_base_len\
    \ = digits_base_len.saturating_sub(1);\n    let mut digits_base_len = digits_base_len.saturating_sub(1);\n\
    \    let mut digits_base_len = digits_base_len.saturating_sub(1);\n    let mut\
    \ digits_base_len = digits_base_len.saturating_sub(1);\n    let mut digits_base_len\
    \ = digits_base_len.saturating_sub(1);\n    let mut digits_base_len = digits_base_len.saturating_sub(1);\n\
    \    let mut digits_base_len = digits_base_len.saturating_sub(1);\n    let mut\
    \ digits_base_len = digits_base_len.saturating_sub(1);\n    let mut digits_base_len\
    \ = digits_base_len.saturating_sub(1);\n    let mut digits_base_len = digits_base_len.saturating_sub(1);\n\
    \    let mut digits_base_len = digits_base_len.saturating_sub(1);\n    let mut\
    \ digits_base_len = digits_base_len.saturating_sub(1);\n    let mut digits_base_len\
    \ = digits_base_len.saturating_sub(1);\n    let mut digits_base_len = digits_base_len.saturating_sub(1);\n\
    \    let mut digits_base_len = digits_base_len.saturating_sub(1);\n    let mut\
    \ digits_base_len = digits_base_len.saturating_sub(1);\n    let mut digits_base_len\
    \ = digits_base_len.saturating_sub(1);\n    let mut digits_base_len = digits_base_len.saturating_sub(1);\n\
    \    let mut digits_base_len = digits_base_len.saturating_sub(1);\n    let mut\
    \ digits_base_len = digits_base_len.saturating_sub(1);\n    let mut digits_base_len\
    \ = digits_base_len.saturating_sub(1);\n    let mut digits_base_len = digits_base_len.saturating_sub(1);\n\
    \    let mut digits_base_len = digits_base_len.saturating_sub(1);\n    let mut\
    \ digits_base_len = digit\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfalce_z9.rs:36:36\n   |\n\
    36 |     let mut digits_base_len = digit\n   |                               \
    \     ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `digit` in this scope\n  --> /tmp/tmpfalce_z9.rs:36:31\n   |\n36\
    \ |     let mut digits_base_len = digit\n   |                               ^^^^^\
    \ help: a local variable with a similar name exists: `digits`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpfalce_z9.rs:7:46\n  |\n7 |     let mut digits_base\
    \ = digits.chars().nth(base);\n  |                                           \
    \   ^^^^ expected `usize`, found `isize`\n  |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n  |\n7 |     let\
    \ mut digits_base = digits.chars().nth(base.try_into().unwrap());\n  |       \
    \                                           ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n --> /tmp/tmpfalce_z9.rs:8:43\n\
    \  |\n8 |     let mut digits_base_len = digits_base.len();\n  |              \
    \                             ^^^ method not found in `Option<char>`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpfalce_z9.rs:4:42\n  |\n4 | fn change_base(x:\
    \ isize, base: isize) -> String {\n  |    -----------                        \
    \   ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ quotient = 0;\n    while remainder > 0 {\n        quotient = remainder / base;\n\
    \        remainder = remainder % base;\n        digits.push(match quotient {\n\
    \            0 => \"0\",\n            1 => \"1\",\n            2 => \"10\",\n\
    \            _ => \"100\",\n        });\n    }\n    s += digits;\n    s += \"\
    0\";\n    s[s.len() - 1]\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpswo6s39r.rs:13:18\n   |\n\
    13 |             0 => \"0\",\n   |                  ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n13 |             0 => '0',\n   |                  ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpswo6s39r.rs:19:10\n   |\n19 |     s += digits;\n\
    \   |          ^^^^^^\n   |          |\n   |          expected `&str`, found struct\
    \ `String`\n   |          help: consider borrowing here: `&digits`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpswo6s39r.rs:21:5\n\
    \   |\n21 |     s[s.len() - 1]\n   |     ^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        s.push((digits[..1] as char).to_string());\n\
    \    }\n    s.push((digits[..1] as char).to_string());\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6y8zdsr5.rs:10:16\n   |\n\
    10 |         s.push((digits[..1] as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6y8zdsr5.rs:12:12\n   |\n12 |     s.push((digits[..1] as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0605]: non-primitive cast: `str` as `char`\n  --> /tmp/tmp6y8zdsr5.rs:10:16\n\
    \   |\n10 |         s.push((digits[..1] as char).to_string());\n   |         \
    \       ^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between\
    \ primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive\
    \ cast: `str` as `char`\n  --> /tmp/tmp6y8zdsr5.rs:12:12\n   |\n12 |     s.push((digits[..1]\
    \ as char).to_string());\n   |            ^^^^^^^^^^^^^^^^^^^^^ an `as` expression\
    \ can only be used to convert between primitive types or to coerce to a specific\
    \ trait object\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0605.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0u8; 10];\n    let mut carry = 0;\n    while x >= base\
    \ {\n        digits[10] = x % base;\n        x /= base;\n        carry += 1;\n\
    \    }\n    digits[10] = x;\n    for i in 0..10 {\n        s += char::from_u32(digits[i]).unwrap();\n\
    \    }\n    if carry > 0 {\n        s += char::from_u32(digits[10]).unwrap();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpavxhecf5.rs:9:22\n  |\n9 |\
    \         digits[10] = x % base;\n  |         ----------   ^^^^^^^^ expected `u8`,\
    \ found `isize`\n  |         |\n  |         expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpavxhecf5.rs:13:18\n   |\n13 |\
    \     digits[10] = x;\n   |     ----------   ^ expected `u8`, found `isize`\n\
    \   |     |\n   |     expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpavxhecf5.rs:15:29\n   |\n15 |         s += char::from_u32(digits[i]).unwrap();\n\
    \   |                             ^^^^^^^^^ expected `u32`, found `u8`\n   |\n\
    help: you can convert a `u8` to a `u32`\n   |\n15 |         s += char::from_u32(digits[i].into()).unwrap();\n\
    \   |                                      +++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpavxhecf5.rs:15:14\n   |\n15 |         s += char::from_u32(digits[i]).unwrap();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpavxhecf5.rs:18:29\n   |\n18 |\
    \         s += char::from_u32(digits[10]).unwrap();\n   |                    \
    \         ^^^^^^^^^^ expected `u32`, found `u8`\n   |\nhelp: you can convert a\
    \ `u8` to a `u32`\n   |\n18 |         s += char::from_u32(digits[10].into()).unwrap();\n\
    \   |                                       +++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpavxhecf5.rs:18:14\n   |\n18 |         s += char::from_u32(digits[10]).unwrap();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `char`\n\nerror: aborting due to 6 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut power = 1;\n    while x >= base\
    \ {\n        digits.push(format!(\"{}\", x % base));\n        x /= base;\n   \
    \     power += 1;\n    }\n    digits.push(format!(\"{}\", x));\n    s += digits.into_owned();\n\
    \    s += \"^\" + format!(\"{}\", power);\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptc_18lv6.rs:9:21\n  |\n9 |\
    \         digits.push(format!(\"{}\", x % base));\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n  |\n  = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptc_18lv6.rs:13:17\n \
    \  |\n13 |     digits.push(format!(\"{}\", x));\n   |                 ^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0599]: no method named `into_owned` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmptc_18lv6.rs:14:17\n   |\n14 |     s += digits.into_owned();\n\
    \   |                 ^^^^^^^^^^ method not found in `String`\n\nerror[E0369]:\
    \ cannot add `String` to `&str`\n  --> /tmp/tmptc_18lv6.rs:15:14\n   |\n15 | \
    \    s += \"^\" + format!(\"{}\", power);\n   |          --- ^ --------------------\
    \ String\n   |          |   |\n   |          |   `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |          &str\n   |\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > 0 {\n        let\
    \ digit = digits.chars().nth(digits.len() - 1);\n        if digit >= '0' && digit\
    \ <= '9' {\n            s += digit;\n        } else {\n            if base ==\
    \ 2 {\n                s += '0';\n            }\n            s += '0';\n     \
    \   }\n        digits = digits.chars().nth(digits.len() - 1);\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcgj1oxvt.rs:9:21\n  |\n9 |\
    \         if digit >= '0' && digit <= '9' {\n  |                     ^^^ expected\
    \ enum `Option`, found `char`\n  |\n  = note: expected enum `Option<char>`\n \
    \            found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \  |\n9 |         if digit >= Some('0') && digit <= '9' {\n  |               \
    \      +++++   +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcgj1oxvt.rs:9:37\n\
    \  |\n9 |         if digit >= '0' && digit <= '9' {\n  |                     \
    \                ^^^ expected enum `Option`, found `char`\n  |\n  = note: expected\
    \ enum `Option<char>`\n             found type `char`\nhelp: try wrapping the\
    \ expression in `Some`\n  |\n9 |         if digit >= '0' && digit <= Some('9')\
    \ {\n  |                                     +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcgj1oxvt.rs:10:18\n   |\n10 |             s += digit;\n\
    \   |                  ^^^^^ expected `&str`, found enum `Option`\n   |\n   =\
    \ note: expected reference `&str`\n                   found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcgj1oxvt.rs:13:22\n   |\n13 |\
    \                 s += '0';\n   |                      ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n13 |                 s += \"0\";\n   |                      ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcgj1oxvt.rs:15:18\n   |\n15 |             s\
    \ += '0';\n   |                  ^^^ expected `&str`, found `char`\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n15 |       \
    \      s += \"0\";\n   |                  ~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcgj1oxvt.rs:17:18\n   |\n6  |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n17 |\
    \         digits = digits.chars().nth(digits.len() - 1);\n   |               \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<cha"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        if digits.len() > base {\n            digits = &digits[..(digits.len()\
    \ - base)];\n            power = power / base;\n        }\n        s += digits[digits.len()\
    \ - 1];\n        digits = &digits[..digits.len() - 1];\n    }\n    format!(\"\
    {}\", power)\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7gwewb1e.rs:9:27\n  |\n9 |\
    \         if digits.len() > base {\n  |                           ^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |         if digits.len() >\
    \ base.try_into().unwrap() {\n  |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7gwewb1e.rs:10:48\n   |\n10 |\
    \             digits = &digits[..(digits.len() - base)];\n   |               \
    \                                 ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmp7gwewb1e.rs:10:46\n   |\n\
    10 |             digits = &digits[..(digits.len() - base)];\n   |            \
    \                                  ^ no implementation for `usize - isize`\n \
    \  |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7gwewb1e.rs:10:22\n   |\n6  |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n10 |\
    \             digits = &digits[..(digits.len() - base)];\n   |               \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n10 |             digits = (&digits[..(digits.len()\
    \ - base)]).to_string();\n   |                      +                        \
    \        +++++++++++++\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmp7gwewb1e.rs:13:14\n   |\n13 |         s += digits[digits.len()\
    \ - 1];\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = h"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let mut digit = digits.pop().unwrap();\n        if digit >= base\
    \ {\n            digit -= base;\n            power = power * base;\n        }\n\
    \        s.push((digit as char).to_string());\n    }\n    format!(\"{}\", power)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbj3f16yl.rs:10:21\n   |\n\
    10 |         if digit >= base {\n   |                     ^^^^ expected `char`,\
    \ found `isize`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpbj3f16yl.rs:11:13\n   |\n11 |             digit\
    \ -= base;\n   |             -----^^^^^^^^\n   |             |\n   |         \
    \    cannot use `-=` on type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbj3f16yl.rs:14:16\n\
    \   |\n14 |         s.push((digit as char).to_string());\n   |               \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        s.push((digits[remainder as usize]\
    \ as char).to_string());\n    }\n    s.push((digits[remainder as usize] as char).to_string());\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1oue6itb.rs:10:17\n\
    \   |\n10 |         s.push((digits[remainder as usize] as char).to_string());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1oue6itb.rs:10:16\n\
    \   |\n10 |         s.push((digits[remainder as usize] as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp1oue6itb.rs:12:13\n   |\n12 |     s.push((digits[remainder\
    \ as usize] as char).to_string());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1oue6itb.rs:12:12\n\
    \   |\n12 |     s.push((digits[remainder as usize] as char).to_string());\n  \
    \ |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more inf"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", s, digits[digit]);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpzse3v3jr.rs:11:32\n\
    \   |\n11 |         s = format!(\"{}{}\", s, digits[digit]);\n   |           \
    \                     ^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n  \
    \ |\n   = help: the trait `Index<isize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base10 = digits.parse::<usize>().unwrap();\n\
    \    let mut remainder = base10;\n    while remainder > base {\n        remainder\
    \ -= base;\n        s.push('0');\n    }\n    s.push(remainder.to_string());\n\
    \    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4iobl4tf.rs:9:23\n  |\n9 |\
    \     while remainder > base {\n  |                       ^^^^ expected `usize`,\
    \ found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     while remainder > base.try_into().unwrap()\
    \ {\n  |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4iobl4tf.rs:10:22\n   |\n10 |         remainder -= base;\n\
    \   |                      ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract-assign `isize` from `usize`\n  --> /tmp/tmp4iobl4tf.rs:10:19\n\
    \   |\n10 |         remainder -= base;\n   |                   ^^ no implementation\
    \ for `usize -= isize`\n   |\n   = help: the trait `SubAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4iobl4tf.rs:13:12\n\
    \   |\n13 |     s.push(remainder.to_string());\n   |            ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x /= base;\n    }\n    digits.push(format!(\"{}\", x));\n\
    \    s += digits.into_owned();\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6xx5ni_.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpl6xx5ni_.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `into_owned` found for struct `String` in the current scope\n  --> /tmp/tmpl6xx5ni_.rs:14:17\n\
    \   |\n14 |     s += digits.into_owned();\n   |                 ^^^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1);\n        if digit == '0' {\n            digit = digits.chars().nth(base.len()\
    \ - 2);\n        }\n        s += digit;\n        base = base.chars().nth(base.len()\
    \ - 1);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpif1g8i8o.rs:10:21\n   |\n\
    10 |         if digit == '0' {\n   |                     ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n10 |       \
    \  if digit == Some('0') {\n   |                     +++++   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpif1g8i8o.rs:13:14\n   |\n13 |         s += digit;\n\
    \   |              ^^^^^ expected `&str`, found enum `Option`\n   |\n   = note:\
    \ expected reference `&str`\n                   found enum `Option<char>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpif1g8i8o.rs:14:16\n   |\n7  |  \
    \   let mut base = base.to_string();\n   |                    ----------------\
    \ expected due to this value\n...\n14 |         base = base.chars().nth(base.len()\
    \ - 1);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<char>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpks0qj8er.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.length() {\n        if base == 10 {\n\
    \            s.push_str(&digits[i]);\n            i += 1;\n        } else {\n\
    \            let mut digit = digits[i];\n            if digit == '0' {\n     \
    \           digit = digits[i - 1];\n            }\n            s.push_str(&digit.to_string());\n\
    \        }\n        if i == digits.length() {\n            break;\n        }\n\
    \        let mut next = digits[i];\n        if next == '0' {\n            base\
    \ = base.to_string();\n            digits.remove_suffix(i);\n            i +=\
    \ 1;\n        } else {\n            base = base.to_string();\n            digits.remove_suffix(i);\n\
    \            i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpdd2sx2jv.rs:9:22\n  |\n9 |     while i < digits.length()\
    \ {\n  |                      ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0277]: can't compare `String` with `{integer}`\n\
    \  --> /tmp/tmpdd2sx2jv.rs:10:17\n   |\n10 |         if base == 10 {\n   |   \
    \              ^^ no implementation for `String == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpdd2sx2jv.rs:11:25\n\
    \   |\n11 |             s.push_str(&digits[i]);\n   |                        \
    \ ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait\
    \ `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpdd2sx2jv.rs:14:29\n   |\n14 |             let mut digit = digits[i];\n\
    \   |                             ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut power = 1;\n    while x != 0\
    \ {\n        digits.push(format!(\"{}\", x % base));\n        x /= base;\n   \
    \     power += 1;\n    }\n    for _ in 0..power {\n        s.push('0');\n    }\n\
    \    s.push((&digits[..]).to_owned());\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk883t276.rs:9:21\n  |\n9 |\
    \         digits.push(format!(\"{}\", x % base));\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n  |\n  = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk883t276.rs:16:12\n \
    \  |\n16 |     s.push((&digits[..]).to_owned());\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, remainder.to_string());\n\
    \    }\n    digits.insert(0, remainder.to_string());\n    s += &digits[..];\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp29ceynqv.rs:10:26\n   |\n\
    10 |         digits.insert(0, remainder.to_string());\n   |                  \
    \        ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp29ceynqv.rs:12:22\n   |\n12 |     digits.insert(0,\
    \ remainder.to_string());\n   |                      ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    let mut\
    \ i = 0;\n    while i < x.len() {\n        let digit = x.chars().nth(i).unwrap();\n\
    \        let mut remainder = remainder % base;\n        remainder = remainder\
    \ / base;\n        if digit == '0' {\n            digits.push('0');\n        }\
    \ else {\n            digits.push(digit.to_string());\n        }\n        remainder\
    \ = remainder % base;\n        i += 1;\n    }\n    if remainder == 0 {\n     \
    \   digits.push('0');\n    }\n    while digits[digits.len() - 1] == '0' {\n  \
    \      digits.pop();\n    }\n    for i in 0..digits.len() {\n        if digits[i]\
    \ == '0' {\n            digits.pop();\n        }\n    }\n    for i in 0..digits.len()\
    \ {\n        if digits[i] == '0' {\n            digits.pop();\n        }\n   \
    \ }\n    for i in 0..digits.len() {\n        if digits[i] == '0' {\n         \
    \   digits.pop();\n        }\n    }\n    for i in 0..digits.len() {\n        if\
    \ digits[i] == '0' {\n            digits.pop();\n        }\n    }\n    for i in\
    \ 0..digits.len() {\n        if digits[i] == '0' {\n            digits.pop();\n\
    \        }\n    }\n    for i in 0..digits.len() {\n        if digits[i] == '0'\
    \ {\n            digits.pop();\n        }\n    }\n    for i in 0..digits.len()\
    \ {\n        if digits[i] == '0' {\n            digits.pop();\n        }\n   \
    \ }\n    for i in 0..digits.len() {\n        if digits[i] == '0' {\n         \
    \   digits.pop();\n        }\n    }\n    for i in 0..digits.len() {\n        if\
    \ digits[i] == '0' {\n            digits.pop();\n        }\n    }\n    for i in\
    \ 0..digits.len() {\n        if digits[i] == '0' {\n            digits.pop();\n\
    \        }\n    }\n    for i in 0..digits.len() {\n        if digits[i] == '0'\
    \ {\n            digits.pop();\n        }\n    }\n    for i in 0..digits.len()\
    \ {\n        if digits[i] == '0' {\n            digits.pop();\n        }\n   \
    \ }\n    for i in 0..digits.len() {\n        if digits[i] == '0' {\n         \
    \   digits.pop();\n        }\n    }\n    for i in 0..digits.len() {\n        if\
    \ digits[i] == '0' {\n            digits.pop();\n        }\n    }\n    for i in\
    \ 0..digits.len() {\n        if digits[i] == '0' {\n            digits.pop();\n\
    \        }\n    }\n    for i in 0..digits.len() {\n        if digits[i] == '0'\
    \ {\n            digits.pop();\n        }\n    }\n    for i in 0.\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp5161rlpe.rs:108:1\n    |\n\
    108 | }\n    | ^ expected `{`\n\nerror[E0599]: no method named `len` found for\
    \ type `isize` in the current scope\n --> /tmp/tmp5161rlpe.rs:9:17\n  |\n9 | \
    \    while i < x.len() {\n  |                 ^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `chars` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5161rlpe.rs:10:23\n   |\n10 |         let digit = x.chars().nth(i).unwrap();\n\
    \   |                       ^^^^^ method not found in `isize`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5161rlpe.rs:24:11\n\
    \   |\n24 |     while digits[digits.len() - 1] == '0' {\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5161rlpe.rs:28:12\n   |\n28 |         if digits[i] == '0' {\n \
    \  |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5161rlpe.rs:33:12\n   |\n33 |         if digits[i] == '0' {\n \
    \  |           "
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    while digits.length()\
    \ > 0 {\n        s.push((digits.pop() + digits.pop()).to_string());\n    }\n \
    \   s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpascprs14.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpascprs14.rs:13:18\n\
    \   |\n13 |     while digits.length() > 0 {\n   |                  ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0369]:\
    \ cannot add `Option<char>` to `Option<char>`\n  --> /tmp/tmpascprs14.rs:14:30\n\
    \   |\n14 |         s.push((digits.pop() + digits.pop()).to_string());\n   | \
    \                ------------ ^ ------------ Option<char>\n   |              \
    \   |\n   |                 Option<char>\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    for digit in digits\
    \ {\n        s += digit;\n    }\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqgnrvjwi.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpqgnrvjwi.rs:13:18\n   |\n13 |     for digit in digits {\n   | \
    \                 ^^^^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03zito6r.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp03zito6r.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ i = 0;\n    while remainder > 0 {\n        remainder %= base;\n        digits.push((remainder\
    \ as char).to_string());\n        i += 1;\n    }\n    digits.push(format!(\"0\"\
    , base));\n    s += digits.join(\"\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmpmu_13nue.rs:14:30\n   |\n14 |\
    \     digits.push(format!(\"0\", base));\n   |                         ---  ^^^^\
    \ argument never used\n   |                         |\n   |                  \
    \       formatting specifier missing\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmu_13nue.rs:11:21\n   |\n11 |         digits.push((remainder as char).to_string());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmu_13nue.rs:14:17\n\
    \   |\n14 |     digits.push(format!(\"0\", base));\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0599]: no method named `join` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmu_13nue.rs:15:17\n   |\n15 |     s += digits.join(\"\
    \");\n   |                 ^^^^ method not found in `String`\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpmu_13nue.rs:11:21\n\
    \   |\n11 |         digits.push((remainder as char).to_string());\n   |      \
    \               ^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmpmu_13nue.rs:11:21\n   |\n11 |         digits.push((remainder\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0604.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpks0qj8er.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while !digits.is_empty()\
    \ {\n        let digit = digits.chars().nth(base).unwrap();\n        remainder\
    \ += digit as isize;\n        s = format!(\"{}{}\", s, digit);\n        digits\
    \ = digits.chars().skip_while(|c| c != digit).collect();\n    }\n    if remainder\
    \ != 0 {\n        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpum6pfbao.rs:9:40\n  |\n9 |\
    \         let digit = digits.chars().nth(base).unwrap();\n  |                \
    \                        ^^^^ expected `usize`, found `isize`\n  |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n  |\n9 |         let digit = digits.chars().nth(base.try_into().unwrap()).unwrap();\n\
    \  |                                            ++++++++++++++++++++\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpum6pfbao.rs:12:50\n   |\n12\
    \ |         digits = digits.chars().skip_while(|c| c != digit).collect();\n  \
    \ |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > base {\n      \
    \  digits = &digits[..(digits.len() - base)];\n    }\n    s += &digits[..digits.len()\
    \ - base];\n    s += &digits[digits.len() - base..];\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8s7fwrft.rs:7:26\n  |\n7 |\
    \     while digits.len() > base {\n  |                          ^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n7 |     while digits.len() >\
    \ base.try_into().unwrap() {\n  |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp8s7fwrft.rs:8:44\n  |\n8 |    \
    \     digits = &digits[..(digits.len() - base)];\n  |                        \
    \                    ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ subtract `isize` from `usize`\n --> /tmp/tmp8s7fwrft.rs:8:42\n  |\n8 |     \
    \    digits = &digits[..(digits.len() - base)];\n  |                         \
    \                 ^ no implementation for `usize - isize`\n  |\n  = help: the\
    \ trait `Sub<isize>` is not implemented for `usize`\n  = help: the following other\
    \ types implement trait `Sub<Rhs>`:\n            <&'a f32 as Sub<f32>>\n     \
    \       <&'a f64 as Sub<f64>>\n            <&'a i128 as Sub<i128>>\n         \
    \   <&'a i16 as Sub<i16>>\n            <&'a i32 as Sub<i32>>\n            <&'a\
    \ i64 as Sub<i64>>\n            <&'a i8 as Sub<i8>>\n            <&'a isize as\
    \ Sub<isize>>\n          and 48 others\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp8s7fwrft.rs:8:18\n  |\n6 |     let mut digits = x.to_string();\n  |\
    \                      ------------- expected due to this value\n7 |     while\
    \ digits.len() > base {\n8 |         digits = &digits[..(digits.len() - base)];\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n  |\nhelp: try using a conversion method\n  |\n8 |         digits\
    \ = (&digits[..(digits.len() - base)]).to_string();\n  |                  +  \
    \                              +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8s7fwrft.rs:10:35\n   |\n10 |     s += &digits[..digits.len() -\
    \ base];\n   |                                   ^^^^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmp8s7fwrft.rs:10:"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    for digit in digits.iter()\
    \ {\n        s.push(digit);\n    }\n    String::from(s)\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpev9qbc1u.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpev9qbc1u.rs:13:25\n\
    \   |\n13 |     for digit in digits.iter() {\n   |                         ^^^^\
    \ method not found in `String`\n   |\nhelp: because of the in-memory representation\
    \ of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n13 |     for digit in digits.chars() {\n   |                         ~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x /= base;\n    }\n    digits.push(format!(\"{}\", x));\n\
    \    for digit in digits.chars() {\n        s += digit;\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9yq3j110.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp9yq3j110.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9yq3j110.rs:15:14\n   |\n15 |         s += digit;\n   |       \
    \       ^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ i = 0;\n    while remainder > 0 {\n        remainder %= base;\n        digits.push((remainder\
    \ as char).to_string());\n        i += 1;\n    }\n    for digit in digits {\n\
    \        s += digit;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpha5x7ekh.rs:11:21\n   |\n\
    11 |         digits.push((remainder as char).to_string());\n   |             \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpha5x7ekh.rs:14:18\n\
    \   |\n14 |     for digit in digits {\n   |                  ^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpha5x7ekh.rs:11:21\n\
    \   |\n11 |         digits.push((remainder as char).to_string());\n   |      \
    \               ^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmpha5x7ekh.rs:11:21\n   |\n11 |         digits.push((remainder\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0604.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base10 = base.to_string().chars().collect::<Vec<_>>();\n    let mut digits_base\
    \ = digits.clone();\n    let mut base10_base = base10.clone();\n    let mut base10_digits\
    \ = base10_base.clone();\n    let mut base10_digits_base = base10_digits.clone();\n\
    \    let mut base10_digits_base2 = base10_digits_base.clone();\n    let mut base10_digits_base3\
    \ = base10_digits_base2.clone();\n    let mut base10_digits_base4 = base10_digits_base3.clone();\n\
    \    let mut base10_digits_base5 = base10_digits_base4.clone();\n    let mut base10_digits_base6\
    \ = base10_digits_base5.clone();\n    let mut base10_digits_base7 = base10_digits_base6.clone();\n\
    \    let mut base10_digits_base8 = base10_digits_base7.clone();\n    let mut base10_digits_base9\
    \ = base10_digits_base8.clone();\n    let mut base10_digits_base10 = base10_digits_base9.clone();\n\
    \    let mut base10_digits_base11 = base10_digits_base10.clone();\n    let mut\
    \ base10_digits_base12 = base10_digits_base11.clone();\n    let mut base10_digits_base13\
    \ = base10_digits_base12.clone();\n    let mut base10_digits_base14 = base10_digits_base13.clone();\n\
    \    let mut base10_digits_base15 = base10_digits_base14.clone();\n    let mut\
    \ base10_digits_base16 = base10_digits_base15.clone();\n    let mut base10_digits_base17\
    \ = base10_digits_base16.clone();\n    let mut base10_digits_base18 = base10_digits_base17.clone();\n\
    \    let mut base10_digits_base19 = base10_digits_base18.clone();\n    let mut\
    \ base10_digits_base20 = base10_digits_base19.clone();\n    let mut base10_digits_base21\
    \ = base10_digits_base20.clone();\n    let mut base10_digits_base22 = base10_digits_base21.clone();\n\
    \    let mut base10_digits_base23 = base10_digits_base22.clone();\n    let mut\
    \ base10_digits_base24 = base10_digits_base23.clone();\n    let mut base10_digits_base25\
    \ = base10_digits_base24.clone();\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2ps36wva.rs:37:1\n\
    \   |\n37 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ bases = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    let mut i = 0;\n    while i < digits.size() {\n        let digit = digits[i];\n\
    \        let base = bases[i];\n        if digit == '0' {\n            digits.remove(&i);\n\
    \            bases.remove(&i);\n            i += 1;\n            continue;\n \
    \       }\n        if digit == '1' {\n            digits.remove(&i);\n       \
    \     bases.remove(&i);\n            i += 1;\n            continue;\n        }\n\
    \        let digit = digit as char;\n        let base = base as char;\n      \
    \  let mut new_digit = digit as char;\n        let mut new_base = base as char;\n\
    \        if digit == '9' {\n            new_digit += '0';\n            new_base\
    \ += '0';\n        }\n        if digit == 'A' {\n            new_digit += '0';\n\
    \            new_base += 'A' - 10;\n        }\n        if digit == 'B' {\n   \
    \         new_digit += '0';\n            new_base += 'B' - 10;\n        }\n  \
    \      if digit == 'C' {\n            new_digit += '0';\n            new_base\
    \ += 'C' - 10;\n        }\n        if digit == 'D' {\n            new_digit +=\
    \ '0';\n            new_base += 'D' - 10;\n        }\n        if digit == 'E'\
    \ {\n            new_digit += '0';\n            new_base += 'E' - 10;\n      \
    \  }\n        if digit == 'F' {\n            new_digit += '0';\n            new_base\
    \ += 'F' - 10;\n        }\n        if digit == 'G' {\n            new_digit +=\
    \ '0';\n            new_base += 'G' - 10;\n        }\n        if digit == 'H'\
    \ {\n            new_digit += '0';\n            new_base += 'H' - 10;\n      \
    \  }\n        if digit == 'I' {\n            new_digit += '0';\n            new_base\
    \ += 'I' - 10;\n        }\n        if digit == 'J' {\n            new_digit +=\
    \ '0';\n            new_base += 'J' - 10;\n        }\n        if digit == 'K'\
    \ {\n            new_digit += '0';\n            new_base += 'K' - 10;\n      \
    \  }\n        if digit == 'L' {\n            new_digit += '0';\n            new_base\
    \ += 'L' - 10;\n        }\n        if digit == 'M' {\n            new_digit +=\
    \ '0';\n            new_base += 'M' - 10;\n        }\n        if digit == 'N'\
    \ {\n            new_digit += '0';\n            new_base += 'N' - 10;\n      \
    \  }\n        if digit == 'O' {\n            new_digit += '0';\n            new_base\
    \ += 'O' - 10;\n        }\n\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpkmyhix4r.rs:110:3\n\
    \    |\n4   | fn change_base(x: isize, base: isize) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n10  |  \
    \   while i < digits.size() {\n    |                             - this delimiter\
    \ might not be properly closed...\n...\n94  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n110 | }\n    |   ^\n\nerror[E0599]: no\
    \ method named `size` found for struct `Vec<char>` in the current scope\n  -->\
    \ /tmp/tmpkmyhix4r.rs:10:22\n   |\n10 |     while i < digits.size() {\n   |  \
    \                    ^^^^ help: there is an associated function with a similar\
    \ name: `resize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkmyhix4r.rs:14:27\n\
    \   |\n14 |             digits.remove(&i);\n   |                           ^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n\
    \   |\n14 -             digits.remove(&i);\n14 +             digits.remove(i);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkmyhix4r.rs:15:26\n  \
    \ |\n15 |             bases.remove(&i);\n   |                          ^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n15\
    \ -             bases.remove(&i);\n15 +             bases.remove(i);\n   | \n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkmyhix4r.rs:20:27\n   |\n20 |  \
    \           digits.remove(&i);\n   |                           ^^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n20 -       \
    \      digits.remove(&i);\n20 +             digits.remove(i);\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkmyhix4r.rs:21:26\n   |\n21 |             bases.remove(&i);\n\
    \   |                          ^^ expected `usize`, found `&usize`\n   |\nhelp:\
    \ consider removing the borrow\n   |\n21 -             bases.remove(&i);\n21 +\
    \             bases.remove(i);\n   | \n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `char`\n  --> /tmp/tmpkmyhix4r.rs:30:13\n   |\n\
    30 |             new_digit += '0';\n   |             ---------^^^^"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        s.push((&digits[..]).to_digit(base).unwrap());\n\
    \    }\n    s.push((&digits[..]).to_digit(base).unwrap());\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpy76oe_g2.rs:10:30\n   |\n10 |         s.push((&digits[..]).to_digit(base).unwrap());\n\
    \   |                              ^^^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpy76oe_g2.rs:12:26\n   |\n12 |     s.push((&digits[..]).to_digit(base).unwrap());\n\
    \   |                          ^^^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ digit = 0;\n    while remainder > 0 {\n        digit = remainder % base;\n \
    \       remainder = remainder / base;\n        digits.push(digit.to_string());\n\
    \    }\n    digits.reverse();\n    for i in 0..digits.len() {\n        s += digits[i];\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb3mehc_l.rs:12:21\n   |\n\
    12 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpb3mehc_l.rs:14:12\n\
    \   |\n14 |     digits.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpb3mehc_l.rs:16:14\n   |\n16 |         s\
    \ += digits[i];\n   |              ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", s, digits[digit].to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpjzzavu_d.rs:11:32\n\
    \   |\n11 |         s = format!(\"{}{}\", s, digits[digit].to_string());\n   |\
    \                                ^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n\
    \   |\n   = help: the trait `Index<isize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        s.push((digits[remainder as usize]\
    \ as char).to_string());\n    }\n    s.push((digits[remainder as usize] as char).to_string());\n\
    \    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptyy82mqe.rs:10:17\n\
    \   |\n10 |         s.push((digits[remainder as usize] as char).to_string());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptyy82mqe.rs:10:16\n\
    \   |\n10 |         s.push((digits[remainder as usize] as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmptyy82mqe.rs:12:13\n   |\n12 |     s.push((digits[remainder\
    \ as usize] as char).to_string());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptyy82mqe.rs:12:12\n\
    \   |\n12 |     s.push((digits[remainder as usize] as char).to_string());\n  \
    \ |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more inf"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    let mut i =\
    \ 0;\n    while i < digits.len() {\n        if digits.len() - i < base {\n   \
    \         power = 1;\n        } else {\n            power = power * base;\n  \
    \      }\n        i += base;\n    }\n    while power > 0 {\n        digits = digits.chars().map(|c|\
    \ if c >= '0' && c <= '9' { c - '0' } else { c }).collect::<String>();\n     \
    \   power = power / base;\n    }\n    s = digits.reverse().collect();\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46_saq_k.rs:10:31\n   |\n\
    10 |         if digits.len() - i < base {\n   |                              \
    \ ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n10 |      \
    \   if digits.len() - i < base.try_into().unwrap() {\n   |                   \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp46_saq_k.rs:15:14\n   |\n15 |         i += base;\n   |             \
    \ ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign `isize`\
    \ to `usize`\n  --> /tmp/tmp46_saq_k.rs:15:11\n   |\n15 |         i += base;\n\
    \   |           ^^ no implementation for `usize += isize`\n   |\n   = help: the\
    \ trait `AddAssign<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror[E0369]: cannot subtract\
    \ `char` from `char`\n  --> /tmp/tmp46_saq_k.rs:18:69\n   |\n18 |         digits\
    \ = digits.chars().map(|c| if c >= '0' && c <= '9' { c - '0' } else { c }).collect::<String>();\n\
    \   |                                                                   - ^ ---\
    \ char\n   |                                                                 \
    \  |\n   |                                                                   char\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp46_saq_k.rs:21:16\n   |\n21 |     s = digits.reverse().collect();\n\
    \   |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0369, E0599.\nFor more information about\
    \ an error, try `rustc --explain E027"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpks0qj8er.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1);\n        if digit == '0' {\n            digit = digits.chars().nth(base.len()\
    \ - 2);\n        }\n        s += digit;\n        digits.remove(digit);\n     \
    \   base /= 10;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm19loap6.rs:10:21\n   |\n\
    10 |         if digit == '0' {\n   |                     ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n10 |       \
    \  if digit == Some('0') {\n   |                     +++++   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm19loap6.rs:13:14\n   |\n13 |         s += digit;\n\
    \   |              ^^^^^ expected `&str`, found enum `Option`\n   |\n   = note:\
    \ expected reference `&str`\n                   found enum `Option<char>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpm19loap6.rs:14:23\n   |\n14 |  \
    \       digits.remove(digit);\n   |                       ^^^^^ expected `usize`,\
    \ found enum `Option`\n   |\n   = note: expected type `usize`\n              found\
    \ enum `Option<char>`\n\nerror[E0368]: binary assignment operation `/=` cannot\
    \ be applied to type `String`\n  --> /tmp/tmpm19loap6.rs:15:9\n   |\n15 |    \
    \     base /= 10;\n   |         ----^^^^^^\n   |         |\n   |         cannot\
    \ use `/=` on type `String`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpim1y41bh.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ digits_len = digits.len();\n    let mut base = base.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base_len = base.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        if digits[i] >= base[base_len - 1] {\n            digits_len -= 1;\n\
    \            base_len -= 1;\n        } else {\n            digits_len -= 1;\n\
    \        }\n        i += 1;\n    }\n    while base_len > 0 {\n        digits.push(0);\n\
    \        base_len -= 1;\n    }\n    digits.reverse();\n    for i in 0..digits_len\
    \ {\n        s += &base[base_len - 1].to_string()[digits[i] - base[base_len -\
    \ 1]];\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvic4d4sz.rs:21:21\n   |\n\
    21 |         digits.push(0);\n   |                     ^ expected `char`, found\
    \ `u8`\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpvic4d4sz.rs:26:56\n\
    \   |\n26 |         s += &base[base_len - 1].to_string()[digits[i] - base[base_len\
    \ - 1]];\n   |                                              --------- ^ ------------------\
    \ char\n   |                                              |\n   |            \
    \                                  char\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder += x % base;\n        x /= base;\n    }\n    digits.push(remainder);\n\
    \    while x != 0 {\n        remainder += x % base;\n        x /= base;\n    \
    \    s.push(char::from_u32(x as u32).unwrap().to_string());\n    }\n    digits.reverse();\n\
    \    format!(\"{}{}\", digits, s)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9in9jwqe.rs:12:17\n   |\n\
    12 |     digits.push(remainder);\n   |                 ^^^^^^^^^ expected `char`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9in9jwqe.rs:16:16\n\
    \   |\n16 |         s.push(char::from_u32(x as u32).unwrap().to_string());\n \
    \  |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp9in9jwqe.rs:18:12\n   |\n18 | \
    \    digits.reverse();\n   |            ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > 0 {\n        let\
    \ digit = digits.chars().nth(digits.len() - 1);\n        if digit >= '0' && digit\
    \ <= '9' {\n            s.push_str(digit.to_string());\n        } else {\n   \
    \         s.push_str(\"0\");\n        }\n        digits = digits.chars().nth(digits.len()\
    \ - 1);\n    }\n    s.push_str(&base.to_string());\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptsb5047f.rs:9:21\n  |\n9 |\
    \         if digit >= '0' && digit <= '9' {\n  |                     ^^^ expected\
    \ enum `Option`, found `char`\n  |\n  = note: expected enum `Option<char>`\n \
    \            found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \  |\n9 |         if digit >= Some('0') && digit <= '9' {\n  |               \
    \      +++++   +\n\nerror[E0308]: mismatched types\n --> /tmp/tmptsb5047f.rs:9:37\n\
    \  |\n9 |         if digit >= '0' && digit <= '9' {\n  |                     \
    \                ^^^ expected enum `Option`, found `char`\n  |\n  = note: expected\
    \ enum `Option<char>`\n             found type `char`\nhelp: try wrapping the\
    \ expression in `Some`\n  |\n9 |         if digit >= '0' && digit <= Some('9')\
    \ {\n  |                                     +++++   +\n\nerror[E0599]: `Option<char>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmptsb5047f.rs:10:30\n  \
    \  |\n10  |               s.push_str(digit.to_string());\n    |              \
    \                  ^^^^^^^^^ `Option<char>` cannot be formatted with the default\
    \ formatter\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: std::fmt::Display`\n            which is required\
    \ by `Option<char>: ToString`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptsb5047f.rs:14:18\n\
    \   |\n6  |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n14 |         digits = digits.chars().nth(digits.len()\
    \ - 1);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<char>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.insert(0, digit.to_string());\n    }\n    digits.insert(0,\
    \ remainder.to_string());\n    s += &digits;\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphghj6dbk.rs:11:26\n   |\n\
    11 |         digits.insert(0, digit.to_string());\n   |                      \
    \    ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphghj6dbk.rs:13:22\n   |\n13 |     digits.insert(0,\
    \ remainder.to_string());\n   |                      ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , digit, s);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976102
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", digit, s);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while digits.len()\
    \ > 0 {\n        remainder = digits[digits.len() - 1] % base;\n        digits\
    \ = &digits[..digits.len() - 1];\n        s = format!(\"{}{}\", s, remainder);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp_ap6cmom.rs:9:21\n\
    \  |\n9 |         remainder = digits[digits.len() - 1] % base;\n  |          \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \ |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  = help:\
    \ the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_ap6cmom.rs:10:18\n   |\n6  |     let mut digits\
    \ = x.to_string();\n   |                      ------------- expected due to this\
    \ value\n...\n10 |         digits = &digits[..digits.len() - 1];\n   |       \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n10 |         digits = (&digits[..digits.len()\
    \ - 1]).to_string();\n   |                  +                           +++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    digits.push(remainder.to_string());\n\
    \    digits.reverse();\n    for digit in digits {\n        s += digit;\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzdgb99k4.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpzdgb99k4.rs:13:17\n   |\n13 |     digits.push(remainder.to_string());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpzdgb99k4.rs:14:12\n   |\n14 |     digits.reverse();\n \
    \  |            ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpzdgb99k4.rs:15:18\n\
    \   |\n15 |     for digit in digits {\n   |                  ^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut basedigits = digits.chars().nth(base);\n\
    \    while basedigits.len() > 0 {\n        s += &basedigits[..];\n        basedigits\
    \ = basedigits.chars().nth(base);\n    }\n    s += &digits[..];\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj4w0xqar.rs:7:45\n  |\n7 |\
    \     let mut basedigits = digits.chars().nth(base);\n  |                    \
    \                         ^^^^ expected `usize`, found `isize`\n  |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n  |\n7 |     let mut basedigits = digits.chars().nth(base.try_into().unwrap());\n\
    \  |                                                 ++++++++++++++++++++\n\n\
    error[E0599]: no method named `len` found for enum `Option` in the current scope\n\
    \ --> /tmp/tmpj4w0xqar.rs:8:22\n  |\n8 |     while basedigits.len() > 0 {\n  |\
    \                      ^^^ method not found in `Option<char>`\n\nerror[E0608]:\
    \ cannot index into a value of type `Option<char>`\n --> /tmp/tmpj4w0xqar.rs:9:15\n\
    \  |\n9 |         s += &basedigits[..];\n  |               ^^^^^^^^^^^^^^\n\n\
    error[E0599]: no method named `chars` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpj4w0xqar.rs:10:33\n   |\n10 |         basedigits = basedigits.chars().nth(base);\n\
    \   |                                 ^^^^^ method not found in `Option<char>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x /= base;\n    }\n    s += &format!(\"{}\", remainder);\n    s += &format!(\"\
    {}\", x);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n --> /tmp/tmp85vgnxwl.rs:9:9\n\
    \  |\n4 | fn change_base(x: isize, base: isize) -> String {\n  |             \
    \   - help: consider making this binding mutable: `mut x`\n...\n9 |         x\
    \ /= base;\n  |         ^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base10 = base.to_string();\n\
    \    let mut base10_digits = base10.to_string();\n    let mut base10_digits_len\
    \ = base10_digits.length();\n    let mut base10_digits_len = base10_digits_len.to_string();\n\
    \    let mut base10_digits_len = base10_digits_len.to_string();\n    let mut base10_digits_len\
    \ = base10_digits_len.to_string();\n    let mut base10_digits_len = base10_digits_len.to_string();\n\
    \    let mut base10_digits_len = base10_digits_len.to_string();\n    let mut base10_digits_len\
    \ = base10_digits_len.to_string();\n    let mut base10_digits_len = base10_digits_len.to_string();\n\
    \    let mut base10_digits_len = base10_digits_len.to_string();\n    let mut base10_digits_len\
    \ = base10_digits_len.to_string();\n    let mut base10_digits_len = base10_digits_len.to_string();\n\
    \    let mut base10_digits_len = base10_digits_len.to_string();\n    let mut base10_digits_len\
    \ = base10_digits_len.to_string();\n    let mut base10_digits_len = base10_digits_len.to_string();\n\
    \    let mut base10_digits_len = base10_digits_len.to_string();\n    let mut base10_digits_len\
    \ = base10_digits_len.to_string();\n    let mut base10_digits_len = base10_digits_len.to_string();\n\
    \    let mut base10_digits_len = base10_digits_len.to_string();\n    let mut base10_digits_len\
    \ = base10_digits_len.to_string();\n    let mut base10_digits_len = base10_digits_len.to_string();\n\
    \    let mut base10_digits_len = base10_digits_len.to_string();\n    let mut base10_digits_len\
    \ = base10_digits_len.to_string();\n    let mut base10_digits_len = base10_digits_len.to_string();\n\
    \    let mut base10_digits_len = base10_digits_len.to_string();\n    let mut base10_digits_len\
    \ = base10_digits_len.to_string();\n    let mut base10_digits_len = base10_digits_len.to_string();\n\
    \    let mut base10_digits_len = base10_digits_len.to_string();\n    let mut base10_digits_len\
    \ = base10_digits_len.to_string();\n\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp2t_6jo4s.rs:9:47\n  |\n9 |     let mut base10_digits_len\
    \ = base10_digits.length();\n  |                                             \
    \  ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp2t_6jo4s.rs:4:42\n  |\n4 | fn change_base(x:\
    \ isize, base: isize) -> String {\n  |    -----------                        \
    \   ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut power = 1;\n    let mut i = 0;\n    while i < digits.size() {\n  \
    \      if digits[i] > base {\n            power = 1;\n            i += 1;\n  \
    \      } else {\n            power += 1;\n        }\n    }\n    while power >\
    \ 0 {\n        if power % 2 == 0 {\n            s.push_str(&base);\n        }\
    \ else {\n            s.push_str(&base);\n            s.push_str(&base);\n   \
    \     }\n        power /= 2;\n        base /= base;\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp95z0kfh3.rs:10:22\n   |\n10 |     while i < digits.size()\
    \ {\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp95z0kfh3.rs:11:12\n\
    \   |\n11 |         if digits[i] > base {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `/=` cannot be applied\
    \ to type `String`\n  --> /tmp/tmp95z0kfh3.rs:26:9\n   |\n26 |         base /=\
    \ base;\n   |         ----^^^^^^^^\n   |         |\n   |         cannot use `/=`\
    \ on type `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0368, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut power = 1;\n    while x != 0\
    \ {\n        digits.push_str(&format!(\"{}\", x % base));\n        x /= base;\n\
    \        power += 1;\n    }\n    digits.push_str(&format!(\"{}\", power));\n \
    \   s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpe_ip5_ny.rs:10:9\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n10 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    for digit in digits\
    \ {\n        s += digit;\n    }\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqgnrvjwi.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpqgnrvjwi.rs:13:18\n   |\n13 |     for digit in digits {\n   | \
    \                 ^^^^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut bases = base.to_string();\n\
    \    let mut i = 0;\n    while i < digits.length() {\n        if digits[i] > bases.chars().last().unwrap()\
    \ {\n            s.push_str(&bases.chars().nth(i).unwrap());\n            bases\
    \ = bases.chars().nth(i + 1).unwrap();\n        } else {\n            s.push_str(&digits.chars().nth(i).unwrap());\n\
    \            digits = digits.chars().nth(i + 1).unwrap();\n        }\n       \
    \ i += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpb82cvh7f.rs:9:22\n  |\n9 |     while i < digits.length()\
    \ {\n  |                      ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `{integer}`\n  --> /tmp/tmpb82cvh7f.rs:10:12\n   |\n10 |         if digits[i]\
    \ > bases.chars().last().unwrap() {\n   |            ^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb82cvh7f.rs:11:24\n\
    \   |\n11 |             s.push_str(&bases.chars().nth(i).unwrap());\n   |    \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb82cvh7f.rs:12:21\n   |\n7  |\
    \     let mut bases = base.to_string();\n   |                     ----------------\
    \ expected due to this value\n...\n12 |             bases = bases.chars().nth(i\
    \ + 1).unwrap();\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |\n   |                     expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb82cvh7f.rs:14:24\n   |\n14 |             s.push_str(&digits.chars().nth(i).unwrap());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /t"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    let mut\
    \ digit = x;\n    while digit > 0 {\n        remainder = digit % base;\n     \
    \   digit = digit / base;\n        digits.push(remainder);\n    }\n    for digit\
    \ in digits {\n        s.push((digit as char).to_string());\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8vc8ejoo.rs:12:21\n   |\n\
    12 |         digits.push(remainder);\n   |                     ^^^^^^^^^ expected\
    \ `char`, found `isize`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp8vc8ejoo.rs:14:18\n\
    \   |\n14 |     for digit in digits {\n   |                  ^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8vc8ejoo.rs:15:16\n   |\n15 |         s.push((digit\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.chars().nth(digits.length() - 1);\n      \
    \  if digit == '0' {\n            power = 1;\n        } else {\n            power\
    \ = power * base;\n        }\n        digits = digits.chars().nth(digits.length()\
    \ - 1);\n    }\n    power.to_string().to_string() + digits\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp6mdsl9lf.rs:9:47\n  |\n9 |         let digit = digits.chars().nth(digits.length()\
    \ - 1);\n  |                                               ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6mdsl9lf.rs:10:21\n   |\n10 |         if digit == '0' {\n\
    \   |                     ^^^ expected enum `Option`, found `char`\n   |\n   =\
    \ note: expected enum `Option<char>`\n              found type `char`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n10 |         if digit == Some('0')\
    \ {\n   |                     +++++   +\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp6mdsl9lf.rs:15:44\n\
    \   |\n15 |         digits = digits.chars().nth(digits.length() - 1);\n   |  \
    \                                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6mdsl9lf.rs:15:18\n   |\n6  |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n15 |\
    \         digits = digits.chars().nth(digits.length() - 1);\n   |            \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6mdsl9lf.rs:17:37\n\
    \   |\n17 |     power.to_string().to_string() + digits\n   |                 \
    \                    ^^^^^^\n   |                                     |\n   |\
    \                                     expected `&str`, found struct `String`\n\
    \   |                                     help: consider borrowing here: `&digits`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpgq884fog.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digits.len() - 1);\n  \
    \      digit = digit.to_string().chars().nth(digits.len() - 1);\n        digit\
    \ = digit.to_string().chars().nth(digits.len() - 1);\n        digit = digit.to_string().chars().nth(digits.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digits.len() - 1);\n  \
    \      digit = digit.to_string().chars().nth(digits.len() - 1);\n        digit\
    \ = digit.to_string().chars().nth(digits.len() - 1);\n        digit = digit.to_string().chars().nth(digits.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digits.len() - 1);\n  \
    \      digit = digit.to_string().chars().nth(digits.len() - 1);\n        digit\
    \ = digit.to_string().chars().nth(digits.len() - 1);\n        digit = digit.to_string().chars().nth(digits.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digits.len() - 1);\n  \
    \      digit = digit.to_string().chars().nth(digits.len() - 1);\n        digit\
    \ = digit.to_string().chars().nth(digits.len() - 1);\n        digit = digit.to_string().chars().nth(digits.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digits.len() - 1);\n  \
    \      digit = digit.to_string().chars().nth(digits.len() - 1);\n        digit\
    \ = digit.to_string().chars().nth(digits.len() - 1);\n        digit = digit.to_string().chars().nth(digits.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digits.len() - 1);\n  \
    \      digit = digit.to_string().chars().nth(digits.len() - 1);\n        digit\
    \ = digit.to_string().chars().nth(digits.len() - 1);\n        digit = digit.to_string().chars().nth(digits.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digits.len() - 1);\n  \
    \      digit = digit.to_string().chars().nth(digits.len() - 1);\n        digit\
    \ = digit.to_string().chars().nth(digits.len() - 1);\n        digit = digit.to_string().chars().nth(digits.len()\
    \ - 1);\n        digit = digit.to_string().chars().nth(digits.len() - 1);\n  \
    \      \n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl9l6p58z.rs:56:3\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n8  |     while\
    \ base.len() > 0 {\n   |                          - this delimiter might not be\
    \ properly closed...\n...\n40 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n56 | }\n   |   ^\n\nerror[E0599]: `Option<char>` doesn't implement\
    \ `std::fmt::Display`\n   --> /tmp/tmpl9l6p58z.rs:10:23\n    |\n10  |        \
    \   digit = digit.to_string().chars().nth(digits.len() - 1);\n    |          \
    \               ^^^^^^^^^ `Option<char>` cannot be formatted with the default\
    \ formatter\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: std::fmt::Display`\n            which is required\
    \ by `Option<char>: ToString`\n\nerror[E0599]: `Option<char>` doesn't implement\
    \ `std::fmt::Display`\n   --> /tmp/tmpl9l6p58z.rs:11:23\n    |\n11  |        \
    \   digit = digit.to_string().chars().nth(digits.len() - 1);\n    |          \
    \               ^^^^^^^^^ `Option<char>` cannot be formatted with the default\
    \ formatter\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: std::fmt::Display`\n            which is required\
    \ by `Option<char>: ToString`\n\nerror[E0599]: `Option<char>` doesn't implement\
    \ `std::fmt::Display`\n   --> /tmp/tmpl9l6p58z.rs:12:23\n    |\n12  |        \
    \   digit = digit.to_string().chars().nth(digits.len() - 1);\n    |          \
    \               ^^^^^^^^^ `Option<char>` cannot be formatted with the default\
    \ formatter\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: std::fmt::Display`\n            which is required\
    \ by `Option<char>: ToString`\n\nerror[E0599]: `Option<char>` doesn't implement\
    \ `std::fmt::Display`\n   --> /tmp/tmpl9l6p58z.rs:13:23\n    |\n13  |        \
    \   digit = digit.to_string().chars().nth(digits.len() - 1);\n    |          \
    \               ^^^^^^^^^ `Option<char>` cannot be formatted with the default\
    \ fo"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        s += &digits[..(remainder as usize)];\n\
    \    }\n    s += &digits[..(remainder as usize)];\n    s\n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 2 is out of bounds of `8`'', library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(&format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(&format!(\"{}\"\
    , x));\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf5mm9ula.rs:10:21\n   |\n\
    10 |         digits.push(&format!(\"{}\", remainder));\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf5mm9ula.rs:13:17\n   |\n13 |     digits.push(&format!(\"\
    {}\", x));\n   |                 ^^^^^^^^^^^^^^^^^ expected `char`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while !digits.is_empty()\
    \ {\n        let digit = digits.chars().nth(base).unwrap();\n        remainder\
    \ *= base;\n        remainder += digit;\n        digits = digits.chars().skip_while(|c|\
    \ c != digit).collect();\n    }\n    format!(\"{}\", remainder)\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5pce496x.rs:9:40\n  |\n9 |\
    \         let digit = digits.chars().nth(base).unwrap();\n  |                \
    \                        ^^^^ expected `usize`, found `isize`\n  |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n  |\n9 |         let digit = digits.chars().nth(base.try_into().unwrap()).unwrap();\n\
    \  |                                            ++++++++++++++++++++\n\nerror[E0277]:\
    \ cannot add-assign `char` to `isize`\n  --> /tmp/tmp5pce496x.rs:11:19\n   |\n\
    11 |         remainder += digit;\n   |                   ^^ no implementation\
    \ for `isize += char`\n   |\n   = help: the trait `AddAssign<char>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp5pce496x.rs:12:50\n\
    \   |\n12 |         digits = digits.chars().skip_while(|c| c != digit).collect();\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s = digits.join(\"\");\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5rm3ivbo.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp5rm3ivbo.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `join` found for struct `String` in the current scope\n  --> /tmp/tmp5rm3ivbo.rs:14:16\n\
    \   |\n14 |     s = digits.join(\"\");\n   |                ^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut digits_len = digits.length();\n\
    \    let mut remainder = 0;\n    while digits_len > 0 {\n        let mut digit\
    \ = digits[digits_len - 1];\n        let mut digits_len -= 1;\n        while digits_len\
    \ > 0 && digit >= base {\n            digit /= base;\n            digits_len -=\
    \ 1;\n        }\n        remainder += digit as isize;\n        digits = &digits[digits_len..];\n\
    \    }\n    if remainder > 0 {\n        s += &format!(\"{}\", remainder);\n  \
    \  }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: can't reassign to an uninitialized variable\n  --> /tmp/tmp5vmkus6n.rs:11:28\n\
    \   |\n11 |         let mut digits_len -= 1;\n   |                           \
    \ ^^ help: initialize the variable\n   |\n   = help: if you meant to overwrite,\
    \ remove the `let` binding\n\nerror[E0599]: no method named `length` found for\
    \ struct `String` in the current scope\n --> /tmp/tmp5vmkus6n.rs:7:33\n  |\n7\
    \ |     let mut digits_len = digits.length();\n  |                           \
    \      ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5vmkus6n.rs:17:18\n   |\n6  |\
    \     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n17 |         digits = &digits[digits_len..];\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n17 |         digits = (&digits[digits_len..]).to_string();\n\
    \   |                  +                     +++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpx5mhlbn7.rs:65:3\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n8  |     while\
    \ base.len() > 0 {\n   |                          - this delimiter might not be\
    \ properly closed...\n...\n49 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n65 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpx5mhlbn7.rs:10:17\n   |\n9  |         let mut digit = digits.chars().nth(base.len()\
    \ - 1).unwrap();\n   |                         -------------------------------------------\
    \ expected due to this value\n10 |         digit = digit.to_string();\n   |  \
    \               ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpx5mhlbn7.rs:11:23\n\
    \   |\n11 |         digit = digit.chars().nth(base.len() - 1).unwrap();\n   |\
    \                       ^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx5mhlbn7.rs:12:17\n   |\n9  |         let mut digit = digits.chars().nth(base.len()\
    \ - 1).unwrap();\n   |                         -------------------------------------------\
    \ expected due to this value\n...\n12 |         digit = digit.to_string();\n \
    \  |                 ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmpx5mhlbn7.rs:13:23\n   |\n13 |         digit = digit.chars().nth(base.len()\
    \ - 1).unwrap();\n   |                       ^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx5mhlbn7.rs:14:17\n   |\n9  |\
    \         let mut digit = digits.chars().nth(base.len() - 1).unwrap();\n   | \
    \                        ------------------------------------------- expected\
    \ due to this value\n...\n14 |         digit = digit.to_string();\n   |      \
    \           ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0599]:\
    \ no method named `chars` found for"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut digits_len = digits.length();\n\
    \    let mut power = 1;\n    let mut i = 0;\n    while i < digits_len {\n    \
    \    if digits[i] > base {\n            digits = digits.insert(i, 0);\n      \
    \      digits_len = digits.length();\n        } else {\n            digits = digits.insert(i,\
    \ digits[i] / power);\n            digits_len = digits.length();\n           \
    \ power = power * base;\n        }\n        i += 1;\n    }\n    s = digits.to_string();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpks5kbgmy.rs:7:33\n  |\n7 |     let mut digits_len\
    \ = digits.length();\n  |                                 ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpks5kbgmy.rs:11:12\n\
    \   |\n11 |         if digits[i] > base {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpks5kbgmy.rs:12:39\n\
    \   |\n12 |             digits = digits.insert(i, 0);\n   |                  \
    \                     ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpks5kbgmy.rs:12:22\n   |\n6  |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n12 |\
    \             digits = digits.insert(i, 0);\n   |                      ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmpks5kbgmy.rs:12:29\n   |\n12 |             digits\
    \ = digits.insert(i, 0);\n   |                      ------ ^^^^^^ this call modifies\
    \ `digits` in-place\n   |                      |\n   |                      you\
    \ probably want to use this value after calling the method...\n   = note: ...instead\
    \ of the `()` output of method `insert`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpks5kbgmy.rs:13:33\n\
    \   |\n13 |             digits_len = digits.length();\n   |                  "
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut digits_len = digits.length();\n\
    \    let mut remainder = 0;\n    while digits_len > 0 {\n        let mut digit\
    \ = digits[digits_len - 1];\n        if digit >= base {\n            digit = digit\
    \ - base;\n            digits_len -= 1;\n        } else {\n            digit =\
    \ digit + base;\n            digits_len -= 1;\n        }\n        digits = &digits[digits_len..];\n\
    \        remainder = remainder + digit.to_string();\n    }\n    s = format!(\"\
    {}\", remainder) + s;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp5r8e601y.rs:7:33\n  |\n7 |     let mut digits_len\
    \ = digits.length();\n  |                                 ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp5r8e601y.rs:10:25\n   |\n\
    10 |         let mut digit = digits[digits_len - 1];\n   |                   \
    \      ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5r8e601y.rs:18:18\n   |\n6  |     let mut digits\
    \ = x.to_string();\n   |                      ------------- expected due to this\
    \ value\n...\n18 |         digits = &digits[digits_len..];\n   |             \
    \     ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n18 |         digits = (&digits[digits_len..]).to_string();\n\
    \   |                  +                     +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5r8e601y.rs:21:36\n   |\n21 |     s = format!(\"{}\", remainder)\
    \ + s;\n   |                                    ^\n   |                      \
    \              |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&s`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        if base < 10 {\n   \
    \         s.push_str(&digits[i..i+1]);\n            i += 1;\n        } else {\n\
    \            s.push_str(&digits[i..i+base.len()]);\n            i += base.len();\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn0wyteo5.rs:10:19\n   |\n\
    10 |         if base < 10 {\n   |                   ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                   |\n   |                   expected\
    \ struct `String`, found integer\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    let mut digits = x.to_string();\n    while !digits.is_empty()\
    \ {\n        let digit = digits.chars().nth(base).unwrap();\n        remainder\
    \ += digit as isize;\n        digits = digits.chars().skip_while(|c| c != digit).collect();\n\
    \    }\n    if remainder > 0 {\n        s += &format!(\"{}\", remainder);\n  \
    \  }\n    s += digits\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpuaz3zqid.rs:9:40\n  |\n9 |\
    \         let digit = digits.chars().nth(base).unwrap();\n  |                \
    \                        ^^^^ expected `usize`, found `isize`\n  |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n  |\n9 |         let digit = digits.chars().nth(base.try_into().unwrap()).unwrap();\n\
    \  |                                            ++++++++++++++++++++\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpuaz3zqid.rs:11:50\n   |\n11\
    \ |         digits = digits.chars().skip_while(|c| c != digit).collect();\n  \
    \ |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuaz3zqid.rs:16:10\n   |\n16 |  \
    \   s += digits\n   |          ^^^^^^\n   |          |\n   |          expected\
    \ `&str`, found struct `String`\n   |          help: consider borrowing here:\
    \ `&digits`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuaz3zqid.rs:16:5\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n16 |     s += digits\n   |     ^^^^^^^^^^^ expected struct `String`, found\
    \ `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut power = 1;\n    let mut remainder\
    \ = 0;\n    while x >= base {\n        remainder = x % base;\n        x /= base;\n\
    \        power = power + 1;\n    }\n    while x != 0 {\n        remainder = remainder\
    \ + x % base;\n        x /= base;\n        power = power + 1;\n    }\n    while\
    \ power != 0 {\n        digits = format!(\"{}{}\", digits, power);\n        power\
    \ = power - 1;\n    }\n    s = format!(\"{}{}\", s, digits);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmp35u98nvk.rs:11:9\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n11 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmp35u98nvk.rs:16:9\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n16 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihc6psaf.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpihc6psaf.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpihc6psaf.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        if digits.len() < base {\n            power = power * 10;\n \
    \       }\n        let digit = digits.chars().nth(digits.len() - 1);\n       \
    \ if digit == '0' {\n            power = power * 10;\n        } else {\n     \
    \       power = power * base;\n        }\n        s = format!(\"{}{}\", s, digit);\n\
    \        digits = &digits[digits.len() - 1];\n    }\n    format!(\"{}\", power)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplv6grrax.rs:9:27\n  |\n9 |\
    \         if digits.len() < base {\n  |                           ^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |         if digits.len() <\
    \ base.try_into().unwrap() {\n  |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplv6grrax.rs:13:21\n   |\n13 |\
    \         if digit == '0' {\n   |                     ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n13 |       \
    \  if digit == Some('0') {\n   |                     +++++   +\n\nerror[E0277]:\
    \ `Option<char>` doesn't implement `std::fmt::Display`\n  --> /tmp/tmplv6grrax.rs:18:32\n\
    \   |\n18 |         s = format!(\"{}{}\", s, digit);\n   |                   \
    \             ^^^^^ `Option<char>` cannot be formatted with the default formatter\n\
    \   |\n   = help: the trait `std::fmt::Display` is not implemented for `Option<char>`\n\
    \   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplv6grrax.rs:19:19\n\
    \   |\n19 |         digits = &digits[digits.len() - 1];\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatch"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.len() {\n        if digits[i] >= base[0] {\n            s.push_str(&base[digits[i]\
    \ - base[0]]);\n            i += 1;\n        } else {\n            s.push_str(&digits[i]);\n\
    \            i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpgchkm0tt.rs:11:40\n\
    \   |\n11 |             s.push_str(&base[digits[i] - base[0]]);\n   |        \
    \                      --------- ^ ------- char\n   |                        \
    \      |\n   |                              char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgchkm0tt.rs:14:24\n   |\n14 |             s.push_str(&digits[i]);\n\
    \   |                        ^^^^^^^^^^ expected `str`, found `char`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&char`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        x /= base;\n        s.push((remainder as char).to_string());\n    }\n\
    \    s.push((x as char).to_string());\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvjb86i__.rs:10:16\n   |\n\
    10 |         s.push((remainder as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpvjb86i__.rs:12:12\n   |\n12 |     s.push((x as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpvjb86i__.rs:10:16\n\
    \   |\n10 |         s.push((remainder as char).to_string());\n   |           \
    \     ^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmpvjb86i__.rs:10:16\n   |\n10 |         s.push((remainder\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpvjb86i__.rs:12:12\n\
    \   |\n12 |     s.push((x as char).to_string());\n   |            ^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpvjb86i__.rs:12:12\n   |\n12 |     s.push((x as char).to_string());\n\
    \   |            ^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0604.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push_str(&format!(\"{}\", digit));\n    }\n    digits.push_str(&format!(\"\
    {}\", remainder));\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"220\"`,\n right: `\"22\"`', /tmp/tmp8pbs5qrw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x / base;\n\
    \        x %= base;\n        s += remainder.to_string();\n        remainder =\
    \ 0;\n    }\n    s += x.to_string();\n    s += remainder.to_string();\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa20dszbf.rs:10:14\n   |\n\
    10 |         s += remainder.to_string();\n   |              ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |              |\n   |              expected `&str`, found struct `String`\n\
    \   |              help: consider borrowing here: `&remainder.to_string()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpa20dszbf.rs:13:10\n   |\n13 |  \
    \   s += x.to_string();\n   |          ^^^^^^^^^^^^^\n   |          |\n   |  \
    \        expected `&str`, found struct `String`\n   |          help: consider\
    \ borrowing here: `&x.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa20dszbf.rs:14:10\n\
    \   |\n14 |     s += remainder.to_string();\n   |          ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |          |\n   |          expected `&str`, found struct `String`\n   | \
    \         help: consider borrowing here: `&remainder.to_string()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpim1y41bh.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1).unwrap();\n        if digit < '0' {\n            digit += '0';\n      \
    \  }\n        s += digit;\n        digits = digits.chars().skip_while(|c| c <\
    \ '0').collect();\n        base = base.chars().skip_while(|c| c < '0').collect();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmp48gnull2.rs:11:13\n   |\n11 |             digit += '0';\n\
    \   |             -----^^^^^^^\n   |             |\n   |             cannot use\
    \ `+=` on type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp48gnull2.rs:13:14\n\
    \   |\n13 |         s += digit;\n   |              ^^^^^ expected `&str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp48gnull2.rs:14:52\n\
    \   |\n14 |         digits = digits.chars().skip_while(|c| c < '0').collect();\n\
    \   |                                                    ^^^\n   |           \
    \                                         |\n   |                            \
    \                        expected `&char`, found `char`\n   |                \
    \                                    help: consider borrowing here: `&'0'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp48gnull2.rs:15:48\n   |\n15 |  \
    \       base = base.chars().skip_while(|c| c < '0').collect();\n   |         \
    \                                       ^^^\n   |                            \
    \                    |\n   |                                                expected\
    \ `&char`, found `char`\n   |                                                help:\
    \ consider borrowing here: `&'0'`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut power = 1;\n    let mut digit\
    \ = x;\n    while digit > 0 {\n        digits.push(digit % base);\n        digit\
    \ /= base;\n        power += 1;\n    }\n    digits.reverse();\n    for digit in\
    \ digits {\n        if power > 0 {\n            s.push_str(&format!(\"{}{}\",\
    \ digit, base**power));\n        } else {\n            s.push_str(&digit);\n \
    \       }\n        power -= 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpskazd8tw.rs:10:21\n   |\n\
    10 |         digits.push(digit % base);\n   |                     ^^^^^^^^^^^^\
    \ expected `char`, found `isize`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpskazd8tw.rs:14:12\n\
    \   |\n14 |     digits.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmpskazd8tw.rs:15:18\n   |\n15 |     for digit in digits\
    \ {\n   |                  ^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  -->\
    \ /tmp/tmpskazd8tw.rs:17:53\n   |\n17 |             s.push_str(&format!(\"{}{}\"\
    , digit, base**power));\n   |                                                \
    \     ^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpskazd8tw.rs:15:9\n   |\n15 |     for digit\
    \ in digits {\n   |         ^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpskazd8tw.rs:15:18\n\
    \    |\n15  |     for digit in digits {\n    |                  ^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Option`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpskazd8tw.rs:15:5\n    |\n15  | /     for digit in digits {\n16  | |\
    \         if power > 0 {\n17  | |             s.push_str(&format!(\"{}{}\", digit,\
    \ base**power));\n18  | |         } else {\n...   |\n21  | |        "
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder += x / base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x % base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprub7cusy.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmprub7cusy.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_len = digits.length();\n    let mut base_len = base.length();\n\
    \    let mut i = 0;\n    while i < digits_len {\n        if digits[i] > base {\n\
    \            digits[i] = digits[i] - base;\n            i += 1;\n        } else\
    \ {\n            digits[i] = digits[i] - base + 10;\n            i += 1;\n   \
    \     }\n    }\n    while i < base_len {\n        digits.push('0');\n        i\
    \ += 1;\n    }\n    s += digits.to_string();\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmphnevgfnc.rs:8:33\n  |\n8 |     let mut digits_len\
    \ = digits.length();\n  |                                 ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n --> /tmp/tmphnevgfnc.rs:9:29\n\
    \  |\n9 |     let mut base_len = base.length();\n  |                         \
    \    ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmphnevgfnc.rs:12:12\n\
    \   |\n12 |         if digits[i] > base {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmphnevgfnc.rs:13:13\n   |\n13 |             digits[i] = digits[i]\
    \ - base;\n   |             ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmphnevgfnc.rs:13:25\n   |\n13 |             digits"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.remove(0);\n        power = power * base;\n\
    \        if power > 10 {\n            power = 1;\n            digits.insert(0,\
    \ digit);\n        }\n    }\n    format!(\"{}\", power)\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"3\"`,\n right: `\"22\"`', /tmp/tmpf_6zxrp4.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03zito6r.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp03zito6r.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.chars().nth(digits.length() - 1).unwrap();\n\
    \        if digit == '0' {\n            power = 1;\n        } else {\n       \
    \     power = power as isize;\n        }\n        if power > base {\n        \
    \    power = 1;\n        } else {\n            power = power as isize;\n     \
    \   }\n        s.push((digit as char).to_string());\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpvrvqnrgf.rs:9:47\n  |\n9 |         let digit = digits.chars().nth(digits.length()\
    \ - 1).unwrap();\n  |                                               ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvrvqnrgf.rs:20:16\n   |\n20 |         s.push((digit\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.length() {\n        if base == \"10\"\
    \ {\n            s += &digits[i ..].to_string();\n            break;\n       \
    \ }\n        if base == \"0\" && digits[i] == \"0\" {\n            s += &digits[i\
    \ ..].to_string();\n            break;\n        }\n        if base == \"0\" &&\
    \ digits[i] == \"1\" {\n            s += &digits[i ..].to_string();\n        \
    \    break;\n        }\n        if base == \"1\" && digits[i] == \"0\" {\n   \
    \         s += &digits[i ..].to_string();\n            break;\n        }\n   \
    \     if base == \"1\" && digits[i] == \"1\" {\n            s += &digits[i ..].to_string();\n\
    \            break;\n        }\n        if base == \"2\" && digits[i] == \"0\"\
    \ {\n            s += &digits[i ..].to_string();\n            break;\n       \
    \ }\n        if base == \"2\" && digits[i] == \"1\" {\n            s += &digits[i\
    \ ..].to_string();\n            break;\n        }\n        if base == \"3\" &&\
    \ digits[i] == \"0\" {\n            s += &digits[i ..].to_string();\n        \
    \    break;\n        }\n        if base == \"3\" && digits[i] == \"1\" {\n   \
    \         s += &digits[i ..].to_string();\n            break;\n        }\n   \
    \     if base == \"4\" && digits[i] == \"0\" {\n            s += &digits[i ..].to_string();\n\
    \            break;\n        }\n        if base == \"4\" && digits[i] == \"1\"\
    \ {\n            s += &digits[i ..].to_string();\n            break;\n       \
    \ }\n        if base == \"5\" && digits[i] == \"0\" {\n            s += &digits[i\
    \ ..].to_string();\n            break;\n        }\n        if base == \"5\" &&\
    \ digits[i] == \"1\" {\n            s += &digits[i ..].to_string();\n        \
    \    break;\n        }\n        if base == \"6\" && digits[i] == \"0\" {\n   \
    \         s += &digits[i ..].to_string();\n            break;\n        }\n   \
    \     if base == \"6\" && digits[i] == \"1\" {\n            s += &digits[i ..].to_string();\n\
    \            break;\n        }\n        if base == \"7\" && digits[i] == \"0\"\
    \ {\n            s += &digits[i ..].to_string();\n            break;\n       \
    \ }\n        if base == \"7\" && digits[i] == \"1\" {\n            s += &digits[i\
    \ ..].to_string();\n            break;\n        }\n        if base == \"8\" &&\
    \ digits[i] == \"0\" {\n            s += &digits[i ..].to_string();\n        \
    \    break;\n        }\n        if base == \"8\" && digits[i] == \"1\" {\n\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjic2_y29.rs:100:3\n\
    \    |\n4   | fn change_base(x: isize, base: isize) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n9   |  \
    \   while i < digits.length() {\n    |                               - unclosed\
    \ delimiter\n...\n82  |         if base == \"8\" && digits[i] == \"1\" {\n   \
    \ |                                            - this delimiter might not be properly\
    \ closed...\n83  | \n84  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n100 | }\n    |   ^\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpjic2_y29.rs:9:22\n\
    \  |\n9 |     while i < digits.length() {\n  |                      ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjic2_y29.rs:14:27\n\
    \   |\n14 |         if base == \"0\" && digits[i] == \"0\" {\n   |           \
    \                ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjic2_y29.rs:18:27\n   |\n18 |         if base == \"0\" && digits[i]\
    \ == \"1\" {\n   |                           ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n         "
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihc6psaf.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpihc6psaf.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpihc6psaf.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, '0');\n    }\n\
    \    digits.insert(0, remainder.to_string());\n    s = &digits[..];\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf2dhkmvh.rs:12:22\n   |\n\
    12 |     digits.insert(0, remainder.to_string());\n   |                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpf2dhkmvh.rs:13:9\n   |\n5  |     let mut s = String::new();\n  \
    \ |                 ------------- expected due to this value\n...\n13 |     s\
    \ = &digits[..];\n   |         ^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n13 |     s = (&digits[..]).to_string();\n\
    \   |         +           +++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += &digits[..digits.len() - 1];\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6xoiz1wb.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6xoiz1wb.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x / base;\n\
    \        x -= base;\n    }\n    remainder += x;\n    s += &format!(\"{}\", remainder);\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n --> /tmp/tmpldmz76gz.rs:9:9\n\
    \  |\n4 | fn change_base(x: isize, base: isize) -> String {\n  |             \
    \   - help: consider making this binding mutable: `mut x`\n...\n9 |         x\
    \ -= base;\n  |         ^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base10: Vec<isize> = digits.iter().map(|x| x as isize).collect();\n    base10.push(0);\n\
    \    let mut base10_iter = base10.iter();\n    let mut base10_len = base10_iter.len();\n\
    \    let mut base10_digits = base10_iter.peekable().peek().unwrap();\n    let\
    \ mut base10_digit = base10_digits.peek().unwrap();\n    let mut base10_digit_len\
    \ = base10_digit.len();\n    let mut base10_digit_digit = base10_digit.peek().unwrap();\n\
    \    let mut base10_digit_digit_len = base10_digit_digit.len();\n    let mut base10_digit_digit_digit\
    \ = base10_digit_digit.peek().unwrap();\n    let mut base10_digit_digit_digit_len\
    \ = base10_digit_digit_digit.len();\n    let mut base10_digit_digit_digit_digit\
    \ = base10_digit_digit_digit.peek().unwrap();\n    let mut base10_digit_digit_digit_len\
    \ = base10_digit_digit_digit_digit.len();\n    let mut base10_digit_digit_digit_digit\
    \ = base10_digit_digit_digit_digit.peek().unwrap();\n    let mut base10_digit_digit_digit_digit_len\
    \ = base10_digit_digit_digit_digit_digit.len();\n    let mut base10_digit_digit_digit_digit_digit\
    \ = base10_digit_digit_digit_digit_digit.peek().unwrap();\n    let mut base10_digit_digit_digit_digit_len\
    \ = base10_digit_digit_digit_digit_digit.len();\n    let mut base10_digit_digit_digit_digit_digit\
    \ = base10_digit_digit_digit_digit_digit.peek().unwrap();\n    let mut base10_digit_digit_digit_digit_len\
    \ = base10_digit_digit_digit_digit_digit.len();\n    let mut base10_digit_digit_digit_digit_digit\
    \ = base10_digit_digit_digit_digit_digit.peek().unwrap();\n    let mut base10_digit_digit_digit_digit_digit_len\
    \ = base10_digit_digit_digit_digit_digit_digit.len();\n    let mut base10_digit_digit_digit_digit_digit_digit\
    \ = base10_digit_digit_digit_digit_digit_digit.peek().unwrap();\n    let mut base10_digit_digit_digit_digit_digit_len\
    \ = base10_digit_digit_digit_digit_digit_digit.len();\n    let mut base10_digit_digit_digit_digit_digit_digit\
    \ = base10_digit_digit_digit_digit_digit_digit.peek().unwrap();\n    let mut base10_digit_digit_digit_digit_digit_len\
    \ = base10_digit_digit_digit_digit_digit_digit\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0wxioyg6.rs:31:98\n   |\n\
    31 |     let mut base10_digit_digit_digit_digit_digit_len = base10_digit_digit_digit_digit_digit_digit\n\
    \   |                                                                        \
    \                          ^ help: add `;` here\n32 | }\n   | - unexpected token\n\
    \nerror[E0425]: cannot find value `base10_digit_digit_digit_digit_digit` in this\
    \ scope\n  --> /tmp/tmp0wxioyg6.rs:21:50\n   |\n21 |     let mut base10_digit_digit_digit_digit_len\
    \ = base10_digit_digit_digit_digit_digit.len();\n   |                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `base10_digit_digit_digit_digit`\n\nerror[E0425]:\
    \ cannot find value `base10_digit_digit_digit_digit_digit` in this scope\n  -->\
    \ /tmp/tmp0wxioyg6.rs:22:52\n   |\n22 |     let mut base10_digit_digit_digit_digit_digit\
    \ = base10_digit_digit_digit_digit_digit.peek().unwrap();\n   |              \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `base10_digit_digit_digit_digit_len`\n\
    \nerror[E0425]: cannot find value `base10_digit_digit_digit_digit_digit_digit`\
    \ in this scope\n  --> /tmp/tmp0wxioyg6.rs:27:56\n   |\n27 |     let mut base10_digit_digit_digit_digit_digit_len\
    \ = base10_digit_digit_digit_digit_digit_digit.len();\n   |                  \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `base10_digit_digit_digit_digit_digit`\n\
    \nerror[E0425]: cannot find value `base10_digit_digit_digit_digit_digit_digit`\
    \ in this scope\n  --> /tmp/tmp0wxioyg6.rs:28:58\n   |\n28 |     let mut base10_digit_digit_digit_digit_digit_digit\
    \ = base10_digit_digit_digit_digit_digit_digit.peek().unwrap();\n   |        \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `base10_digit_digit_digit_digit_digit_len`\n\
    \nerror[E0599]: no method named "
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03zito6r.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp03zito6r.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    for digit in digits.iter()\
    \ {\n        s.push(digit);\n    }\n    String::from(s)\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpev9qbc1u.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpev9qbc1u.rs:13:25\n\
    \   |\n13 |     for digit in digits.iter() {\n   |                         ^^^^\
    \ method not found in `String`\n   |\nhelp: because of the in-memory representation\
    \ of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n13 |     for digit in digits.chars() {\n   |                         ~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder += x % base;\n        x /= base;\n    }\n    digits.push(&remainder);\n\
    \    while x > 0 {\n        remainder += x % base;\n        x /= base;\n     \
    \   s.push(&remainder);\n    }\n    digits.reverse();\n    format!(\"{}\", digits)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzo20wbz7.rs:12:17\n   |\n\
    12 |     digits.push(&remainder);\n   |                 ^^^^^^^^^^ expected `char`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzo20wbz7.rs:16:16\n\
    \   |\n16 |         s.push(&remainder);\n   |                ^^^^^^^^^^ expected\
    \ `char`, found `&isize`\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpzo20wbz7.rs:18:12\n   |\n\
    18 |     digits.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ i = 0;\n    while remainder > 0 {\n        digits.push(format!(\"{}\", remainder\
    \ % base));\n        remainder = remainder / base;\n        i += 1;\n    }\n \
    \   while i < 10 {\n        digits.push('0');\n        i += 1;\n    }\n    s +=\
    \ digits.reverse();\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_i6x1l0x.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder % base));\n   |           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `reverse` found for struct `String` in the current scope\n  --> /tmp/tmp_i6x1l0x.rs:18:17\n\
    \   |\n18 |     s += digits.reverse();\n   |                 ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpks0qj8er.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    for digit in digits.drain(..)\
    \ {\n        s.push(digit);\n    }\n    String::from(s)\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphmd41_uz.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut digits_base = digits.chars().collect::<Vec<_>>();\n\
    \    let mut digits_base2 = digits.chars().collect::<Vec<_>>();\n    let mut digits_base3\
    \ = digits.chars().collect::<Vec<_>>();\n    let mut digits_base4 = digits.chars().collect::<Vec<_>>();\n\
    \    let mut digits_base5 = digits.chars().collect::<Vec<_>>();\n    let mut digits_base6\
    \ = digits.chars().collect::<Vec<_>>();\n    let mut digits_base7 = digits.chars().collect::<Vec<_>>();\n\
    \    let mut digits_base8 = digits.chars().collect::<Vec<_>>();\n    let mut digits_base9\
    \ = digits.chars().collect::<Vec<_>>();\n    let mut digits_base10 = digits.chars().collect::<Vec<_>>();\n\
    \    let mut digits_base11 = digits.chars().collect::<Vec<_>>();\n    let mut\
    \ digits_base12 = digits.chars().collect::<Vec<_>>();\n    let mut digits_base13\
    \ = digits.chars().collect::<Vec<_>>();\n    let mut digits_base14 = digits.chars().collect::<Vec<_>>();\n\
    \    let mut digits_base15 = digits.chars().collect::<Vec<_>>();\n    let mut\
    \ digits_base16 = digits.chars().collect::<Vec<_>>();\n    let mut digits_base17\
    \ = digits.chars().collect::<Vec<_>>();\n    let mut digits_base18 = digits.chars().collect::<Vec<_>>();\n\
    \    let mut digits_base19 = digits.chars().collect::<Vec<_>>();\n    let mut\
    \ digits_base20 = digits.chars().collect::<Vec<_>>();\n    let mut digits_base21\
    \ = digits.chars().collect::<Vec<_>>();\n    let mut digits_base22 = digits.chars().collect::<Vec<_>>();\n\
    \    let mut digits_base23 = digits.chars().collect::<Vec<_>>();\n    let mut\
    \ digits_base24 = digits.chars().collect::<Vec<_>>();\n    let mut digits_base25\
    \ = digits.chars().collect::<Vec<_>>();\n    let mut digits_base26 = digits.chars().collect::<Vec<_>>();\n\
    \    let mut digits_base27 = digits.chars().collect::\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `.`, `;`, `?`, `else`, or an operator, found\
    \ `::`\n  --> /tmp/tmpp_kv5mv9.rs:33:51\n   |\n33 |     let mut digits_base27\
    \ = digits.chars().collect::\n   |                                           \
    \        ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base10 = digits.chars().nth(base).unwrap();\n\
    \    let mut base10_digits = base10.to_string();\n    let mut base10_digits_len\
    \ = base10_digits.len();\n    let mut base10_digits_pow = base10_digits_len.powf(2);\n\
    \    let mut base10_digits_pow_len = base10_digits_pow.len();\n    let mut base10_digits_pow_pow_len\
    \ = base10_digits_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_len\
    \ = base10_digits_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_pow_pow_pow_len.powf(2);\n    let mut base10_digits_pow_pow_pow_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_pow_pow_pow_pow_len.powf(2);\n    let mut\
    \ base10_digits_pow_pow_pow_pow_pow_pow_pow_pow_len = base10_digits_pow_pow_pow_pow_pow_pow_pow_pow_pow_len.powf(2);\n\
    \    let mut base10_digits_pow_pow_pow_pow_pow_pow_pow_pow_len = base10_digits_pow_pow_pow_pow_pow_pow_pow_pow_pow_len.powf(2);\n\
    \    let mut base\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi4l47h8b.rs:26:17\n   |\n\
    26 |     let mut base\n   |                 ^ help: add `;` here\n27 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `base10_digits_pow_pow_pow_pow_len`\
    \ in this scope\n  --> /tmp/tmpi4l47h8b.rs:15:49\n   |\n15 |     let mut base10_digits_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_len.powf(2);\n   |                         \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `base10_digits_pow_pow_pow_len`\n\nerror[E0425]:\
    \ cannot find value `base10_digits_pow_pow_pow_pow_pow_len` in this scope\n  -->\
    \ /tmp/tmpi4l47h8b.rs:16:53\n   |\n16 |     let mut base10_digits_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_len.powf(2);\n   |                     \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a\
    \ local variable with a similar name exists: `base10_digits_pow_pow_pow_pow_len`\n\
    \nerror[E0425]: cannot find value `base10_digits_pow_pow_pow_pow_pow_pow_len`\
    \ in this scope\n  --> /tmp/tmpi4l47h8b.rs:18:53\n   |\n18 |     let mut base10_digits_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_pow_len.powf(2);\n   |                 \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `base10_digits_pow_pow_pow_pow_pow_len`\n\
    \nerror[E0425]: cannot find value `base10_digits_pow_pow_pow_pow_pow_pow_pow_len`\
    \ in this scope\n  --> /tmp/tmpi4l47h8b.rs:19:57\n   |\n19 |     let mut base10_digits_pow_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_pow_pow_pow_pow_pow_pow_len.powf(2);\n   |             \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `base10_digits_pow_pow_pow_pow_pow_len`\n\
    \nerror[E0425]: cannot find value `base10_digits_pow_pow_pow_pow_pow_pow_pow_len`\
    \ in this scope\n  --> /tmp/tmpi4l47h8b.rs:20:61\n   |\n20 |     let mut base10_digits_pow_pow_pow_pow_pow_pow_pow_len\
    \ = base10_digits_pow_po"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base10 = base.to_string();\n\
    \    while base10.len() > 0 {\n        let digit = digits.chars().nth(base10.len()\
    \ - 1).unwrap();\n        s = format!(\"{}{}\", s, digit);\n        base10 = base10.repeat(digit.len_utf8());\n\
    \        digits = digits.chars().nth(digits.len() - 1);\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2us82hfk.rs:12:18\n   |\n\
    6  |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n12 |         digits = digits.chars().nth(digits.len()\
    \ - 1);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while remainder\
    \ < base {\n        remainder += base;\n        digits = digits.chars().nth(digits.len()\
    \ - 1);\n    }\n    while remainder > 0 {\n        remainder -= base;\n      \
    \  digits = digits.chars().nth(digits.len() - 1);\n    }\n    s += digits;\n \
    \   s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr7hldzi9.rs:10:18\n   |\n\
    6  |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n10 |         digits = digits.chars().nth(digits.len()\
    \ - 1);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr7hldzi9.rs:14:18\n   |\n6  |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n14 |\
    \         digits = digits.chars().nth(digits.len() - 1);\n   |               \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr7hldzi9.rs:16:10\n\
    \   |\n16 |     s += digits;\n   |          ^^^^^^\n   |          |\n   |    \
    \      expected `&str`, found struct `String`\n   |          help: consider borrowing\
    \ here: `&digits`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , s, digit.to_string());\n    }\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmp9x46_qrm.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0u8; base];\n    let mut carry = 0;\n    while x >=\
    \ base {\n        let digit = x % base;\n        digits[digit] += 1;\n       \
    \ x /= base;\n        carry += 1;\n    }\n    while carry > 0 {\n        digits[digits[digits.len()\
    \ - 1]] += 1;\n        carry -= 1;\n    }\n    for digit in digits.iter().rev()\
    \ {\n        s += char::from_u32(digit as u32).unwrap();\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcbh8_6fy.rs:6:32\n  |\n6 |\
    \     let mut digits = vec![0u8; base];\n  |                                ^^^^\
    \ expected `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n  |\n6 |     let mut digits\
    \ = vec![0u8; base.try_into().unwrap()];\n  |                                \
    \    ++++++++++++++++++++\n\nerror[E0277]: the type `[u8]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpcbh8_6fy.rs:10:9\n   |\n10 |         digits[digit] +=\
    \ 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for\
    \ `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<u8>`\n\nerror[E0277]: the type `[u8]` cannot be indexed by `u8`\n \
    \ --> /tmp/tmpcbh8_6fy.rs:15:9\n   |\n15 |         digits[digits[digits.len()\
    \ - 1]] += 1;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `u8`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<u8>` for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcbh8_6fy.rs:19:14\n\
    \   |\n19 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0606]: casting `&u8` as `u32` is invalid\n  --> /tmp/tmpcbh8_6fy.rs:19:29\n\
    \   |\n19 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \                     -----^^^^^^^\n   |                             |\n   | \
    \                            cannot cast `&u8` as `u32`\n   |                \
    \             help: dereference the expression: `*digit`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0606.\nFor more information about an error, try `rustc --exp"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03zito6r.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp03zito6r.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpz7gwz44y.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_base = digits.chars().collect::<Vec<_>>();\n    let mut base_base\
    \ = base.chars().collect::<Vec<_>>();\n    let mut digits_base_base = digits_base.iter().zip(base_base.iter()).collect::<Vec<_>>();\n\
    \    let mut digits_base_base_iter = digits_base_base.iter();\n    let mut digits_base_base_iter\
    \ = digits_base_base_iter.zip(0..).collect::<Vec<_>>();\n    let mut digits_base_base_iter\
    \ = digits_base_base_iter.map(|&(digit, base)| {\n        if digit == 0 {\n  \
    \          digit\n        } else {\n            digit + base * (digits_base_base_iter.next().unwrap()\
    \ - 1)\n        }\n    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(digit,\
    \ base)| {\n        if digit == 0 {\n            digit\n        } else {\n   \
    \         digit + base * (digits_base_base_iter.next().unwrap() - 1)\n       \
    \ }\n    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(digit,\
    \ base)| {\n        if digit == 0 {\n            digit\n        } else {\n   \
    \         digit + base * (digits_base_base_iter.next().unwrap() - 1)\n       \
    \ }\n    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(digit,\
    \ base)| {\n        if digit == 0 {\n            digit\n        } else {\n   \
    \         digit + base * (digits_base_base_iter.next().unwrap() - 1)\n       \
    \ }\n    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(digit,\
    \ base)| {\n        if digit == 0 {\n            digit\n        } else {\n   \
    \         digit + base * (digits_base_base_iter.next().unwrap() - 1)\n       \
    \ }\n    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(digit,\
    \ base)| {\n        if digit == 0 {\n            digit\n        } else {\n   \
    \         digit + base * (digits_base_base_iter.next().unwrap() - 1)\n       \
    \ }\n    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(digit,\
    \ base)| {\n        if digit == 0 {\n            digit\n        } else {\n   \
    \         digit + base * (digits_base_base_iter.next().unwrap() - 1)\n       \
    \ }\n    });\n    let mut digits_base_base_iter = digits_base_base_iter.map(|&(digit,\
    \ base)| {\n        if \n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwmtgkjls.rs:80:3\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n62 |     let\
    \ mut digits_base_base_iter = digits_base_base_iter.map(|&(digit, base)| {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n80 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpwmtgkjls.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected expression\n\nerror: expected one of `)`, `,`,\
    \ `.`, `?`, or an operator, found keyword `fn`\n  --> /tmp/tmpwmtgkjls.rs:66:1\n\
    \   |\n64 | }\n   |  - expected one of `)`, `,`, `.`, `?`, or an operator\n65\
    \ | \n66 | fn main() {\n   | ^^ unexpected token\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976102
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihc6psaf.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpihc6psaf.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpihc6psaf.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: -1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        remainder %= base;\n        digits.push_str(&format!(\"{}\",\
    \ remainder));\n    }\n    digits.push_str(&format!(\"{}\", x));\n    s += &digits;\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976108
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x /= base;\n    }\n    s += remainder.to_string();\n    s += \"0\".to_string();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9i_z4b3.rs:11:10\n   |\n\
    11 |     s += remainder.to_string();\n   |          ^^^^^^^^^^^^^^^^^^^^^\n  \
    \ |          |\n   |          expected `&str`, found struct `String`\n   |   \
    \       help: consider borrowing here: `&remainder.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb9i_z4b3.rs:12:10\n   |\n12 |     s += \"0\"\
    .to_string();\n   |          ^^^^^^^^^^^^^^^\n   |          |\n   |          expected\
    \ `&str`, found struct `String`\n   |          help: consider borrowing here:\
    \ `&\"0\".to_string()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976102
