language: rs
name: HumanEval_44_change_base
results:
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base10 = base.to_string();\n\
    \    let mut digits_base = digits.chars().collect::<Vec<_>>();\n    let mut base10_base\
    \ = base10.chars().collect::<Vec<_>>();\n    let mut base10_digits = base10_base.len();\n\
    \    let mut base10_digits_base = base10_digits.chars().collect::<Vec<_>>();\n\
    \    let mut base10_digits_base2 = base10_digits_base.len();\n    let mut base10_digits_base3\
    \ = base10_digits_base2.chars().collect::<Vec<_>>();\n    let mut base10_digits_base4\
    \ = base10_digits_base3.chars().collect::<Vec<_>>();\n    let mut base10_digits_base5\
    \ = base10_digits_base4.chars().collect::<Vec<_>>();\n    let mut base10_digits_base6\
    \ = base10_digits_base5.chars().collect::<Vec<_>>();\n    let mut base10_digits_base7\
    \ = base10_digits_base6.chars().collect::<Vec<_>>();\n    let mut base10_digits_base8\
    \ = base10_digits_base7.chars().collect::<Vec<_>>();\n    let mut base10_digits_base9\
    \ = base10_digits_base8.chars().collect::<Vec<_>>();\n    let mut base10_digits_base10\
    \ = base10_digits_base9.chars().collect::<Vec<_>>();\n    let mut base10_digits_base11\
    \ = base10_digits_base10.chars().collect::<Vec<_>>();\n    let mut base10_digits_base12\
    \ = base10_digits_base11.chars().collect::<Vec<_>>();\n    let mut base10_digits_base13\
    \ = base10_digits_base12.chars().collect::<Vec<_>>();\n    let mut base10_digits_base14\
    \ = base10_digits_base13.chars().collect::<Vec<_>>();\n    let mut base10_digits_base15\
    \ = base10_digits_base14.chars().collect::<Vec<_>>();\n    let mut base10_digits_base16\
    \ = base10_digits_base15.chars().collect::<Vec<_>>();\n    let mut base10_digits_base17\
    \ = base10_digits_base16.chars().collect::<Vec<_>>();\n    let mut base10_digits_base18\
    \ = base10_digits_base17.chars().collect\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkslb57kc.rs:28:72\n   |\n\
    28 |     let mut base10_digits_base18 = base10_digits_base17.chars().collect\n\
    \   |                                                                        ^\
    \ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0599]: no method\
    \ named `chars` found for type `usize` in the current scope\n  --> /tmp/tmpkslb57kc.rs:11:48\n\
    \   |\n11 |     let mut base10_digits_base = base10_digits.chars().collect::<Vec<_>>();\n\
    \   |                                                ^^^^^ method not found in\
    \ `usize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpkslb57kc.rs:4:42\n \
    \ |\n4 | fn change_base(x: isize, base: isize) -> String {\n  |    -----------\
    \                           ^^^^^^ expected struct `String`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    let mut\
    \ i = 0;\n    while i < x.len() {\n        let digit = x.chars().nth(i).unwrap();\n\
    \        if digit < '0' || digit > '9' {\n            break;\n        }\n    \
    \    remainder = digit - '0';\n        if base == 10 {\n            digits.push_str(&format!(\"\
    {}\", remainder));\n        } else {\n            digits.push_str(&format!(\"\
    {}{}\", remainder, base));\n        }\n        i += 1;\n    }\n    s += digits;\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n --> /tmp/tmpkka640fi.rs:9:17\n  |\n9 |     while i < x.len() {\n  |\
    \                 ^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `chars` found for type `isize` in the current scope\n  --> /tmp/tmpkka640fi.rs:10:23\n\
    \   |\n10 |         let digit = x.chars().nth(i).unwrap();\n   |             \
    \          ^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkka640fi.rs:22:10\n   |\n22 |     s += digits;\n   |          ^^^^^^\n\
    \   |          |\n   |          expected `&str`, found struct `String`\n   | \
    \         help: consider borrowing here: `&digits`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while power.is_positive()\
    \ {\n        if digits.len() > base.to_digits().len() {\n            digits.truncate(base.to_digits().len());\n\
    \        }\n        if digits.len() < base.to_digits().len() {\n            digits\
    \ = digits.pad(base.to_digits().len());\n        }\n        let mut digit = digits.chars().nth(base.to_digits().len()).unwrap();\n\
    \        if digit >= '0' && digit <= '9' {\n            digit -= '0';\n      \
    \  } else {\n            digit -= 'a' - 10;\n        }\n        power = power.pow(base);\n\
    \        s += digit.to_string();\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `is_positive` on ambiguous numeric type\
    \ `{integer}`\n --> /tmp/tmp5w3sy3nh.rs:8:17\n  |\n8 |     while power.is_positive()\
    \ {\n  |                 ^^^^^^^^^^^\n  |\nhelp: you must specify a type for this\
    \ binding, like `i32`\n  |\n7 |     let mut power: i32 = 1;\n  |         ~~~~~~~~~~~~~~\n\
    \nerror[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n --> /tmp/tmp5w3sy3nh.rs:9:32\n  |\n9 |         if digits.len() > base.to_digits().len()\
    \ {\n  |                                ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5w3sy3nh.rs:10:34\n   |\n10 |             digits.truncate(base.to_digits().len());\n\
    \   |                                  ^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5w3sy3nh.rs:12:32\n   |\n12 |         if digits.len() <\
    \ base.to_digits().len() {\n   |                                ^^^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `pad` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp5w3sy3nh.rs:13:29\n   |\n13 | \
    \            digits = digits.pad(base.to_digits().len());\n   |              \
    \               ^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `to_digits` found for type `isize` in the current scope\n  --> /tmp/tmp5w3sy3nh.rs:13:38\n\
    \   |\n13 |             digits = digits.pad(base.to_digits().len());\n   |   \
    \                                   ^^^^^^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5w3sy3nh.rs:15:49\n   |\n15 |         let mut digit = digits.chars().nth(base.to_digits().len()).unwrap();\n\
    \   |                                                 ^^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmp5w3sy3nh.rs:17:13\n   |\n17 |             digit\
    \ -= '0';\n   |          "
  stdout: ''
  timestamp: 1659748755
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp7_k91hq0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.chars().nth(digits.length() - 1).unwrap();\n\
    \        if base == 10 {\n            s.push_str(&digit);\n        } else {\n\
    \            let mut new_digit = digit;\n            if digit == '0' {\n     \
    \           remainder = 0;\n            } else {\n                remainder =\
    \ digit as isize - base;\n                new_digit = digit as isize;\n      \
    \      }\n            s.push_str(&new_digit.to_string());\n        }\n       \
    \ digits = digits.chars().nth(digits.length() - 1).unwrap();\n    }\n    if remainder\
    \ != 0 {\n        s.push_str(&remainder.to_string());\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpxtn777dj.rs:9:47\n  |\n9 |         let digit = digits.chars().nth(digits.length()\
    \ - 1).unwrap();\n  |                                               ^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtn777dj.rs:11:24\n\
    \   |\n11 |             s.push_str(&digit);\n   |                        ^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxtn777dj.rs:18:29\n   |\n18 |                 new_digit = digit as isize;\n\
    \   |                             ^^^^^^^^^^^^^^ expected `char`, found `isize`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpxtn777dj.rs:22:44\n   |\n22 |         digits = digits.chars().nth(digits.length()\
    \ - 1).unwrap();\n   |                                            ^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtn777dj.rs:22:18\n\
    \   |\n22 |         digits = digits.chars().nth(digits.length() - 1).unwrap();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |\n   |\
    \                  expected struct `String`, found `char`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.size() {\n        if base == 0 {\n            s.push_str(&digits[i]);\n\
    \            i += 1;\n        } else {\n            let mut j = i;\n         \
    \   while j < digits.size() && base == 0 {\n                s.push_str(&digits[j]);\n\
    \                j += 1;\n            }\n            let mut base = base.to_string().chars().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned();\n            base = base.iter().cloned().collect::<Vec<_>>();\n\
    \            base = base.to_owned\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6h4mbxeg.rs:69:3\n\
    \   |\n4  | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n9  |     while\
    \ i < digits.size() {\n   |                             - unclosed delimiter\n\
    ...\n13 |         } else {\n   |                - this delimiter might not be\
    \ properly closed...\n...\n53 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n69 | }\n   |   ^\n\nerror[E0599]: no method named `size` found\
    \ for struct `Vec<char>` in the current scope\n --> /tmp/tmp6h4mbxeg.rs:9:22\n\
    \  |\n9 |     while i < digits.size() {\n  |                      ^^^^ method\
    \ not found in `Vec<char>`\n\nerror[E0277]: can't compare `Vec<char>` with `{integer}`\n\
    \  --> /tmp/tmp6h4mbxeg.rs:10:17\n   |\n10 |         if base == 0 {\n   |    \
    \             ^^ no implementation for `Vec<char> == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `Vec<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6h4mbxeg.rs:11:24\n   |\n11 |             s.push_str(&digits[i]);\n\
    \   |                        ^^^^^^^^^^ expected `str`, found `char`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&char`\n\n\
    error[E0599]: no method named `size` found for struct `Vec<char>` in the current\
    \ scope\n  --> /tmp/tmp6h4mbxeg.rs:15:30\n   |\n15 |             while j < digits.size()\
    \ && base == 0 {\n   |                              ^^^^ method not found in `Vec<char>`\n\
    \nerror[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmp6h4mbxeg.rs:15:45\n\
    \   |\n15 |             while j < digits.size() && base == 0 {\n   |         \
    \                                    ^^ no implementation for `Vec<char> == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `Vec<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6h4mbxeg.rs:16:28\n   |\n16 |\
    \                 s.push_str(&digits[j]);\n   |                            ^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected ref"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > base {\n      \
    \  digits = &digits[..(digits.len() - base)];\n    }\n    s += &digits[..];\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjieplaki.rs:7:26\n  |\n7 |\
    \     while digits.len() > base {\n  |                          ^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n7 |     while digits.len() >\
    \ base.try_into().unwrap() {\n  |                          ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpjieplaki.rs:8:44\n  |\n8 |    \
    \     digits = &digits[..(digits.len() - base)];\n  |                        \
    \                    ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ subtract `isize` from `usize`\n --> /tmp/tmpjieplaki.rs:8:42\n  |\n8 |     \
    \    digits = &digits[..(digits.len() - base)];\n  |                         \
    \                 ^ no implementation for `usize - isize`\n  |\n  = help: the\
    \ trait `Sub<isize>` is not implemented for `usize`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpjieplaki.rs:8:18\n  |\n8 |         digits = &digits[..(digits.len()\
    \ - base)];\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n  |\nhelp: try using a conversion method\n  |\n8 | \
    \        digits = (&digits[..(digits.len() - base)]).to_string();\n  |       \
    \           +                                +++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > 0 {\n        let\
    \ digit = digits.chars().nth(base).unwrap();\n        digits = digits.chars().nth(base\
    \ - 1).unwrap() + digit;\n        s += digit;\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpds31yvj1.rs:8:40\n  |\n8 |\
    \         let digit = digits.chars().nth(base).unwrap();\n  |                \
    \                        ^^^^ expected `usize`, found `isize`\n  |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n  |\n8 |         let digit = digits.chars().nth(base.try_into().unwrap()).unwrap();\n\
    \  |                                        ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpds31yvj1.rs:9:37\n  |\n9 |         digits = digits.chars().nth(base\
    \ - 1).unwrap() + digit;\n  |                                     ^^^^^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |         digits = digits.chars().nth((base\
    \ - 1).try_into().unwrap()).unwrap() + digit;\n  |                           \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0369]: cannot add `char` to\
    \ `char`\n --> /tmp/tmpds31yvj1.rs:9:56\n  |\n9 |         digits = digits.chars().nth(base\
    \ - 1).unwrap() + digit;\n  |                  -------------------------------------\
    \ ^ ----- char\n  |                  |\n  |                  char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpds31yvj1.rs:10:14\n   |\n10 |         s += digit;\n\
    \   |              ^^^^^ expected `&str`, found `char`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    while digits.len() > 0 {\n        let\
    \ mut digit = digits.chars().nth(digits.len() - 1);\n        if digit < '0' {\n\
    \            digit += '0';\n        }\n        if digit > '9' {\n            digit\
    \ += '0';\n        }\n        digits = digits.chars().nth(digits.len() - 1);\n\
    \        s += digit;\n    }\n    let mut digits = base.to_string();\n    while\
    \ digits.len() > 0 {\n        let mut digit = digits.chars().nth(digits.len()\
    \ - 1);\n        if digit < '0' {\n            digit += '0';\n        }\n    \
    \    if digit > '9' {\n            digit += '0';\n        }\n        digits =\
    \ digits.chars().nth(digits.len() - 1);\n        s += digit;\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc_o13uxf.rs:9:20\n  |\n9 |\
    \         if digit < '0' {\n  |                    ^^^\n  |                  \
    \  |\n  |                    expected enum `Option`, found `char`\n  |       \
    \             help: try using a variant of the expected enum: `Some('0')`\n  |\n\
    \  = note: expected enum `Option<char>`\n             found type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<char>`\n\
    \  --> /tmp/tmpc_o13uxf.rs:10:13\n   |\n10 |             digit += '0';\n   | \
    \            -----^^^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_o13uxf.rs:12:20\n\
    \   |\n12 |         if digit > '9' {\n   |                    ^^^\n   |      \
    \              |\n   |                    expected enum `Option`, found `char`\n\
    \   |                    help: try using a variant of the expected enum: `Some('9')`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Option<char>`\n\
    \  --> /tmp/tmpc_o13uxf.rs:13:13\n   |\n13 |             digit += '0';\n   | \
    \            -----^^^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_o13uxf.rs:15:18\n\
    \   |\n15 |         digits = digits.chars().nth(digits.len() - 1);\n   |     \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_o13uxf.rs:16:14\n\
    \   |\n16 |         s += digit;\n   |              ^^^^^ expected `&str`, found\
    \ enum `Option`\n   |\n   = note: expected reference `&str`\n                \
    \   found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_o13uxf.rs:21:20\n\
    \   |\n21 |         if digit < '0' {\n   |                    ^^^\n   |      \
    \              |\n   |                    expected enum `Option`, found `char`\n\
    \   |         "
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        if digits.len() > base {\n            digits = &digits[..(digits.len()\
    \ - base)];\n            power = power * base;\n        }\n        s += digits[digits.len()\
    \ - 1];\n        digits = &digits[..digits.len() - 1];\n    }\n    format!(\"\
    {}\", power)\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmputmuuwhv.rs:9:27\n  |\n9 |\
    \         if digits.len() > base {\n  |                           ^^^^ expected\
    \ `usize`, found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |         if digits.len() >\
    \ base.try_into().unwrap() {\n  |                           ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmputmuuwhv.rs:10:48\n   |\n10 |\
    \             digits = &digits[..(digits.len() - base)];\n   |               \
    \                                 ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmputmuuwhv.rs:10:46\n   |\n\
    10 |             digits = &digits[..(digits.len() - base)];\n   |            \
    \                                  ^ no implementation for `usize - isize`\n \
    \  |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmputmuuwhv.rs:10:22\n   |\n10 |             digits\
    \ = &digits[..(digits.len() - base)];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n10 |             digits = (&digits[..(digits.len() - base)]).to_string();\n\
    \   |                      +                                +++++++++++++\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmputmuuwhv.rs:13:14\n\
    \   |\n13 |         s += digits[digits.len() - 1];\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmputmuuwhv.rs:14:18\n\
    \   |\n14 |         digits = &digits[..digits.len() - 1];\n   |              \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n14 |         digits = (&digits[..digits.len()\
    \ - 1]).to_string();\n   |                  +                           +++++++++++++\n\
    \nerror: aborting due to 6 previous error"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while digits.len()\
    \ > 0 {\n        let mut digit = digits.pop().unwrap();\n        if digit >= base\
    \ {\n            digit -= base;\n            power = 1;\n        } else {\n  \
    \          power <<= 1;\n        }\n        s += digit.to_string();\n    }\n \
    \   format!(\"{}\", power)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpee0j1fpg.rs:10:21\n   |\n\
    10 |         if digit >= base {\n   |                     ^^^^ expected `char`,\
    \ found `isize`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpee0j1fpg.rs:11:13\n   |\n11 |             digit\
    \ -= base;\n   |             -----^^^^^^^^\n   |             |\n   |         \
    \    cannot use `-=` on type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpee0j1fpg.rs:16:14\n\
    \   |\n16 |         s += digit.to_string();\n   |              ^^^^^^^^^^^^^^^^^\n\
    \   |              |\n   |              expected `&str`, found struct `String`\n\
    \   |              help: consider borrowing here: `&digit.to_string()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihc6psaf.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpihc6psaf.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpihc6psaf.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x /= base;\n    }\n    if x > 0 {\n        remainder += x;\n    }\n \
    \   s += format!(\"{}\", remainder);\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_w0znppe.rs:14:10\n   |\n\
    14 |     s += format!(\"{}\", remainder);\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ i = 0;\n    while remainder > 0 {\n        remainder = remainder % base;\n \
    \       digits.push(&format!(\"{}\", remainder));\n        i += 1;\n    }\n  \
    \  digits.push(&format!(\"{}\", remainder));\n    s += &digits[..i];\n    s +=\
    \ &digits[..i].to_string();\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpest03p_l.rs:11:21\n   |\n\
    11 |         digits.push(&format!(\"{}\", remainder));\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpest03p_l.rs:14:17\n   |\n14 |     digits.push(&format!(\"\
    {}\", remainder));\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ quotient = x;\n    while remainder > 0 {\n        remainder /= base;\n     \
    \   digits.push_str(&format!(\"{}\", quotient));\n        quotient *= base;\n\
    \    }\n    digits.push_str(&format!(\"{}\", quotient));\n    s += &digits;\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82472\"`,\n right: `\"22\"`', /tmp/tmpl3u2bezi.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    for digit in digits\
    \ {\n        s.push(digit);\n    }\n    String::from(s)\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqws7pmy_.rs:11:21\n   |\n\
    11 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0277]: `String` is not an iterator\n\
    \   --> /tmp/tmpqws7pmy_.rs:13:18\n    |\n13  |     for digit in digits {\n  \
    \  |                  ^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base10: Vec<_> = digits.iter().map(|x| x.to_digit(base)).collect();\n    let\
    \ mut base10_len = base10.len();\n    let mut base10_pow = base10_len.powf(base);\n\
    \    let mut base10_pow2 = base10_pow.clone();\n    let mut base10_pow2_len =\
    \ base10_pow2.len();\n    let mut base10_pow2_pow = base10_pow2.powf(2);\n   \
    \ let mut base10_pow2_pow2 = base10_pow2_pow.clone();\n    let mut base10_pow2_pow2_len\
    \ = base10_pow2_pow2.len();\n    let mut base10_pow2_pow2_pow = base10_pow2_pow2.powf(2);\n\
    \    let mut base10_pow2_pow2_pow2 = base10_pow2_pow2_pow.clone();\n    let mut\
    \ base10_pow2_pow2_pow2_len = base10_pow2_pow2_pow2.len();\n    let mut base10_pow2_pow2_pow2_pow\
    \ = base10_pow2_pow2_pow2.powf(2);\n    let mut base10_pow2_pow2_pow2_pow2 = base10_pow2_pow2_pow2_pow.clone();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_len = base10_pow2_pow2_pow2_pow2.len();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow = base10_pow2_pow2_pow2_pow2.powf(2);\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2 = base10_pow2_pow2_pow2_pow2_pow.clone();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_len = base10_pow2_pow2_pow2_pow2_pow2.len();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_pow = base10_pow2_pow2_pow2_pow2_pow2.powf(2);\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_pow2 = base10_pow2_pow2_pow2_pow2_pow2_pow.clone();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_pow2_len = base10_pow2_pow2_pow2_pow2_pow2_pow2.len();\n\
    \    let mut base10_pow2_pow2_pow2_pow2_pow2_pow2_pow = \n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp77d0jmg5.rs:28:1\n\
    \   |\n28 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp77d0jmg5.rs:7:63\n  |\n7 |     let mut base10: Vec<_> = digits.iter().map(|x|\
    \ x.to_digit(base)).collect();\n  |                                          \
    \                     ^^^^ expected `u32`, found `isize`\n  |\nhelp: you can convert\
    \ an `isize` to a `u32` and panic if the converted value doesn't fit\n  |\n7 |\
    \     let mut base10: Vec<_> = digits.iter().map(|x| x.to_digit(base.try_into().unwrap())).collect();\n\
    \  |                                                               ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0599]: no method named `powf` found for type `usize` in the current scope\n\
    \ --> /tmp/tmp77d0jmg5.rs:9:37\n  |\n9 |     let mut base10_pow = base10_len.powf(base);\n\
    \  |                                     ^^^^ help: there is an associated function\
    \ with a similar name: `pow`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihc6psaf.rs:10:21\n   |\n\
    10 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpihc6psaf.rs:13:17\n   |\n13 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpihc6psaf.rs:14:10\n   |\n14 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let digit = digits.chars().nth(base.len()\
    \ - 1).unwrap();\n        s += digit;\n        digits = digits.chars().skip_while(|c|\
    \ c != digit).collect();\n        base = base.chars().skip_while(|c| c != digit).collect();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbg_u9r2.rs:10:14\n   |\n\
    10 |         s += digit;\n   |              ^^^^^ expected `&str`, found `char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjbg_u9r2.rs:11:50\n\
    \   |\n11 |         digits = digits.chars().skip_while(|c| c != digit).collect();\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjbg_u9r2.rs:12:46\n\
    \   |\n12 |         base = base.chars().skip_while(|c| c != digit).collect();\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748755
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\nfn\
    \ change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder += x % base;\n        x /= base;\n    }\n    s\
    \ += digits[remainder];\n    while x > 0 {\n        remainder += x % base;\n \
    \       x /= base;\n        s += digits[remainder];\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmp2ylr0qs_.rs:12:10\n\
    \   |\n12 |     s += digits[remainder];\n   |          ^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `isize`\n   |\n   = help: the trait `Index<isize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp2ylr0qs_.rs:16:14\n   |\n16 |         s += digits[remainder];\n\
    \   |              ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n \
    \  |\n   = help: the trait `Index<isize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748755
