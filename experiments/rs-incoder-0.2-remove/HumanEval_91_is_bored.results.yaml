language: rs
name: HumanEval_91_is_bored
results:
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace().collect();\n    for word in sentence {\n  \
    \      if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n \
    \   }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpd2qf46tz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            i += 1;\n        } else {\n            i += 1;\n        }\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmp4yx1oehj.rs:9:21\n  |\n9 |     while i <\
    \ words.len() {\n  |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp4yx1oehj.rs:10:12\n   |\n10 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            cnt += 1;\n        }\n\
    \    }\n    cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp53c51vze.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    for word in sentence {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprylu7r9k.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut boredom_words:\
    \ Vec<&str> = Vec::new();\n    let mut boredom_sentences: Vec<&str> = Vec::new();\n\
    \    let mut boredom_word: &str;\n    let mut boredom_sentence: &str;\n    let\
    \ mut boredom_word_len: usize;\n    let mut boredom_sentence_len: usize;\n   \
    \ for word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n \
    \           boredoms += 1;\n            boredom_words.push(word);\n        } else\
    \ {\n            boredom_sentences.push(word);\n        }\n    }\n    for sentence\
    \ in boredom_sentences {\n        for word in sentence.split_whitespace() {\n\
    \            boredom_word_len = word.len();\n            boredom_sentence_len\
    \ = sentence.len();\n            if boredom_word_len == boredom_sentence_len {\n\
    \                if boredom_word == word {\n                    boredoms += 1;\n\
    \                }\n            }\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `boredom_sentence`\n  --> /tmp/tmpc2m81n5a.rs:10:13\n\
    \   |\n10 |     let mut boredom_sentence: &str;\n   |             ^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_boredom_sentence`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0381]: borrow\
    \ of possibly-uninitialized variable: `boredom_word`\n  --> /tmp/tmpc2m81n5a.rs:26:20\n\
    \   |\n26 |                 if boredom_word == word {\n   |                  \
    \  ^^^^^^^^^^^^ use of possibly-uninitialized `boredom_word`\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0381`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    let mut word: &str = sentence.first();\n\
    \    while let Some(word) = word {\n        if word == \"I\" {\n            boredoms\
    \ += 1;\n        }\n        word = sentence.next();\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmph755bwis.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmph755bwis.rs:8:26\n\
    \  |\n8 |     let mut word: &str = sentence.first();\n  |                   ----\
    \   ^^^^^^^^^^^^^^^^ expected `&str`, found enum `Option`\n  |               \
    \    |\n  |                   expected due to this\n  |\n  = note: expected reference\
    \ `&str`\n                  found enum `Option<&&str>`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmph755bwis.rs:9:15\n  |\n9 |     while let Some(word) = word\
    \ {\n  |               ^^^^^^^^^^   ---- this expression has type `&str`\n  |\
    \               |\n  |               expected `str`, found enum `Option`\n  |\n\
    \  = note: expected type `str`\n             found enum `Option<_>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<&str>` in the current scope\n \
    \ --> /tmp/tmph755bwis.rs:13:25\n   |\n13 |         word = sentence.next();\n\
    \   |                         ^^^^ method not found in `Vec<&str>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for s in S.split() {\n       \
    \ if s.starts_with(\"I\") {\n            cnt += 1;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp2c4k74ap.rs:7:16\n     |\n7    |     for s in S.split() {\n \
    \    |                ^^^^^- supplied 0 arguments\n     |                |\n \
    \    |                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp58c34mac.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
