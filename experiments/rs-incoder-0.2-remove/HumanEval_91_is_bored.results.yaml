language: rs
name: HumanEval_91_is_bored
results:
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace().collect();\n    for word in sentence {\n  \
    \      if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n \
    \   }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpd2qf46tz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            i += 1;\n        } else {\n            i += 1;\n        }\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmp4yx1oehj.rs:9:21\n  |\n9 |     while i <\
    \ words.len() {\n  |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp4yx1oehj.rs:10:12\n   |\n10 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            cnt += 1;\n        }\n\
    \    }\n    cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp53c51vze.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    for word in sentence {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprylu7r9k.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut boredom_words:\
    \ Vec<&str> = Vec::new();\n    let mut boredom_sentences: Vec<&str> = Vec::new();\n\
    \    let mut boredom_word: &str;\n    let mut boredom_sentence: &str;\n    let\
    \ mut boredom_word_len: usize;\n    let mut boredom_sentence_len: usize;\n   \
    \ for word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n \
    \           boredoms += 1;\n            boredom_words.push(word);\n        } else\
    \ {\n            boredom_sentences.push(word);\n        }\n    }\n    for sentence\
    \ in boredom_sentences {\n        for word in sentence.split_whitespace() {\n\
    \            boredom_word_len = word.len();\n            boredom_sentence_len\
    \ = sentence.len();\n            if boredom_word_len == boredom_sentence_len {\n\
    \                if boredom_word == word {\n                    boredoms += 1;\n\
    \                }\n            }\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `boredom_sentence`\n  --> /tmp/tmpc2m81n5a.rs:10:13\n\
    \   |\n10 |     let mut boredom_sentence: &str;\n   |             ^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_boredom_sentence`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0381]: borrow\
    \ of possibly-uninitialized variable: `boredom_word`\n  --> /tmp/tmpc2m81n5a.rs:26:20\n\
    \   |\n26 |                 if boredom_word == word {\n   |                  \
    \  ^^^^^^^^^^^^ use of possibly-uninitialized `boredom_word`\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0381`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    let mut word: &str = sentence.first();\n\
    \    while let Some(word) = word {\n        if word == \"I\" {\n            boredoms\
    \ += 1;\n        }\n        word = sentence.next();\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmph755bwis.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmph755bwis.rs:8:26\n\
    \  |\n8 |     let mut word: &str = sentence.first();\n  |                   ----\
    \   ^^^^^^^^^^^^^^^^ expected `&str`, found enum `Option`\n  |               \
    \    |\n  |                   expected due to this\n  |\n  = note: expected reference\
    \ `&str`\n                  found enum `Option<&&str>`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmph755bwis.rs:9:15\n  |\n9 |     while let Some(word) = word\
    \ {\n  |               ^^^^^^^^^^   ---- this expression has type `&str`\n  |\
    \               |\n  |               expected `str`, found enum `Option`\n  |\n\
    \  = note: expected type `str`\n             found enum `Option<_>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<&str>` in the current scope\n \
    \ --> /tmp/tmph755bwis.rs:13:25\n   |\n13 |         word = sentence.next();\n\
    \   |                         ^^^^ method not found in `Vec<&str>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for s in S.split() {\n       \
    \ if s.starts_with(\"I\") {\n            cnt += 1;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp2c4k74ap.rs:7:16\n     |\n7    |     for s in S.split() {\n \
    \    |                ^^^^^- supplied 0 arguments\n     |                |\n \
    \    |                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp58c34mac.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\")\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpmm6w5w00.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence =\
    \ S.to_string();\n    let mut i = 0;\n    while i < sentence.len() {\n       \
    \ if sentence[i] == '.' || sentence[i] == '?' || sentence[i] == '!' {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp954b3udg.rs:10:12\n\
    \   |\n10 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp954b3udg.rs:10:34\n   |\n10 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp954b3udg.rs:10:56\n   |\n10 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for s in S.chars() {\n       \
    \ if s.is_ascii() {\n            if s.as_bytes()[0] == b'I' {\n              \
    \  cnt += 1;\n            }\n        }\n    }\n    cnt\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n --> /tmp/tmpl28sihcm.rs:9:18\n  |\n9 |             if s.as_bytes()[0]\
    \ == b'I' {\n  |                  ^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for s in S.chars()\
    \ {\n        if s.is_ascii_lowercase() {\n            if s.starts_with(\"i\")\
    \ {\n                boredoms += 1;\n            }\n        }\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n --> /tmp/tmpxr3uzk3l.rs:9:18\n  |\n9 |             if s.starts_with(\"\
    i\") {\n  |                  ^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut s = S.to_string();\n\
    \    s.replace(\"I\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\"\
    , \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"\
    !\", \"\");\n    s.replace(\"?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"\
    ?\", \"\");\n    s.replace(\"!\", \"\");\n    s.replace(\"?\", \"\");\n    s.\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp7spy3szm.rs:92:1\n   |\n92\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7spy3szm.rs:91:5\n\
    \   |\n5  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n91 |     s.\n   |     ^\
    \ expected `isize`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for s in S.split('.')\
    \ {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpk2_of7n1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    let mut s = S.to_string();\n \
    \   while s.len() > 0 {\n        if s.starts_with(\"I\") {\n            cnt +=\
    \ 1;\n        }\n        s = s.trim_end().to_string();\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009147
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for s in S.chars() {\n     \
    \   if s.is_ascii_lowercase() {\n            count += 1;\n        }\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `0`', /tmp/tmp_0miyizr.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    while s.len() > 0 {\n        let mut i = s.find('i');\n        if i == s.len()\
    \ {\n            break;\n        }\n        if s.starts_with(\"I\") {\n      \
    \      boredoms += 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp95wv8ylt.rs:10:17\n   |\n\
    10 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n10 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmp95wv8ylt.rs:16:14\n\
    \   |\n16 |         s = &s[i..];\n   |              ^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp95wv8ylt.rs:16:13\n\
    \   |\n7  |     let mut s = S.to_string();\n   |                 -------------\
    \ expected due to this value\n...\n16 |         s = &s[i..];\n   |           \
    \  ^^^^^^^ expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\nhelp: consider removing the\
    \ borrow\n   |\n16 -         s = &s[i..];\n16 +         s = s[i..];\n   | \n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut boredom = false;\n \
    \   for word in S.split_whitespace() {\n        if word == \"I\" {\n         \
    \   boredom = true;\n        }\n        if boredom {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `1`', /tmp/tmp5zllnqom.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\")\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpmm6w5w00.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence =\
    \ S.to_string();\n    let mut i = 0;\n    while i < sentence.len() {\n       \
    \ if sentence[i] == 'I' {\n            i += 1;\n            while i < sentence.len()\
    \ {\n                if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n                    i += 1;\n                } else {\n          \
    \          break;\n                }\n            }\n            boredoms += 1;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptw7wyj98.rs:10:12\n\
    \   |\n10 |         if sentence[i] == 'I' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptw7wyj98.rs:13:20\n   |\n13 |                 if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n   |                    ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptw7wyj98.rs:13:42\n   |\n13 |                 if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n   |                    \
    \                      ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\")\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpmm6w5w00.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for s in S.chars() {\n     \
    \   if s.is_ascii_letter() {\n            if s.as_bytes()[0] == b'I'\n       \
    \         || s.as_bytes()[0] == b'i'\n                || s.as_bytes()[0] == b'I'\n\
    \                || s.as_bytes()[0] == b'i'\n            {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n --> /tmp/tmpse41jr5y.rs:8:14\n  |\n8 |         if s.is_ascii_letter()\
    \ {\n  |              ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror[E0599]: no method named `as_bytes` found\
    \ for type `char` in the current scope\n --> /tmp/tmpse41jr5y.rs:9:18\n  |\n9\
    \ |             if s.as_bytes()[0] == b'I'\n  |                  ^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `as_bytes` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpse41jr5y.rs:10:22\n   |\n10 |   \
    \              || s.as_bytes()[0] == b'i'\n   |                      ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `as_bytes` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpse41jr5y.rs:11:22\n   |\n\
    11 |                 || s.as_bytes()[0] == b'I'\n   |                      ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `as_bytes` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpse41jr5y.rs:12:22\n   |\n\
    12 |                 || s.as_bytes()[0] == b'i'\n   |                      ^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    while !s.is_empty() {\n        let mut i = s.find('i');\n        if i ==\
    \ s.len() {\n            break;\n        }\n        if s.starts_with(\"I\") {\n\
    \            boredoms += 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9j1hoyuy.rs:10:17\n   |\n\
    10 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n10 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmp9j1hoyuy.rs:16:14\n\
    \   |\n16 |         s = &s[i..];\n   |              ^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9j1hoyuy.rs:16:13\n\
    \   |\n7  |     let mut s = S.to_string();\n   |                 -------------\
    \ expected due to this value\n...\n16 |         s = &s[i..];\n   |           \
    \  ^^^^^^^ expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\nhelp: consider removing the\
    \ borrow\n   |\n16 -         s = &s[i..];\n16 +         s = s[i..];\n   | \n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk3ll6e74.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    for word in sentence {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprylu7r9k.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for s in S.chars() {\n     \
    \   if s.is_ascii_letter() {\n            if s.to_ascii_lowercase() == \"i\" {\n\
    \                count += 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n --> /tmp/tmpu6uuknk1.rs:8:14\n  |\n8 |         if s.is_ascii_letter()\
    \ {\n  |              ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpu6uuknk1.rs:9:42\n\
    \  |\n9 |             if s.to_ascii_lowercase() == \"i\" {\n  |              \
    \                            ^^^ expected `char`, found `&str`\n  |\nhelp: if\
    \ you meant to write a `char` literal, use single quotes\n  |\n9 |           \
    \  if s.to_ascii_lowercase() == 'i' {\n  |                                   \
    \       ~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for s in S.chars()\
    \ {\n        if s.is_ascii() && (s.to_ascii_lowercase() == \"i\") {\n        \
    \    boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp25zkqnsh.rs:8:55\n  |\n8 |\
    \         if s.is_ascii() && (s.to_ascii_lowercase() == \"i\") {\n  |        \
    \                                               ^^^ expected `char`, found `&str`\n\
    \  |\nhelp: if you meant to write a `char` literal, use single quotes\n  |\n8\
    \ |         if s.is_ascii() && (s.to_ascii_lowercase() == 'i') {\n  |        \
    \                                               ~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut boredoms = Vec::new();\n\
    \    for word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n\
    \            count += 1;\n        } else {\n            boredoms.push(word);\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpdphi5zet.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for s in S.split()\
    \ {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp9msq30bh.rs:7:16\n     |\n7    |     for s in S.split() {\n \
    \    |                ^^^^^- supplied 0 arguments\n     |                |\n \
    \    |                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk3ll6e74.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\")\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpmm6w5w00.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    for word in sentence {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprylu7r9k.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk3ll6e74.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\")\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpmm6w5w00.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3cx1zhbt.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3cx1zhbt.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3cx1zhbt.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\")\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpmm6w5w00.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    while s.len() > 0 {\n        let mut i = s.find('i');\n        if i == s.len()\
    \ {\n            break;\n        }\n        if s.starts_with(\"I\") {\n      \
    \      boredoms += 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp95wv8ylt.rs:10:17\n   |\n\
    10 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n10 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmp95wv8ylt.rs:16:14\n\
    \   |\n16 |         s = &s[i..];\n   |              ^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp95wv8ylt.rs:16:13\n\
    \   |\n7  |     let mut s = S.to_string();\n   |                 -------------\
    \ expected due to this value\n...\n16 |         s = &s[i..];\n   |           \
    \  ^^^^^^^ expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\nhelp: consider removing the\
    \ borrow\n   |\n16 -         s = &s[i..];\n16 +         s = s[i..];\n   | \n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for s in S.split() {\n       \
    \ if s.starts_with(\"I\") {\n            cnt += 1;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp2c4k74ap.rs:7:16\n     |\n7    |     for s in S.split() {\n \
    \    |                ^^^^^- supplied 0 arguments\n     |                |\n \
    \    |                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp58c34mac.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut i: usize =\
    \ 0;\n    while i < S.len() {\n        if S[i] == '.' || S[i] == '?' || S[i] ==\
    \ '!' {\n            i += 1;\n        } else {\n            boredoms += 1;\n \
    \       }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp14d942y_.rs:9:12\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \    ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp14d942y_.rs:9:27\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                   ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp14d942y_.rs:9:42\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                                  ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n   "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    for word in sentence {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprylu7r9k.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwo1xj_q7.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwo1xj_q7.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwo1xj_q7.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n \
    \   while i < S.len() {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!'\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpchd6k2ei.rs:9:12\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \    ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpchd6k2ei.rs:9:27\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                   ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpchd6k2ei.rs:9:42\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                                  ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n   "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    for word in sentence {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    return boredoms;\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnhmz8_ry.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence =\
    \ String::new();\n    let mut word = String::new();\n    let mut delimiter = String::new();\n\
    \    let mut delimiters = vec![\".\", \"?\", \"!\"];\n    let mut delimiters_set\
    \ = HashSet::new();\n    let mut delimiters_set = delimiters_set.insert(delimiters.clone());\n\
    \    for c in S.chars() {\n        if delimiters_set.contains(&c) {\n        \
    \    delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiters.clone());\n\
    \            delimiters_set.insert(delimiters.clone());\n            delimiters_set.insert(delimiter\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxm_85kt8.rs:67:3\n\
    \   |\n5  | fn is_bored(S: String) -> isize {\n   |                          \
    \       - unclosed delimiter\n...\n13 |     for c in S.chars() {\n   |       \
    \                 - unclosed delimiter\n14 |         if delimiters_set.contains(&c)\
    \ {\n   |                                        - this delimiter might not be\
    \ properly closed...\n...\n57 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n67 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmpxm_85kt8.rs:56:34\n   |\n5  | fn is_bored(S: String) -> isize {\n\
    \   |                                 - closing delimiter possibly meant for this\n\
    ...\n56 |             delimiters_set.insert(delimiter\n   |                  \
    \                ^ unclosed delimiter\n57 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpxm_85kt8.rs:11:30\n\
    \   |\n11 |     let mut delimiters_set = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxm_85kt8.rs:13:5\n   |\n5  |   fn is_bored(S:\
    \ String) -> isize {\n   |                             ----- expected `isize`\
    \ because of return type\n...\n13 | /     for c in S.chars() {\n14 | |       \
    \  if delimiters_set.contains(&c) {\n15 | |             delimiters_set.insert(delimiters.clone());\n\
    16 | |             delimiters_set.insert(delimiters.clone());\n...  |\n66 | |\
    \     assert_eq!(candidate(String::from(\"You and I are going for a walk\")),\
    \ 0);\n67 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    return boredoms;\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpv6uhwby9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for s in S.chars() {\n       \
    \ if s.is_ascii_letter() {\n            if s.as_bytes()[0] == b'I'\n         \
    \       || s.as_bytes()[0] == b'a'\n                || s.as_bytes()[0] == b'e'\n\
    \                || s.as_bytes()[0] == b'i'\n                || s.as_bytes()[0]\
    \ == b'o'\n                || s.as_bytes()[0] == b'u'\n            {\n       \
    \         cnt += 1;\n            }\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n --> /tmp/tmp1t8rjr_3.rs:8:14\n  |\n8 |         if s.is_ascii_letter()\
    \ {\n  |              ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror[E0599]: no method named `as_bytes` found\
    \ for type `char` in the current scope\n --> /tmp/tmp1t8rjr_3.rs:9:18\n  |\n9\
    \ |             if s.as_bytes()[0] == b'I'\n  |                  ^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `as_bytes` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp1t8rjr_3.rs:10:22\n   |\n10 |   \
    \              || s.as_bytes()[0] == b'a'\n   |                      ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `as_bytes` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp1t8rjr_3.rs:11:22\n   |\n\
    11 |                 || s.as_bytes()[0] == b'e'\n   |                      ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `as_bytes` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp1t8rjr_3.rs:12:22\n   |\n\
    12 |                 || s.as_bytes()[0] == b'i'\n   |                      ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `as_bytes` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp1t8rjr_3.rs:13:22\n   |\n\
    13 |                 || s.as_bytes()[0] == b'o'\n   |                      ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `as_bytes` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp1t8rjr_3.rs:14:22\n   |\n\
    14 |                 || s.as_bytes()[0] == b'u'\n   |                      ^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 7 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    for word in sentence {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprylu7r9k.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut boredoms = vec![\"I\"\
    ];\n    for word in S.split_whitespace() {\n        if boredoms.contains(&word)\
    \ {\n            count += 1;\n        } else {\n            boredoms.push(word);\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `2`', /tmp/tmpqixu0oma.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    return boredoms;\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpv6uhwby9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n \
    \   while i < S.len() {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpbzuag5_d.rs:9:12\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \    ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpbzuag5_d.rs:9:27\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                   ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpbzuag5_d.rs:9:42\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                                  ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n   "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence =\
    \ String::new();\n    let mut word = String::new();\n    let mut is_bored = false;\n\
    \    for c in S.chars() {\n        if c == '.' || c == '?' || c == '!' {\n   \
    \         boredoms += 1;\n            sentence.push_str(&sentence);\n        \
    \    word.push_str(&word);\n            sentence = String::new();\n          \
    \  word = String::new();\n        }\n        if c == 'I' {\n            is_bored\
    \ = true;\n        }\n        if !is_bored {\n            sentence.push_str(&sentence);\n\
    \            word.push_str(&word);\n        }\n    }\n    boredoms += 1;\n   \
    \ sentence.push_str(&sentence);\n    word.push_str(&word);\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `sentence` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpnn79bjv6.rs:13:13\n   |\n13 |             sentence.push_str(&sentence);\n\
    \   |             ^^^^^^^^^--------^---------^\n   |             |        |  \
    \      |\n   |             |        |        immutable borrow occurs here\n  \
    \ |             |        immutable borrow later used by call\n   |           \
    \  mutable borrow occurs here\n\nerror[E0502]: cannot borrow `word` as mutable\
    \ because it is also borrowed as immutable\n  --> /tmp/tmpnn79bjv6.rs:14:13\n\
    \   |\n14 |             word.push_str(&word);\n   |             ^^^^^--------^-----^\n\
    \   |             |    |        |\n   |             |    |        immutable borrow\
    \ occurs here\n   |             |    immutable borrow later used by call\n   |\
    \             mutable borrow occurs here\n\nerror[E0502]: cannot borrow `sentence`\
    \ as mutable because it is also borrowed as immutable\n  --> /tmp/tmpnn79bjv6.rs:22:13\n\
    \   |\n22 |             sentence.push_str(&sentence);\n   |             ^^^^^^^^^--------^---------^\n\
    \   |             |        |        |\n   |             |        |        immutable\
    \ borrow occurs here\n   |             |        immutable borrow later used by\
    \ call\n   |             mutable borrow occurs here\n\nerror[E0502]: cannot borrow\
    \ `word` as mutable because it is also borrowed as immutable\n  --> /tmp/tmpnn79bjv6.rs:23:13\n\
    \   |\n23 |             word.push_str(&word);\n   |             ^^^^^--------^-----^\n\
    \   |             |    |        |\n   |             |    |        immutable borrow\
    \ occurs here\n   |             |    immutable borrow later used by call\n   |\
    \             mutable borrow occurs here\n\nerror[E0502]: cannot borrow `sentence`\
    \ as mutable because it is also borrowed as immutable\n  --> /tmp/tmpnn79bjv6.rs:27:5\n\
    \   |\n27 |     sentence.push_str(&sentence);\n   |     ^^^^^^^^^--------^---------^\n\
    \   |     |        |        |\n   |     |        |        immutable borrow occurs\
    \ here\n   |     |        immutable borrow later used by call\n   |     mutable\
    \ borrow occurs here\n\nerror[E0502]: ca"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            if\
    \ s[i] == \"I\" {\n                boredoms += 1;\n            }\n           \
    \ i += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpokiybveu.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            cnt += 1;\n        }\n\
    \    }\n    cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp53c51vze.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut boredom_words:\
    \ Vec<String> = vec![];\n    let mut boredom_sentences: Vec<String> = vec![];\n\
    \    let mut boredom_word: String;\n    let mut boredom_sentence: String;\n  \
    \  for word in S.split() {\n        if word.starts_with(\"I\") {\n           \
    \ boredoms += 1;\n            boredom_words.push(word);\n        } else {\n  \
    \          boredom_sentences.push(word);\n        }\n    }\n    for sentence in\
    \ boredom_sentences {\n        for word in sentence.split() {\n            if\
    \ word.starts_with(\"I\") {\n                boredoms += 1;\n                boredom_words.push(word);\n\
    \            }\n        }\n    }\n    for word in boredom_words {\n        for\
    \ sentence in boredom_sentences {\n            if word == sentence {\n       \
    \         boredoms += 1;\n            }\n        }\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpih31nfrs.rs:11:19\n     |\n11   |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpih31nfrs.rs:14:32\n\
    \   |\n14 |             boredom_words.push(word);\n   |                      \
    \          ^^^^- help: try using a conversion method: `.to_string()`\n   |   \
    \                             |\n   |                                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpih31nfrs.rs:16:36\n\
    \   |\n16 |             boredom_sentences.push(word);\n   |                  \
    \                  ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                    |\n   |                             \
    \       expected struct `String`, found `&str`\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpih31nfrs.rs:20:30\n\
    \     |\n20   |         for word in sentence.split() {\n     |               \
    \               ^^^^^- supplied 0 arguments\n     |                          \
    \    |\n     |                              expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpih31nfrs.rs:23:36\n\
    \   |\n23 |                 boredom_words.push(word);\n   |                  \
    \                  ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                    |\n   |                             \
    \       expected struct `String`, found `&str`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence =\
    \ String::new();\n    let mut words = String::new();\n    let mut delimiters =\
    \ vec![\".\", \"?\", \"!\"];\n    \n    for c in S.chars() {\n        if delimiters.contains(&c)\
    \ {\n            if sentence.len() > 0 {\n                boredoms += 1;\n   \
    \             sentence = String::new();\n            }\n        } else {\n   \
    \         sentence += &c;\n        }\n    }\n    \n    if sentence.len() > 0 {\n\
    \        boredoms += 1;\n    }\n    \n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnbvhe88p.rs:12:32\n   |\n\
    12 |         if delimiters.contains(&c) {\n   |                              \
    \  ^^ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnbvhe88p.rs:18:25\n   |\n18 |             sentence += &c;\n   |    \
    \                     ^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut boredoms = Vec::new();\n\
    \    for word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n\
    \            count += 1;\n        } else {\n            boredoms.push(word);\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpdphi5zet.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    for word in sentence {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    return boredoms;\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnhmz8_ry.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            if\
    \ s[i] == \"I\" {\n                boredoms += 1;\n            }\n           \
    \ i += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpokiybveu.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            if\
    \ s[i] == \"I\" {\n                boredoms += 1;\n            }\n           \
    \ i += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpokiybveu.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdbm1jy3n.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdbm1jy3n.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdbm1jy3n.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut boredom = false;\n \
    \   for c in S.chars() {\n        if c == '.' || c == '?' || c == '!' {\n    \
    \        boredom = true;\n        }\n        if boredom {\n            count +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpp0foxtpl.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk3ll6e74.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk3ll6e74.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdbm1jy3n.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdbm1jy3n.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdbm1jy3n.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp58c34mac.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut s = S;\n    while !s.is_empty()\
    \ {\n        if s.starts_with(\"I\") {\n            count += 1;\n        }\n \
    \       s = s.trim_end();\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7tmtqkg6.rs:12:13\n   |\n\
    7  |     let mut s = S;\n   |                 - expected due to this value\n...\n\
    12 |         s = s.trim_end();\n   |             ^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |             |\n   |             expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdbm1jy3n.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdbm1jy3n.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdbm1jy3n.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n \
    \   while i < S.len() {\n        if S[i] == 'I' {\n            i += 1;\n     \
    \       while i < S.len() {\n                if S[i] == '.' || S[i] == '?' ||\
    \ S[i] == '!' {\n                    i += 1;\n                } else {\n     \
    \               break;\n                }\n            }\n            boredoms\
    \ += 1;\n        } else {\n            i += 1;\n        }\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpul0s7auu.rs:9:12\n\
    \  |\n9 |         if S[i] == 'I' {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpul0s7auu.rs:12:20\n\
    \   |\n12 |                 if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n \
    \  |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpul0s7auu.rs:12:35\n\
    \   |\n12 |                 if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n \
    \  |                                   ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n  "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    let mut s = S.to_string();\n \
    \   while !s.is_empty() {\n        if s.starts_with(\"I\") {\n            cnt\
    \ += 1;\n        }\n        s = s.next();\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp6guvnrdz.rs:12:15\n   |\n12 |         s = s.next();\n \
    \  |               ^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut is_bored =\
    \ false;\n    for word in S.split() {\n        if word.starts_with(\"I\") {\n\
    \            boredoms += 1;\n        }\n    }\n    return boredoms;\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp645ziyuu.rs:8:19\n     |\n8    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n \
    \   while i < S.len() {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            boredoms += 1;\n     \
    \   }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpbzuag5_d.rs:9:12\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \    ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpbzuag5_d.rs:9:27\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                   ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpbzuag5_d.rs:9:42\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                                  ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n   "
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n \
    \   while i < S.len() {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!'\
    \ {\n            i += 1;\n        } else {\n            if S[i] == 'I' {\n   \
    \             i += 1;\n                boredoms += 1;\n            }\n       \
    \ }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n  \
    \  assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmppsn202dw.rs:9:12\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \    ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmppsn202dw.rs:9:27\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                   ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmppsn202dw.rs:9:42\n\
    \  |\n9 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n  |        \
    \                                  ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n   "
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut boredoms = Vec::new();\n\
    \    for word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n\
    \            count += 1;\n            boredoms.push(word);\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp1ucd5b3k.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n \
    \   while i < S.len() {\n        if S[i] == 'I' {\n            i += 1;\n     \
    \       if S[i] == '.' {\n                i += 1;\n                while S[i]\
    \ != '!' {\n                    i += 1;\n                }\n                i\
    \ += 1;\n            }\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmphplr2m0r.rs:9:12\n\
    \  |\n9 |         if S[i] == 'I' {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphplr2m0r.rs:11:16\n\
    \   |\n11 |             if S[i] == '.' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphplr2m0r.rs:13:23\n   |\n13 |                 while S[i] != '!'\
    \ {\n   |                       ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nFor m"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    while s.len() > 0 {\n        let mut i = s.find('I');\n        if i == s.len()\
    \ {\n            break;\n        }\n        if s.starts_with(\"I\") {\n      \
    \      boredoms += 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1r9p7fi5.rs:10:17\n   |\n\
    10 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n10 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmp1r9p7fi5.rs:16:14\n\
    \   |\n16 |         s = &s[i..];\n   |              ^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1r9p7fi5.rs:16:13\n\
    \   |\n7  |     let mut s = S.to_string();\n   |                 -------------\
    \ expected due to this value\n...\n16 |         s = &s[i..];\n   |           \
    \  ^^^^^^^ expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\nhelp: consider removing the\
    \ borrow\n   |\n16 -         s = &s[i..];\n16 +         s = s[i..];\n   | \n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    while s.len() > 0 {\n        let mut i = s.find('i');\n        if i == s.len()\
    \ {\n            break;\n        }\n        let mut j = s.find('i', i + 1);\n\
    \        if j == s.len() {\n            break;\n        }\n        if s[j] ==\
    \ '.' || s[j] == '?' || s[j] == '!' {\n            boredoms += 1;\n        }\n\
    \        s = &s[i..j];\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8qpu1szg.rs:10:17\n   |\n\
    10 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n10 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp8qpu1szg.rs:13:35\n\
    \   |\n13 |         let mut j = s.find('i', i + 1);\n   |                    \
    \             - ^ - {integer}\n   |                                 |\n   |  \
    \                               Option<usize>\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmp8qpu1szg.rs:13:23\n\
    \     |\n13   |         let mut j = s.find('i', i + 1);\n     |              \
    \         ^^^^ ---  ----- supplied 2 arguments\n     |                       |\n\
    \     |                       expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8qpu1szg.rs:14:17\n\
    \   |\n14 |         if j == s.len() {\n   |                 ^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n14 |         if j == Some(s.len()) {\n   |                 +++++      \
    \ +\n\nerror[E0277]: the type `String` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmp8qpu1szg.rs:17:12\n   |\n17 |         if s[j] == '.' || s[j] ==\
    \ '?' || s[j] == '!' {\n   |            ^^^^ `String` cannot be indexed by `Option<usize>`\n\
    \   |\n   = help: the trait `Index<Option<usize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<u"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for word in S.split() {\n    \
    \    if word.starts_with(\"I\") {\n            cnt += 1;\n        }\n    }\n \
    \   cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpwfs9ekra.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    while s.len() > 0 {\n        let mut i = s.find('i');\n        if i == s.len()\
    \ {\n            break;\n        }\n        if s[i] == '.' || s[i] == '?' || s[i]\
    \ == '!' {\n            boredoms += 1;\n            s = &s[i..];\n        } else\
    \ {\n            break;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1wt9o4rv.rs:10:17\n   |\n\
    10 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n10 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `Option<usize>`\n  --> /tmp/tmp1wt9o4rv.rs:13:12\n\
    \   |\n13 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `Option<usize>`\n   |\n   = help: the\
    \ trait `Index<Option<usize>>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `Option<usize>`\n  --> /tmp/tmp1wt9o4rv.rs:13:27\n\
    \   |\n13 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \                      ^^^^ `String` cannot be indexed by `Option<usize>`\n  \
    \ |\n   = help: the trait `Index<Option<usize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmp1wt9o4rv.rs:13:42\n   |\n13 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot b"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            if\
    \ s[i] == 'I' {\n                boredoms += 1;\n            }\n            i\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppp7e8rpl.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppp7e8rpl.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppp7e8rpl.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk3ll6e74.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk3ll6e74.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\")\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpmm6w5w00.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2662z3n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            if\
    \ s[i] == \"I\" {\n                boredoms += 1;\n            }\n           \
    \ i += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpokiybveu.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwo1xj_q7.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwo1xj_q7.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwo1xj_q7.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp58c34mac.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    while s.len() > 0 {\n        if s.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n        s = s.trim_end().to_string();\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009147
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for s in S.chars() {\n       \
    \ if s.is_ascii_lowercase() {\n            if s.starts_with(\"i\") {\n       \
    \         cnt += 1;\n            }\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n --> /tmp/tmpo2kh6345.rs:9:18\n  |\n9 |             if s.starts_with(\"\
    i\") {\n  |                  ^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut boredom = false;\n \
    \   for word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n\
    \            boredom = true;\n        }\n        if boredom {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `0`', /tmp/tmpfk4dl12g.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut boredom_words:\
    \ Vec<String> = vec![];\n    let mut boredom_word_count: Vec<usize> = vec![];\n\
    \    for word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n\
    \            boredoms += 1;\n            boredom_words.push(word);\n         \
    \   boredom_word_count.push(1);\n        } else {\n            boredom_word_count[boredom_words.iter().position(|&x|\
    \ x == word).unwrap()] += 1;\n        }\n    }\n    boredoms * boredom_word_count.iter().sum::<usize>()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2n3exbnj.rs:12:32\n   |\n\
    12 |             boredom_words.push(word);\n   |                             \
    \   ^^^^- help: try using a conversion method: `.to_string()`\n   |          \
    \                      |\n   |                                expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2n3exbnj.rs:18:16\n\
    \   |\n18 |     boredoms * boredom_word_count.iter().sum::<usize>()\n   |    \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot multiply `isize` by `usize`\n  --> /tmp/tmp2n3exbnj.rs:18:14\n\
    \   |\n18 |     boredoms * boredom_word_count.iter().sum::<usize>()\n   |    \
    \          ^ no implementation for `isize * usize`\n   |\n   = help: the trait\
    \ `Mul<usize>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n    \
    \         <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n      \
    \       <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n          \
    \   <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n             <&'a\
    \ isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence =\
    \ S.to_string();\n    let mut i = 0;\n    while i < sentence.len() {\n       \
    \ if sentence[i] == '.' || sentence[i] == '?' || sentence[i] == '!' {\n      \
    \      boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp954b3udg.rs:10:12\n\
    \   |\n10 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp954b3udg.rs:10:34\n   |\n10 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp954b3udg.rs:10:56\n   |\n10 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp58c34mac.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut is_bored =\
    \ false;\n    for word in S.split() {\n        if word.starts_with(\"I\") {\n\
    \            boredoms += 1;\n        } else {\n            is_bored = true;\n\
    \        }\n    }\n    if is_bored {\n        boredoms\n    } else {\n       \
    \ 0\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpaex4365a.rs:8:19\n     |\n8    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    return boredoms;\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp4idexdmd.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut count = 0;\n    for word in S.split() {\n  \
    \      if word.starts_with(\"I\") {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp46h8pk2d.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwo1xj_q7.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwo1xj_q7.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwo1xj_q7.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmptq6qsrr0.rs:7:19\n     |\n7    |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            cnt += 1;\n        }\n\
    \    }\n    cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp53c51vze.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for w in S.split_whitespace()\
    \ {\n        if w == \"I\" {\n            cnt += 1;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp98sce639.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence:\
    \ Vec<&str> = S.split_whitespace();\n    let mut i: usize = 0;\n    while i <\
    \ sentence.len() {\n        if sentence[i] == \"I\" {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpw9d1mvd5.rs:7:35\n  |\n7 |\
    \     let mut sentence: Vec<&str> = S.split_whitespace();\n  |               \
    \        ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n  |                       |\n  |                       expected\
    \ due to this\n  |\n  = note: expected struct `Vec<&str>`\n             found\
    \ struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms\
    \ += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwo1xj_q7.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwo1xj_q7.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwo1xj_q7.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms += 1;\n      \
    \  }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpayo_umd5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:28\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                            ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:40\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                        ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9c6mwj06.rs:6:52\n\
    \  |\n6 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() +\
    \ 1\n  |                                                    ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9c6mwj06.rs:6:5\n\
    \  |\n5 | fn is_bored(S: String) -> isize {\n  |                           -----\
    \ expected `isize` because of return type\n6 |     S.chars().filter(|c| c == '.'\
    \ || c == '?' || c == '!').count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n6 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n  |\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747086
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n            i += 1;\n        } else {\n            if\
    \ s[i] == \"I\" {\n                boredoms += 1;\n            }\n           \
    \ i += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpokiybveu.rs:10:12\n\
    \   |\n10 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:27\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokiybveu.rs:10:42\n   |\n10 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    let mut sentence =\
    \ String::new();\n    let mut word = String::new();\n    let mut delimiter = String::new();\n\
    \    let mut i = 0;\n    while i < S.len() {\n        sentence = S.split_whitespace()[i];\n\
    \        word = sentence.split_whitespace()[0];\n        delimiter = word.split_whitespace()[1];\n\
    \        if delimiter == \"?\" || delimiter == \"!\" {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpfsc40x1h.rs:12:20\n   |\n12 |         sentence = S.split_whitespace()[i];\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpfsc40x1h.rs:13:16\n\
    \   |\n13 |         word = sentence.split_whitespace()[0];\n   |             \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmpfsc40x1h.rs:14:21\n   |\n14 | \
    \        delimiter = word.split_whitespace()[1];\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\nfn is_bored(S:\
    \ String) -> isize {\n    let mut boredoms: isize = 0;\n    for s in S.split()\
    \ {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp9msq30bh.rs:7:16\n     |\n7    |     for s in S.split() {\n \
    \    |                ^^^^^- supplied 0 arguments\n     |                |\n \
    \    |                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009142
