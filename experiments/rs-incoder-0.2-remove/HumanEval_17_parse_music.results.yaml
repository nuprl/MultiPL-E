language: rs
name: HumanEval_17_parse_music
results:
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ notes_len: usize = 0;\n    let mut current_note = 0;\n    let mut current_beat\
    \ = 0;\n    let mut current_note_len = 0;\n    let mut current_beat_len = 0;\n\
    \    let mut current_note_beat_len = 0;\n    let mut current_note_beat_len2 =\
    \ 0;\n    let mut current_note_beat_len3 = 0;\n    let mut current_note_beat_len4\
    \ = 0;\n    let mut current_note_beat_len5 = 0;\n    let mut current_note_beat_len6\
    \ = 0;\n    let mut current_note_beat_len7 = 0;\n    let mut current_note_beat_len8\
    \ = 0;\n    let mut current_note_beat_len9 = 0;\n    let mut current_note_beat_len10\
    \ = 0;\n    let mut current_note_beat_len11 = 0;\n    let mut current_note_beat_len12\
    \ = 0;\n    let mut current_note_beat_len13 = 0;\n    let mut current_note_beat_len14\
    \ = 0;\n    let mut current_note_beat_len15 = 0;\n    let mut current_note_beat_len16\
    \ = 0;\n    let mut current_note_beat_len17 = 0;\n    let mut current_note_beat_len18\
    \ = 0;\n    let mut current_note_beat_len19 = 0;\n    let mut current_note_beat_len20\
    \ = 0;\n    let mut current_note_beat_len21 = 0;\n    let mut current_note_beat_len22\
    \ = 0;\n    let mut current_note_beat_len23 = 0;\n    let mut current_note_beat_len24\
    \ = 0;\n    let mut current_note_beat_len25 = 0;\n    let mut current_note_beat_len26\
    \ = 0;\n    let mut current_note_beat_len27 = 0;\n    let mut current_note_beat_len28\
    \ = 0;\n    let mut current_note_beat_len29 = 0;\n    let mut current_note_beat_len30\
    \ = 0;\n    let mut current_note_beat_len31 = 0;\n    let mut current_note_beat_len32\
    \ = 0;\n    let mut current_note_beat_len33 = 0;\n    let mut current_note_beat_len34\
    \ = 0;\n    let mut current_note_beat_len35 = 0;\n    let mut current_note_beat_len36\
    \ = 0;\n    let mut current_note_beat_len37 = 0;\n    let mut current_note_beat_len38\
    \ = 0;\n    let mut current_note_beat_len39 = 0;\n    let mut current_note_beat_len40\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbb9jmf6w.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut music_str: String = music_string;\n    let mut music_char: char;\n\
    \    let mut music_beats: isize = 0;\n    let mut music_notes: isize = 0;\n  \
    \  let mut music_last_char: char;\n    let mut music_last_beats: isize = 0;\n\
    \    let mut music_last_notes: isize = 0;\n    let mut music_last_last_char: char;\n\
    \    let mut music_last_last_beats: isize = 0;\n    let mut music_last_last_notes:\
    \ isize = 0;\n    let mut music_last_last_last_char: char;\n    let mut music_last_last_last_beats:\
    \ isize = 0;\n    let mut music_last_last_last_notes: isize = 0;\n    let mut\
    \ music_last_last_last_last_char: char;\n    let mut music_last_last_last_last_beats:\
    \ isize = 0;\n    let mut music_last_last_last_last_notes: isize = 0;\n    let\
    \ mut music_last_last_last_last_last_char: char;\n    let mut music_last_last_last_last_last_beats:\
    \ isize = 0;\n    let mut music_last_last_last_last_last_notes: isize = 0;\n \
    \   let mut music_last_last_last_last_last_last_char: char;\n    let mut music_last_last_last_last_last_last_beats:\
    \ isize = 0;\n    let mut music_last_last_last_last_last_last_notes: isize = 0;\n\
    \    let mut music_last_last_last_last_last_last_last_char: char;\n    let mut\
    \ music_last_last_last_last_last_last_last_beats: isize = 0;\n    let mut music_last_last_last_last_last_last_last_notes:\
    \ isize = 0;\n    let mut music_last_last_last_last_last_last_last_last_char:\
    \ char;\n    let mut music_last_last_last_last_last_last_last_last_beats: isize\
    \ = 0;\n    let mut music_last_last_last_last_last_last_last_last_notes: isize\
    \ = 0;\n    let mut music_last_last_last_last_last_last_last_last_last_char: char;\n\
    \    let mut music_last_last_last_last_last_last_last_last_last_beats: isize =\
    \ 0;\n    let mut music_last_last_last_last_last_last_last_last_last_notes: isize\
    \ = 0;\n    let mut music_last_last_last_last_last_last_last_last_last_last_char:\
    \ char;\n    let mut music_last_last_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_b7lnfbu.rs:42:29\n   |\n\
    42 |     let mut music_last_last_\n   |                             ^ help: add\
    \ `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp_b7lnfbu.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ c)| c == 'o' || c == '|' || c == '.').collect::<Vec<_>>();\n    for note in\
    \ notes {\n        let mut beat = 0;\n        let mut note = note.1;\n       \
    \ while note != 'o' && note != '|' && note != '.' {\n            beat += 1;\n\
    \            note += 1;\n        }\n        beats.push(beat);\n    }\n    return\
    \ beats;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4j322lka.rs:10:72\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c == 'o' || c == '|' || c == '.').collect::<Vec<_>>();\n   |               \
    \                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4j322lka.rs:10:84\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c == 'o' || c == '|' || c == '.').collect::<Vec<_>>();\n   |               \
    \                                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4j322lka.rs:10:96\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c == 'o' || c == '|' || c == '.').collect::<Vec<_>>();\n   |               \
    \                                                                            \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `char`\n  --> /tmp/tmp4j322lka.rs:16:13\n   |\n\
    16 |             note += 1;\n   |             ----^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `char`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes: Vec<isize> = vec![];\n    let mut\
    \ beats: Vec<isize> = vec![];\n    let mut current_note = String::new();\n   \
    \ let mut current_beat = String::new();\n    let mut current_beats: isize = 0;\n\
    \    let mut current_notes: isize = 0;\n    let mut current_notes_beats: isize\
    \ = 0;\n    let mut current_notes_beats_beats: isize = 0;\n    let mut current_notes_beats_beats_beats:\
    \ isize = 0;\n    let mut current_notes_beats_beats_beats_beats: isize = 0;\n\
    \    let mut current_notes_beats_beats_beats_beats_beats: isize = 0;\n    let\
    \ mut current_notes_beats_beats_beats_beats_beats_beats: isize = 0;\n    let mut\
    \ current_notes_beats_beats_beats_beats_beats_beats_beats: isize = 0;\n    let\
    \ mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats: isize = 0;\n\
    \    let mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats: isize\
    \ = 0;\n    let mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut current_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut current_notes_beats_beats_beats_beats_beats_beats_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8y818o09.rs:32:63\n   |\n\
    32 |     let mut current_notes_beats_beats_beats_beats_beats_beats_\n   |    \
    \                                                           ^ help: add `;` here\n\
    33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8y818o09.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut notes: Vec<&str> = music_string.split(\"|\").collect();\n    for note\
    \ in notes {\n        let mut note_string = note.trim();\n        let mut beats:\
    \ isize = 0;\n        let mut last_note = false;\n        while note_string.len()\
    \ > 0 {\n            let mut note = note_string[0];\n            note_string =\
    \ note_string.split_whitespace().collect();\n            if note == \"o\" {\n\
    \                beats = 4;\n                last_note = true;\n            }\
    \ else if note == \"o|\" {\n                beats = 2;\n                last_note\
    \ = true;\n            } else if note == \".|\" {\n                beats = 1;\n\
    \                last_note = true;\n            } else if note == \".\" {\n  \
    \              beats = 0;\n                last_note = false;\n            } else\
    \ {\n                panic!(\"Invalid note '{}'\", note);\n            }\n   \
    \         music_vec.push(beats);\n        }\n        if last_note {\n        \
    \    music_vec.push(4);\n        }\n    }\n    music_vec\n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpq5e7zbs6.rs:16:28\n\
    \   |\n16 |             let mut note = note_string[0];\n   |                 \
    \           ^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `{integer}`\n   = note: you\
    \ can use `.chars().nth()` or `.bytes().nth()`\n           for more information,\
    \ see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = note: required because of the requirements on the impl of `Index<{integer}>`\
    \ for `str`\n\nerror[E0277]: a value of type `&str` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpq5e7zbs6.rs:17:58\n   |\n17 |  \
    \           note_string = note_string.split_whitespace().collect();\n   |    \
    \                                                      ^^^^^^^ value of type `&str`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the\
    \ trait `FromIterator<&str>` is not implemented for `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_char = 0;\n    let mut current_note_char_len\
    \ = 0;\n    let mut current_note_char_value = 0;\n    let mut current_note_char_next_value\
    \ = 0;\n    let mut current_note_char_next_next_value = 0;\n    let mut current_note_char_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_value = 0;\n    let\
    \ mut current_note_char_next_next_next_next_next_value = 0;\n    let mut current_note_char_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_next_next_next_next_value\
    \ = 0;\n    let mut current_note_char_next_next_next_next_next_next_next_\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0ce243wk.rs:41:66\n   |\n\
    41 |     let mut current_note_char_next_next_next_next_next_next_next_\n   | \
    \                                                                 ^ help: add\
    \ `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp0ce243wk.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    let mut current_note_index = 0;\n    let mut current_beat_length\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5urpqlei.rs:61:26\n   |\n\
    61 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp5urpqlei.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.last().unwrap();\n    let mut current_beat = 0;\n    for\
    \ note in notes {\n        if note == current_note {\n            current_beat\
    \ += 1;\n        } else {\n            beats.push(current_beat);\n           \
    \ current_beat = 1;\n            current_note = note;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpb4wn8tto.rs:14:17\n\
    \   |\n14 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = note: required because of the requirements on the impl of `PartialEq<&&str>`\
    \ for `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4wn8tto.rs:19:28\n\
    \   |\n19 |             current_note = note;\n   |                           \
    \ ^^^^ expected `&str`, found `str`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&str`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_beat = 0;\n    let mut current_len = 0;\n\
    \    let mut current_len2 = 0;\n    let mut current_len3 = 0;\n    let mut current_len4\
    \ = 0;\n    let mut current_len5 = 0;\n    let mut current_len6 = 0;\n    let\
    \ mut current_len7 = 0;\n    let mut current_len8 = 0;\n    let mut current_len9\
    \ = 0;\n    let mut current_len10 = 0;\n    let mut current_len11 = 0;\n    let\
    \ mut current_len12 = 0;\n    let mut current_len13 = 0;\n    let mut current_len14\
    \ = 0;\n    let mut current_len15 = 0;\n    let mut current_len16 = 0;\n    let\
    \ mut current_len17 = 0;\n    let mut current_len18 = 0;\n    let mut current_len19\
    \ = 0;\n    let mut current_len20 = 0;\n    let mut current_len21 = 0;\n    let\
    \ mut current_len22 = 0;\n    let mut current_len23 = 0;\n    let mut current_len24\
    \ = 0;\n    let mut current_len25 = 0;\n    let mut current_len26 = 0;\n    let\
    \ mut current_len27 = 0;\n    let mut current_len28 = 0;\n    let mut current_len29\
    \ = 0;\n    let mut current_len30 = 0;\n    let mut current_len31 = 0;\n    let\
    \ mut current_len32 = 0;\n    let mut current_len33 = 0;\n    let mut current_len34\
    \ = 0;\n    let mut current_len35 = 0;\n    let mut current_len36 = 0;\n    let\
    \ mut current_len37 = 0;\n    let mut current_len38 = 0;\n    let mut current_len39\
    \ = 0;\n    let mut current_len40 = 0;\n    let mut current_len41 = 1;\n    let\
    \ mut current_len42 = 1;\n    let mut current_len43 = 1;\n    let mut current_len44\
    \ = 1;\n    let mut current_len45 = 1;\n    let mut current_len46 = 1;\n    let\
    \ mut current_len47 = 1;\n    let mut current_len48 = 1;\n    let mut current_len49\
    \ = 1;\n    let mut current_len50 = 1;\n    let mut current_len51 = 1;\n    let\
    \ mut current_len52 = 1;\n    let mut current_len53 = 1;\n    let mut current_len54\
    \ = 1;\n    let mut current_len55 = 1;\n    let mut current_len56 = 1;\n    let\
    \ mut current_len57\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2qli1i1j.rs:70:26\n   |\n\
    70 |     let mut current_len57\n   |                          ^ help: add `;`\
    \ here\n71 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp2qli1i1j.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    let mut current_note\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_beats\
    \ = 0;\n    for note in notes {\n        if note.1 == 0 {\n            if last_note\
    \ != 0 {\n                beats.push(last_beat);\n            }\n            last_beat\
    \ = 0;\n            last_note = 0;\n            last_beats = 0;\n            current_note\
    \ = note.0;\n        } else {\n            if last_note != 0 {\n             \
    \   beats.push(last_beat);\n            }\n            last_beat = 0;\n      \
    \      last_note = note.0;\n            last_beats = note.1;\n            current_note\
    \ = note.0;\n        }\n    }\n    if last_note != 0 {\n        beats.push(last_beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp5g34q8es.rs:10:72\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5g34q8es.rs:16:22\n   |\n16 |         if note.1 == 0 {\n\
    \   |                      ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5g34q8es.rs:30:26\n   |\n30 |             last_beats =\
    \ note.1;\n   |                          ^^^^^^ expected integer, found `char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_length = 0;\n    let mut current_note_length_value_length_index\
    \ = 0;\n    let mut current_note_length_value_length_value = 0;\n    let mut current_note_length_value_length_value_index\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2kkcsh6c.rs:50:57\n   |\n\
    50 |     let mut current_note_length_value_length_value_value\n   |          \
    \                                               ^ help: add `;` here\n51 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2kkcsh6c.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut last_note\
    \ = notes.last().unwrap();\n    let mut last_beat = -1;\n    let mut last_beats:\
    \ isize = 0;\n    notes.iter().for_each(|note| {\n        if note == last_note\
    \ {\n            last_beats += 1;\n        } else {\n            beats.push(last_beats);\n\
    \            last_beats = 1;\n            last_note = note;\n        }\n    });\n\
    \    beats.push(last_beats);\n    beats\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpujk_qt0k.rs:11:38

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_beats: isize = 0;\n    let mut last_beats_length\
    \ = 0;\n    let mut last_beats_lengths: Vec<isize> = vec![];\n    let mut last_beats_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths: Vec<isize> = vec![];\n    let\
    \ mut last_beats_lengths_lengths_length = 0;\n    let mut last_beats_lengths_lengths_lengths:\
    \ Vec<isize> = vec![];\n    let mut last_beats_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths: Vec<isize> = vec![];\n\
    \    let mut last_beats_lengths_lengths_lengths_lengths_length = 0;\n    let mut\
    \ last_beats_lengths_lengths_lengths_lengths_lengths: Vec<isize> = vec![];\n \
    \   let mut last_beats_lengths_lengths_lengths_lengths_lengths_length = 0;\n \
    \   let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths: Vec<isize>\
    \ = vec![];\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec![];\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec![];\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec![];\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec![];\n    let mut last_\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0lugw86_.rs:34:18\n   |\n\
    34 |     let mut last_\n   |                  ^ help: add `;` here\n35 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp0lugw86_.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    for c in music_string {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == \"o\" {\n                beats.push(current_beat);\n\
    \                current_beat += 4;\n                current_note = String::new();\n\
    \                current_note_len = String::new();\n            } else if c.to_ascii_lowercase()\
    \ == \"o|\" {\n                beats.push(current_beat);\n                current_beat\
    \ += 2;\n                current_note = String::new();\n                current_note_len\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == \".|\" {\n\
    \                beats.push(current_beat);\n                current_beat += 1;\n\
    \                current_note = String::new();\n                current_note_len\
    \ = String::new();\n            } else {\n                current_note.push(c);\n\
    \                current_note_len = c.len();\n            }\n        } else {\n\
    \            if current_note.len() > 0 {\n                beats.push(current_beat);\n\
    \                current_beat += current_note_len;\n                current_note\
    \ = String::new();\n                current_note_len = String::new();\n      \
    \      }\n        }\n    }\n    beats.push(current_beat);\n    current_beat +=\
    \ current_note_len;\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmppsy9191d.rs:13:14\n\
    \    |\n13  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppsy9191d.rs:19:36\n\
    \   |\n19 |                 current_note_len = String::new();\n   |          \
    \                          ^^^^^^^^^^^^^ expected integer, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppsy9191d.rs:24:36\n   |\n24 |\
    \                 current_note_len = String::new();\n   |                    \
    \                ^^^^^^^^^^^^^ expected integer, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppsy9191d.rs:29:36\n   |\n29 |              \
    \   current_note_len = String::new();\n   |                                  \
    \  ^^^^^^^^^^^^^ expected integer, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppsy9191d.rs:39:36\n   |\n39 |                 current_note_len\
    \ = String::new();\n   |                                    ^^^^^^^^^^^^^ expected\
    \ integer, found struct `String`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_beat:\
    \ isize = 0;\n    let mut current_note = notes.first().unwrap();\n    let mut\
    \ current_note_len: isize = 0;\n    let mut last_note = notes.last().unwrap();\n\
    \    let mut last_note_len: isize = 0;\n    let mut last_beat: isize = 0;\n  \
    \  let mut last_beat_len: isize = 0;\n    while current_note != last_note {\n\
    \        if current_note_len > last_note_len() {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_len = 0;\n        }\n\
    \        if current_note_len == last_note_len() {\n            current_beat +=\
    \ 1;\n        }\n        if current_note_len > last_note_len() {\n           \
    \ current_note_len = 0;\n        }\n        if current_note_len == last_note_len()\
    \ {\n            current_note_len += 1;\n        }\n        if current_note_len\
    \ == last_note_len() {\n            current_note_len += 1;\n        }\n      \
    \  if current_note_len == last_note_len() {\n            current_note_len += 1;\n\
    \        }\n        if current_note_len == last_note_len() {\n            current_note_len\
    \ += 1;\n        }\n        if current_note_len == last_note_len() {\n       \
    \     current_note_len += 1;\n        }\n        if current_note_len == last_note_len()\
    \ {\n            current_note_len += 1;\n        }\n        if current_note_len\
    \ == last_note_len() {\n            current_note_len += 1;\n        }\n      \
    \  if current_note_len == last_note_len() {\n            current_note_len += 1;\n\
    \        }\n        if current_note_len == last_note_len() {\n            current_note_len\
    \ += 1;\n        }\n        if current_note_len == last_note_len() {\n       \
    \     current_note_len += 1;\n        }\n        if current_note_len == last_note_len()\
    \ {\n            current_note_len += 1;\n        }\n        if current_note_len\
    \ == last_note_len() {\n            current_note_len += 1;\n        }\n      \
    \  if current_note_len == last_note_len() {\n            current_note_len += 1;\n\
    \        }\n        if current_note_len == last_note_len() {\n            current_note_len\
    \ += 1;\n        }\n        if current_note_len == last_note_len() {\n       \
    \     current_note_len += 1;\n        }\n        if current_note_len == last_note_len()\
    \ {\n            current_note_len += 1;\n        }\n        if current_note_len\
    \ == last_note_len() {\n            current_note_len += 1;\n        }\n      \
    \  if current_note_len == last_note_len() {\n            current_note_len += 1;\n\
    \        }\n        if current_note\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvxdqn4yv.rs:94:3\n\
    \   |\n8  | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n18 |\
    \     while current_note != last_note {\n   |                                \
    \     - this delimiter might not be properly closed...\n...\n85 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n94 | }\n   |   ^\n\n\
    error: expected `{`, found `}`\n  --> /tmp/tmpvxdqn4yv.rs:85:1\n   |\n84 |   \
    \      if current_note\n   |         -- this `if` expression has a condition,\
    \ but no block\n85 | }\n   | ^ expected `{`\n\nerror[E0618]: expected function,\
    \ found `isize`\n  --> /tmp/tmpvxdqn4yv.rs:19:31\n   |\n15 |     let mut last_note_len:\
    \ isize = 0;\n   |         ----------------- `last_note_len` has type `isize`\n\
    ...\n19 |         if current_note_len > last_note_len() {\n   |              \
    \                 ^^^^^^^^^^^^^--\n   |                               |\n   |\
    \                               call expression requires function\n\nerror[E0618]:\
    \ expected function, found `isize`\n  --> /tmp/tmpvxdqn4yv.rs:24:32\n   |\n15\
    \ |     let mut last_note_len: isize = 0;\n   |         ----------------- `last_note_len`\
    \ has type `isize`\n...\n24 |         if current_note_len == last_note_len() {\n\
    \   |                                ^^^^^^^^^^^^^--\n   |                   \
    \             |\n   |                                call expression requires\
    \ function\n\nerror[E0618]: expected function, found `isize`\n  --> /tmp/tmpvxdqn4yv.rs:27:31\n\
    \   |\n15 |     let mut last_note_len: isize = 0;\n   |         -----------------\
    \ `last_note_len` has type `isize`\n...\n27 |         if current_note_len > last_note_len()\
    \ {\n   |                               ^^^^^^^^^^^^^--\n   |                \
    \               |\n   |                               call expression requires\
    \ function\n\nerror[E0618]: expected function, found `isize`\n  --> /tmp/tmpvxdqn4yv.rs:30:32\n\
    \   |\n15 |     let mut last_note_len: isize = 0;\n   |         -----------------\
    \ `last_note_len` has type `i"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.first().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_length = 0;\n    for note in notes {\n        if note == current_note\
    \ {\n            current_beat += 1;\n            current_length += 1;\n      \
    \  } else {\n            beats.push(current_beat);\n            current_beat =\
    \ 1;\n            current_length = 1;\n            current_note = note;\n    \
    \    }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n  \
    \  let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpjrbujdqe.rs:15:17\n\
    \   |\n15 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = note: required because of the requirements on the impl of `PartialEq<&&str>`\
    \ for `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjrbujdqe.rs:22:28\n\
    \   |\n22 |             current_note = note;\n   |                           \
    \ ^^^^ expected `&str`, found `str`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&str`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    let mut current_note_len = 0;\n    let mut current_beat_len\
    \ = 0;\n    let mut current_note_char = 0;\n    let mut current_beat_char = 0;\n\
    \    let mut current_note_char_is_octave = false;\n    let mut current_beat_char_is_octave\
    \ = false;\n    let mut current_note_char_is_note = false;\n    let mut current_beat_char_is_note\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\
    \ = false;\n    let mut current_note_char_is_rest = false;\n    let mut current_beat_char_is_rest\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptcfv0b0a.rs:58:38\n   |\n\
    58 |     let mut current_beat_char_is_rest\n   |                             \
    \         ^ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmptcfv0b0a.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = music_string.chars().map(|c| match\
    \ c {\n        'o' => 1,\n        'o|' => 2,\n        '.|' => 3,\n        _ =>\
    \ 0,\n    }).collect::<Vec<isize>>();\n    notes.sort_unstable();\n    notes.reverse();\n\
    \    notes\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpps61qbmq.rs:11:12\n\
    \   |\n11 |         'o|' => 2,\n   |            ^^^^^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n \
    \   let mut current_note_length_index2 = 0;\n    for c in music_string {\n   \
    \     if c.is_ascii() {\n            if c == 'o' {\n                if current_note_length_index\
    \ == 0 {\n                    current_note = String::new();\n                \
    \    current_note_length_index = 0;\n                    current_note_length_index2\
    \ = 0;\n                }\n                current_note.push(c);\n           \
    \     current_note_length_index += 1;\n            } else if c == '|' {\n    \
    \            if current_note_length_index2 == 0 {\n                    current_note\
    \ = String::new();\n                    current_note_length_index = 0;\n     \
    \               current_note_length_index2 = 1;\n                }\n         \
    \       current_note.push(c);\n                current_note_length_index += 1;\n\
    \            } else if c == '.' {\n                if current_note_length_index2\
    \ == 0 {\n                    current_note = String::new();\n                \
    \    current_note_length_index = 0;\n                    current_note_length_index2\
    \ = 1;\n                }\n                current_note.push(c);\n           \
    \     current_note_length_index += 1;\n            } else if c == '|' {\n    \
    \            if current_note_length_index2 == 0 {\n                    current_note\
    \ = String::new();\n                    current_note_length_index = 0;\n     \
    \               current_note_length_index2 = 1;\n                }\n         \
    \       current_note.push(c);\n                current_note_length_index += 1;\n\
    \            } else if c == '|' {\n                if current_note_length_index2\
    \ == 0 {\n                    current_note = String::new();\n                \
    \    current_note_length_index = 0;\n                    current_note_length_index2\
    \ = 1;\n                }\n                current_note.push(c);\n           \
    \     current_note_length_index += 1;\n            } else if c == '|' {\n    \
    \            if current_note_length_index2 == 0 {\n                    current_note\
    \ = String::new();\n                    current_note_length_index = 0;\n     \
    \               current_note_length_index2 = 1;\n                }\n         \
    \       current_note.push(c);\n                current_note_length_index += 1;\n\
    \            } else if c == '|' {\n                if current_note_length_index2\
    \ == 0 {\n                    current_note = String::new();\n                \
    \    current_note_length_index = 0;\n                    current_note_length_index2\
    \ = 1;\n                }\n                current_note.push(c);\n           \
    \     current_note_length_index += 1;\n            } else if c == '|' {\n    \
    \            if current_note_length_index2 == 0 {\n                    current_note\
    \ = String::new();\n                    current_note_length_index = 0;\n     \
    \               current_note_length_index2 = 1;\n                }\n         \
    \       current_note.push(c);\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8z75_zky.rs:89:3\n\
    \   |\n8  | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n15 |\
    \     for c in music_string {\n   |                           - unclosed delimiter\n\
    16 |         if c.is_ascii() {\n   |                         - unclosed delimiter\n\
    ...\n73 |             } else if c == '|' {\n   |                             \
    \   - this delimiter might not be properly closed...\n...\n80 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n89 | }\n   |   ^\n\n\
    error[E0277]: `String` is not an iterator\n   --> /tmp/tmp8z75_zky.rs:15:14\n\
    \    |\n15  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8z75_zky.rs:15:5\n\
    \   |\n8  |   fn parse_music(music_string: String) -> Vec<isize> {\n   |     \
    \                                      ---------- expected `Vec<isize>` because\
    \ of return type\n...\n15 | /     for c in music_string {\n16 | |         if c.is_ascii()\
    \ {\n17 | |             if c == 'o' {\n18 | |                 if current_note_length_index\
    \ == 0 {\n...  |\n88 | |     assert_eq!(candidate(String::from(\"o| .| o| .| o\
    \ o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n89 | | }\n   | |__^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_octave\
    \ = 0;\n    let mut current_length = 0;\n    let mut current_note_is_octave =\
    \ false;\n    let mut current_note_is_length = false;\n\n    for c in music_string\
    \ {\n        if c == 'o' {\n            if current_note_is_octave {\n        \
    \        println!(\"Invalid music string: note {} is octave {} but octave was\
    \ already set\", current_note, current_octave);\n                return beats;\n\
    \            }\n            current_note_is_octave = true;\n            current_octave\
    \ = 0;\n            current_length = 0;\n            current_note_is_length =\
    \ false;\n            current_note = String::new();\n            current_note_is_length\
    \ = true;\n            current_beat = 0;\n        } else if c == '|' {\n     \
    \       if current_note_is_length {\n                println!(\"Invalid music\
    \ string: note {} is length {} but length was already set\", current_note, current_length);\n\
    \                return beats;\n            }\n            current_note_is_length\
    \ = true;\n            current_length = 0;\n            current_note_is_octave\
    \ = false;\n            current_note = String::new();\n            current_note_is_octave\
    \ = true;\n            current_beat = 0;\n        } else if c == '.' {\n     \
    \       if current_note_is_length {\n                println!(\"Invalid music\
    \ string: note {} is length {} but length was already set\", current_note, current_length);\n\
    \                return beats;\n            }\n            current_note_is_length\
    \ = true;\n            current_length = 0;\n            current_note_is_octave\
    \ = false;\n            current_note = String::new();\n            current_note_is_octave\
    \ = true;\n            current_beat = 0;\n        } else if c.is_ascii() {\n \
    \           if current_note_is_length {\n                current_length += 1;\n\
    \            } else if current_note_is_octave {\n                current_octave\
    \ += 1;\n            } else if current_note.is_empty() {\n                current_note\
    \ = c.to_ascii_lowercase();\n                current_beat = 0;\n            }\
    \ else {\n                println!(\"Invalid music string: note {} is length {},\
    \ octave {} but note was already set\", current_note, current_length, current_octave);\n\
    \                return beats;\n            }\n        } else {\n            println!(\"\
    Invalid music string: note {} is length {}, octave {} but note was already set\"\
    , current_note, current_length, current_octave);\n            return beats;\n\
    \        }\n    }\n\n    if current_note_is_length {\n        println!(\"Invalid\
    \ music string: note {} is length {}, octave {} but note was already set\", current_note,\
    \ \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpiy3agwui.rs:81:3\n\
    \   |\n8  | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n70 |\
    \     if current_note_is_length {\n   |                               - this delimiter\
    \ might not be properly closed...\n71 |         println!(\"Invalid music string:\
    \ note {} is length {}, octave {} but note was already set\", current_note, \n\
    72 | }\n   | - ...as it matches this but it has different indentation\n...\n81\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpiy3agwui.rs:71:17\n\
    \   |\n8  | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n71 |         println!(\"Invalid music string: note {} is length\
    \ {}, octave {} but note was already set\", current_note, \n   |             \
    \    ^ unclosed delimiter\n72 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ 3 positional arguments in format string, but there is 1 argument\n  --> /tmp/tmpiy3agwui.rs:71:46\n\
    \   |\n71 |         println!(\"Invalid music string: note {} is length {}, octave\
    \ {} but note was already set\", current_note, \n   |                        \
    \                      ^^           ^^         ^^                            ------------\n\
    \nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpiy3agwui.rs:17:14\n\
    \    |\n17  |     for c in music_string {\n    |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpiy3agwui.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression"
  stdout: ''
  timestamp: 1659749153
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octoct = 0;\n    let mut current_note_octoctlen\
    \ = 0;\n    let mut current_note_octoctoctlen = 0;\n    let mut current_note_octoctoctoct\
    \ = 0;\n    let mut current_note_octoctoctoctlen = 0;\n    let mut current_note_octoctoctoctoct\
    \ = 0;\n    let mut current_note_octoctoctoctlen = 0;\n    let mut current_note_octoctoctoctoct\
    \ = 0;\n    let mut current_note_octoctoctoctlen = 0;\n    let mut current_note_octoctoctoctoct\
    \ = 0;\n    let mut current_note_octoctoctoctlen = 0;\n    let mut current_note_octoctoctoctoct\
    \ = 0;\n    let mut current_note_octoctoctoctlen = 0;\n    let mut current_note_octoctoctoctoct\
    \ = 0;\n    let mut current_note_octoctoctlen = 0;\n    let mut current_note_octoctoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen = 0;\n    let mut current_note_octoctoct\
    \ = 0;\n    let mut current_note_octoctlen\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptngd0hf8.rs:57:35\n   |\n\
    57 |     let mut current_note_octoctlen\n   |                                \
    \   ^ help: add `;` here\n58 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmptngd0hf8.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    for note in notes {\n        if note != current_note {\n         \
    \   beats.push(current_beat);\n            current_beat = 0;\n            current_note\
    \ = note;\n        }\n        current_beat += 1;\n        current_length += 1;\n\
    \    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp1m90_af1.rs:15:17\n\
    \   |\n15 |         if note != current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1m90_af1.rs:18:28\n   |\n11 |     let mut current_note\
    \ = notes.last().unwrap();\n   |                            ---------------------\
    \ expected due to this value\n...\n18 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut last_note = notes.next();\n\
    \    loop {\n        let note = notes.next();\n        if note.1 == last_note.1\
    \ {\n            beats.push(note.0);\n        } else {\n            beats.push(note.1\
    \ - beats.last().unwrap());\n        }\n        last_note = note;\n    }\n   \
    \ beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `1` on type `Option<(usize, char)>`\n  --> /tmp/tmpu5cjz_j9.rs:14:17\n\
    \   |\n14 |         if note.1 == last_note.1 {\n   |                 ^\n\nerror[E0609]:\
    \ no field `1` on type `Option<(usize, char)>`\n  --> /tmp/tmpu5cjz_j9.rs:14:32\n\
    \   |\n14 |         if note.1 == last_note.1 {\n   |                         \
    \       ^\n\nerror[E0609]: no field `0` on type `Option<(usize, char)>`\n  -->\
    \ /tmp/tmpu5cjz_j9.rs:15:29\n   |\n15 |             beats.push(note.0);\n   |\
    \                             ^\n\nerror[E0609]: no field `1` on type `Option<(usize,\
    \ char)>`\n  --> /tmp/tmpu5cjz_j9.rs:17:29\n   |\n17 |             beats.push(note.1\
    \ - beats.last().unwrap());\n   |                             ^\n\nwarning: unreachable\
    \ expression\n  --> /tmp/tmpu5cjz_j9.rs:21:5\n   |\n12 | /     loop {\n13 | |\
    \         let note = notes.next();\n14 | |         if note.1 == last_note.1 {\n\
    15 | |             beats.push(note.0);\n...  |\n19 | |         last_note = note;\n\
    20 | |     }\n   | |_____- any code following this expression is unreachable\n\
    21 |       beats\n   |       ^^^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat: isize = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9eycnzne.rs:65:21\n   |\n\
    65 |     let mut current_\n   |                     ^ help: add `;` here\n66 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9eycnzne.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = music_string.chars().next().unwrap();\n\
    \    \n    for c in music_string.chars() {\n        if c == 'o' {\n          \
    \  beats.push(current_beat);\n            current_beat = 0;\n            current_note\
    \ = c;\n        } else if c == 'o|' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = c;\n        } else\
    \ if c == '.|' {\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = c;\n        } else {\n            current_beat\
    \ += 1;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp9vpc2qdg.rs:18:27\n\
    \   |\n18 |         } else if c == 'o|' {\n   |                           ^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_len = 0;\n   \
    \ let mut current_note_char = 0;\n    let mut current_note_char_len = 0;\n   \
    \ let mut current_note_char_index = 0;\n    let mut current_note_char_offset =\
    \ 0;\n    let mut current_note_char_offset2 = 0;\n    let mut current_note_char_offset3\
    \ = 0;\n    let mut current_note_char_offset4 = 0;\n    let mut current_note_char_offset5\
    \ = 0;\n    let mut current_note_char_offset6 = 0;\n    let mut current_note_char_offset7\
    \ = 0;\n    let mut current_note_char_offset8 = 0;\n    let mut current_note_char_offset9\
    \ = 0;\n    let mut current_note_char_offset10 = 0;\n    let mut current_note_char_offset11\
    \ = 0;\n    let mut current_note_char_offset12 = 0;\n    let mut current_note_char_offset13\
    \ = 0;\n    let mut current_note_char_offset14 = 0;\n    let mut current_note_char_offset15\
    \ = 0;\n    let mut current_note_char_offset16 = 0;\n    let mut current_note_char_offset17\
    \ = 0;\n    let mut current_note_char_offset18 = 0;\n    let mut current_note_char_offset19\
    \ = 0;\n    let mut current_note_char_offset20 = 0;\n    let mut current_note_char_offset21\
    \ = 0;\n    let mut current_note_char_offset22 = 0;\n    let mut current_note_char_offset23\
    \ = 0;\n    let mut current_note_char_offset24 = 0;\n    let mut current_note_char_offset25\
    \ = 0;\n    let mut current_note_char_offset26 = 0;\n    let mut current_note_char_offset27\
    \ = 0;\n    let mut current_note_char_offset28 = 0;\n    let mut current_note_char_offset29\
    \ = 0;\n    let mut current_note_char_offset30 = 0;\n    let mut current_note_char_offset31\
    \ = 0;\n    let mut current_note_char_offset32 = 0;\n    let mut current_note_char_offset33\
    \ = 0;\n    let mut current_note_char_offset34 = 0;\n    let mut current_note_char_offset35\
    \ = 0;\n    let mut current_note_char_offset36 = 0;\n    let mut current_note_char_offset37\
    \ = 0;\n    let mut current_note_char_offset38 = 0;\n    let mut current_note_char_offset39\
    \ = 0;\n    let mut current_note_char_offset40 = 0;\n    let mut current_note_char_offset41\
    \ = 0;\n    let mut current_note_char_offset42 = 0;\n    let mut current_note_char_offset43\
    \ = 0;\n    let mut current_note_char_offset44 = 0;\n    let mut current_note_char_offset45\
    \ = 0;\n    let mut current_note_char_offset46 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnqam6hgp.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_note_length = -1;\n    let \n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmprxdlwccb.rs:73:1\n  \
    \ |\n73 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_beats: isize = 0;\n    let mut last_beats_length\
    \ = 0;\n    let mut last_beats_length2 = 0;\n    let mut last_beats_length3 =\
    \ 0;\n    let mut last_beats_length4 = 0;\n    let mut last_beats_length5 = 0;\n\
    \    let mut last_beats_length6 = 0;\n    let mut last_beats_length7 = 0;\n  \
    \  let mut last_beats_length8 = 0;\n    let mut last_beats_length9 = 0;\n    let\
    \ mut last_beats_length10 = 0;\n    let mut last_beats_length11 = 0;\n    let\
    \ mut last_beats_length12 = 0;\n    let mut last_beats_length13 = 0;\n    let\
    \ mut last_beats_length14 = 0;\n    let mut last_beats_length15 = 0;\n    let\
    \ mut last_beats_length16 = 0;\n    let mut last_beats_length17 = 0;\n    let\
    \ mut last_beats_length18 = 0;\n    let mut last_beats_length19 = 0;\n    let\
    \ mut last_beats_length20 = 0;\n    let mut last_beats_length21 = 0;\n    let\
    \ mut last_beats_length22 = 0;\n    let mut last_beats_length23 = 0;\n    let\
    \ mut last_beats_length24 = 0;\n    let mut last_beats_length25 = 0;\n    let\
    \ mut last_beats_length26 = 0;\n    let mut last_beats_length27 = 0;\n    let\
    \ mut last_beats_length28 = 0;\n    let mut last_beats_length29 = 0;\n    let\
    \ mut last_beats_length30 = 0;\n    let mut last_beats_length31 = 0;\n    let\
    \ mut last_beats_length32 = 0;\n    let mut last_beats_length33 = 0;\n    let\
    \ mut last_beats_length34 = 0;\n    let mut last_beats_length35 = 0;\n    let\
    \ mut last_beats_length36 = 0;\n    let mut last_beats_length37 = 0;\n    let\
    \ mut last_beats_length38 = 0;\n    let mut last_beats_length39 = 0;\n    let\
    \ mut last_beats_length40 = 0;\n    let mut last_beats_length41 = 0;\n    let\
    \ mut last_beats_length42 = 0;\n    let mut last_beats_length43 = 0;\n    let\
    \ mut last_beats_length44 = 0;\n    let mut last_beats_length45 = 0;\n    let\
    \ mut last_beats_length46 = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbgzn2ce7.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != '|');\n    let\
    \ mut last_note = notes.next().unwrap();\n    let mut last_beat = 0;\n    for\
    \ note in notes {\n        if note.1 == last_note.1 {\n            last_beat =\
    \ note.0;\n        } else {\n            beats.push(last_beat - last_note.0);\n\
    \            last_beat = note.0;\n            last_note = note;\n        }\n \
    \   }\n    beats.push(last_beat - last_note.0);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0yoz8yuz.rs:10:78\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0yoz8yuz.rs:23:5\n   |\n8  | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |                                         ---------- expected\
    \ `Vec<isize>` because of return type\n...\n23 |     beats\n   |     ^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_length: usize = 0;\n    let mut\
    \ current_note = String::new();\n    let mut current_note_len = 0;\n    let mut\
    \ current_beat = 0;\n    let mut current_beat_len = 0;\n    let mut current_note_beat_len\
    \ = 0;\n    let mut current_note_beat_len2 = 0;\n    let mut current_note_beat_len3\
    \ = 0;\n    let mut current_note_beat_len4 = 0;\n    let mut current_note_beat_len5\
    \ = 0;\n    let mut current_note_beat_len6 = 0;\n    let mut current_note_beat_len7\
    \ = 0;\n    let mut current_note_beat_len8 = 0;\n    let mut current_note_beat_len9\
    \ = 0;\n    let mut current_note_beat_len10 = 0;\n    let mut current_note_beat_len11\
    \ = 0;\n    let mut current_note_beat_len12 = 0;\n    let mut current_note_beat_len13\
    \ = 0;\n    let mut current_note_beat_len14 = 0;\n    let mut current_note_beat_len15\
    \ = 0;\n    let mut current_note_beat_len16 = 0;\n    let mut current_note_beat_len17\
    \ = 0;\n    let mut current_note_beat_len18 = 0;\n    let mut current_note_beat_len19\
    \ = 0;\n    let mut current_note_beat_len20 = 0;\n    let mut current_note_beat_len21\
    \ = 0;\n    let mut current_note_beat_len22 = 0;\n    let mut current_note_beat_len23\
    \ = 0;\n    let mut current_note_beat_len24 = 0;\n    let mut current_note_beat_len25\
    \ = 0;\n    let mut current_note_beat_len26 = 0;\n    let mut current_note_beat_len27\
    \ = 0;\n    let mut current_note_beat_len28 = 0;\n    let mut current_note_beat_len29\
    \ = 0;\n    let mut current_note_beat_len30 = 0;\n    let mut current_note_beat_len31\
    \ = 0;\n    let mut current_note_beat_len32 = 0;\n    let mut current_note_beat_len33\
    \ = 0;\n    let mut current_note_beat_len34 = 0;\n    let mut current_note_beat_len35\
    \ = 0;\n    let mut current_note_beat_len36 = 0;\n    let mut current_note_beat_len37\
    \ = 0;\n    let mut current_note_beat_len38 = 0;\n    let mut current_note_beat_len39\
    \ = 0;\n    let mut current_note_beat_len40 = 0;\n    let \n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpdlt9xu7a.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|').collect::<Vec<_>>();\n\
    \    let mut last_note = notes.len() - 1;\n    let mut last_beat = 0;\n    for\
    \ note in notes {\n        if note.1 == last_note {\n            beats.push(last_beat);\n\
    \            last_beat = 0;\n            last_note = note.0;\n        } else {\n\
    \            last_beat = last_beat + 1;\n        }\n    }\n    beats.push(last_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdrdegeyu.rs:10:72\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|').collect::<Vec<_>>();\n   |                                       \
    \                                 ^^ no implementation for `&char == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdrdegeyu.rs:14:22\n   |\n14 |         if note.1 == last_note\
    \ {\n   |                      ^^^^^^^^^ expected `char`, found `usize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo4cgmw18.rs:60:32\n   |\n\
    60 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpo4cgmw18.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n \
    \   let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy8klw_fm.rs:61:1\n\
    \   |\n61 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    let mut last_note = -1;\n    let mut last_beat = -1;\n    let mut\
    \ last_length = -1;\n    while let Some(note) = notes.next() {\n        let note\
    \ = note.0;\n        let length = note.len_utf8();\n        if length == 0 {\n\
    \            // Empty note\n            current_length += 1;\n            current_note\
    \ += 1;\n            current_beat += 1;\n            last_note = -1;\n       \
    \     last_beat = -1;\n            last_length = -1;\n            continue;\n\
    \        }\n        let note = note.as_bytes();\n        let note = note.iter().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n        if note[0] == 0 {\n          \
    \  // Note is silence\n            current_length += 1;\n            current_note\
    \ += 1;\n            current_beat += 1;\n            last_note = -1;\n       \
    \     last_beat = -1;\n            last_length = -1;\n            continue;\n\
    \        }\n        if note[0] == 1 {\n            // Note is whole note\n   \
    \         current_length += 1;\n            current_note += 1;\n            current_beat\
    \ += 1;\n            last_note = -1;\n            last_beat = -1;\n          \
    \  last_length = -1;\n            continue;\n        }\n        if note[0] ==\
    \ 2 {\n            // Note is half note\n            current_length += 1;\n  \
    \          current_note += 1;\n            current_beat += 1;\n            last_note\
    \ = -1;\n            last_beat = -1;\n            last_length = -1;\n        \
    \    continue;\n        }\n        if note[0] == 3 {\n            // Note is quarter\
    \ note\n            current_length += 1;\n            current_note += 1;\n   \
    \         current_beat += 1;\n            last_note = -1;\n            last_beat\
    \ = -1;\n            last_length = -1;\n            continue;\n        }\n   \
    \     if note[0] == 4 {\n            // Note is eighth note\n            current_length\
    \ += 1;\n            current_note += 1;\n            current_beat += 1;\n    \
    \        last_note = -1;\n            last_beat = -1;\n            last_length\
    \ = -1;\n            continue;\n        }\n        if note[0] == 5 {\n       \
    \     // Note is sixteenth note\n            current_length += 1;\n          \
    \  current_note += 1;\n            current_beat += 1;\n            last_note =\
    \ -1;\n            last_beat = -1;\n            last_length = -1;\n          \
    \  continue;\n        }\n        if note[0] == 6 {\n            // Note is thirty-sixth\
    \ note\n            current_length += 1;\n            current_note += 1;\n   \
    \         current_beat += 1;\n            last_note = -1;\n            last_beat\
    \ = -1;\n            last_length = -1;\n            continue;\n        }\n   \
    \     if note[0] == 7 {\n            // Note is \n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp1eo8kxa0.rs:113:3\n\
    \    |\n8   | fn parse_music(music_string: String) -> Vec<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n17\
    \  |     while let Some(note) = notes.next() {\n    |                        \
    \                 - unclosed delimiter\n...\n102 |         if note[0] == 7 {\n\
    \    |                         - this delimiter might not be properly closed...\n\
    103 |             // Note is \n104 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n113 | }\n    |   ^\n\nerror[E0599]: no method named\
    \ `len_utf8` found for type `usize` in the current scope\n  --> /tmp/tmp1eo8kxa0.rs:19:27\n\
    \   |\n19 |         let length = note.len_utf8();\n   |                      \
    \     ^^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named `as_bytes`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmp1eo8kxa0.rs:30:25\n\
    \   |\n30 |         let note = note.as_bytes();\n   |                        \
    \ ^^^^^^^^ help: there is an associated function with a similar name: `swap_bytes`\n\
    \nerror[E0308]: mismatched types\n   --> /tmp/tmp1eo8kxa0.rs:17:5\n    |\n8  \
    \ |   fn parse_music(music_string: String) -> Vec<isize> {\n    |            \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n17  | /     while let Some(note) = notes.next() {\n18  | |      \
    \   let note = note.0;\n19  | |         let length = note.len_utf8();\n20  | |\
    \         if length == 0 {\n...   |\n112 | |     assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n113 | | }\n    | |__^\
    \ expected struct `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n\
    \            found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_octave = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_octave\
    \ = 0;\n    let mut current_note_length_to_length = 0;\n    let mut current_note_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_octave = 0;\n    let mut\
    \ current_note_length_to_length_to_length = 0;\n    let mut current_note_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_octave = 0;\n \
    \   let mut current_note_length_to_length_to_length_to_length = 0;\n    let mut\
    \ current_note_length_to_length_to_length_to_length_to_beat = 0;\n    let mut\
    \ current_note_length_to_length_to_length_to_length_to_octave = 0;\n    let mut\
    \ current_note_length_to_length_to_length_to_length_to_length = 0;\n    let mut\
    \ current_note_length_to_length_to_length_to_length_to_length_to_beat = 0;\n \
    \   let mut current_note_length_to_length_to_length_to_length_to_length_to_octave\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_octave\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_octave\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_octave\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp01i37e8u.rs:40:72\n   |\n\
    40 |     let mut current_note_length_to_length_to_length_to_length_to_length\n\
    \   |                                                                        ^\
    \ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp01i37e8u.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|&(_, c)| c != '|');\n    let mut\
    \ last_note = notes.next();\n    let mut last_beat = 0;\n    for note in notes\
    \ {\n        if note.1 == last_note.1 {\n            last_beat = note.0;\n   \
    \     } else {\n            beats.push(last_beat + 4 - last_note.0);\n       \
    \     last_beat = note.0;\n        }\n        last_note = note;\n    }\n    beats.push(last_beat\
    \ + 4 - last_note.0);\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `1` on type `Option<(usize, char)>`\n  --> /tmp/tmpruih96bu.rs:14:32\n\
    \   |\n14 |         if note.1 == last_note.1 {\n   |                         \
    \       ^\n\nerror[E0609]: no field `0` on type `Option<(usize, char)>`\n  -->\
    \ /tmp/tmpruih96bu.rs:17:50\n   |\n17 |             beats.push(last_beat + 4 -\
    \ last_note.0);\n   |                                                  ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpruih96bu.rs:20:21\n   |\n11 |     let mut last_note\
    \ = notes.next();\n   |                         ------------ expected due to this\
    \ value\n...\n20 |         last_note = note;\n   |                     ^^^^ expected\
    \ enum `Option`, found tuple\n   |\n   = note: expected enum `Option<(usize, char)>`\n\
    \             found tuple `(usize, char)`\nhelp: try wrapping the expression in\
    \ `Some`\n   |\n20 |         last_note = Some(note);\n   |                   \
    \  +++++    +\n\nerror[E0609]: no field `0` on type `Option<(usize, char)>`\n\
    \  --> /tmp/tmpruih96bu.rs:22:42\n   |\n22 |     beats.push(last_beat + 4 - last_note.0);\n\
    \   |                                          ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpruih96bu.rs:23:5\n   |\n8  | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |                                         ---------- expected\
    \ `Vec<isize>` because of return type\n...\n23 |     beats\n   |     ^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_beats_left = 0;\n \
    \   let mut current_notes_left = 0;\n    let mut current_notes_left_in_note =\
    \ 0;\n    let mut current_notes_left_in_beat = 0;\n    let mut current_notes_left_in_beats_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left = 0;\n    let mut current_notes_left_in_notes_left_in_beat\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left = 0;\n    let\
    \ mut current_notes_left_in_notes_left_in_beats_left_in_note = 0;\n    let mut\
    \ current_notes_left_in_notes_left_in_beats_left_in_notes_left = 0;\n    let mut\
    \ current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beat = 0;\n\
    \    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_note\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beat\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_note\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beat\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmfsir7z6.rs:32:111\n   |\n\
    32 |     let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_\n\
    \   |                                                                        \
    \                                       ^ help: add `;` here\n33 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmfsir7z6.rs:8:41\n  |\n\
    8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    ----------- \
    \                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |  \
    \  |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length = 0;\n    let\
    \ mut current_note_length_to_beat_with_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkxcfzr0a.rs:30:32\n   |\n\
    30 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpkxcfzr0a.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc920bqs5.rs:61:26\n   |\n\
    61 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpc920bqs5.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_octave = 0;\n    let mut current_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_length\
    \ == 0 {\n                notes.push(current_note);\n                current_note\
    \ = String::new();\n                current_length = 0;\n            }\n     \
    \       current_note.push_str(&c);\n            current_length += 1;\n       \
    \ } else if c == '|' {\n            if current_length == 0 {\n               \
    \ notes.push(current_note);\n                current_note = String::new();\n \
    \               current_length = 0;\n            }\n            current_note.push_str(&c);\n\
    \            current_length += 1;\n        } else if c == '.' {\n            if\
    \ current_length == 0 {\n                notes.push(current_note);\n         \
    \       current_note = String::new();\n                current_length = 0;\n \
    \           }\n            current_note.push_str(&c);\n            current_length\
    \ += 1;\n        } else if c == 'o|' {\n            if current_length == 0 {\n\
    \                notes.push(current_note);\n                current_note = String::new();\n\
    \                current_length = 0;\n            }\n            current_note.push_str(&c);\n\
    \            current_length += 1;\n        } else if c == '.|' {\n           \
    \ if current_length == 0 {\n                notes.push(current_note);\n      \
    \          current_note = String::new();\n                current_length = 0;\n\
    \            }\n            current_note.push_str(&c);\n            current_length\
    \ += 1;\n        } else {\n            if current_length == 0 {\n            \
    \    notes.push(current_note);\n                current_note = String::new();\n\
    \                current_length = 0;\n            }\n            current_note.push_str(&c);\n\
    \            current_length += 1;\n        }\n        if current_length == 4 {\n\
    \            beats.push(current_beat);\n            current_beat = 0;\n      \
    \      current_length = 0;\n        }\n        current_beat += 1;\n        current_octave\
    \ += 1;\n    }\n    if current_length != 0 {\n        notes.push(current_note);\n\
    \    }\n    notes\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp53qtl8wu.rs:40:27\n\
    \   |\n40 |         } else if c == 'o|' {\n   |                           ^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_count\
    \ = 0;\n    let mut last_note = notes.last().unwrap();\n    let mut last_beat\
    \ = 0;\n    let mut last_note_count = 0;\n    while current_note != last_note\
    \ {\n        if current_note == \"o\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_count += 1;\n       \
    \     last_note_count = current_note_count;\n            last_note = current_note;\n\
    \        } else if current_note == \"o|\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_count += 1;\n       \
    \     last_note_count = current_note_count;\n            last_note = current_note;\n\
    \        } else if current_note == \".|\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_count += 1;\n       \
    \     last_note_count = current_note_count;\n            last_note = current_note;\n\
    \        } else {\n            current_beat += 1;\n            current_note_count\
    \ += 1;\n            last_note_count = current_note_count;\n            last_note\
    \ = current_note;\n        }\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp2dbbfwlu.rs:18:25\n\
    \   |\n18 |         if current_note == \"o\" {\n   |                         ^^\
    \ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare `&str`\
    \ with `str`\n  --> /tmp/tmp2dbbfwlu.rs:24:32\n   |\n24 |         } else if current_note\
    \ == \"o|\" {\n   |                                ^^ no implementation for `&str\
    \ == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented for\
    \ `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmp2dbbfwlu.rs:30:32\n   |\n30 |\
    \         } else if current_note == \".|\" {\n   |                           \
    \     ^^ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as Part"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.first().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_beats: isize = 0;\n    for note in notes {\n        if note == current_note\
    \ {\n            current_beat += 1;\n        } else {\n            beats.push(current_beat);\n\
    \            current_beat = 1;\n            current_beats += 1;\n            current_note\
    \ = note;\n        }\n    }\n    beats.push(current_beats);\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpd3bhtut4.rs:15:17\n\
    \   |\n15 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd3bhtut4.rs:21:28\n   |\n11 |     let mut current_note\
    \ = notes.first().unwrap();\n   |                            ----------------------\
    \ expected due to this value\n...\n21 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    for c in music_string {\n\
    \        if c == 'o' {\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        } else if c == 'o|'\
    \ {\n            beats.push(current_beat);\n            current_beat = 0;\n  \
    \          current_note = String::new();\n        } else if c == '.|' {\n    \
    \        beats.push(current_beat);\n            current_beat = 0;\n          \
    \  current_note = String::new();\n        } else {\n            current_note.push(c);\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpy_6pta39.rs:17:27\n\
    \   |\n17 |         } else if c == 'o|' {\n   |                           ^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut notes_len:\
    \ usize = 0;\n    let mut last_note = notes.last().unwrap();\n    let mut last_note_len:\
    \ usize = 0;\n    let mut last_note_beat: usize = 0;\n    let mut last_note_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_len: usize = 0;\n    let mut last_note_beat_beat:\
    \ usize = 0;\n    let mut last_note_beat_beat_len: usize = 0;\n    let mut last_note_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_len: usize = 0;\n    let mut\
    \ last_note_beat_beat_beat_beat: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat: usize = 0;\n    let mut\
    \ last_note_beat_beat_beat_len: usize = 0;\n    let mut last_note_beat_beat_beat_beat:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_len: usize = 0;\n    let mut\
    \ last_note_beat_beat_beat_beat: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat: usize = 0;\n    let mut\
    \ last_note_beat_beat_beat_len: usize = 0;\n    let mut last_note_beat_beat_beat_beat:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_len: usize = 0;\n    let mut\
    \ last_note_beat_beat_beat_beat: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat: usize = 0;\n    let mut\
    \ last_note_beat_beat_beat_len: usize = 0;\n    let mut last_note_beat_beat_beat_beat:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_len: usize = 0;\n    let mut\
    \ last_note_beat_beat_beat_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqw5deo99.rs:41:38\n   |\n\
    41 |     let mut last_note_beat_beat_beat_\n   |                             \
    \         ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpqw5deo99.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut notes = music_string.chars().collect::<Vec<char>>();\n    let mut\
    \ current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_beat_length = 0;\n    let mut current_note_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat = 0;\n    let mut current_note_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length = 0;\n    let mut current_note_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat = 0;\n    let mut\
    \ current_note_length_to_beat_length_to_beat_length = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeu46tqas.rs:36:92\n   |\n\
    36 |     let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\n\
    \   |                                                                        \
    \                    ^ help: add `;` here\n37 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpeu46tqas.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_octave = 0;\n    let mut current_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note\
    \ != String::new() {\n                notes.push(current_note);\n            \
    \    current_note = String::new();\n            }\n            current_length\
    \ = current_beat + 4;\n            current_beat = 0;\n            current_octave\
    \ = 0;\n        } else if c == 'o|' {\n            if current_note != String::new()\
    \ {\n                notes.push(current_note);\n                current_note =\
    \ String::new();\n            }\n            current_length = current_beat + 2;\n\
    \            current_beat = 0;\n            current_octave = 1;\n        } else\
    \ if c == '.|' {\n            if current_note != String::new() {\n           \
    \     notes.push(current_note);\n                current_note = String::new();\n\
    \            }\n            current_length = current_beat;\n            current_beat\
    \ = 0;\n            current_octave = 2;\n        } else {\n            if current_note\
    \ != String::new() {\n                notes.push(current_note);\n            \
    \    current_note = String::new();\n            }\n            current_length\
    \ += 1;\n            current_beat += 1;\n            current_octave += 1;\n  \
    \      }\n    }\n    notes.push(current_note);\n    for note in notes {\n    \
    \    let mut beats_count = beats.len();\n        for _ in 0..note.len() {\n  \
    \          beats_count += 1;\n        }\n        beats.push(beats_count);\n  \
    \  }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpy8um1bro.rs:24:27\n\
    \   |\n24 |         } else if c == 'o|' {\n   |                           ^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_chars = music_string.chars();\n \
    \   let mut music_chars_iter = music_chars.clone();\n    let mut music_chars_len\
    \ = music_chars.len();\n    let mut music_chars_index = 0;\n    let mut music_chars_last_index\
    \ = 0;\n    let mut music_chars_last_char = 0;\n    let mut music_chars_last_char_beat\
    \ = 0;\n    let mut music_chars_last_char_beat_index = 0;\n    let mut music_chars_last_char_beat_index2\
    \ = 0;\n    let mut music_chars_last_char_beat_index3 = 0;\n    let mut music_chars_last_char_beat_index4\
    \ = 0;\n    let mut music_chars_last_char_beat_index5 = 0;\n    let mut music_chars_last_char_beat_index6\
    \ = 0;\n    let mut music_chars_last_char_beat_index7 = 0;\n    let mut music_chars_last_char_beat_index8\
    \ = 0;\n    let mut music_chars_last_char_beat_index9 = 0;\n    let mut music_chars_last_char_beat_index10\
    \ = 0;\n    let mut music_chars_last_char_beat_index11 = 0;\n    let mut music_chars_last_char_beat_index12\
    \ = 0;\n    let mut music_chars_last_char_beat_index13 = 0;\n    let mut music_chars_last_char_beat_index14\
    \ = 0;\n    let mut music_chars_last_char_beat_index15 = 0;\n    let mut music_chars_last_char_beat_index16\
    \ = 0;\n    let mut music_chars_last_char_beat_index17 = 0;\n    let mut music_chars_last_char_beat_index18\
    \ = 0;\n    let mut music_chars_last_char_beat_index19 = 0;\n    let mut music_chars_last_char_beat_index20\
    \ = 0;\n    let mut music_chars_last_char_beat_index21 = 0;\n    let mut music_chars_last_char_beat_index22\
    \ = 0;\n    let mut music_chars_last_char_beat_index23 = 0;\n    let mut music_chars_last_char_beat_index24\
    \ = 0;\n    let mut music_chars_last_char_beat_index25 = 0;\n    let mut music_chars_last_char_beat_index26\
    \ = 0;\n    let mut music_chars_last_char_beat_index27 = 0;\n    let mut music_chars_last_char_beat_index28\
    \ = 0;\n    let mut music_chars_last_char_beat_index29 = 0;\n    let mut music_chars_last_char_beat_index30\
    \ = 0;\n    let mut music_chars_last_char_beat_index\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4gk99j29.rs:46:45\n   |\n\
    46 |     let mut music_chars_last_char_beat_index\n   |                      \
    \                       ^ help: add `;` here\n47 | }\n   | - unexpected token\n\
    \nerror[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp4gk99j29.rs:11:43\n   |\n11 |     let mut music_chars_len\
    \ = music_chars.len();\n   |                                           ^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4gk99j29.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().collect::<Vec<char>>();\n    let mut current_note = 0;\n\
    \    let mut current_beat = 0;\n    let mut current_note_len = 0;\n    let mut\
    \ last_note_len = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n\
    \    let mut last_note_oct = 0;\n    let mut last_beat_oct = 0;\n    let mut last_note_oct2\
    \ = 0;\n    let mut last_beat_oct2 = 0;\n    let mut last_note_oct3 = 0;\n   \
    \ let mut last_beat_oct3 = 0;\n    let mut last_note_oct4 = 0;\n    let mut last_beat_oct4\
    \ = 0;\n    let mut last_note_oct5 = 0;\n    let mut last_beat_oct5 = 0;\n   \
    \ let mut last_note_oct6 = 0;\n    let mut last_beat_oct6 = 0;\n    let mut last_note_oct7\
    \ = 0;\n    let mut last_beat_oct7 = 0;\n    let mut last_note_oct8 = 0;\n   \
    \ let mut last_beat_oct8 = 0;\n    let mut last_note_oct9 = 0;\n    let mut last_beat_oct9\
    \ = 0;\n    let mut last_note_oct10 = 0;\n    let mut last_beat_oct10 = 0;\n \
    \   let mut last_note_oct11 = 0;\n    let mut last_beat_oct11 = 0;\n    let mut\
    \ last_note_oct12 = 0;\n    let mut last_beat_oct12 = 0;\n    let mut last_note_oct13\
    \ = 0;\n    let mut last_beat_oct13 = 0;\n    let mut last_note_oct14 = 0;\n \
    \   let mut last_beat_oct14 = 0;\n    let mut last_note_oct15 = 0;\n    let mut\
    \ last_beat_oct15 = 0;\n    let mut last_note_oct16 = 0;\n    let mut last_beat_oct16\
    \ = 0;\n    let mut last_note_oct17 = 0;\n    let mut last_beat_oct17 = 0;\n \
    \   let mut last_note_oct18 = 0;\n    let mut last_beat_oct18 = 0;\n    let mut\
    \ last_note_oct19 = 0;\n    let mut last_beat_oct19 = 0;\n    let mut last_note_oct20\
    \ = 0;\n    let mut last_beat_oct20 = 0;\n    let mut last_note_oct21 = 0;\n \
    \   let mut last_beat_oct21 = 0;\n    let mut last_note_oct22 = 0;\n    let mut\
    \ last_beat_oct22 = 0;\n    let mut last_note_oct23 = 0;\n    let mut last_beat_oct23\
    \ = 0;\n    let mut last_note_oct24 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz9e46iyp.rs:64:11\n   |\n\
    64 |     let mu\n   |           ^ help: add `;` here\n65 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpz9e46iyp.rs:8:41\n  |\n\
    8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    ----------- \
    \                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |  \
    \  |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_beat = 0;\n    let mut current_octave\
    \ = 0;\n    let mut current_length = 0;\n    let mut current_note_len = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_octave = 0;\n    let mut current_note_length = 0;\n \
    \   let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp60fbzizk.rs:69:11\n   |\n\
    69 |     let mu\n   |           ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp60fbzizk.rs:8:41\n  |\n\
    8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    ----------- \
    \                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |  \
    \  |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut notes_index\
    \ = 0;\n    let mut notes_len_index = 0;\n    let mut notes_len_index2 = 0;\n\
    \    let mut notes_len_index3 = 0;\n    let mut notes_len_index4 = 0;\n    let\
    \ mut notes_len_index5 = 0;\n    let mut notes_len_index6 = 0;\n    let mut notes_len_index7\
    \ = 0;\n    let mut notes_len_index8 = 0;\n    let mut notes_len_index9 = 0;\n\
    \    let mut notes_len_index10 = 0;\n    let mut notes_len_index11 = 0;\n    let\
    \ mut notes_len_index12 = 0;\n    let mut notes_len_index13 = 0;\n    let mut\
    \ notes_len_index14 = 0;\n    let mut notes_len_index15 = 0;\n    let mut notes_len_index16\
    \ = 0;\n    let mut notes_len_index17 = 0;\n    let mut notes_len_index18 = 0;\n\
    \    let mut notes_len_index19 = 0;\n    let mut notes_len_index20 = 0;\n    let\
    \ mut notes_len_index21 = 0;\n    let mut notes_len_index22 = 0;\n    let mut\
    \ notes_len_index23 = 0;\n    let mut notes_len_index24 = 0;\n    let mut notes_len_index25\
    \ = 0;\n    let mut notes_len_index26 = 0;\n    let mut notes_len_index27 = 0;\n\
    \    let mut notes_len_index28 = 0;\n    let mut notes_len_index29 = 0;\n    let\
    \ mut notes_len_index30 = 0;\n    let mut notes_len_index31 = 0;\n    let mut\
    \ notes_len_index32 = 0;\n    let mut notes_len_index33 = 0;\n    let mut notes_len_index34\
    \ = 0;\n    let mut notes_len_index35 = 0;\n    let mut notes_len_index36 = 0;\n\
    \    let mut notes_len_index37 = 0;\n    let mut notes_len_index38 = 0;\n    let\
    \ mut notes_len_index39 = 0;\n    let mut notes_len_index40 = 0;\n    let mut\
    \ notes_len_index41 = 0;\n    let mut notes_len_index42 = 0;\n    let mut notes_len_index43\
    \ = 0;\n    let mut notes_len_index44 = 0;\n    let mut notes_len_index45 = 0;\n\
    \    let mut notes_len_index46 = 0;\n    let mut notes_len_index47\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa3zblrae.rs:59:30\n   |\n\
    59 |     let mut notes_len_index47\n   |                              ^ help:\
    \ add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpa3zblrae.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut notes_len:\
    \ usize = 0;\n    let mut current_note = notes.last().unwrap();\n    let mut current_beat:\
    \ isize = 0;\n    let mut current_note_beat: isize = 0;\n    let mut current_note_len:\
    \ usize = 0;\n    let mut current_note_octave: usize = 0;\n    let mut current_note_octave_len:\
    \ usize = 0;\n    let mut current_note_octave_sign: usize = 0;\n    let mut current_note_octave_sign_index:\
    \ usize = 0;\n    let mut current_note_octave_sign_index2: usize = 0;\n    let\
    \ mut current_note_octave_sign_index3: usize = 0;\n    let mut current_note_octave_sign_index4:\
    \ usize = 0;\n    let mut current_note_octave_sign_index5: usize = 0;\n    let\
    \ mut current_note_octave_sign_index6: usize = 0;\n    let mut current_note_octave_sign_index7:\
    \ usize = 0;\n    let mut current_note_octave_sign_index8: usize = 0;\n    let\
    \ mut current_note_octave_sign_index9: usize = 0;\n    let mut current_note_octave_sign_index10:\
    \ usize = 0;\n    let mut current_note_octave_sign_index11: usize = 0;\n    let\
    \ mut current_note_octave_sign_index12: usize = 0;\n    let mut current_note_octave_sign_index13:\
    \ usize = 0;\n    let mut current_note_octave_sign_index14: usize = 0;\n    let\
    \ mut current_note_octave_sign_index15: usize = 0;\n    let mut current_note_octave_sign_index16:\
    \ usize = 0;\n    let mut current_note_octave_sign_index17: usize = 0;\n    let\
    \ mut current_note_octave_sign_index18: usize = 0;\n    let mut current_note_octave_sign_index19:\
    \ usize = 0;\n    let mut current_note_octave_sign_index20: usize = 0;\n    let\
    \ mut current_note_octave_sign_index21: usize = 0;\n    let mut current_note_octave_sign_index22:\
    \ usize = 0;\n    let mut current_note_octave_sign_index23: usize = 0;\n    let\
    \ mut current_note_octave_sign_index24: usize = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpxbj5q617.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprpx_8nv1.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp268wg133.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut current_note\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_beats\
    \ = 1;\n    let mut last_beats_index = 0;\n    let mut last_beats_index2 = 0;\n\
    \    let mut last_beats_index3 = 0;\n    let mut last_beats_index4 = 0;\n    let\
    \ mut last_beats_index5 = 0;\n    let mut last_beats_index6 = 0;\n    let mut\
    \ last_beats_index7 = 0;\n    let mut last_beats_index8 = 0;\n    let mut last_beats_index9\
    \ = 0;\n    let mut last_beats_index10 = 0;\n    let mut last_beats_index11 =\
    \ 0;\n    let mut last_beats_index12 = 0;\n    let mut last_beats_index13 = 0;\n\
    \    let mut last_beats_index14 = 0;\n    let mut last_beats_index15 = 0;\n  \
    \  let mut last_beats_index16 = 0;\n    let mut last_beats_index17 = 0;\n    let\
    \ mut last_beats_index18 = 0;\n    let mut last_beats_index19 = 0;\n    let mut\
    \ last_beats_index20 = 0;\n    let mut last_beats_index21 = 0;\n    let mut last_beats_index22\
    \ = 0;\n    let mut last_beats_index23 = 0;\n    let mut last_beats_index24 =\
    \ 0;\n    let mut last_beats_index25 = 0;\n    let mut last_beats_index26 = 0;\n\
    \    let mut last_beats_index27 = 0;\n    let mut last_beats_index28 = 0;\n  \
    \  let mut last_beats_index29 = 0;\n    let mut last_beats_index30 = 0;\n    let\
    \ mut last_beats_index31 = 0;\n    let mut last_beats_index32 = 0;\n    let mut\
    \ last_beats_index33 = 0;\n    let mut last_beats_index34 = 0;\n    let mut last_beats_index35\
    \ = 0;\n    let mut last_beats_index36 = 0;\n    let mut last_beats_index37 =\
    \ 0;\n    let mut last_beats_index38 = 0;\n    let mut last_beats_index39 = 0;\n\
    \    let mut last_beats_index40 = 0;\n    let mut last_beats_index41 = 0;\n  \
    \  let mut last_beats_index42 = 0;\n    let mut last_beats_index43 = 0;\n    let\
    \ mut last_beats_index44 = 0;\n    let mut last_beats_index45 = 0;\n    let mut\
    \ last_beats_index46 = 0;\n    let mut last_beats_index47 = 0;\n    let mut last_beats_index48\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiou6wt78.rs:61:31\n   |\n\
    61 |     let mut last_beats_index48\n   |                               ^ help:\
    \ add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpiou6wt78.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_octave = 0;\n    let mut current_length\
    \ = 0;\n    let mut current_length_index = 0;\n    let mut current_length_index2\
    \ = 0;\n    let mut current_length_index3 = 0;\n    let mut current_length_index4\
    \ = 0;\n    let mut current_length_index5 = 0;\n    let mut current_length_index6\
    \ = 0;\n    let mut current_length_index7 = 0;\n    let mut current_length_index8\
    \ = 0;\n    let mut current_length_index9 = 0;\n    let mut current_length_index10\
    \ = 0;\n    let mut current_length_index11 = 0;\n    let mut current_length_index12\
    \ = 0;\n    let mut current_length_index13 = 0;\n    let mut current_length_index14\
    \ = 0;\n    let mut current_length_index15 = 0;\n    let mut current_length_index16\
    \ = 0;\n    let mut current_length_index17 = 0;\n    let mut current_length_index18\
    \ = 0;\n    let mut current_length_index19 = 0;\n    let mut current_length_index20\
    \ = 0;\n    let mut current_length_index21 = 0;\n    let mut current_length_index22\
    \ = 0;\n    let mut current_length_index23 = 0;\n    let mut current_length_index24\
    \ = 0;\n    let mut current_length_index25 = 0;\n    let mut current_length_index26\
    \ = 0;\n    let mut current_length_index27 = 0;\n    let mut current_length_index28\
    \ = 0;\n    let mut current_length_index29 = 0;\n    let mut current_length_index30\
    \ = 0;\n    let mut current_length_index31 = 0;\n    let mut current_length_index32\
    \ = 0;\n    let mut current_length_index33 = 0;\n    let mut current_length_index34\
    \ = 0;\n    let mut current_length_index35 = 0;\n    let mut current_length_index36\
    \ = 0;\n    let mut current_length_index37 = 0;\n    let mut current_length_index38\
    \ = 0;\n    let mut current_length_index39 = 0;\n    let mut current_length_index40\
    \ = 0;\n    let mut current_length_index41 = 0;\n    let mut current_length_index42\
    \ = 0;\n    let mut current_length_index43 = 0;\n    let mut current_length_index44\
    \ = 0;\n    let mut current_length_index45 = 0;\n    let mut current_length_index46\
    \ = 0;\n    let mut current_length_index47 = 0;\n    let mut current_length_index48\
    \ = 0;\n    let mut current_length_index49 = 0;\n    let mut current_length_index50\
    \ = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9m_x963f.rs:65:21\n   |\n\
    65 |     let mut current_\n   |                     ^ help: add `;` here\n66 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9m_x963f.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut notes_length\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_length = 0;\n    let\
    \ mut current_note_len = 0;\n    let mut current_note_note_length = 0;\n    let\
    \ mut current_note_note_length2 = 0;\n    let mut current_note_note_length3 =\
    \ 0;\n    let mut current_note_note_length4 = 0;\n    let mut current_note_note_length5\
    \ = 0;\n    let mut current_note_note_length6 = 0;\n    let mut current_note_note_length7\
    \ = 0;\n    let mut current_note_note_length8 = 0;\n    let mut current_note_note_length9\
    \ = 0;\n    let mut current_note_note_length10 = 0;\n    let mut current_note_note_length11\
    \ = 0;\n    let mut current_note_note_length12 = 0;\n    let mut current_note_note_length13\
    \ = 0;\n    let mut current_note_note_length14 = 0;\n    let mut current_note_note_length15\
    \ = 0;\n    let mut current_note_note_length16 = 0;\n    let mut current_note_note_length17\
    \ = 0;\n    let mut current_note_note_length18 = 0;\n    let mut current_note_note_length19\
    \ = 0;\n    let mut current_note_note_length20 = 0;\n    let mut current_note_note_length21\
    \ = 0;\n    let mut current_note_note_length22 = 0;\n    let mut current_note_note_length23\
    \ = 0;\n    let mut current_note_note_length24 = 0;\n    let mut current_note_note_length25\
    \ = 0;\n    let mut current_note_note_length26 = 0;\n    let mut current_note_note_length27\
    \ = 0;\n    let mut current_note_note_length28 = 0;\n    let mut current_note_note_length29\
    \ = 0;\n    let mut current_note_note_length30 = 0;\n    let mut current_note_note_length31\
    \ = 0;\n    let mut current_note_note_length32 = 0;\n    let mut current_note_note_length33\
    \ = 0;\n    let mut current_note_note_length34 = 0;\n    let mut current_note_note_length35\
    \ = 0;\n    let mut current_note_note_length36 = 0;\n    let mut current_note_note_length37\
    \ = 0;\n    let mut current_note_note_length38 = 0;\n    let mut current_note_note_length39\
    \ = 0;\n    let mut current_note_note_length40 = 0;\n    let mut current_note_note_length41\
    \ = 0;\n    let mut current_note_note_length42 = 0;\n    let mut current_note_note_length43\
    \ = 0;\n    let mut current_note_note_length44 = 0;\n    let mut current_note_note_length45\
    \ = 0;\n    let mut current_note_note_length46 = 0;\n    let mut current_note_note_length47\
    \ = 0;\n    let mut current_note_note_length\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplf16aooz.rs:61:37\n   |\n\
    61 |     let mut current_note_note_length\n   |                              \
    \       ^ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmplf16aooz.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut beats\
    \ = Vec::new();\n    let mut current_note = 0;\n    let mut current_beat = 0;\n\
    \    let mut current_note_index = 0;\n    let mut current_beat_index = 0;\n  \
    \  let mut current_note_length = 0;\n    let mut current_beat_length = 0;\n  \
    \  let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_beat_length_index\
    \ = 0;\n    let mut current_note_length_index = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpanfcyc9x.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpak4y2zqp.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat: isize = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9eycnzne.rs:65:21\n   |\n\
    65 |     let mut current_\n   |                     ^ help: add `;` here\n66 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9eycnzne.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != '|');\n    for\
    \ note in notes {\n        let note_string = note.1.to_string();\n        let\
    \ note_string = note_string.trim_left_matches(\"o|.\");\n        let note_string\
    \ = note_string.trim_right_matches(\"o|.\");\n        let note_string = note_string.trim_left_matches(\"\
    o|.\");\n        let note_string = note_string.trim_right_matches(\"o|.\");\n\
    \        let note_string = note_string.trim_left_matches(\"o|.\");\n        let\
    \ note_string = note_string.trim_right_matches(\"o|.\");\n        let note_string\
    \ = note_string.trim_left_matches(\"o|.\");\n        let note_string = note_string.trim_right_matches(\"\
    o|.\");\n        let note_string = note_string.trim_left_matches(\"o|.\");\n \
    \       let note_string = note_string.trim_right_matches(\"o|.\");\n        let\
    \ note_string = note_string.trim_left_matches(\"o|.\");\n        let note_string\
    \ = note_string.trim_right_matches(\"o|.\");\n        let note_string = note_string.trim_left_matches(\"\
    o|.\");\n        let note_string = note_string.trim_right_matches(\"o|.\");\n\
    \        let note_string = note_string.trim_left_matches(\"o|.\");\n        let\
    \ note_string = note_string.trim_right_matches(\"o|.\");\n        let note_string\
    \ = note_string.trim_left_matches(\"o|.\");\n        let note_string = note_string.trim_right_matches(\"\
    o|.\");\n        let note_string = note_string.trim_left_matches(\"o|.\");\n \
    \       let note_string = note_string.trim_right_matches(\"o|.\");\n        let\
    \ note_string = note_string.trim_left_matches(\"o|.\");\n        let note_string\
    \ = note_string.trim_right_matches(\"o|.\");\n        let note_string = note_string.trim_left_matches(\"\
    o|.\");\n        let note_string = note_string.trim_right_matches(\"o|.\");\n\
    \        let note_string = note_string.trim_left_matches(\"o|.\");\n        let\
    \ note_string = note_string.trim_right_matches(\"o|.\");\n        let note_string\
    \ = note_string.trim_left_matches(\"o|.\");\n        let note_string = note_string.trim_right_matches(\"\
    o|.\");\n        let note_string = note_string.trim_left_matches(\"o|.\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp82wvx89a.rs:50:61\n\
    \   |\n50 |       assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\"\
    )), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n   |  _____________________________________________________________^\n\
    51 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.last().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_length = 0;\n    for note in notes {\n        if note != current_note\
    \ {\n            beats.push(current_beat);\n            current_beat = 0;\n  \
    \          current_note = note;\n        }\n        current_beat += 1;\n     \
    \   current_length += 1;\n    }\n    beats.push(current_beat);\n    beats\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpq6p530r7.rs:15:17\n\
    \   |\n15 |         if note != current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq6p530r7.rs:18:28\n   |\n11 |     let mut current_note\
    \ = notes.last().unwrap();\n   |                            ---------------------\
    \ expected due to this value\n...\n18 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_octave: isize = 0;\n    let mut current_note_is_octave = false;\n\
    \    let mut current_note_is_rest = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_note_is_chord = false;\n    let mut current_note_is_chord\
    \ = false;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgscy_oj4.rs:64:21\n   |\n\
    64 |     let mut current_\n   |                     ^ help: add `;` here\n65 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpgscy_oj4.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate();\n\
    \    let mut current_note = 0;\n    let mut last_note = 0;\n    let mut last_beat\
    \ = 0;\n    let mut last_beats = 0;\n    let mut last_beats_after_note = 0;\n\
    \    let mut last_beats_after_notes = 0;\n    let mut last_beats_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes = 0;\n    let mut last_beats_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdb1n35cu.rs:41:18\n   |\n\
    41 |     let mut last_\n   |                  ^ help: add `;` here\n42 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdb1n35cu.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut music_notes = music_string.chars().collect::<Vec<char>>();\n    let\
    \ mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_beat_length = 0;\n    let mut current_note_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat = 0;\n    let mut current_note_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length = 0;\n    let mut current_note_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat = 0;\n    let mut\
    \ current_note_length_to_beat_length_to_beat_length = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_be\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprvdnyg4p.rs:36:83\n   |\n\
    36 |     let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_be\n\
    \   |                                                                        \
    \           ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmprvdnyg4p.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = music_string.chars().collect::<Vec<char>>();\n\
    \    let mut beats = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note\
    \ = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length =\
    \ 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_index = 0;\n    let mut current_note_length_value_value\
    \ = 0;\n    let mut current_note_length_value_value_index = 0;\n    let mut current_note_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq0u3a49h.rs:53:56\n   |\n\
    53 |     let mut current_note_length_value_value_value_index\n   |           \
    \                                             ^ help: add `;` here\n54 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpq0u3a49h.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu997k_8s.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ last_note = notes.last().unwrap();\n    let mut last_beat = 0;\n    let mut\
    \ last_beats: isize = 0;\n    for note in notes {\n        if note == last_note\
    \ {\n            last_beats += 1;\n        } else {\n            beats.push(last_beats);\n\
    \            last_beats = 0;\n            last_beats += 1;\n            last_note\
    \ = note;\n        }\n    }\n    beats.push(last_beats);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpabj1ao71.rs:15:17\n\
    \   |\n15 |         if note == last_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpabj1ao71.rs:21:25\n   |\n11 |     let mut last_note\
    \ = notes.last().unwrap();\n   |                         ---------------------\
    \ expected due to this value\n...\n21 |             last_note = note;\n   |  \
    \                       ^^^^ expected `&str`, found `str`\n   |\n   = note: expected\
    \ reference `&&str`\n              found reference `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes: Vec<isize> = vec![];\n    let mut\
    \ current_note = 0;\n    let mut current_beat = 0;\n    let mut current_beats_left\
    \ = 0;\n    let mut current_notes_left = 0;\n    let mut current_notes_left_in_beat\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note = 0;\n\
    \    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat = 0;\n\
    \    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat = 0;\n\
    \    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_note_in_beat_in_note\
    \ = 0;\n    let mut current_notes_left_in_beat_in_note_in_beat_in_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplmkt_rax.rs:37:59\n   |\n\
    37 |     let mut current_notes_left_in_beat_in_note_in_beat_in_\n   |        \
    \                                                   ^ help: add `;` here\n38 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmplmkt_rax.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != '|');\n    let\
    \ mut current_note = 0;\n    let mut current_beat = 0;\n    for note in notes\
    \ {\n        if note.1 == 0 {\n            beats.push(current_beat);\n       \
    \     current_beat = 0;\n            current_note = note.0;\n        } else {\n\
    \            current_beat += note.1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdy5iw8ik.rs:10:78\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdy5iw8ik.rs:14:22\n   |\n14 |         if note.1 == 0 {\n   |       \
    \               ^ expected `char`, found `u8`\n\nerror[E0277]: cannot add-assign\
    \ `char` to `{integer}`\n  --> /tmp/tmpdy5iw8ik.rs:19:26\n   |\n19 |         \
    \    current_beat += note.1;\n   |                          ^^ no implementation\
    \ for `{integer} += char`\n   |\n   = help: the trait `AddAssign<char>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    \    let mut current_note_length = -1;\n    let mut current_note_length = -1;\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpi0wc3ry1.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_index = 0;\n    let mut current_note_length_value_value\
    \ = 0;\n    let mut current_note_length_value_value_index = 0;\n    let mut current_note_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value = 0;\n \
    \   let mut current_note_length_value_value_value_value_index = 0;\n    let mut\
    \ current_note_length_value_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value = 0;\n \
    \   let mut current_note_length_value_value_value_value_index = 0;\n    let mut\
    \ current_note_length_value_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value = 0;\n \
    \   let mut current_note_length_value_value_value_value_index = 0;\n    let mut\
    \ current_note_length_value_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value = 0;\n \
    \   let mut current_note_length_value_value_value_value_index = 0;\n    let mut\
    \ current_note_length_value_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value = 0;\n \
    \   let mut current_note_length_value_value_value_value_index = 0;\n    let mut\
    \ current_note_length_value_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value = 0;\n \
    \   let mut current_note_length_value_value_value_value_index = 0;\n    let mut\
    \ current_note_length_value_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value = 0;\n \
    \   let mut current_note_length_value_value_value_value_index = 0;\n    let mut\
    \ current_note_length_value_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value = 0;\n \
    \   let mut current_note_length\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4d8l4xot.rs:51:32\n   |\n\
    51 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp4d8l4xot.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.chars().collect();\n    let mut last_note =\
    \ notes.last().unwrap();\n    let mut last_beat = 0;\n    let mut last_beats:\
    \ isize = 0;\n    for note in notes {\n        let mut beat = 0;\n        if note\
    \ == last_note {\n            beat += last_beats;\n            last_beats += 1;\n\
    \        } else {\n            last_beat = 0;\n            last_beats = 1;\n \
    \       }\n        beats.push(beat);\n        last_note = note;\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp2o__sn6f.rs:10:53\n     |\n10\
    \   |     let mut notes: Vec<&str> = music_string.chars().collect();\n     | \
    \                                                    ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp2o__sn6f.rs:16:17\n\
    \   |\n16 |         if note == last_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2o__sn6f.rs:24:21\n   |\n11 |     let mut last_note\
    \ = notes.last().unwrap();\n   |                         ---------------------\
    \ expected due to this value\n...\n24 |         last_note = note;\n   |      \
    \               ^^^^ expected `&str`, found `str`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<String> = music_string.split_whitespace().collect();\n    let\
    \ mut current_note = String::new();\n    let mut current_beat = 0;\n    let mut\
    \ current_beats_length = 0;\n    let mut current_note_length = 0;\n    let mut\
    \ current_note_index = 0;\n    let mut current_note_octave = 0;\n    let mut current_note_octave_length\
    \ = 0;\n    let mut current_note_octave_octave = 0;\n    let mut current_note_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_octave = 0;\n    let mut current_note_octave_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave = 0;\n    let mut\
    \ current_note_octave_octave_octave_octave_length = 0;\n    let mut current_note_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_length = 0;\n\
    \    let mut current_note_octave_octave_octave_octave_octave_octave = 0;\n   \
    \ let mut current_note_octave_octave_octave_octave_octave_octave_length = 0;\n\
    \    let mut current_note_octave_octave_octave_octave_octave_octave_octave = 0;\n\
    \    let mut current_note_octave_octave_octave_octave_octave_octave_length = 0;\n\
    \    let mut current_note_octave_octave_octave_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp158ihuhp.rs:35:54\n   |\n\
    35 |     let mut current_note_octave_octave_octave_octave_\n   |             \
    \                                         ^ help: add `;` here\n36 | }\n   | -\
    \ unexpected token\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `&str`\n    --> /tmp/tmp158ihuhp.rs:10:66\n\
    \     |\n10   |     let mut notes: Vec<String> = music_string.split_whitespace().collect();\n\
    \     |                                                                  ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp158ihuhp.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpak4y2zqp.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_note_len = String::new();\n    let mut\
    \ current_note_len_len: usize = 0;\n    let mut current_note_len_len_len: usize\
    \ = 0;\n    let mut current_note_len_len_len_len: usize = 0;\n    let mut current_note_len_len_len_len_len:\
    \ usize = 0;\n    let mut current_note_len_len_len_len_len_len: usize = 0;\n \
    \   let mut current_note_len_len_len_len_len_len_len: usize = 0;\n    let mut\
    \ current_note_len_len_len_len_len_len_len: usize = 0;\n    let mut current_note_len_len_len_len_len_len_len_len:\
    \ usize = 0;\n    let mut current_note_len_len_len_len_len_len_len_len: usize\
    \ = 0;\n    let mut current_note_len_len_len_len_len_len_len_len_len: usize =\
    \ 0;\n    let mut current_note_len_len_len_len_len_len_len_len_len: usize = 0;\n\
    \    let mut current_note_len_len_len_len_len_len_len_len_len: usize = 0;\n  \
    \  let mut current_note_len_len_len_len_len_len_len_len_len: usize = 0;\n    let\
    \ mut current_note_len_len_len_len_len_len_len_len_len_len: usize = 0;\n    let\
    \ mut current_note_len_len_len_len_len_len_len_len_len_len: usize = 0;\n    let\
    \ mut current_note_len_len_len_len_len_len_len_len_len_len: usize = 0;\n    let\
    \ mut current_note_len_len_len_len_len_len_len_len_len_len_len: usize = 0;\n \
    \   let mut current_note_len_len_len_len_len_len_len_len_len_len_len: usize =\
    \ 0;\n    let mut current_note_len_len_len_len_len_len_len_len_len_len_len: usize\
    \ = 0;\n    let mut current_note_len_len_len_len_len_len_len_len_len_len_len:\
    \ usize = 0;\n    let mut current_note_len_len_len_len_len_len_len_len_len_len_len:\
    \ usize = 0;\n    let mut current_note_len_len_len_len_len_len_len_len_len_len_len_len:\
    \ usize = 0;\n    let mut current_note_len_len_len_len_len_len_len_len_len_len_len_len:\
    \ usize = 0;\n    let mut current_note_len_len_len_len_len_len_len_len_len_len_len_len_len:\
    \ usize = 0;\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n \
    \   assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp5_dq1ef2.rs:39:1\n  \
    \ |\n39 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    let mut note_count\
    \ = notes.len();\n    let mut last_note = notes.last().unwrap();\n    let mut\
    \ last_beat = last_note.1;\n    let mut last_beats = last_note.1;\n    let mut\
    \ last_beats_remaining = last_note.1;\n    let mut last_beats_remaining_to_beats\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining = last_note.1;\n\
    \    let mut last_beats_remaining_to_beats_remaining_to_beats = last_note.1;\n\
    \    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining = last_note.1;\n\
    \    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats\
    \ = last_note.1;\n    let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps3n_ppvv.rs:29:81\n   |\n\
    29 |     let mut last_beats_remaining_to_beats_remaining_to_beats_remaining_to_beats_\n\
    \   |                                                                        \
    \         ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmps3n_ppvv.rs:10:72\n   |\n10\
    \ |     let mut notes = music_string.chars().enumerate().filter(|(_, c)| c !=\
    \ '|');\n   |                                                                \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0599]: no method named `len` found for struct\
    \ `Filter` in the current scope\n  --> /tmp/tmps3n_ppvv.rs:11:32\n   |\n11 | \
    \    let mut note_count = notes.len();\n   |                                ^^^\
    \ method not found in `Filter<Enumerate<Chars<'_>>, [closure@/tmp/tmps3n_ppvv.rs:10:61:\
    \ 10:78]>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmps3n_ppvv.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ last_note = notes.last().unwrap();\n    let mut last_beat = 0;\n    for note\
    \ in notes {\n        if note == last_note {\n            beats.push(last_beat);\n\
    \            last_beat = 0;\n        } else {\n            last_beat = last_beat\
    \ * 4 + 1;\n        }\n        last_note = note;\n    }\n    beats.push(last_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpclocrj2t.rs:14:17\n\
    \   |\n14 |         if note == last_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpclocrj2t.rs:20:21\n   |\n11 |     let mut last_note\
    \ = notes.last().unwrap();\n   |                         ---------------------\
    \ expected due to this value\n...\n20 |         last_note = note;\n   |      \
    \               ^^^^ expected `&str`, found `str`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpak4y2zqp.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|&(_, c)| c != '|');\n    let mut\
    \ current_note = 0;\n    let mut current_beat = 0;\n    let mut last_note = 0;\n\
    \    let mut last_beat = 0;\n    for note in notes {\n        if note.1 == last_note\
    \ {\n            current_beat += 1;\n        } else {\n            beats.push(current_beat);\n\
    \            current_beat = 1;\n            current_note = note.1;\n         \
    \   last_note = note.1;\n            last_beat = current_beat;\n        }\n  \
    \  }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ik141wu.rs:16:22\n   |\n\
    16 |         if note.1 == last_note {\n   |                      ^^^^^^^^^ expected\
    \ `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5ik141wu.rs:21:28\n\
    \   |\n11 |     let mut current_note = 0;\n   |                            - expected\
    \ due to this value\n...\n21 |             current_note = note.1;\n   |      \
    \                      ^^^^^^ expected integer, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5ik141wu.rs:22:25\n   |\n13 |     let mut last_note\
    \ = 0;\n   |                         - expected due to this value\n...\n22 | \
    \            last_note = note.1;\n   |                         ^^^^^^ expected\
    \ integer, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_octave = 0;\n    let mut current_note_octave_length\
    \ = 0;\n    let mut current_note_octave_octave = 0;\n    let mut current_note_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_octave = 0;\n    let mut current_note_octave_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave = 0;\n    let mut\
    \ current_note_octave_octave_octave_octave_length = 0;\n    let mut current_note_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_length = 0;\n\
    \    let mut current_note_octave_octave_octave_octave_octave_octave = 0;\n   \
    \ let mut current_note_octave_octave_octave_octave_octave_length = 0;\n    let\
    \ mut current_note_octave_octave_octave_octave_octave_octave = 0;\n    let mut\
    \ current_note_octave_octave_octave_octave_octave_octave_length = 0;\n    let\
    \ mut current_note_octave_octave_octave_octave_octave_octave_octave = 0;\n   \
    \ let mut current_note_octave_octave_octave_octave_octave_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_octave_\n}\n\nfn main() {\n   \
    \ let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb6bc0u07.rs:35:47\n   |\n\
    35 |     let mut current_note_octave_octave_octave_\n   |                    \
    \                           ^ help: add `;` here\n36 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpb6bc0u07.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    for note\
    \ in notes {\n        let mut beat = 0;\n        let mut note = note.0;\n    \
    \    let mut note_count = 1;\n        while note != 'o' {\n            if note\
    \ == 'o' {\n                beat += 4;\n                note_count = 4;\n    \
    \        } else if note == 'o|' {\n                beat += 2;\n              \
    \  note_count = 2;\n            } else if note == '.|' {\n                beat\
    \ += 1;\n                note_count = 1;\n            } else {\n             \
    \   panic!(\"Unknown note in music string\");\n            }\n            note\
    \ = notes[note.next_back()];\n        }\n        beats.push(beat);\n    }\n  \
    \  beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpq14kyekv.rs:19:34\n\
    \   |\n19 |             } else if note == 'o|' {\n   |                       \
    \           ^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut music_str: String = music_string;\n    let mut music_char: char;\n\
    \    let mut music_last_char: char;\n    let mut music_last_beat: isize = 0;\n\
    \    let mut music_beat: isize = 0;\n    let mut music_last_beats_cnt: isize =\
    \ 0;\n    let mut music_last_beats_cnt2: isize = 0;\n    let mut music_last_beats_cnt3:\
    \ isize = 0;\n    let mut music_last_beats_cnt4: isize = 0;\n    let mut music_last_beats_cnt5:\
    \ isize = 0;\n    let mut music_last_beats_cnt6: isize = 0;\n    let mut music_last_beats_cnt7:\
    \ isize = 0;\n    let mut music_last_beats_cnt8: isize = 0;\n    let mut music_last_beats_cnt9:\
    \ isize = 0;\n    let mut music_last_beats_cnt10: isize = 0;\n    let mut music_last_beats_cnt11:\
    \ isize = 0;\n    let mut music_last_beats_cnt12: isize = 0;\n    let mut music_last_beats_cnt13:\
    \ isize = 0;\n    let mut music_last_beats_cnt14: isize = 0;\n    let mut music_last_beats_cnt15:\
    \ isize = 0;\n    let mut music_last_beats_cnt16: isize = 0;\n    let mut music_last_beats_cnt17:\
    \ isize = 0;\n    let mut music_last_beats_cnt18: isize = 0;\n    let mut music_last_beats_cnt19:\
    \ isize = 0;\n    let mut music_last_beats_cnt20: isize = 0;\n    let mut music_last_beats_cnt21:\
    \ isize = 0;\n    let mut music_last_beats_cnt22: isize = 0;\n    let mut music_last_beats_cnt23:\
    \ isize = 0;\n    let mut music_last_beats_cnt24: isize = 0;\n    let mut music_last_beats_cnt25:\
    \ isize = 0;\n    let mut music_last_beats_cnt26: isize = 0;\n    let mut music_last_beats_cnt27:\
    \ isize = 0;\n    let mut music_last_beats_cnt28: isize = 0;\n    let mut music_last_beats_cnt29:\
    \ isize = 0;\n    let mut music_last_beats_\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgps0hxk7.rs:44:30\n   |\n\
    44 |     let mut music_last_beats_\n   |                              ^ help:\
    \ add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpgps0hxk7.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmppil6688r.rs:62:1\n  \
    \ |\n62 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ notes_len: usize = 0;\n    let mut notes_str: &str = &notes[0];\n    let mut\
    \ notes_beats: usize = 0;\n    let mut notes_beats_len: usize = 0;\n    let mut\
    \ notes_beats_str: &str = &notes_beats[0];\n    let mut notes_beats_str_len: usize\
    \ = 0;\n    let mut notes_beats_str_len2: usize = 0;\n    let mut notes_beats_str_len3:\
    \ usize = 0;\n    let mut notes_beats_str_len4: usize = 0;\n    let mut notes_beats_str_len5:\
    \ usize = 0;\n    let mut notes_beats_str_len6: usize = 0;\n    let mut notes_beats_str_len7:\
    \ usize = 0;\n    let mut notes_beats_str_len8: usize = 0;\n    let mut notes_beats_str_len9:\
    \ usize = 0;\n    let mut notes_beats_str_len10: usize = 0;\n    let mut notes_beats_str_len11:\
    \ usize = 0;\n    let mut notes_beats_str_len12: usize = 0;\n    let mut notes_beats_str_len13:\
    \ usize = 0;\n    let mut notes_beats_str_len14: usize = 0;\n    let mut notes_beats_str_len15:\
    \ usize = 0;\n    let mut notes_beats_str_len16: usize = 0;\n    let mut notes_beats_str_len17:\
    \ usize = 0;\n    let mut notes_beats_str_len18: usize = 0;\n    let mut notes_beats_str_len19:\
    \ usize = 0;\n    let mut notes_beats_str_len20: usize = 0;\n    let mut notes_beats_str_len21:\
    \ usize = 0;\n    let mut notes_beats_str_len22: usize = 0;\n    let mut notes_beats_str_len23:\
    \ usize = 0;\n    let mut notes_beats_str_len24: usize = 0;\n    let mut notes_beats_str_len25:\
    \ usize = 0;\n    let mut notes_beats_str_len26: usize = 0;\n    let mut notes_beats_str_len27:\
    \ usize = 0;\n    let mut notes_beats_str_len28: \n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpi3uc39l7.rs:44:1\n   |\n\
    43 |     let mut notes_beats_str_len28: \n   |         -------------------------\
    \ while parsing the type for `mut notes_beats_str_len28`\n44 | }\n   | ^ expected\
    \ type\n\nerror[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmpi3uc39l7.rs:15:38\n\
    \   |\n15 |     let mut notes_beats_str: &str = &notes_beats[0];\n   |       \
    \                               ^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note_len\
    \ > 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_len\
    \ = 0;\n            }\n        } else if c == '|' {\n            current_note_len\
    \ = current_note_len * 4 + 1;\n        } else if c == ' ' {\n            if current_note_len\
    \ > 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_len\
    \ = 0;\n            }\n        } else {\n            current_note.push(c);\n \
    \           current_note_len = current_note.len();\n        }\n    }\n    if current_note_len\
    \ > 0 {\n        beats.push(current_beat);\n    }\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpeb9x5zre.rs:13:14\n\
    \   |\n13 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes: Vec<isize> = vec![];\n    let mut\
    \ current_note = 0;\n    let mut current_beat = 0;\n    let mut current_beats_left\
    \ = 0;\n    for c in music_string {\n        match c {\n            'o' => notes.push(current_note),\n\
    \            'o|' => notes.push(current_note + 4),\n            '.|' => notes.push(current_note\
    \ + 1),\n            _ => (),\n        }\n        current_note += 1;\n       \
    \ current_beats_left += 1;\n        if current_beats_left == 4 {\n           \
    \ current_beats_left = 0;\n            current_beat += 1;\n        }\n    }\n\
    \    notes\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpqtcd4imt.rs:16:16\n\
    \   |\n16 |             'o|' => notes.push(current_note + 4),\n   |          \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = String::new();\n    let mut\
    \ current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2\
    \ = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n\
    \    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let\
    \ mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut\
    \ current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11\
    \ = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 =\
    \ 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n\
    \    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n  \
    \  let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let\
    \ mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut\
    \ current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24\
    \ = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 =\
    \ 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n\
    \    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n  \
    \  let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let\
    \ mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut\
    \ current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37\
    \ = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 =\
    \ 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n\
    \    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n  \
    \  let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let\
    \ mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut\
    \ current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50\
    \ = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 =\
    \ 0;\n    let mut current_note_oct53\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpol2baqf5.rs:65:31\n   |\n\
    65 |     let mut current_note_oct53\n   |                               ^ help:\
    \ add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpol2baqf5.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_length: usize = 0;\n    for c in music_string {\n        if\
    \ c == 'o' {\n            current_note += '.';\n            current_note_length\
    \ += 1;\n        } else if c == '|' {\n            current_note += '|';\n    \
    \        current_note_length += 1;\n        } else if c == '.' {\n           \
    \ current_note += 'o';\n            current_note_length += 1;\n        } else\
    \ {\n            current_note += c;\n            current_note_length += 1;\n \
    \       }\n        if current_note_length == 4 {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_length = 0;\n       \
    \ }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpo0c3aipc.rs:13:14\n\
    \   |\n13 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo0c3aipc.rs:15:29\n   |\n15 |             current_note\
    \ += '.';\n   |                             ^^^ expected `&str`, found `char`\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    15 |             current_note += \".\";\n   |                             ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo0c3aipc.rs:18:29\n   |\n18 |\
    \             current_note += '|';\n   |                             ^^^ expected\
    \ `&str`, found `char`\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n18 |             current_note += \"|\";\n   |         \
    \                    ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo0c3aipc.rs:21:29\n\
    \   |\n21 |             current_note += 'o';\n   |                           \
    \  ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n21 |             current_note += \"o\";\n\
    \   |                             ~~~\n\nerror[E0277]: can't compare `&str` with\
    \ `char`\n  --> /tmp/tmpo0c3aipc.rs:14:14\n   |\n14 |         if c == 'o' {\n\
    \   |              ^^ no implementation for `&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut current_note\
    \ = String::new();\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            current_note\
    \ = String::new();\n            current_length = 0;\n            current_beat\
    \ = 0;\n            notes.push(current_note.len());\n        } else if c == 'o|'\
    \ {\n            current_note = String::new();\n            current_length = 0;\n\
    \            current_beat = 0;\n            notes.push(current_note.len());\n\
    \        } else if c == '.|' {\n            current_note = String::new();\n  \
    \          current_length = 0;\n            current_beat = 0;\n            notes.push(current_note.len());\n\
    \        } else {\n            current_note.push(c);\n            current_length\
    \ += 1;\n        }\n        if current_length == 4 {\n            current_beat\
    \ += 1;\n        }\n    }\n    notes\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpschpb4ay.rs:19:27\n\
    \   |\n19 |         } else if c == 'o|' {\n   |                           ^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|&(_, c)| c == 'o' || c == 'o|' ||\
    \ c == '.|');\n    for note in notes {\n        let beat = note.1.parse().unwrap();\n\
    \        beats.push(beat);\n    }\n    return beats;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp66hsk318.rs:10:91\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|&(_,\
    \ c)| c == 'o' || c == 'o|' || c == '.|');\n   |                             \
    \                                                              ^^^^^^^^^^^\n \
    \  |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n10\
    \ |     let mut notes = music_string.chars().enumerate().filter(|&(_, c)| c ==\
    \ 'o' || c == 'o|\" || c == \".|');\n   |                                    \
    \                                                       ~~~~~~~~~~~\n\nerror[E0762]:\
    \ unterminated character literal\n  --> /tmp/tmp66hsk318.rs:10:104\n   |\n10 |\
    \     let mut notes = music_string.chars().enumerate().filter(|&(_, c)| c == 'o'\
    \ || c == 'o|' || c == '.|');\n   |                                          \
    \                                                              ^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().filter(|c|\
    \ c != '|');\n    let mut note_count = music_string.chars().filter(|c| c != 'o').count();\n\
    \    let mut last_note = music_string.chars().filter(|c| c != 'o').last().unwrap();\n\
    \    let mut last_beat = music_string.chars().filter(|c| c != '|').last().unwrap();\n\
    \    let mut last_beats = music_string.chars().filter(|c| c != '|').count();\n\
    \    notes.for_each(|c| {\n        if c == 'o' {\n            beats.push(note_count);\n\
    \            note_count += 4;\n        } else {\n            beats.push(note_count);\n\
    \            note_count += 2;\n        }\n    });\n    beats.push(note_count);\n\
    \    beats.push(last_beats);\n    beats\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmbs16s22.rs:10:55\n\
    \   |\n10 |     let mut notes = music_string.chars().filter(|c| c != '|');\n \
    \  |                                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmbs16s22.rs:11:60\n\
    \   |\n11 |     let mut note_count = music_string.chars().filter(|c| c != 'o').count();\n\
    \   |                                                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmbs16s22.rs:12:59\n\
    \   |\n12 |     let mut last_note = music_string.chars().filter(|c| c != 'o').last().unwrap();\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmbs16s22.rs:13:59\n\
    \   |\n13 |     let mut last_beat = music_string.chars().filter(|c| c != '|').last().unwrap();\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmbs16s22.rs:14:60\n\
    \   |\n14 |     let mut last_beats = music_string.chars().filter(|c| c != '|').count();\n\
    \   |                                                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    let mut current_note_count = 0;\n    let mut current_beat_count\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_beat_length\
    \ = 0;\n    let mut current_note = notes.next()\n        .unwrap()\n        .unwrap()\n\
    \        .unwrap();\n    while let Some(note) = current_note {\n        if note\
    \ == 'o' {\n            if current_note_count > 0 {\n                beats.push(current_beat_count);\n\
    \            }\n            current_note_count = 0;\n            current_beat_count\
    \ = 0;\n            current_note_length = 0;\n            current_beat_length\
    \ = 0;\n            current_note = notes.next()\n                .unwrap()\n \
    \               .unwrap()\n                .unwrap();\n        } else if note\
    \ == 'o|' {\n            if current_note_count > 0 {\n                beats.push(current_beat_count);\n\
    \            }\n            current_note_count = 0;\n            current_beat_count\
    \ = 0;\n            current_note_length = 1;\n            current_beat_length\
    \ = 0;\n            current_note = notes.next()\n                .unwrap()\n \
    \               .unwrap()\n                .unwrap();\n        } else if note\
    \ == '.|' {\n            if current_note_count > 0 {\n                beats.push(current_beat_count);\n\
    \            }\n            current_note_count = 0;\n            current_beat_count\
    \ = 0;\n            current_note_length = 2;\n            current_beat_length\
    \ = 0;\n            current_note = notes.next()\n                .unwrap()\n \
    \               .unwrap()\n                .unwrap();\n        } else {\n    \
    \        current_note_count += 1;\n            current_beat_count += 1;\n    \
    \        current_note_length += 1;\n            current_beat_length += 1;\n  \
    \          current_note = notes.next()\n                .unwrap()\n          \
    \      .unwrap()\n                .unwrap();\n        }\n    }\n    if current_note_count\
    \ > 0 {\n        beats.push(current_beat_count);\n    }\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpgt4iy833.rs:34:30\n\
    \   |\n34 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut last_note_len = 0;\n    let mut last_note = 0;\n    let mut\
    \ last_beat = 0;\n    let mut last_note_len = 0;\n    let mut last_note = 0;\n\
    \    let mut last_beat = 0;\n    let mut last_note_len = 0;\n    let mut last_note\
    \ = 0;\n    let mut last_beat = 0;\n    let mut last_note_len = 0;\n    let mut\
    \ last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len = 0;\n\
    \    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_note_len\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgonx8nc.rs:77:26\n   |\n\
    77 |     let mut last_note_len\n   |                          ^ help: add `;`\
    \ here\n78 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpvgonx8nc.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length = 0;\n    let\
    \ mut current_note_length_to_beat_with_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0ndtx_s_.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_chars = music_string.chars();\n \
    \   let mut music_chars_iter = music_chars.iter();\n    let mut music_chars_len\
    \ = music_chars.len();\n    let mut music_chars_index = 0;\n    let mut music_chars_last_index\
    \ = 0;\n    let mut music_chars_last_char = 0;\n    let mut music_chars_last_char_beat\
    \ = 0;\n    let mut music_chars_last_char_beat_beat = 0;\n    let mut music_chars_last_char_beat_beat_index\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index2 = 0;\n    let mut music_chars_last_char_beat_beat_index3\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index4 = 0;\n    let mut music_chars_last_char_beat_beat_index5\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index6 = 0;\n    let mut music_chars_last_char_beat_beat_index7\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index8 = 0;\n    let mut music_chars_last_char_beat_beat_index9\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index10 = 0;\n    let mut\
    \ music_chars_last_char_beat_beat_index11 = 0;\n    let mut music_chars_last_char_beat_beat_index12\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index13 = 0;\n    let mut\
    \ music_chars_last_char_beat_beat_index14 = 0;\n    let mut music_chars_last_char_beat_beat_index15\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index16 = 0;\n    let mut\
    \ music_chars_last_char_beat_beat_index17 = 0;\n    let mut music_chars_last_char_beat_beat_index18\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index19 = 0;\n    let mut\
    \ music_chars_last_char_beat_beat_index20 = 0;\n    let mut music_chars_last_char_beat_beat_index21\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index22 = 0;\n    let mut\
    \ music_chars_last_char_beat_beat_index23 = 0;\n    let mut music_chars_last_char_beat_beat_index24\
    \ = 0;\n    let mut music_chars_last_char_beat_beat_index25 = 0;\n    let mut\
    \ music_chars_last_char_beat_beat_index26 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpmv8tmk1s.rs:10:44\n   |\n10 |     let mut music_chars_iter\
    \ = music_chars.iter();\n   |                                            ^^^^\
    \ private field, not a method\n\nerror[E0599]: no method named `len` found for\
    \ struct `Chars` in the current scope\n  --> /tmp/tmpmv8tmk1s.rs:11:43\n   |\n\
    11 |     let mut music_chars_len = music_chars.len();\n   |                  \
    \                         ^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpmv8tmk1s.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|&(_, c)| c == 'o' || c == '|' ||\
    \ c == '.').collect::<Vec<_>>();\n    for note in notes {\n        let beat =\
    \ note.1.parse().unwrap();\n        beats.push(beat);\n    }\n    return beats;\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `parse` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpsqwt6_j3.rs:12:27\n   |\n12 |         let beat = note.1.parse().unwrap();\n\
    \   |                           ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut last_note\
    \ = String::new();\n    let mut last_beat: usize = 0;\n    let mut last_beats:\
    \ usize = 0;\n    let mut last_note_len: usize = 0;\n    let mut last_note_beat:\
    \ usize = 0;\n    let mut last_note_beats: usize = 0;\n    let mut last_note_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat: usize = 0;\n    let mut last_note_beat_beats:\
    \ usize = 0;\n    let mut last_note_beat_beat_len: usize = 0;\n    let mut last_note_beat_beat_beat:\
    \ usize = 0;\n    let mut last_note_beat_beat_beats: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat: usize = 0;\n    let mut\
    \ last_note_beat_beat_beats: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat: usize = 0;\n    let mut\
    \ last_note_beat_beat_beats: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat: usize = 0;\n    let mut\
    \ last_note_beat_beat_beats: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat: usize = 0;\n    let mut\
    \ last_note_beat_beat_beats: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat: usize = 0;\n    let mut\
    \ last_note_beat_beat_beats: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat: usize = 0;\n    let mut\
    \ last_note_beat_beat_beats: usize = 0;\n    let mut last_note_beat_beat_beat_len:\
    \ usize = 0;\n    let mut last_note_beat_beat_beat_beat\n}\n\nfn main() {\n  \
    \  let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpawigcuft.rs:43:42\n   |\n\
    43 |     let mut last_note_beat_beat_beat_beat\n   |                         \
    \                 ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpawigcuft.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    let mut current_beats_length = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_type = 0;\n    let mut current_note_length =\
    \ 0;\n    let mut current_note_type = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_type = 0;\n    let mut current_note_length = 0;\n  \
    \  let mut current_note_type = 0;\n    let mut current_note_length = 0;\n    let\
    \ mut current_note_type = 0;\n    let mut current_note_length = 0;\n    let mut\
    \ current_note_type = 0;\n    let mut current_note_length = 0;\n    let mut current_note_type\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_type =\
    \ 0;\n    let mut current_note_length = 0;\n    let mut current_note_type = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_type = 0;\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_type = 0;\n    let\
    \ mut current_note_length = 0;\n    let mut current_note_type = 0;\n    let mut\
    \ current_note_length = 0;\n    let mut current_note_type = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_type = 0;\n    let mut current_note_length =\
    \ 0;\n    let mut current_note_type = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_type = 0;\n    let mut current_note_length = 0;\n  \
    \  let mut current_note_type = 0;\n    let mut current_note_length = 0;\n    let\
    \ mut current_note_type = 0;\n    let mut current_note_length = 0;\n    let mut\
    \ current_note_type = 0;\n    let mut current_note_length = 0;\n    let mut current_note_type\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_type =\
    \ 0;\n    let mut current_note_length = 0;\n    let mut current_note_type = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_type = 0;\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_type = 0;\n    let\
    \ mut current_note_length = 0;\n    let mut current_note_type = 0;\n    let mut\
    \ current_note_length = 0;\n    let mut current_note_type = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_type = 0;\n    let mut current_note_length =\
    \ 0;\n    let mut current_note_type = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_type = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpe9po9we0.rs:72:11\n   |\n\
    72 |     let mu\n   |           ^ help: add `;` here\n73 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpe9po9we0.rs:8:41\n  |\n\
    8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    ----------- \
    \                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |  \
    \  |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = music_string.chars().nth(0).unwrap();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_to_beat\
    \ = -1;\n    let mut current_note_length_to_beat_with_note = -1;\n    let mut\
    \ current_note_length_to_beat_with_note_length = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = -1;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_be\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqnv_88h3.rs:29:188\n   |\n\
    29 |     let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_be\n\
    \   |                                                                        \
    \                                                                            \
    \                                        ^ help: add `;` here\n30 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpqnv_88h3.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != '|');\n    for\
    \ note in notes {\n        let beat = note.1.parse().unwrap();\n        beats.push(beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp5jlryfm4.rs:10:78\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `parse`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp5jlryfm4.rs:12:27\n\
    \   |\n12 |         let beat = note.1.parse().unwrap();\n   |                \
    \           ^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_octave = 0;\n    for c in music_string {\n        match c {\n  \
    \          'o' => current_note = String::new(),\n            'o|' => current_note\
    \ = String::new(),\n            '.|' => current_note = String::new(),\n      \
    \      'o' => current_octave = 1,\n            'o|' => current_octave = 2,\n \
    \           '.|' => current_octave = 3,\n            _ => current_note.push(c),\n\
    \        }\n    }\n    for c in current_note {\n        match c {\n          \
    \  'o' => beats.push(current_beat),\n            'o|' => beats.push(current_beat\
    \ * 2),\n            '.|' => beats.push(current_beat * 4),\n            _ => panic!(\"\
    Invalid note: {}\", c),\n        }\n        current_beat += 1;\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpdbavd0s3.rs:16:16\n\
    \   |\n16 |             'o|' => current_note = String::new(),\n   |          \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note = 0;\n    let mut current_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat = 0;\n\
    \    let mut current_note_length_to_beat_with_note_length_to_beat_with_note =\
    \ 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_be\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmnalug3_.rs:29:88\n   |\n\
    29 |     let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_be\n\
    \   |                                                                        \
    \                ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpmnalug3_.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    let mut note\
    \ = notes.next();\n    let mut last_note = note;\n    while let Some(note) = note\
    \ {\n        let mut beat = 0;\n        while let Some(note) = note {\n      \
    \      beat += 1;\n            if note == 'o' {\n                beats.push(beat);\n\
    \            }\n            last_note = note;\n            note = notes.next();\n\
    \        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcsoauhoq.rs:10:72\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcsoauhoq.rs:15:19\n\
    \   |\n15 |         while let Some(note) = note {\n   |                   ^^^^^^^^^^\
    \   ---- this expression has type `(usize, char)`\n   |                   |\n\
    \   |                   expected tuple, found enum `Option`\n   |\n   = note:\
    \ expected tuple `(usize, char)`\n               found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `Option<(usize, char)>` with `char`\n  --> /tmp/tmpcsoauhoq.rs:17:21\n\
    \   |\n17 |             if note == 'o' {\n   |                     ^^ no implementation\
    \ for `Option<(usize, char)> == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `Option<(usize, char)>`\n   = help: the trait `PartialEq`\
    \ is implemented for `Option<T>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    let mut current_beats_length = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat = 0;\n    let mut\
    \ current_note_length_to_beat_length_to_beat_length = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_be\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu28a0wrn.rs:31:158\n   |\n\
    31 |     let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_be\n\
    \   |                                                                        \
    \                                                                            \
    \          ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpu28a0wrn.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ last_note = notes.last().unwrap();\n    let mut last_beat = 0;\n    let mut\
    \ last_beats: isize = 0;\n    for note in notes {\n        if note == last_note\
    \ {\n            last_beats += last_beat;\n            last_beat = 0;\n      \
    \  } else {\n            last_beat = 1;\n        }\n        beats.push(last_beats);\n\
    \        last_beats = last_beat;\n        last_note = note;\n    }\n    beats.push(last_beats);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmptcxvbpvo.rs:15:17\n\
    \   |\n15 |         if note == last_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptcxvbpvo.rs:23:21\n   |\n11 |     let mut last_note\
    \ = notes.last().unwrap();\n   |                         ---------------------\
    \ expected due to this value\n...\n23 |         last_note = note;\n   |      \
    \               ^^^^ expected `&str`, found `str`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes: Vec<isize> = vec![];\n    let mut\
    \ beats: Vec<isize> = vec![];\n    let mut current_note = 0;\n    let mut current_beat\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length = 0;\n    let mut current_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat = 0;\n    let mut\
    \ current_beat_length_to_beat_length_to_beat = 0;\n    let mut current_note_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length = 0;\n \
    \   let mut current_note_length_to_beat_length_to_beat_length_to_beat = 0;\n \
    \   let mut current_beat_length_to_beat_length_to_beat_length_to_beat = 0;\n \
    \   let mut current_note_length_to_beat_length_to_beat_length_to_beat_length =\
    \ 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length\
    \ = 0;\n    let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_be\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo45o__kw.rs:36:113\n   |\n\
    36 |     let mut current_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_beat_length_to_be\n\
    \   |                                                                        \
    \                                         ^ help: add `;` here\n37 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpo45o__kw.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_string = music_string.to_string();\n\
    \    let mut music_vec: Vec<isize> = Vec::new();\n    let mut current_beat = 0;\n\
    \    let mut current_note = 0;\n    let mut current_note_len = 0;\n    let mut\
    \ last_note = 0;\n    let mut last_note_len = 0;\n    let mut last_note_len_len\
    \ = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n\
    \    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let\
    \ mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut\
    \ last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len\
    \ = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n\
    \    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let\
    \ mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut\
    \ last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len\
    \ = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n\
    \    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let\
    \ mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut\
    \ last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len\
    \ = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n\
    \    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let\
    \ mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut\
    \ last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len\
    \ = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n\
    \    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let\
    \ mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut\
    \ last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len\
    \ = 0;\n    let mut last_note_len_len = 0;\n    let mut last_note_len_len = 0;\n\
    \    let mut last_note_len_len = 0;\n    let mut last_\n}\n\nfn main() {\n   \
    \ let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvheilrwr.rs:65:18\n   |\n\
    65 |     let mut last_\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvheilrwr.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    for note\
    \ in notes {\n        beats.push(note.1.parse().unwrap());\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpombym819.rs:10:72\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0599]: no method named `parse` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpombym819.rs:12:27\n   |\n12\
    \ |         beats.push(note.1.parse().unwrap());\n   |                       \
    \    ^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_string = music_string.to_string();\n\
    \    let mut beats = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note\
    \ = music_string.chars().nth(1).unwrap();\n    music_string.chars().for_each(|c|\
    \ {\n        if c == current_note {\n            beats.push(current_beat);\n \
    \           current_beat += 1;\n            current_note = music_string.chars().nth(1).unwrap();\n\
    \        } else {\n            current_beat = 0;\n            current_note = c;\n\
    \        }\n    });\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpwfr70evc.rs:12:56

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().next().unwrap();\n\
    \    while current_note != '.' {\n        beats.push(current_beat);\n        current_beat\
    \ += 1;\n        current_note = music_string.chars().next().unwrap();\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmplfk8s9e6.rs:11:56

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_string.len();\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_len = music_string.len();\n\
    \    let mut current_note_len = music_\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppfgmr051.rs:52:38\n   |\n\
    52 |     let mut current_note_len = music_\n   |                             \
    \         ^ help: add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `music_` in this scope\n  --> /tmp/tmppfgmr051.rs:52:32\n\
    \   |\n52 |     let mut current_note_len = music_\n   |                      \
    \          ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmppfgmr051.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_notes = music_string.chars().collect::<Vec<&str>>();\n\
    \    let mut beats = music_notes.len();\n    let mut notes = music_notes.clone();\n\
    \    let mut last_note = music_notes.len();\n    let mut last_beat = music_notes.len();\n\
    \    let mut last_beats = music_notes.len();\n    let mut last_notes = music_notes.len();\n\
    \    let mut last_notes_beats = music_notes.len();\n    let mut last_notes_beats_beats\
    \ = music_notes.len();\n    let mut last_notes_beats_beats_beats = music_notes.len();\n\
    \    let mut last_notes_beats_beats_beats_beats = music_notes.len();\n    let\
    \ mut last_notes_beats_beats_beats_beats_beats = music_notes.len();\n    let mut\
    \ last_notes_beats_beats_beats_beats_beats_beats = music_notes.len();\n    let\
    \ mut last_notes_beats_beats_beats_beats_beats_beats = music_notes.len();\n  \
    \  let mut last_notes_beats_beats_beats_beats_beats_beats_beats = music_notes.len();\n\
    \    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats = music_notes.len();\n\
    \    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = music_notes.len();\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = music_notes.len();\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = music_notes.len();\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = music_notes.len();\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = music_notes.len();\n    let mut last_notes_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats_beats\
    \ = music_notes.len();\n    let mut last_notes_beats_beats_beats_beats_beats_beats_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphlbtvlhs.rs:31:60\n   |\n\
    31 |     let mut last_notes_beats_beats_beats_beats_beats_beats_\n   |       \
    \                                                     ^ help: add `;` here\n32\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<&str>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmphlbtvlhs.rs:9:48\n\
    \     |\n9    |     let mut music_notes = music_string.chars().collect::<Vec<&str>>();\n\
    \     |                                                ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n --> /tmp/tmphlbtvlhs.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_oct2 = 0;\n\
    \    let mut current_note_oct3 = 0;\n    let mut current_note_oct4 = 0;\n    let\
    \ mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n    let mut\
    \ current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let mut current_note_oct9\
    \ = 0;\n    let mut current_note_oct10 = 0;\n    let mut current_note_oct11 =\
    \ 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13 = 0;\n\
    \    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 = 0;\n  \
    \  let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n    let\
    \ mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n    let mut\
    \ current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let mut current_note_oct22\
    \ = 0;\n    let mut current_note_oct23 = 0;\n    let mut current_note_oct24 =\
    \ 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26 = 0;\n\
    \    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 = 0;\n  \
    \  let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n    let\
    \ mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n    let mut\
    \ current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let mut current_note_oct35\
    \ = 0;\n    let mut current_note_oct36 = 0;\n    let mut current_note_oct37 =\
    \ 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39 = 0;\n\
    \    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 = 0;\n  \
    \  let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n    let\
    \ mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n    let mut\
    \ current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let mut current_note_oct48\
    \ = 0;\n    let mut current_note_oct49 = 0;\n    let mut current_note_oct50 =\
    \ 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52 = 0;\n\
    \    let mut current_note_oct53 = 0;\n    let mut current_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpupb6thwo.rs:66:21\n   |\n\
    66 |     let mut current_\n   |                     ^ help: add `;` here\n67 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpupb6thwo.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().collect::<Vec<char>>();\n    let mut current_note = notes.len();\n\
    \    let mut current_beat = 0;\n    let mut current_beats = 4;\n    let mut current_notes\
    \ = 4;\n    let mut current_notes_index = 0;\n    let mut current_notes_index2\
    \ = 0;\n    let mut current_notes_index3 = 0;\n    let mut current_notes_index4\
    \ = 0;\n    let mut current_notes_index5 = 0;\n    let mut current_notes_index6\
    \ = 0;\n    let mut current_notes_index7 = 0;\n    let mut current_notes_index8\
    \ = 0;\n    let mut current_notes_index9 = 0;\n    let mut current_notes_index10\
    \ = 0;\n    let mut current_notes_index11 = 0;\n    let mut current_notes_index12\
    \ = 0;\n    let mut current_notes_index13 = 0;\n    let mut current_notes_index14\
    \ = 0;\n    let mut current_notes_index15 = 0;\n    let mut current_notes_index16\
    \ = 0;\n    let mut current_notes_index17 = 0;\n    let mut current_notes_index18\
    \ = 0;\n    let mut current_notes_index19 = 0;\n    let mut current_notes_index20\
    \ = 0;\n    let mut current_notes_index21 = 0;\n    let mut current_notes_index22\
    \ = 0;\n    let mut current_notes_index23 = 0;\n    let mut current_notes_index24\
    \ = 0;\n    let mut current_notes_index25 = 0;\n    let mut current_notes_index26\
    \ = 0;\n    let mut current_notes_index27 = 0;\n    let mut current_notes_index28\
    \ = 0;\n    let mut current_notes_index29 = 0;\n    let mut current_notes_index30\
    \ = 0;\n    let mut current_notes_index31 = 0;\n    let mut current_notes_index32\
    \ = 0;\n    let mut current_notes_index33 = 0;\n    let mut current_notes_index34\
    \ = 0;\n    let mut current_notes_index35 = 0;\n    let mut current_notes_index36\
    \ = 0;\n    let mut current_notes_index37 = 0;\n    let mut current_notes_index38\
    \ = 0;\n    let mut current_notes_index39 = 0;\n    let mut current_notes_index40\
    \ = 0;\n    let mut current_notes_index41 = 0;\n    let mut current_notes_index42\
    \ = 0;\n    let mut current_notes_index43 = 0;\n    let mut current_notes_index44\
    \ = 0;\n    let mut current_notes_index45 = 0;\n    let mut current_note\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgfopa1jq.rs:60:25\n   |\n\
    60 |     let mut current_note\n   |                         ^ help: add `;` here\n\
    61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpgfopa1jq.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    let mut last_note\
    \ = notes.next().unwrap().0;\n    let mut last_beat = 0;\n    let mut last_beats\
    \ = 4;\n    for note in notes {\n        let note = note.0;\n        let beat\
    \ = note.as_bytes().last().unwrap();\n        if note == 'o' {\n            last_beat\
    \ = beat;\n            last_beats = 4;\n        } else if note == 'o|' {\n   \
    \         last_beat = beat;\n            last_beats = 2;\n        } else if note\
    \ == '.|' {\n            last_beat = beat;\n            last_beats = 1;\n    \
    \    } else {\n            beats.push(beat);\n            last_beat = beat;\n\
    \            last_beats = 4;\n        }\n    }\n    beats.push(last_beat);\n \
    \   beats.push(last_beats);\n    beats\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpaq_vzejv.rs:20:30\n\
    \   |\n20 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_beats_left = 0;\n \
    \   let mut current_notes_left = 0;\n    let mut current_notes_left_in_note =\
    \ 0;\n    let mut current_notes_left_in_beat = 0;\n    let mut current_notes_left_in_beats_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left = 0;\n    let mut current_notes_left_in_notes_left_in_beat\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left = 0;\n    let\
    \ mut current_notes_left_in_notes_left_in_beats_left_in_note = 0;\n    let mut\
    \ current_notes_left_in_notes_left_in_beats_left_in_notes_left = 0;\n    let mut\
    \ current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beat = 0;\n\
    \    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_note\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beat\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_note\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beat\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left\
    \ = 0;\n    let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmfsir7z6.rs:32:111\n   |\n\
    32 |     let mut current_notes_left_in_notes_left_in_beats_left_in_notes_left_in_beats_left_in_notes_left_in_beats_\n\
    \   |                                                                        \
    \                                       ^ help: add `;` here\n33 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmfsir7z6.rs:8:41\n  |\n\
    8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    ----------- \
    \                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |  \
    \  |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.first().unwrap();\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length =\
    \ 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4mugoval.rs:59:40\n   |\n\
    59 |     let mut current_note_length_index44\n   |                           \
    \             ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp4mugoval.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != '|');\n    for\
    \ note in notes {\n        let note = note.0;\n        let beat = note.parse::<isize>().unwrap();\n\
    \        beats.push(beat);\n    }\n    return beats;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpkx2th6hy.rs:10:78\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `parse`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpkx2th6hy.rs:13:25\n\
    \   |\n13 |         let beat = note.parse::<isize>().unwrap();\n   |         \
    \                ^^^^^ method not found in `usize`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ note)| note != 'o').collect::<Vec<_>>();\n    let mut current_note = 0;\n  \
    \  let mut current_beat = 0;\n    let mut current_note_index = 0;\n    let mut\
    \ current_beat_index = 0;\n    let mut current_note_length = 0;\n    let mut current_beat_length\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n    let mut current_note_value = 0;\n    let mut current_beat_length_value\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0xr9d0as.rs:10:78\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o').collect::<Vec<_>>();\n   |                                    \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp0xr9d0as.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_beats = 0;\n    let mut last_beats_after_note\
    \ = 0;\n    let mut last_beats_after_notes = 0;\n    let mut last_beats_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes = 0;\n    let mut last_beats_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes_after_notes = 0;\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc7jwuxh_.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_beats: isize = 0;\n    let mut current_note_index\
    \ = 0;\n    let mut current_note_indexes: Vec<isize> = vec![];\n    let mut current_note_indexes_index\
    \ = 0;\n    let mut current_note_indexes_indexes: Vec<isize> = vec![];\n    let\
    \ mut current_note_indexes_indexes_index = 0;\n    let mut current_note_indexes_indexes_indexes:\
    \ Vec<isize> = vec![];\n    let mut current_note_indexes_indexes_indexes_index\
    \ = 0;\n    let mut current_note_indexes_indexes_indexes_indexes: Vec<isize> =\
    \ vec![];\n    let mut current_note_indexes_indexes_indexes_indexes_index = 0;\n\
    \    let mut current_note_indexes_indexes_indexes_indexes_indexes: Vec<isize>\
    \ = vec![];\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_index\
    \ = 0;\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes:\
    \ Vec<isize> = vec![];\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_index\
    \ = 0;\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes:\
    \ Vec<isize> = vec![];\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_index\
    \ = 0;\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes_indexes:\
    \ Vec<isize> = vec![];\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes_index\
    \ = 0;\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes_indexes:\
    \ Vec<isize> = vec![];\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes_index\
    \ = 0;\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes_indexes_indexes:\
    \ Vec<isize> = vec![];\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes_indexes_index\
    \ = 0;\n    let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes_indexes_index\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpusahf7q7.rs:35:87\n   |\n\
    35 |     let mut current_note_indexes_indexes_indexes_indexes_indexes_indexes_indexes_index\n\
    \   |                                                                        \
    \               ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpusahf7q7.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note_index = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_octave = 0;\n    let mut current_note_octave_offset\
    \ = 0;\n    let mut current_note_octave_length = 0;\n    let mut current_note_octave_offset\
    \ = 0;\n    let mut current_note_octave_index = 0;\n    let mut current_note_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_offset = 0;\n    let mut current_note_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_offset = 0;\n    let mut current_note_octave_octave_index\
    \ = 0;\n    let mut current_note_octave_octave_octave = 0;\n    let mut current_note_octave_octave_offset\
    \ = 0;\n    let mut current_note_octave_octave_length = 0;\n    let mut current_note_octave_octave_offset\
    \ = 0;\n    let mut current_note_octave_octave_index = 0;\n    let mut current_note_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_offset = 0;\n    let mut current_note_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_offset = 0;\n    let mut current_note_octave_octave_index\
    \ = 0;\n    let mut current_note_octave_octave_octave = 0;\n    let mut current_note_octave_octave_offset\
    \ = 0;\n    let mut current_note_octave_octave_length = 0;\n    let mut current_note_octave_octave_offset\
    \ = 0;\n    let mut current_note_octave_octave_index = 0;\n    let mut current_note_octave_octave_octave\
    \ = 0;\n    let mut current_note_octave_octave_offset = 0;\n    let mut current_note_octave_octave_length\
    \ = 0;\n    let mut current_note_octave_octave_offset = 0;\n    let mut current_note_octave_octave_index\
    \ = 0;\n    let mut current_note_octave_octave_octave = 0;\n    let mut current_note_octave_octave_offset\
    \ = 0;\n    let mut current_note_octave_octave_length = 0;\n    let mut current_note_oct\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4pyoioci.rs:48:29\n   |\n\
    48 |     let mut current_note_oct\n   |                             ^ help: add\
    \ `;` here\n49 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp4pyoioci.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut notes_len2:\
    \ usize = 0;\n    let mut notes_len3: usize = 0;\n    let mut notes_len4: usize\
    \ = 0;\n    let mut notes_len5: usize = 0;\n    let mut notes_len6: usize = 0;\n\
    \    let mut notes_len7: usize = 0;\n    let mut notes_len8: usize = 0;\n    let\
    \ mut notes_len9: usize = 0;\n    let mut notes_len10: usize = 0;\n    let mut\
    \ notes_len11: usize = 0;\n    let mut notes_len12: usize = 0;\n    let mut notes_len13:\
    \ usize = 0;\n    let mut notes_len14: usize = 0;\n    let mut notes_len15: usize\
    \ = 0;\n    let mut notes_len16: usize = 0;\n    let mut notes_len17: usize =\
    \ 0;\n    let mut notes_len18: usize = 0;\n    let mut notes_len19: usize = 0;\n\
    \    let mut notes_len20: usize = 0;\n    let mut notes_len21: usize = 0;\n  \
    \  let mut notes_len22: usize = 0;\n    let mut notes_len23: usize = 0;\n    let\
    \ mut notes_len24: usize = 0;\n    let mut notes_len25: usize = 0;\n    let mut\
    \ notes_len26: usize = 0;\n    let mut notes_len27: usize = 0;\n    let mut notes_len28:\
    \ usize = 0;\n    let mut notes_len29: usize = 0;\n    let mut notes_len30: usize\
    \ = 0;\n    let mut notes_len31: usize = 0;\n    let mut notes_len32: usize =\
    \ 0;\n    let mut notes_len33: usize = 0;\n    let mut notes_len34: usize = 0;\n\
    \    let mut notes_len35: usize = 0;\n    let mut notes_len36: usize = 0;\n  \
    \  let mut notes_len37: usize = 0;\n    let mut notes_len38: usize = 0;\n    let\
    \ mut notes_len39: usize = 0;\n    let mut notes_len40: usize = 0;\n    let mut\
    \ notes_len4\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk5ybfbm3.rs:51:23\n   |\n\
    51 |     let mut notes_len4\n   |                       ^ help: add `;` here\n\
    52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk5ybfbm3.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_beats: isize = 0;\n    let mut last_beats_after_note\
    \ = 0;\n    let mut last_beats_after_notes: isize = 0;\n    let mut last_beats_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes: isize = 0;\n    let mut\
    \ last_beats_after_notes_after_notes_after_note = 0;\n    let mut last_beats_after_notes_after_notes_after_notes:\
    \ isize = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes:\
    \ isize = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes:\
    \ isize = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes:\
    \ isize = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes:\
    \ isize = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes:\
    \ isize = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr8rloz7k.rs:32:126\n   |\n\
    32 |     let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_\n\
    \   |                                                                        \
    \                                                      ^ help: add `;` here\n\
    33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpr8rloz7k.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.chars().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_beats:\
    \ isize = 0;\n    let mut current_notes: isize = 0;\n    let mut current_notes_length:\
    \ isize = 0;\n    let mut current_notes_lengths: isize = 0;\n    let mut current_notes_lengths_length:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths: isize = 0;\n    let mut\
    \ current_notes_lengths_lengths_length: isize = 0;\n    let mut current_notes_lengths_lengths_lengths:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_length: isize\
    \ = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths: isize = 0;\n\
    \    let mut current_notes_lengths_lengths_lengths_lengths_length: isize = 0;\n\
    \    let mut current_notes_lengths_lengths_lengths_lengths_lengths: isize = 0;\n\
    \    let mut current_notes_lengths_lengths_lengths_lengths_lengths_length: isize\
    \ = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_length:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_lengths_length:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_lengths_length:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length:\
    \ isize = 0;\n    let mut current_notes_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length:\
    \ isize = 0;\n    let mut current_notes_length\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvy3gyn6d.rs:36:33\n   |\n\
    36 |     let mut current_notes_length\n   |                                 ^\
    \ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<&str>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpvy3gyn6d.rs:10:53\n     |\n10   |     let mut notes: Vec<&str>\
    \ = music_string.chars().collect();\n     |                                  \
    \                   ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvy3gyn6d.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.chars().collect();\n    let mut last_note\
    \ = notes.last().unwrap();\n    let mut last_beat = 0;\n    let mut last_beats:\
    \ isize = 0;\n    notes.iter().for_each(|note| {\n        if note == last_note\
    \ {\n            last_beats += 1;\n        } else {\n            beats.push(last_beats);\n\
    \            last_beats = 0;\n            last_beats += 1;\n            last_note\
    \ = note;\n        }\n    });\n    beats.push(last_beats);\n    beats\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp2oqra7lc.rs:10:53\n     |\n10\
    \   |     let mut notes: Vec<&str> = music_string.chars().collect();\n     | \
    \                                                    ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut notes = music_string.chars().enumerate().filter(|&(_, note)| note\
    \ != '|');\n    for note in notes {\n        let mut note_string = note.1.to_string();\n\
    \        let mut beats = note_string.chars().enumerate().filter(|&(_, beat)| beat\
    \ != 'o');\n        for beat in beats {\n            music_vec.push(beat.1.to_isize());\n\
    \        }\n    }\n    music_vec\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_isize` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpv4pei1c7.rs:15:35\n   |\n15 |             music_vec.push(beat.1.to_isize());\n\
    \   |                                   ^^^^^^^^ method not found in `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_note_len = String::new();\n    let mut\
    \ current_beat = 0;\n    let mut current_beat_len = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_len_len = 0;\n    let mut current_beat_len_len\
    \ = 0;\n    let mut current_note_len_len_len = 0;\n    let mut current_beat_len_len_len\
    \ = 0;\n    let mut current_note_len_len = 0;\n    let mut current_beat_len =\
    \ 0;\n    let mut current_note = String::new();\n    let mut current_note_len\
    \ = String::new();\n    let mut current_beat = 0;\n    let mut current_beat_len\
    \ = 0;\n    let mut current_note_len = 0;\n    let mut current_note_len_len =\
    \ 0;\n    let mut current_beat_len_len = 0;\n    let mut current_note_len_len\
    \ = 0;\n    let mut current_beat_len_len = 0;\n    let mut current_note_len =\
    \ 0;\n    let mut current_beat_len = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = String::new();\n    let mut current_beat = 0;\n\
    \    let mut current_beat_len = 0;\n    let mut current_note_len = 0;\n    let\
    \ mut current_note_len_len = 0;\n    let mut current_beat_len_len = 0;\n    let\
    \ mut current_note_len_len = 0;\n    let mut current_beat_len_len = 0;\n    let\
    \ mut current_note_len = 0;\n    let mut current_beat_len = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_note_len = String::new();\n    let mut\
    \ current_beat = 0;\n    let mut current_beat_len = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_len_len = 0;\n    let mut current_beat_len_len\
    \ = 0;\n    let mut current_note_len_len = 0;\n    let mut current_beat_len_len\
    \ = 0;\n    let mut current_note_len = 0;\n    let mut current_beat_len = 0;\n\
    \    let mut current_note = String::new();\n    let mut current_note_len = String::new();\n\
    \    let mut current_beat = 0;\n    let mut current_beat_len = 0;\n    let mut\
    \ current_note_len = 0;\n    let mut current_note_len_len = 0;\n    let mut current_beat_len_len\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0nckcg56.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_string = music_string.to_string();\n\
    \    let mut music_vec: Vec<isize> = Vec::new();\n    let mut note_count = 0;\n\
    \    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_beats\
    \ = 0;\n    let mut last_beats_after_note = 0;\n    let mut last_beats_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_note = 0;\n    let mut last_beats_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl2sxrsio.rs:40:60\n   |\n\
    40 |     let mut last_beats_after_notes_after_notes_after_notes_\n   |       \
    \                                                     ^ help: add `;` here\n41\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpl2sxrsio.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.last().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_length = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzc6co4re.rs:59:38\n   |\n\
    59 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpzc6co4re.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n \
    \   let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy8klw_fm.rs:61:1\n\
    \   |\n61 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ last_note = notes.last().unwrap();\n    let mut last_beat = 0;\n    let mut\
    \ last_beats_cnt = 0;\n    for note in notes {\n        if note == last_note {\n\
    \            last_beats_cnt += 1;\n        } else {\n            beats.push(last_beats_cnt);\n\
    \            last_beats_cnt = 0;\n            last_beat = 0;\n            last_note\
    \ = note;\n        }\n    }\n    beats.push(last_beats_cnt);\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp6jfjr7av.rs:15:17\n\
    \   |\n15 |         if note == last_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6jfjr7av.rs:21:25\n   |\n11 |     let mut last_note\
    \ = notes.last().unwrap();\n   |                         ---------------------\
    \ expected due to this value\n...\n21 |             last_note = note;\n   |  \
    \                       ^^^^ expected `&str`, found `str`\n   |\n   = note: expected\
    \ reference `&&str`\n              found reference `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_beats: isize = 0;\n    let mut last_beats_len\
    \ = 0;\n    let mut last_beats_len2 = 0;\n    let mut last_beats_len3 = 0;\n \
    \   let mut last_beats_len4 = 0;\n    let mut last_beats_len5 = 0;\n    let mut\
    \ last_beats_len6 = 0;\n    let mut last_beats_len7 = 0;\n    let mut last_beats_len8\
    \ = 0;\n    let mut last_beats_len9 = 0;\n    let mut last_beats_len10 = 0;\n\
    \    let mut last_beats_len11 = 0;\n    let mut last_beats_len12 = 0;\n    let\
    \ mut last_beats_len13 = 0;\n    let mut last_beats_len14 = 0;\n    let mut last_beats_len15\
    \ = 0;\n    let mut last_beats_len16 = 0;\n    let mut last_beats_len17 = 0;\n\
    \    let mut last_beats_len18 = 0;\n    let mut last_beats_len19 = 0;\n    let\
    \ mut last_beats_len20 = 0;\n    let mut last_beats_len21 = 0;\n    let mut last_beats_len22\
    \ = 0;\n    let mut last_beats_len23 = 0;\n    let mut last_beats_len24 = 0;\n\
    \    let mut last_beats_len25 = 0;\n    let mut last_beats_len26 = 0;\n    let\
    \ mut last_beats_len27 = 0;\n    let mut last_beats_len28 = 0;\n    let mut last_beats_len29\
    \ = 0;\n    let mut last_beats_len30 = 0;\n    let mut last_beats_len31 = 0;\n\
    \    let mut last_beats_len32 = 0;\n    let mut last_beats_len33 = 0;\n    let\
    \ mut last_beats_len34 = 0;\n    let mut last_beats_len35 = 0;\n    let mut last_beats_len36\
    \ = 0;\n    let mut last_beats_len37 = 0;\n    let mut last_beats_len38 = 0;\n\
    \    let mut last_beats_len39 = 0;\n    let mut last_beats_len40 = 0;\n    let\
    \ mut last_beats_len41 = 0;\n    let mut last_beats_len42 = 0;\n    let mut last_beats_len43\
    \ = 0;\n    let mut last_beats_len44 = 0;\n    let mut last_beats_len45 = 0;\n\
    \    let mut last_beats_len46 = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsgppajca.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_octave\
    \ = 0;\n    for c in music_string {\n        if c.is_ascii() {\n            if\
    \ c == 'o' {\n                if current_note.is_empty() {\n                 \
    \   current_note = String::from(\"o\");\n                    current_octave =\
    \ 0;\n                } else {\n                    current_note = String::from(current_note\
    \ + \"o\");\n                    current_octave++;\n                }\n      \
    \      } else {\n                if current_note.is_empty() {\n              \
    \      current_note = String::from(c);\n                } else {\n           \
    \         current_note = String::from(current_note + c);\n                }\n\
    \            }\n        } else {\n            if current_note.is_empty() {\n \
    \               panic!(\"Music string contains non-ascii character\");\n     \
    \       }\n            if c == '|' {\n                if current_note.len() ==\
    \ 1 {\n                    current_note = String::from(\"o\");\n             \
    \       current_octave = 0;\n                } else {\n                    current_note\
    \ = String::from(current_note + \"o\");\n                    current_octave++;\n\
    \                }\n            } else {\n                if current_note.len()\
    \ == 1 {\n                    current_note = String::from(c);\n              \
    \  } else {\n                    current_note = String::from(current_note + c);\n\
    \                }\n            }\n        }\n        if current_note.len() ==\
    \ 1 {\n            beats.push(current_beat);\n            current_beat = 0;\n\
    \            current_note = String::new();\n            current_octave = 0;\n\
    \        } else {\n            current_beat++;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpacagmiru.rs:21:35\n\
    \   |\n21 |                     current_octave++;\n   |                      \
    \             ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n21 |                     { let tmp = current_octave; current_octave +=\
    \ 1; tmp };\n   |                     +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    21 -                     current_octave++;\n21 +                     current_octave\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpacagmiru.rs:40:35\n\
    \   |\n40 |                     current_octave++;\n   |                      \
    \             ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n40 |                     { let tmp = current_octave; current_octave +=\
    \ 1; tmp };\n   |                     +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    40 -                     current_octave++;\n40 +                     current_octave\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpacagmiru.rs:56:25\n\
    \   |\n56 |             current_beat++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n56 |         \
    \    { let tmp = current_beat; current_beat += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n56 -             current_beat++;\n56\
    \ +             current_beat += 1;\n   | \n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmpacagmiru.rs:13:14\n   |\n13 |     for c in music_string\
    \ {\n   |              ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut current_note_octlen\
    \ = 0;\n    let mut current_note_octlen2 = 0;\n    let mut current_note_octlen3\
    \ = 0;\n    let mut current_note_octlen4 = 0;\n    let mut current_note_octlen5\
    \ = 0;\n    let mut current_note_octlen6 = 0;\n    let mut current_note_octlen7\
    \ = 0;\n    let mut current_note_octlen8 = 0;\n    let mut current_note_octlen9\
    \ = 0;\n    let mut current_note_octlen10 = 0;\n    let mut current_note_octlen11\
    \ = 0;\n    let mut current_note_octlen12 = 0;\n    let mut current_note_octlen13\
    \ = 0;\n    let mut current_note_octlen14 = 0;\n    let mut current_note_octlen15\
    \ = 0;\n    let mut current_note_octlen16 = 0;\n    let mut current_note_octlen17\
    \ = 0;\n    let mut current_note_octlen18 = 0;\n    let mut current_note_octlen19\
    \ = 0;\n    let mut current_note_octlen20 = 0;\n    let mut current_note_octlen21\
    \ = 0;\n    let mut current_note_octlen22 = 0;\n    let mut current_note_octlen23\
    \ = 0;\n    let mut current_note_octlen24 = 0;\n    let mut current_note_octlen25\
    \ = 0;\n    let mut current_note_octlen26 = 0;\n    let mut current_note_octlen27\
    \ = 0;\n    let mut current_note_octlen28 = 0;\n    let mut current_note_octlen29\
    \ = 0;\n    let mut current_note_octlen30 = 0;\n    let mut current_note_octlen31\
    \ = 0;\n    let mut current_note_octlen32 = 0;\n    let mut current_note_octlen33\
    \ = 0;\n    let mut current_note_octlen34 = 0;\n    let mut current_note_octlen35\
    \ = 0;\n    let mut current_note_octlen36 = 0;\n    let mut current_note_octlen37\
    \ = 0;\n    let mut current_note_octlen38 = 0;\n    let mut current_note_octlen39\
    \ = 0;\n    let mut current_note_octlen40 = 0;\n    let mut current_note_octlen41\
    \ = 0;\n    let mut current_note_octlen42 = 0;\n    let mut current_note_octlen43\
    \ = 0;\n    let mut current_note_octlen44 = 0;\n    let mut current_note_octlen45\
    \ = 0;\n    let mut current_note_octlen46 = 0;\n    let mut current_note_\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpql54oaii.rs:60:26\n   |\n\
    60 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpql54oaii.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_octave = 0;\n    let mut last_duration\
    \ = 0;\n    let mut last_duration_index = 0;\n    let mut last_duration_index2\
    \ = 0;\n    let mut last_duration_index3 = 0;\n    let mut last_duration_index4\
    \ = 0;\n    let mut last_duration_index5 = 0;\n    let mut last_duration_index6\
    \ = 0;\n    let mut last_duration_index7 = 0;\n    let mut last_duration_index8\
    \ = 0;\n    let mut last_duration_index9 = 0;\n    let mut last_duration_index10\
    \ = 0;\n    let mut last_duration_index11 = 0;\n    let mut last_duration_index12\
    \ = 0;\n    let mut last_duration_index13 = 0;\n    let mut last_duration_index14\
    \ = 0;\n    let mut last_duration_index15 = 0;\n    let mut last_duration_index16\
    \ = 0;\n    let mut last_duration_index17 = 0;\n    let mut last_duration_index18\
    \ = 0;\n    let mut last_duration_index19 = 0;\n    let mut last_duration_index20\
    \ = 0;\n    let mut last_duration_index21 = 0;\n    let mut last_duration_index22\
    \ = 0;\n    let mut last_duration_index23 = 0;\n    let mut last_duration_index24\
    \ = 0;\n    let mut last_duration_index25 = 0;\n    let mut last_duration_index26\
    \ = 0;\n    let mut last_duration_index27 = 0;\n    let mut last_duration_index28\
    \ = 0;\n    let mut last_duration_index29 = 0;\n    let mut last_duration_index30\
    \ = 0;\n    let mut last_duration_index31 = 0;\n    let mut last_duration_index32\
    \ = 0;\n    let mut last_duration_index33 = 0;\n    let mut last_duration_index34\
    \ = 0;\n    let mut last_duration_index35 = 0;\n    let mut last_duration_index36\
    \ = 0;\n    let mut last_duration_index37 = 0;\n    let mut last_duration_index38\
    \ = 0;\n    let mut last_duration_index39 = 0;\n    let mut last_duration_index40\
    \ = 0;\n    let mut last_duration_index41 = 0;\n    let mut last_duration_index42\
    \ = 0;\n    let mut last_duration_index43 = 0;\n    let mut last_duration_index44\
    \ = 0;\n    let mut last_duration_index45 = 0;\n    let mut last_duration_index46\
    \ = 0;\n    let mut last_duration_index47 = 0;\n    let mut last_duration_index48\
    \ = 0;\n    let mut last_duration_index49 = 0;\n    let mut last_duration_index50\
    \ = 0;\n    let mut last_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1305ww7b.rs:65:18\n   |\n\
    65 |     let mut last_\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1305ww7b.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_ascii_whitespace().collect();\n  \
    \  let mut current_note = notes.first().unwrap();\n    let mut current_beat =\
    \ 0;\n    let mut current_beats_length = 0;\n    for note in notes {\n       \
    \ if note == current_note {\n            current_beats_length += 1;\n        }\
    \ else {\n            beats.push(current_beats_length);\n            current_beats_length\
    \ = 1;\n            current_beat = 0;\n            current_note = note;\n    \
    \    }\n    }\n    beats.push(current_beats_length);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpu672t9cq.rs:15:17\n\
    \   |\n15 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu672t9cq.rs:21:28\n   |\n11 |     let mut current_note\
    \ = notes.first().unwrap();\n   |                            ----------------------\
    \ expected due to this value\n...\n21 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    let mut last_note\
    \ = notes.next();\n    let mut last_beat = 0;\n    let mut last_beats = 4;\n \
    \   let mut last_beats_index = 0;\n    for note in notes {\n        let mut beat\
    \ = 0;\n        let mut note = note.0;\n        let mut note_index = 0;\n    \
    \    while note != '|' {\n            if note == 'o' {\n                beat +=\
    \ 4;\n                note_index += 1;\n            } else if note == 'o|' {\n\
    \                beat += 2;\n                note_index += 1;\n            } else\
    \ if note == '.|' {\n                beat += 1;\n                note_index +=\
    \ 1;\n            } else {\n                note_index += 1;\n            }\n\
    \            note = notes[note_index].0;\n        }\n        if beat > last_beat\
    \ {\n            last_beat = beat;\n            last_beats_index = note_index;\n\
    \        }\n        beats.push(beat);\n    }\n    beats[last_beats_index..].into_iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp3ao1k4qq.rs:23:34\n\
    \   |\n23 |             } else if note == 'o|' {\n   |                       \
    \           ^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, note)| note != '|');\n    let\
    \ mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_length\
    \ = -1;\n    let mut current_beat_length = -1;\n    let mut current_note_\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5vscurln.rs:67:26\n   |\n\
    67 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n68 | }\n   | - unexpected token\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp5vscurln.rs:10:78\n   |\n10 |     let mut notes =\
    \ music_string.chars().enumerate().filter(|(_, note)| note != '|');\n   |    \
    \                                                                          ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5vscurln.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut last_note\
    \ = String::new();\n    let mut last_beat = 0;\n    let mut last_beat_len = 0;\n\
    \    let mut last_note_len = 0;\n    let mut last_note_char: char;\n    let mut\
    \ last_note_char_len = 0;\n    let mut last_note_char_len2 = 0;\n    let mut last_note_char_len3\
    \ = 0;\n    let mut last_note_char_len4 = 0;\n    let mut last_note_char_len5\
    \ = 0;\n    let mut last_note_char_len6 = 0;\n    let mut last_note_char_len7\
    \ = 0;\n    let mut last_note_char_len8 = 0;\n    let mut last_note_char_len9\
    \ = 0;\n    let mut last_note_char_len10 = 0;\n    let mut last_note_char_len11\
    \ = 0;\n    let mut last_note_char_len12 = 0;\n    let mut last_note_char_len13\
    \ = 0;\n    let mut last_note_char_len14 = 0;\n    let mut last_note_char_len15\
    \ = 0;\n    let mut last_note_char_len16 = 0;\n    let mut last_note_char_len17\
    \ = 0;\n    let mut last_note_char_len18 = 0;\n    let mut last_note_char_len19\
    \ = 0;\n    let mut last_note_char_len20 = 0;\n    let mut last_note_char_len21\
    \ = 0;\n    let mut last_note_char_len22 = 0;\n    let mut last_note_char_len23\
    \ = 0;\n    let mut last_note_char_len24 = 0;\n    let mut last_note_char_len25\
    \ = 0;\n    let mut last_note_char_len26 = 0;\n    let mut last_note_char_len27\
    \ = 0;\n    let mut last_note_char_len28 = 0;\n    let mut last_note_char_len29\
    \ = 0;\n    let mut last_note_char_len30 = 0;\n    let mut last_note_char_len31\
    \ = 0;\n    let mut last_note_char_len32 = 0;\n    let mut last_note_char_len33\
    \ = 0;\n    let mut last_note_char_len34 = 0;\n    let mut last_note_char_len35\
    \ = 0;\n    let mut last_note_char_len36 = 0;\n    let mut last_note_char_len37\
    \ = 0;\n    let mut last_note_char_len38 = 0;\n    let mut last_note_char_len39\
    \ = 0;\n    let mut last_note_char_len40 = 0;\n    let mut last_note_char_len41\
    \ = 0;\n    let mut last_note_char_len42 = 0;\n    let mut last_note_char_len43\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwrlvyvu4.rs:60:11\n   |\n\
    60 |     let mu\n   |           ^ help: add `;` here\n61 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwrlvyvu4.rs:8:41\n  |\n\
    8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    ----------- \
    \                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |  \
    \  |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_len = 0;\n   \
    \ let mut current_note_char = 0;\n    let mut current_note_char_len = 0;\n   \
    \ let mut current_note_char_value = 0;\n    let mut current_note_char_value_len\
    \ = 0;\n    let mut current_note_char_value_len2 = 0;\n    let mut current_note_char_value_len3\
    \ = 0;\n    let mut current_note_char_value_len4 = 0;\n    let mut current_note_char_value_len5\
    \ = 0;\n    let mut current_note_char_value_len6 = 0;\n    let mut current_note_char_value_len7\
    \ = 0;\n    let mut current_note_char_value_len8 = 0;\n    let mut current_note_char_value_len9\
    \ = 0;\n    let mut current_note_char_value_len10 = 0;\n    let mut current_note_char_value_len11\
    \ = 0;\n    let mut current_note_char_value_len12 = 0;\n    let mut current_note_char_value_len13\
    \ = 0;\n    let mut current_note_char_value_len14 = 0;\n    let mut current_note_char_value_len15\
    \ = 0;\n    let mut current_note_char_value_len16 = 0;\n    let mut current_note_char_value_len17\
    \ = 0;\n    let mut current_note_char_value_len18 = 0;\n    let mut current_note_char_value_len19\
    \ = 0;\n    let mut current_note_char_value_len20 = 0;\n    let mut current_note_char_value_len21\
    \ = 0;\n    let mut current_note_char_value_len22 = 0;\n    let mut current_note_char_value_len23\
    \ = 0;\n    let mut current_note_char_value_len24 = 0;\n    let mut current_note_char_value_len25\
    \ = 0;\n    let mut current_note_char_value_len26 = 0;\n    let mut current_note_char_value_len27\
    \ = 0;\n    let mut current_note_char_value_len28 = 0;\n    let mut current_note_char_value_len29\
    \ = 0;\n    let mut current_note_char_value_len30 = 0;\n    let mut current_note_char_value_len31\
    \ = 0;\n    let mut current_note_char_value_len32 = 0;\n    let mut current_note_char_value_len33\
    \ = 0;\n    let mut current_note_char_value_len34 = 0;\n    let mut current_note_char_value_len35\
    \ = 0;\n    let mut current_note_char_value_len36 = 0;\n    let mut current_note_char_value_len37\
    \ = 0;\n    let mut current_note_char_value_len38 = 0;\n    let mut current_note_char_value_len39\
    \ = 0;\n    let mut current_note_char_value_len40 = 0;\n    let mut current_note_char_value_len41\
    \ = 0;\n    let mut current_note_char_value_len\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplmubugpw.rs:57:40\n   |\n\
    57 |     let mut current_note_char_value_len\n   |                           \
    \             ^ help: add `;` here\n58 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmplmubugpw.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.first().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_beat = 0;\n    let mut current_note_beat_len\
    \ = 0;\n    let mut current_note_beat_len2 = 0;\n    let mut current_note_beat_len3\
    \ = 0;\n    let mut current_note_beat_len4 = 0;\n    let mut current_note_beat_len5\
    \ = 0;\n    let mut current_note_beat_len6 = 0;\n    let mut current_note_beat_len7\
    \ = 0;\n    let mut current_note_beat_len8 = 0;\n    let mut current_note_beat_len9\
    \ = 0;\n    let mut current_note_beat_len10 = 0;\n    let mut current_note_beat_len11\
    \ = 0;\n    let mut current_note_beat_len12 = 0;\n    let mut current_note_beat_len13\
    \ = 0;\n    let mut current_note_beat_len14 = 0;\n    let mut current_note_beat_len15\
    \ = 0;\n    let mut current_note_beat_len16 = 0;\n    let mut current_note_beat_len17\
    \ = 0;\n    let mut current_note_beat_len18 = 0;\n    let mut current_note_beat_len19\
    \ = 0;\n    let mut current_note_beat_len20 = 0;\n    let mut current_note_beat_len21\
    \ = 0;\n    let mut current_note_beat_len22 = 0;\n    let mut current_note_beat_len23\
    \ = 0;\n    let mut current_note_beat_len24 = 0;\n    let mut current_note_beat_len25\
    \ = 0;\n    let mut current_note_beat_len26 = 0;\n    let mut current_note_beat_len27\
    \ = 0;\n    let mut current_note_beat_len28 = 0;\n    let mut current_note_beat_len29\
    \ = 0;\n    let mut current_note_beat_len30 = 0;\n    let mut current_note_beat_len31\
    \ = 0;\n    let mut current_note_beat_len32 = 0;\n    let mut current_note_beat_len33\
    \ = 0;\n    let mut current_note_beat_len34 = 0;\n    let mut current_note_beat_len35\
    \ = 0;\n    let mut current_note_beat_len36 = 0;\n    let mut current_note_beat_len37\
    \ = 0;\n    let mut current_note_beat_len38 = 0;\n    let mut current_note_beat_len39\
    \ = 0;\n    let mut current_note_beat_len40 = 0;\n    let mut current_note_be\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpygnuu8_3.rs:55:28\n   |\n\
    55 |     let mut current_note_be\n   |                            ^ help: add\
    \ `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpygnuu8_3.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut music_chars: Vec<char> = music_string.chars().collect();\n    let\
    \ mut music_char: char;\n    let mut music_beats: isize = 0;\n    let mut music_last_char:\
    \ char;\n    let mut music_last_beats: isize = 0;\n    let mut music_last_last_char:\
    \ char;\n    let mut music_last_last_beats: isize = 0;\n    let mut music_last_last_last_char:\
    \ char;\n    let mut music_last_last_last_beats: isize = 0;\n    let mut music_last_last_last_last_char:\
    \ char;\n    let mut music_last_last_last_last_beats: isize = 0;\n    let mut\
    \ music_last_last_last_last_last_char: char;\n    let mut music_last_last_last_last_last_beats:\
    \ isize = 0;\n    let mut music_last_last_last_last_last_last_char: char;\n  \
    \  let mut music_last_last_last_last_last_last_beats: isize = 0;\n    let mut\
    \ music_last_last_last_last_last_last_last_char: char;\n    let mut music_last_last_last_last_last_last_last_beats:\
    \ isize = 0;\n    let mut music_last_last_last_last_last_last_last_last_char:\
    \ char;\n    let mut music_last_last_last_last_last_last_last_last_beats: isize\
    \ = 0;\n    let mut music_last_last_last_last_last_last_last_last_last_char: char;\n\
    \    let mut music_last_last_last_last_last_last_last_last_last_beats: isize =\
    \ 0;\n    let mut music_last_last_last_last_last_last_last_last_last_last_char:\
    \ char;\n    let mut music_last_last_last_last_last_last_last_last_last_last_beats:\
    \ isize = 0;\n    let mut music_last_last_last_last_last_last_last_last_last_last_last_char:\
    \ char;\n    let mut music_last_last_last_last_last_last_last_last_last_last_last_beats:\
    \ isize = 0;\n    let mut music_last_last_last_last_last_last_last_last_last_last_last_last_char:\
    \ char;\n    let mut music_last_last_last_last_last_last_last_last_last_last_last_beats:\
    \ isize = 0;\n    let mut music_last_last_last_last_last_last_last_last_last_last_last_last_last_char:\
    \ char;\n    let mut music_last_last_last_last_last_last_last_last_last_last_last_last_last_beats:\
    \ isize = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfcdg4dpt.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_octave = 0;\n    let mut current_note_is_octave = false;\n    for\
    \ c in music_string.chars() {\n        if c == 'o' {\n            if current_note_is_octave\
    \ {\n                println!(\"Invalid music string\");\n                break;\n\
    \            }\n            current_note_is_octave = true;\n            current_octave\
    \ += 1;\n            current_note = String::new();\n            current_note_is_octave\
    \ = false;\n        }\n        if c == '|' {\n            if current_note_is_octave\
    \ {\n                println!(\"Invalid music string\");\n                break;\n\
    \            }\n            current_note_is_octave = false;\n            current_octave\
    \ -= 1;\n            current_note = String::new();\n            current_note_is_octave\
    \ = false;\n        }\n        if c == ' ' {\n            if current_note_is_octave\
    \ {\n                println!(\"Invalid music string\");\n                break;\n\
    \            }\n            current_note_is_octave = false;\n            current_note\
    \ = String::new();\n            current_note_is_octave = false;\n        }\n \
    \       if c == '.' {\n            if current_note_is_octave {\n             \
    \   println!(\"Invalid music string\");\n                break;\n            }\n\
    \            current_note_is_octave = false;\n            current_note = String::new();\n\
    \            current_note_is_octave = false;\n        }\n        if c == 'o' {\n\
    \            if current_note_is_octave {\n                println!(\"Invalid music\
    \ string\");\n                break;\n            }\n            current_note_is_octave\
    \ = true;\n            current_octave += 1;\n            current_note = String::new();\n\
    \            current_note_is_octave = false;\n        }\n        if c == '|' {\n\
    \            if current_note_is_octave {\n                println!(\"Invalid music\
    \ string\");\n                break;\n            }\n            current_note_is_octave\
    \ = false;\n            current_octave -= 1;\n            current_note = String::new();\n\
    \            current_note_is_octave = false;\n        }\n        if c == ' ' {\n\
    \            if current_note_is_octave {\n                println!(\"Invalid music\
    \ string\");\n                break;\n            }\n            current_note_is_octave\
    \ = false;\n            current_note = String::new();\n            current_note_is_octave\
    \ = false;\n        }\n        if c == '.' {\n            if current_note_is_octave\
    \ {\n                println!(\"Invalid music string\");\n                break;\n\
    \            }\n            current_note_is_octave = false;\n            current_note\
    \ = String::new();\n            current_note_is_octave\n}\n\nfn main() {\n   \
    \ let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp800febpn.rs:99:3\n\
    \   |\n8  | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n14 |\
    \     for c in music_string.chars() {\n   |                                  \
    \ - unclosed delimiter\n...\n82 |         if c == '.' {\n   |                \
    \     - this delimiter might not be properly closed...\n...\n90 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n99 | }\n   |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp800febpn.rs:89:13\n   |\n82 | /\
    \         if c == '.' {\n83 | |             if current_note_is_octave {\n84 |\
    \ |                 println!(\"Invalid music string\");\n85 | |              \
    \   break;\n...  |\n89 | |             current_note_is_octave\n   | |        \
    \     ^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found `bool`\n90 | | }\n   | |_- expected\
    \ this to be `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp800febpn.rs:14:5\n\
    \   |\n8  |   fn parse_music(music_string: String) -> Vec<isize> {\n   |     \
    \                                      ---------- expected `Vec<isize>` because\
    \ of return type\n...\n14 | /     for c in music_string.chars() {\n15 | |    \
    \     if c == 'o' {\n16 | |             if current_note_is_octave {\n17 | |  \
    \               println!(\"Invalid music string\");\n...  |\n98 | |     assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n99 | | }\n   | |__^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_length = 0;\n    let\
    \ mut current_note_length = 0;\n    let mut current_note_length_to_beat = 0;\n\
    \    let mut current_note_length_to_length = 0;\n    let mut current_note_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_beat = 0;\n   \
    \ let mut current_note_length_to_length_to_length_to_length_to_beat = 0;\n   \
    \ let mut current_note_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8x0iyhx1.rs:32:96\n   |\n\
    32 |     let mut current_note_length_to_length_to_length_to_length_to_length_to_length_to_length_to_\n\
    \   |                                                                        \
    \                        ^ help: add `;` here\n33 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp8x0iyhx1.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    for note in notes {\n        if note.1\
    \ == '.' {\n            beats.push(current_beat);\n            current_beat =\
    \ 0;\n            current_note += 1;\n        } else if note.1 == ',' {\n    \
    \        beats.push(current_beat);\n            current_beat = 0;\n          \
    \  current_note += 2;\n        } else if note.1 == '|' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note += 4;\n        } else\
    \ {\n            current_note += note.1;\n            current_beat += 1;\n   \
    \     }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjrh2nbyd.rs:10:72\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: cannot add-assign `char` to `{integer}`\n\
    \  --> /tmp/tmpjrh2nbyd.rs:27:26\n   |\n27 |             current_note += note.1;\n\
    \   |                          ^^ no implementation for `{integer} += char`\n\
    \   |\n   = help: the trait `AddAssign<char>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note_len = 0;\n    let mut current_note_len\
    \ = music_string.len();\n    let mut current_note_char = music_string.chars().nth(current_note_len).unwrap();\n\
    \    while current_note_len > 0 {\n        if current_note_char == b'o' {\n  \
    \          notes.push(current_note.clone());\n            current_note = String::new();\n\
    \            current_note_len = 0;\n            current_note_char = music_string.chars().nth(current_note_len).unwrap();\n\
    \        } else if current_note_char == b'o|' {\n            notes.push(current_note.clone());\n\
    \            current_note = String::new();\n            current_note_len = 0;\n\
    \            current_note_char = music_string.chars().nth(current_note_len).unwrap();\n\
    \        } else if current_note_char == b'.|' {\n            notes.push(current_note.clone());\n\
    \            current_note = String::new();\n            current_note_len = 0;\n\
    \            current_note_char = music_string.chars().nth(current_note_len).unwrap();\n\
    \        } else {\n            current_note.push(current_note_char);\n       \
    \     current_note_char = music_string.chars().nth(current_note_len).unwrap();\n\
    \        }\n        current_beat += 1;\n        beats.push(current_beat);\n  \
    \  }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpmll5hmbh.rs:22:40\n\
    \   |\n22 |         } else if current_note_char == b'o|' {\n   |             \
    \                           ^^^^^\n   |\nhelp: if you meant to write a byte string\
    \ literal, use double quotes\n   |\n22 |         } else if current_note_char ==\
    \ b\"o|\" {\n   |                                        ~~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmpmll5hmbh.rs:27:40\n  \
    \ |\n27 |         } else if current_note_char == b'.|' {\n   |               \
    \                         ^^^^^\n   |\nhelp: if you meant to write a byte string\
    \ literal, use double quotes\n   |\n27 |         } else if current_note_char ==\
    \ b\".|\" {\n   |                                        ~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmll5hmbh.rs:17:33\n   |\n17 |         if current_note_char\
    \ == b'o' {\n   |                                 ^^^^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmll5hmbh.rs:18:24\n  \
    \ |\n18 |             notes.push(current_note.clone());\n   |                \
    \        ^^^^^^^^^^^^^^^^^^^^\n   |                        |\n   |           \
    \             expected `&str`, found struct `String`\n   |                   \
    \     help: consider borrowing here: `&current_note`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmll5hmbh.rs:23:24\n   |\n23 |             notes.push(current_note.clone());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^\n   |                      \
    \  |\n   |                        expected `&str`, found struct `String`\n   |\
    \                        help: consider borrowing here: `&current_note`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmll5hmbh.rs:28:24\n   |\n28 |             notes.push(current_note.clone());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^\n   |                      \
    \  |\n   |                        expected `&str`, found struct `String`\n   |\
    \                        help: consider borrowing here: `&current_note`\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `ru"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_string = music_string.to_string();\n\
    \    let mut beats: Vec<isize> = vec![];\n    let mut notes: Vec<isize> = vec![];\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_index\
    \ = 0;\n    let mut current_beat_index = 0;\n    while current_note_index < music_string.len()\
    \ {\n        let note = music_string[current_note_index];\n        if note ==\
    \ 'o' {\n            notes.push(current_note);\n            current_note_index\
    \ += 1;\n            current_note += 1;\n            current_beat_index += 1;\n\
    \            beats.push(current_beat);\n            current_beat += 1;\n     \
    \       current_note_index += 1;\n        } else if note == 'o|' {\n         \
    \   notes.push(current_note);\n            current_note_index += 1;\n        \
    \    current_note += 1;\n            current_beat_index += 1;\n            beats.push(current_beat);\n\
    \            current_beat += 1;\n            current_note_index += 1;\n      \
    \      current_beat_index += 1;\n        } else if note == '.|' {\n          \
    \  notes.push(current_note);\n            current_note_index += 1;\n         \
    \   current_note += 1;\n            current_beat_index += 1;\n            beats.push(current_beat);\n\
    \            current_beat += 1;\n            current_note_index += 1;\n      \
    \      current_beat_index += 1;\n            current_beat_index += 1;\n      \
    \  } else {\n            current_note_index += 1;\n        }\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpc8adf50w.rs:26:30\n\
    \   |\n26 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = String::new();\n    let mut\
    \ current_note_length = 0;\n    let mut current_note_length_index = 0;\n    let\
    \ mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphtj7ss34.rs:60:26\n   |\n\
    60 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmphtj7ss34.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = String::new();\n    let mut\
    \ current_note_length = 0;\n    let mut current_note_length_index = 0;\n    let\
    \ mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphtj7ss34.rs:60:26\n   |\n\
    60 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmphtj7ss34.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    for note in notes {\n        if note != current_note {\n         \
    \   beats.push(current_beat);\n            current_beat = 0;\n            current_note\
    \ = note;\n            current_note_length = 0;\n        }\n        current_beat\
    \ += 1;\n        current_note_length += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp2mqr5l0v.rs:15:17\n\
    \   |\n15 |         if note != current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2mqr5l0v.rs:18:28\n   |\n11 |     let mut current_note\
    \ = notes.last().unwrap();\n   |                            ---------------------\
    \ expected due to this value\n...\n18 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ note)| note != 'o');\n    for note in notes {\n        let mut beat = 0;\n \
    \       let mut note = note.unwrap();\n        if note == 'o' {\n            beat\
    \ = 4;\n        } else if note == 'o|' {\n            beat = 2;\n        } else\
    \ if note == '.|' {\n            beat = 1;\n        } else {\n            beat\
    \ = 0;\n        }\n        beats.push(beat);\n    }\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp8s1w5q9v.rs:16:30\n\
    \   |\n16 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().collect::<Vec<char>>();\n    let mut current_note = notes.len();\n\
    \    let mut last_note = -1;\n    let mut last_beat = -1;\n    let mut last_beats\
    \ = -1;\n    let mut last_beats_after_note = -1;\n    let mut last_beats_after_note_before_note\
    \ = -1;\n    let mut last_beats_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_after_note = -1;\n    let mut last_beats_after_note_before_note\
    \ = -1;\n    let mut last_beats_after_note_after_note = -1;\n    let mut last_beats_before_note_after_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = -1;\n    let mut last_beats_before_note_before_note\
    \ = -1;\n    let mut last_beats_before_note_before_note = \n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpsu8p0y0f.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut beats\
    \ = Vec::new();\n    let mut current_note = String::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_index = 0;\n    let mut current_beat_count =\
    \ 0;\n    let mut current_note_count = 0;\n    let mut current_note_beat_count\
    \ = 0;\n    let mut current_note_beat_count_index = 0;\n    let mut current_note_beat_count_index2\
    \ = 0;\n    let mut current_note_beat_count_index3 = 0;\n    let mut current_note_beat_count_index4\
    \ = 0;\n    let mut current_note_beat_count_index5 = 0;\n    let mut current_note_beat_count_index6\
    \ = 0;\n    let mut current_note_beat_count_index7 = 0;\n    let mut current_note_beat_count_index8\
    \ = 0;\n    let mut current_note_beat_count_index9 = 0;\n    let mut current_note_beat_count_index10\
    \ = 0;\n    let mut current_note_beat_count_index11 = 0;\n    let mut current_note_beat_count_index12\
    \ = 0;\n    let mut current_note_beat_count_index13 = 0;\n    let mut current_note_beat_count_index14\
    \ = 0;\n    let mut current_note_beat_count_index15 = 0;\n    let mut current_note_beat_count_index16\
    \ = 0;\n    let mut current_note_beat_count_index17 = 0;\n    let mut current_note_beat_count_index18\
    \ = 0;\n    let mut current_note_beat_count_index19 = 0;\n    let mut current_note_beat_count_index20\
    \ = 0;\n    let mut current_note_beat_count_index21 = 0;\n    let mut current_note_beat_count_index22\
    \ = 0;\n    let mut current_note_beat_count_index23 = 0;\n    let mut current_note_beat_count_index24\
    \ = 0;\n    let mut current_note_beat_count_index25 = 0;\n    let mut current_note_beat_count_index26\
    \ = 0;\n    let mut current_note_beat_count_index27 = 0;\n    let mut current_note_beat_count_index28\
    \ = 0;\n    let mut current_note_beat_count_index29 = 0;\n    let mut current_note_beat_count_index30\
    \ = 0;\n    let mut current_note_beat_count_index31 = 0;\n    let mut current_note_beat_count_index32\
    \ = 0;\n    let mut current_note_beat_count_index33 = 0;\n    let mut current_note_beat_count_index34\
    \ = 0;\n    let mut current_note_beat_count_index35 = 0;\n    let mut current_note_beat_count_index36\
    \ = 0;\n    let mut current_note_beat_count_index37 = 0;\n    let mu\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmeqcrpa4.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmeqcrpa4.rs:8:41\n  |\n\
    8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    ----------- \
    \                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |  \
    \  |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc920bqs5.rs:61:26\n   |\n\
    61 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpc920bqs5.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976510
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut notes_size:\
    \ usize = 0;\n    let mut last_note = String::new();\n    let mut last_beat: usize\
    \ = 0;\n    let mut last_beats: usize = 0;\n    let mut last_beats_size: usize\
    \ = 0;\n    let mut last_beats_last_beat: usize = 0;\n    let mut last_beats_last_beats:\
    \ usize = 0;\n    let mut last_beats_last_beats_size: usize = 0;\n    let mut\
    \ last_beats_last_beats_last_beat: usize = 0;\n    let mut last_beats_last_beats_last_beats:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_size: usize = 0;\n\
    \    let mut last_beats_last_beats_last_beats_last_beat: usize = 0;\n    let mut\
    \ last_beats_last_beats_last_beats_last_beats: usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_size:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beat:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats_size:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats_last_beat:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats_last_beats:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats_last_beats_size:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats_last_beats_last_beat:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats_last_beats_last_beats:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats_last_beats_last_beats_size:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats_last_beats_last_beats_last_beat:\
    \ usize = 0;\n    let mut last_beats_last_beats_last_beats_last_beats_last_beats_last_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_s6gfj47.rs:35:73\n   |\n\
    35 |     let mut last_beats_last_beats_last_beats_last_beats_last_beats_last_\n\
    \   |                                                                        \
    \ ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp_s6gfj47.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c == 'o' || c == '|' || c\
    \ == '.').collect::<Vec<_>>();\n    for note in notes {\n        let mut beat\
    \ = 0;\n        note.1.unwrap().to_ascii_lowercase().chars().enumerate().filter(|(_,\
    \ c)| c == 'o' || c == '|' || c == '.').for_each(|(_, c)| {\n            if c\
    \ == 'o' {\n                beat += 4;\n            } else if c == '|' {\n   \
    \             beat += 2;\n            } else if c == '.' {\n                beat\
    \ += 1;\n            }\n        });\n        beats.push(beat);\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmy4aqz0g.rs:10:72\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c == 'o' || c == '|' || c == '.').collect::<Vec<_>>();\n   |               \
    \                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmy4aqz0g.rs:10:84\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c == 'o' || c == '|' || c == '.').collect::<Vec<_>>();\n   |               \
    \                                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmy4aqz0g.rs:10:96\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c == 'o' || c == '|' || c == '.').collect::<Vec<_>>();\n   |               \
    \                                                                            \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0599]: no method named `unwrap` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpmy4aqz0g.rs:13:16\n   |\n13 |         note.1.unwrap().to_ascii_lowercase().chars().enumerate().filter(|(_,\
    \ c)| c == 'o' || c == '|' || c == '.').for_each(|(_, c)| {\n   |            \
    \    ^^^^^^ method not found in `char`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut notes_length:\
    \ usize = 0;\n    let mut current_note = notes.last().unwrap();\n    for note\
    \ in notes {\n        if note != current_note {\n            beats.push(notes_length);\n\
    \            notes_length = 0;\n            current_note = note;\n        }\n\
    \        notes_length += 1;\n    }\n    beats.push(notes_length);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb2thg9jv.rs:15:24\n   |\n\
    15 |             beats.push(notes_length);\n   |                        ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |           \
    \  beats.push(notes_length.try_into().unwrap());\n   |                       \
    \             ++++++++++++++++++++\n\nerror[E0277]: can't compare `str` with `&str`\n\
    \  --> /tmp/tmpb2thg9jv.rs:14:17\n   |\n14 |         if note != current_note {\n\
    \   |                 ^^ no implementation for `str == &str`\n   |\n   = help:\
    \ the trait `PartialEq<&str>` is not implemented for `str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb2thg9jv.rs:17:28\n   |\n12 |     let mut current_note = notes.last().unwrap();\n\
    \   |                            --------------------- expected due to this value\n\
    ...\n17 |             current_note = note;\n   |                            ^^^^\
    \ expected `&str`, found `str`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb2thg9jv.rs:21:16\n   |\n21 |     beats.push(notes_length);\n   |  \
    \              ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n21 |     beats.push(notes_length.try_into().unwrap());\n   |          \
    \                  ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed e"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_beat_len = 0;\n    let mut current_note_char = 0;\n\
    \    let mut current_beat_char = 0;\n    let mut current_note_char_count = 0;\n\
    \    let mut current_beat_char_count = 0;\n    let mut current_note_char_is_octave\
    \ = false;\n    let mut current_beat_char_is_octave = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8kh034sn.rs:58:26\n   |\n\
    58 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp8kh034sn.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_beat_length = 0;\n    let mut current_note_length_to_beat\
    \ = 0;\n    let mut current_beat_length_to_beat = 0;\n    let mut current_note_to_beat\
    \ = 0;\n    let mut current_beat_length_to_note = 0;\n    let mut current_note_to_note\
    \ = 0;\n    let mut current_note_to_length = 0;\n    let mut current_beat_length_to_length\
    \ = 0;\n    let mut current_length_to_length = 0;\n    let mut current_length_to_note\
    \ = 0;\n    let mut current_note_to_length_to_length = 0;\n    let mut current_note_to_length_to_note\
    \ = 0;\n    let mut current_note_to_length_to_beat = 0;\n    let mut current_note_to_beat_to_length\
    \ = 0;\n    let mut current_note_to_beat_to_note = 0;\n    let mut current_note_to_beat_to_beat\
    \ = 0;\n    let mut current_note_to_length_to_length_to_note = 0;\n    let mut\
    \ current_note_to_length_to_length_to_beat = 0;\n    let mut current_note_to_length_to_beat_to_length\
    \ = 0;\n    let mut current_note_to_length_to_beat_to_note = 0;\n    let mut current_note_to_beat_to_length_to_note\
    \ = 0;\n    let mut current_note_to_beat_to_length_to_beat = 0;\n    let mut current_note_to_beat_to_beat_to_length\
    \ = 0;\n    let mut current_note_to_beat_to_beat_to_note = 0;\n    let mut current_note_to_length_to_length_to_length_to_note\
    \ = 0;\n    let mut current_note_to_length_to_length_to_length_to_beat = 0;\n\
    \    let mut current_note_to_length_to_length_to_beat_to_length = 0;\n    let\
    \ mut current_note_to_length_to_beat_to_length_to_note = 0;\n    let mut current_note_to_beat_to_length_to_length_to_note\
    \ = 0;\n    let mut current_note_to_beat_to_length_to_length_to_beat = 0;\n  \
    \  let mut current_note_to_beat_to_beat_to_length_to_note = 0;\n    let mut current_note_to_beat_to_beat_to_length_to_beat\
    \ = 0;\n    let mut current_note_to_length_to_length_to_length_to_length_to_note\
    \ = 0;\n    let mut current_note_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_to_length_to_length_to_length_to_length_to_beat_to_length\
    \ = 0;\n    let mut current_note_to_length_to_beat_to_length_to_length_to_note\
    \ = 0;\n    let mut current_note_to_beat_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut current_note_to_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph1wok8e0.rs:50:29\n   |\n\
    50 |     let mut current_note_to_\n   |                             ^ help: add\
    \ `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmph1wok8e0.rs:8:41\n  |\n8 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_next = 0;\n    let mut current_note_length_value_next2\
    \ = 0;\n    let mut current_note_length_value_next3 = 0;\n    let mut current_note_length_value_next4\
    \ = 0;\n    let mut current_note_length_value_next5 = 0;\n    let mut current_note_length_value_next6\
    \ = 0;\n    let mut current_note_length_value_next7 = 0;\n    let mut current_note_length_value_next8\
    \ = 0;\n    let mut current_note_length_value_next9 = 0;\n    let mut current_note_length_value_next10\
    \ = 0;\n    let mut current_note_length_value_next11 = 0;\n    let mut current_note_length_value_next12\
    \ = 0;\n    let mut current_note_length_value_next13 = 0;\n    let mut current_note_length_value_next14\
    \ = 0;\n    let mut current_note_length_value_next15 = 0;\n    let mut current_note_length_value_next16\
    \ = 0;\n    let mut current_note_length_value_next17 = 0;\n    let mut current_note_length_value_next18\
    \ = 0;\n    let mut current_note_length_value_next19 = 0;\n    let mut current_note_length_value_next20\
    \ = 0;\n    let mut current_note_length_value_next21 = 0;\n    let mut current_note_length_value_next22\
    \ = 0;\n    let mut current_note_length_value_next23 = 0;\n    let mut current_note_length_value_next24\
    \ = 0;\n    let mut current_note_length_value_next25 = 0;\n    let mut current_note_length_value_next26\
    \ = 0;\n    let mut current_note_length_value_next27 = 0;\n    let mut current_note_length_value_next28\
    \ = 0;\n    let mut current_note_length_value_next29 = 0;\n    let mut current_note_length_value_next30\
    \ = 0;\n    let mut current_note_length_value_next31 = 0;\n    let mut current_note_length_value_next32\
    \ = 0;\n    let mut current_note_length_value_next33 = 0;\n    let mut current_note_length_value_next34\
    \ = 0;\n    let mut current_note_length_value_next35 = 0;\n    let mut current_note_length_value_next36\
    \ = 0;\n    let mut current_note_length_value_next37 = 0;\n    let mut current_note_length_value_next38\
    \ = 0;\n    let mut current_note_length_value_next39 = 0;\n    let mut current_note_length_value_next40\
    \ = 0;\n    let mut current_note_length_value_next41 = 0;\n    let mut current_note_length_value_next42\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnkzu3fbq.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_string = music_string.to_string();\n\
    \    let mut music_vec: Vec<isize> = Vec::new();\n    let mut beat = 0;\n    let\
    \ mut note = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let\
    \ mut last_beats = 0;\n    let mut last_beats_cnt = 0;\n    let mut last_beats_cnt2\
    \ = 0;\n    let mut last_beats_cnt3 = 0;\n    let mut last_beats_cnt4 = 0;\n \
    \   let mut last_beats_cnt5 = 0;\n    let mut last_beats_cnt6 = 0;\n    let mut\
    \ last_beats_cnt7 = 0;\n    let mut last_beats_cnt8 = 0;\n    let mut last_beats_cnt9\
    \ = 0;\n    let mut last_beats_cnt10 = 0;\n    let mut last_beats_cnt11 = 0;\n\
    \    let mut last_beats_cnt12 = 0;\n    let mut last_beats_cnt13 = 0;\n    let\
    \ mut last_beats_cnt14 = 0;\n    let mut last_beats_cnt15 = 0;\n    let mut last_beats_cnt16\
    \ = 0;\n    let mut last_beats_cnt17 = 0;\n    let mut last_beats_cnt18 = 0;\n\
    \    let mut last_beats_cnt19 = 0;\n    let mut last_beats_cnt20 = 0;\n    let\
    \ mut last_beats_cnt21 = 0;\n    let mut last_beats_cnt22 = 0;\n    let mut last_beats_cnt23\
    \ = 0;\n    let mut last_beats_cnt24 = 0;\n    let mut last_beats_cnt25 = 0;\n\
    \    let mut last_beats_cnt26 = 0;\n    let mut last_beats_cnt27 = 0;\n    let\
    \ mut last_beats_cnt28 = 0;\n    let mut last_beats_cnt29 = 0;\n    let mut last_beats_cnt30\
    \ = 0;\n    let mut last_beats_cnt31 = 0;\n    let mut last_beats_cnt32 = 0;\n\
    \    let mut last_beats_cnt33 = 0;\n    let mut last_beats_cnt34 = 0;\n    let\
    \ mut last_beats_cnt35 = 0;\n    let mut last_beats_cnt36 = 0;\n    let mut last_beats_cnt37\
    \ = 0;\n    let mut last_beats_cnt38 = 0;\n    let mut last_beats_cnt39 = 0;\n\
    \    let mut last_beats_cnt40 = 0;\n    let mut last_beats_cnt41 = 0;\n    let\
    \ mut last_beats_cnt42 = 0;\n    let mut last_beats_cnt43 = 0;\n    let mut last_beats_cnt44\
    \ = 0;\n    let mut last_beats_cnt45 = 0;\n    let mut last_\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkaj9jpxt.rs:61:18\n   |\n\
    61 |     let mut last_\n   |                  ^ help: add `;` here\n62 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpkaj9jpxt.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut current_note = 0;\n    let\
    \ mut current_beat = 0;\n    let mut current_note_length = 0;\n    let mut current_beat_length\
    \ = 0;\n    let mut current_note_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut current_beat_length_to_beat = -1;\n    let mut current_beat_length_to_note\
    \ = -1;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpesc6g0xv.rs:54:1\n\
    \   |\n54 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_octave = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_octave = 0;\n    let mut current_note_note =\
    \ String::new();\n    let mut current_note_oct = String::new();\n    let mut current_note_note_len\
    \ = 0;\n    let mut current_note_note_octave = 0;\n    let mut current_note_note_note\
    \ = String::new();\n    let mut current_note_note_oct = String::new();\n    let\
    \ mut current_note_note_note_len = 0;\n    let mut current_note_note_note_octave\
    \ = 0;\n    let mut current_note_note_note = String::new();\n    let mut current_note_note_oct\
    \ = String::new();\n    let mut current_note_note_note_len = 0;\n    let mut current_note_note_note_octave\
    \ = 0;\n    let mut current_note_note_note = String::new();\n    let mut current_note_note_oct\
    \ = String::new();\n    let mut current_note_note_note_len = 0;\n    let mut current_note_note_note_octave\
    \ = 0;\n    let mut current_note_note_note = String::new();\n    let mut current_note_note_oct\
    \ = String::new();\n    let mut current_note_note_note_len = 0;\n    let mut current_note_note_note_octave\
    \ = 0;\n    let mut current_note_note_note = String::new();\n    let mut current_note_note_oct\
    \ = String::new();\n    let mut current_note_note_note_len = 0;\n    let mut current_note_note_note_octave\
    \ = 0;\n    let mut current_note_note_note = String::new();\n    let mut current_note_note_oct\
    \ = String::new();\n    let mut current_note_note_note_len = 0;\n    let mut current_note_note_note_octave\
    \ = 0;\n    let mut current_note_note_note = String::new();\n    let mut current_note_note_oct\
    \ = String::new();\n    let mut current_note_note_note_len = 0;\n    let mut current_note_note_note_octave\
    \ = 0;\n    let mut current_note_note_note = String::new();\n    let mut current_note_note_oct\
    \ = String::new();\n    let mut current_note_note_note_len = 0;\n    let mut current_note_note_note_octave\
    \ = 0;\n    let mut current_note_note_note = String::new();\n    let mut current_note_note_oct\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw6nu5tua.rs:53:34\n   |\n\
    53 |     let mut current_note_note_oct\n   |                                 \
    \ ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpw6nu5tua.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_ascii_whitespace().collect();\n  \
    \  let mut last_note = notes.last().unwrap();\n    let mut last_beat = -1;\n \
    \   let mut last_beats = -1;\n    for note in notes {\n        if note != last_note\
    \ {\n            beats.push(last_beat);\n            last_beat = -1;\n       \
    \ }\n        if note == last_note {\n            last_beats += 1;\n        } else\
    \ {\n            last_beat = 1;\n        }\n        last_note = note;\n    }\n\
    \    beats.push(last_beat);\n    beats\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpmhu72upp.rs:15:17\n\
    \   |\n15 |         if note != last_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0277]:\
    \ can't compare `str` with `&str`\n  --> /tmp/tmpmhu72upp.rs:19:17\n   |\n19 |\
    \         if note == last_note {\n   |                 ^^ no implementation for\
    \ `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmhu72upp.rs:24:21\n   |\n11 |     let mut last_note\
    \ = notes.last().unwrap();\n   |                         ---------------------\
    \ expected due to this value\n...\n24 |         last_note = note;\n   |      \
    \               ^^^^ expected `&str`, found `str`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E02"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_length = 0;\n    let mut current_length_index\
    \ = 0;\n    let mut current_length_index2 = 0;\n    let mut current_length_index3\
    \ = 0;\n    let mut current_length_index4 = 0;\n    let mut current_length_index5\
    \ = 0;\n    let mut current_length_index6 = 0;\n    let mut current_length_index7\
    \ = 0;\n    let mut current_length_index8 = 0;\n    let mut current_length_index9\
    \ = 0;\n    let mut current_length_index10 = 0;\n    let mut current_length_index11\
    \ = 0;\n    let mut current_length_index12 = 0;\n    let mut current_length_index13\
    \ = 0;\n    let mut current_length_index14 = 0;\n    let mut current_length_index15\
    \ = 0;\n    let mut current_length_index16 = 0;\n    let mut current_length_index17\
    \ = 0;\n    let mut current_length_index18 = 0;\n    let mut current_length_index19\
    \ = 0;\n    let mut current_length_index20 = 0;\n    let mut current_length_index21\
    \ = 0;\n    let mut current_length_index22 = 0;\n    let mut current_length_index23\
    \ = 0;\n    let mut current_length_index24 = 0;\n    let mut current_length_index25\
    \ = 0;\n    let mut current_length_index26 = 0;\n    let mut current_length_index27\
    \ = 0;\n    let mut current_length_index28 = 0;\n    let mut current_length_index29\
    \ = 0;\n    let mut current_length_index30 = 0;\n    let mut current_length_index31\
    \ = 0;\n    let mut current_length_index32 = 0;\n    let mut current_length_index33\
    \ = 0;\n    let mut current_length_index34 = 0;\n    let mut current_length_index35\
    \ = 0;\n    let mut current_length_index36 = 0;\n    let mut current_length_index37\
    \ = 0;\n    let mut current_length_index38 = 0;\n    let mut current_length_index39\
    \ = 0;\n    let mut current_length_index40 = 0;\n    let mut current_length_index41\
    \ = 0;\n    let mut current_length_index42 = 0;\n    let mut current_length_index43\
    \ = 0;\n    let mut current_length_index44 = 0;\n    let mut current_length_index45\
    \ = 0;\n    let mut current_length_index46 = 0;\n    let mut current_length_index47\
    \ = 0;\n    let mut current_length_index48 = 0;\n    let mut current_length_index49\
    \ = 0;\n    let mut current_length_index50 = 0;\n    let mut current_length_index51\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp32saz0fo.rs:66:1\n\
    \   |\n66 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = vec![];\n    let\
    \ mut music_string_iter = music_string.chars().enumerate();\n    let mut music_string_iter2\
    \ = music_string_iter.next();\n    let mut music_string_iter3 = music_string_iter2.next();\n\
    \    let mut music_string_iter4 = music_string_iter3.next();\n    let mut music_string_iter5\
    \ = music_string_iter4.next();\n    let mut music_string_iter6 = music_string_iter5.next();\n\
    \    let mut music_string_iter7 = music_string_iter6.next();\n    let mut music_string_iter8\
    \ = music_string_iter7.next();\n    let mut music_string_iter9 = music_string_iter8.next();\n\
    \    let mut music_string_iter10 = music_string_iter9.next();\n    let mut music_string_iter11\
    \ = music_string_iter10.next();\n    let mut music_string_iter12 = music_string_iter11.next();\n\
    \    let mut music_string_iter13 = music_string_iter12.next();\n    let mut music_string_iter14\
    \ = music_string_iter13.next();\n    let mut music_string_iter15 = music_string_iter14.next();\n\
    \    let mut music_string_iter16 = music_string_iter15.next();\n    let mut music_string_iter17\
    \ = music_string_iter16.next();\n    let mut music_string_iter18 = music_string_iter17.next();\n\
    \    let mut music_string_iter19 = music_string_iter18.next();\n    let mut music_string_iter20\
    \ = music_string_iter19.next();\n    let mut music_string_iter21 = music_string_iter20.next();\n\
    \    let mut music_string_iter22 = music_string_iter21.next();\n    let mut music_string_iter23\
    \ = music_string_iter22.next();\n    let mut music_string_iter24 = music_string_iter23.next();\n\
    \    let mut music_string_iter25 = music_string_iter24.next();\n    let mut music_string_iter26\
    \ = music_string_iter25.next();\n    let mut music_string_iter27 = music_string_iter26.next();\n\
    \    let mut music_string_iter28 = music_string_iter27.next();\n    let mut music_string_iter29\
    \ = music_string_iter28.next();\n    let mut music_string_iter30 = music_string_iter29.next();\n\
    \    let mut music_string_iter31 = music_string_iter30.next();\n    let mut music_string_iter32\
    \ = music_string_\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsocyqyu3.rs:41:48\n   |\n\
    41 |     let mut music_string_iter32 = music_string_\n   |                   \
    \                             ^ help: add `;` here\n42 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `music_string_` in this scope\n  -->\
    \ /tmp/tmpsocyqyu3.rs:41:35\n   |\n41 |     let mut music_string_iter32 = music_string_\n\
    \   |                                   ^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `music_string`\n\nerror[E0599]: no method named `next`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpsocyqyu3.rs:12:53\n\
    \   |\n12 |     let mut music_string_iter3 = music_string_iter2.next();\n   |\
    \                                                     ^^^^ method not found in\
    \ `Option<(usize, char)>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsocyqyu3.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_index\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_octave\
    \ = 0;\n    let mut current_note_octave_change = 0;\n    let mut current_note_octave_change_direction\
    \ = 0;\n    let mut current_note_octave_direction = 0;\n    let mut current_note_octave_direction_change\
    \ = 0;\n    let mut current_note_octave_direction_change_direction = 0;\n    let\
    \ mut current_note_octave_direction_change_direction_change = 0;\n    let mut\
    \ current_note_octave_direction_change_direction_change_direction = 0;\n    let\
    \ mut current_note_octave_direction_change_direction_change_direction_change =\
    \ 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change\
    \ = 0;\n    let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr1acugjw.rs:35:152\n   |\n\
    35 |     let mut current_note_octave_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_\n\
    \   |                                                                        \
    \                                                                            \
    \    ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpr1acugjw.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = vec![];\n    let\
    \ mut music_chars: Vec<char> = music_string.chars().collect();\n    let mut music_char:\
    \ char;\n    let mut music_beats: isize = 0;\n    let mut music_last_beats: isize\
    \ = 0;\n    let mut music_last_char: char;\n    let mut music_last_chars: Vec<char>\
    \ = music_chars.clone();\n    let mut music_last_char: char;\n    let mut music_last_beats:\
    \ isize = 0;\n    let mut music_last_beats_char: char;\n    let mut music_last_beats_chars:\
    \ Vec<char> = music_chars.clone();\n    let mut music_last_beats_char: char;\n\
    \    let mut music_last_beats_chars: Vec<char> = music_chars.clone();\n    let\
    \ mut music_last_beats_char: char;\n    let mut music_last_beats_chars: Vec<char>\
    \ = music_chars.clone();\n    let mut music_last_beats_char: char;\n    let mut\
    \ music_last_beats_chars: Vec<char> = music_chars.clone();\n    let mut music_last_beats_char:\
    \ char;\n    let mut music_last_beats_chars: Vec<char> = music_chars.clone();\n\
    \    let mut music_last_beats_char: char;\n    let mut music_last_beats_chars:\
    \ Vec<char> = music_chars.clone();\n    let mut music_last_beats_char: char;\n\
    \    let mut music_last_beats_chars: Vec<char> = music_chars.clone();\n    let\
    \ mut music_last_beats_char: char;\n    let mut music_last_beats_chars: Vec<char>\
    \ = music_chars.clone();\n    let mut music_last_beats_char: char;\n    let mut\
    \ music_last_beats_chars: Vec<char> = music_chars.clone();\n    let mut music_last_beats_char:\
    \ char;\n    let mut music_last_beats_chars: Vec<char> = music_chars.clone();\n\
    \    let mut music_last_beats_char: char;\n    let mut music_last_beats_chars:\
    \ Vec<char> = music_chars.clone();\n    let mut music_last_beats_char: char;\n\
    \    let mut music_last_beats_chars: Vec<char> = musi\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4hnu6qdq.rs:41:53\n   |\n\
    41 |     let mut music_last_beats_chars: Vec<char> = musi\n   |              \
    \                                       ^ help: add `;` here\n42 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `musi` in this scope\n  --> /tmp/tmp4hnu6qdq.rs:41:49\n\
    \   |\n41 |     let mut music_last_beats_chars: Vec<char> = musi\n   |       \
    \                                          ^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp4hnu6qdq.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut current_note\
    \ = notes.last().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_count\
    \ = 0;\n    let mut last_note = notes.last().unwrap();\n    let mut last_note_count\
    \ = 0;\n    for note in notes {\n        let note_count = note.chars().filter(|c|\
    \ c == '|').count() - 1;\n        if note_count == 0 {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_count = 0;\n        \
    \    last_note_count = 0;\n        } else {\n            current_note_count +=\
    \ note_count;\n            current_beat += note_count;\n        }\n        last_note_count\
    \ = note_count;\n        last_note = note;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnr8uup88.rs:17:52\n\
    \   |\n17 |         let note_count = note.chars().filter(|c| c == '|').count()\
    \ - 1;\n   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnr8uup88.rs:25:29\n   |\n25 |  \
    \           current_beat += note_count;\n   |                             ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to\
    \ `isize`\n  --> /tmp/tmpnr8uup88.rs:25:26\n   |\n25 |             current_beat\
    \ += note_count;\n   |                          ^^ no implementation for `isize\
    \ += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnr8uup88.rs:28:21\n\
    \   |\n14 |     let mut last_note = notes.last().unwrap();\n   |             \
    \            --------------------- expected due to this value\n...\n28 |     \
    \    last_note = note;\n   |                     ^^^^ expected `&str`, found `str`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&str`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.first().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_beats_length = 0;\n    let mut current_notes_length = 0;\n    let\
    \ mut current_notes_length_to_beats = HashMap::new();\n    let mut current_notes_length_to_beats_length:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length_to_beats:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length_to_beats_length:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length_to_beats_length_to_beats:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length_to_beats:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length_to_beats:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut current_notes_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length_to_beats_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp677juztt.rs:27:107\n   |\n\
    27 |     let mut current_notes_length_to_beats_length_to_beats_length_to_beats_length_to_beats_length_to_beats_\n\
    \   |                                                                        \
    \                                   ^ help: add `;` here\n28 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmp677juztt.rs:15:45\n   |\n15 |     let mut current_notes_length_to_beats\
    \ = HashMap::new();\n   |                                             ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0412]: cannot find type `HashMap`\
    \ in this scope\n  --> /tmp/tmp677juztt.rs:16:51\n   |\n16 |     let mut current_notes_length_to_beats_length:\
    \ HashMap<isize, isize> = HashMap::new();\n   |                              \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp677juztt.rs:16:75\n\
    \   |\n16 |     let mut current_notes_length_to_beats_length: HashMap<isize, isize>\
    \ = HashMap::new();\n   |                                                    \
    \                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashMap` in this scope\n  --> /tmp/tmp677juztt.rs:17:60\n\
    \   |\n17 |     let mut current_notes_length_to_beats_length_to_beats: HashMap<isize,\
    \ isize> = HashMap::new();\n   |                                             \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp677juztt.rs:17:84\n\
    \   |\n17 |     let mut current_notes_length_to_beats_length_to_beats: HashMap<isize,\
    \ isize> = HashMap::new();\n   |            "
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_len\
    \ = 0;\n    let mut current_note_len = music_string.len();\n    let mut current_note_char\
    \ = 0;\n    let mut current_note_char_len = 0;\n    let mut current_note_char_len2\
    \ = 0;\n    let mut current_note_char_len3 = 0;\n    let mut current_note_char_len4\
    \ = 0;\n    let mut current_note_char_len5 = 0;\n    let mut current_note_char_len6\
    \ = 0;\n    let mut current_note_char_len7 = 0;\n    let mut current_note_char_len8\
    \ = 0;\n    let mut current_note_char_len9 = 0;\n    let mut current_note_char_len10\
    \ = 0;\n    let mut current_note_char_len11 = 0;\n    let mut current_note_char_len12\
    \ = 0;\n    let mut current_note_char_len13 = 0;\n    let mut current_note_char_len14\
    \ = 0;\n    let mut current_note_char_len15 = 0;\n    let mut current_note_char_len16\
    \ = 0;\n    let mut current_note_char_len17 = 0;\n    let mut current_note_char_len18\
    \ = 0;\n    let mut current_note_char_len19 = 0;\n    let mut current_note_char_len20\
    \ = 0;\n    let mut current_note_char_len21 = 0;\n    let mut current_note_char_len22\
    \ = 0;\n    let mut current_note_char_len23 = 0;\n    let mut current_note_char_len24\
    \ = 0;\n    let mut current_note_char_len25 = 0;\n    let mut current_note_char_len26\
    \ = 0;\n    let mut current_note_char_len27 = 0;\n    let mut current_note_char_len28\
    \ = 0;\n    let mut current_note_char_len29 = 0;\n    let mut current_note_char_len30\
    \ = 0;\n    let mut current_note_char_len31 = 0;\n    let mut current_note_char_len32\
    \ = 0;\n    let mut current_note_char_len33 = 0;\n    let mut current_note_char_len34\
    \ = 0;\n    let mut current_note_char_len35 = 0;\n    let mut current_note_char_len36\
    \ = 0;\n    let mut current_note_char_len37 = 0;\n    let mut current_note_char_len38\
    \ = 0;\n    let mut current_note_char_len39 = 0;\n    let mut current_note_char_len40\
    \ = 0;\n    let mut current_note_char_len41 = 0;\n    let mut current_note_char_len42\
    \ = 0;\n    let mut current_note_char_len43 = 0;\n    let mut current_note_char_len44\
    \ = 0;\n    let mut current_note_char_len45 = 0;\n    let mut current_note_char_len46\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp008nnagq.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut current_note = String::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note_length = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_length_in_bps:\
    \ f64 = 0.0;\n    let mut current_note_length_in_bps: f64 = 0.0;\n    let mut\
    \ current_note_length_in_bps: f64 = 0.0;\n    let mut current_note_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpztj1ms0b.rs:44:26\n   |\n\
    44 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpztj1ms0b.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = music_string.chars().collect();\n    let mut current_note\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_beats:\
    \ isize = 0;\n    let mut last_beats_index = 0;\n    let mut last_beats_index2\
    \ = 0;\n    let mut last_beats_index3 = 0;\n    let mut last_beats_index4 = 0;\n\
    \    let mut last_beats_index5 = 0;\n    let mut last_beats_index6 = 0;\n    let\
    \ mut last_beats_index7 = 0;\n    let mut last_beats_index8 = 0;\n    let mut\
    \ last_beats_index9 = 0;\n    let mut last_beats_index10 = 0;\n    let mut last_beats_index11\
    \ = 0;\n    let mut last_beats_index12 = 0;\n    let mut last_beats_index13 =\
    \ 0;\n    let mut last_beats_index14 = 0;\n    let mut last_beats_index15 = 0;\n\
    \    let mut last_beats_index16 = 0;\n    let mut last_beats_index17 = 0;\n  \
    \  let mut last_beats_index18 = 0;\n    let mut last_beats_index19 = 0;\n    let\
    \ mut last_beats_index20 = 0;\n    let mut last_beats_index21 = 0;\n    let mut\
    \ last_beats_index22 = 0;\n    let mut last_beats_index23 = 0;\n    let mut last_beats_index24\
    \ = 0;\n    let mut last_beats_index25 = 0;\n    let mut last_beats_index26 =\
    \ 0;\n    let mut last_beats_index27 = 0;\n    let mut last_beats_index28 = 0;\n\
    \    let mut last_beats_index29 = 0;\n    let mut last_beats_index30 = 0;\n  \
    \  let mut last_beats_index31 = 0;\n    let mut last_beats_index32 = 0;\n    let\
    \ mut last_beats_index33 = 0;\n    let mut last_beats_index34 = 0;\n    let mut\
    \ last_beats_index35 = 0;\n    let mut last_beats_index36 = 0;\n    let mut last_beats_index37\
    \ = 0;\n    let mut last_beats_index38 = 0;\n    let mut last_beats_index39 =\
    \ 0;\n    let mut last_beats_index40 = 0;\n    let mut last_beats_index41 = 0;\n\
    \    let mut last_beats_index42 = 0;\n    let mut last_beats_index43 = 0;\n  \
    \  let mut last_beats_index44 = 0;\n    let mut last_beats_index45 = 0;\n    let\
    \ mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp24pwtz6f.rs:60:11\n   |\n\
    60 |     let mu\n   |           ^ help: add `;` here\n61 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp24pwtz6f.rs:10:53\n     |\n10\
    \   |     let mut notes: Vec<&str> = music_string.chars().collect();\n     | \
    \                                                    ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp24pwtz6f.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|').collect::<Vec<_>>();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_beats\
    \ = 0;\n    let mut last_note = notes.len() - 1;\n    let mut last_beat = notes[last_note].unwrap();\n\
    \    let mut last_beats = 0;\n    let mut last_notes = Vec::new();\n    notes.iter().for_each(|note|\
    \ {\n        if note != '.' {\n            if note == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat += 1;\n                current_beats += 1;\n   \
    \         }\n            if note == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat += 1;\n                current_beats += 1;\n   \
    \         }\n            if note == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat += 1;\n                current_beats += 1;\n   \
    \         }\n        }\n        last_notes.push(note);\n    });\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_beats += 1;\n    beats.push(current_beat);\n\
    \    current_\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpoxjrh6om.rs:25:27\n\
    \   |\n25 |             if note == 'o|' {\n   |                           ^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut notes_len2:\
    \ usize = 0;\n    let mut notes_len3: usize = 0;\n    let mut notes_len4: usize\
    \ = 0;\n    let mut notes_len5: usize = 0;\n    let mut notes_len6: usize = 0;\n\
    \    let mut notes_len7: usize = 0;\n    let mut notes_len8: usize = 0;\n    let\
    \ mut notes_len9: usize = 0;\n    let mut notes_len10: usize = 0;\n    let mut\
    \ notes_len11: usize = 0;\n    let mut notes_len12: usize = 0;\n    let mut notes_len13:\
    \ usize = 0;\n    let mut notes_len14: usize = 0;\n    let mut notes_len15: usize\
    \ = 0;\n    let mut notes_len16: usize = 0;\n    let mut notes_len17: usize =\
    \ 0;\n    let mut notes_len18: usize = 0;\n    let mut notes_len19: usize = 0;\n\
    \    let mut notes_len20: usize = 0;\n    let mut notes_len21: usize = 0;\n  \
    \  let mut notes_len22: usize = 0;\n    let mut notes_len23: usize = 0;\n    let\
    \ mut notes_len24: usize = 0;\n    let mut notes_len25: usize = 0;\n    let mut\
    \ notes_len26: usize = 0;\n    let mut notes_len27: usize = 0;\n    let mut notes_len28:\
    \ usize = 0;\n    let mut notes_len29: usize = 0;\n    let mut notes_len30: usize\
    \ = 0;\n    let mut notes_len31: usize = 0;\n    let mut notes_len32: usize =\
    \ 0;\n    let mut notes_len33: usize = 0;\n    let mut notes_len34: usize = 0;\n\
    \    let mut notes_len35: usize = 0;\n    let mut notes_len36: usize = 0;\n  \
    \  let mut notes_len37: usize = 0;\n    let mut notes_len38: usize = 0;\n    let\
    \ mut notes_len39: usize = 0;\n    let mut notes_len40: usize = 0;\n    let mut\
    \ notes_len4\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk5ybfbm3.rs:51:23\n   |\n\
    51 |     let mut notes_len4\n   |                       ^ help: add `;` here\n\
    52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk5ybfbm3.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_string = music_string.to_string();\n\
    \    let mut music_notes: Vec<isize> = vec![];\n    let mut current_note = 0;\n\
    \    let mut current_beat = 0;\n    let mut current_length = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpiatj6wxq.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = music_string.chars().nth(1).unwrap();\n\
    \    let mut current_note_length: isize = 1;\n\n    for c in music_string.chars()\
    \ {\n        if c == current_note {\n            current_beat += 1;\n        }\
    \ else {\n            if current_beat > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n            }\n            current_note =\
    \ c;\n            current_note_length = 1;\n        }\n        current_note_length\
    \ += 1;\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp9sif3p2e.rs:11:56

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().collect::<Vec<char>>();\n    let mut current_note = 0;\n\
    \    let mut current_beat = 0;\n    let mut last_note = 0;\n    let mut last_beat\
    \ = 0;\n    let mut last_note_index = 0;\n    let mut last_beat_index = 0;\n \
    \   while notes.len() > 0 {\n        let note = notes.last().unwrap();\n     \
    \   if note == 'o' {\n            if current_note == 0 {\n                last_note\
    \ = current_note;\n                last_beat = current_beat;\n               \
    \ last_note_index = current_note;\n                last_beat_index = current_beat;\n\
    \            }\n            current_note = 0;\n            current_beat = 0;\n\
    \        } else if note == 'o|' {\n            if current_note == 0 {\n      \
    \          last_note = current_note;\n                last_beat = current_beat;\n\
    \                last_note_index = current_note;\n                last_beat_index\
    \ = current_beat;\n            }\n            current_note = 0;\n            current_beat\
    \ = 1;\n        } else if note == '.|' {\n            if current_note == 0 {\n\
    \                last_note = current_note;\n                last_beat = current_beat;\n\
    \                last_note_index = current_note;\n                last_beat_index\
    \ = current_beat;\n            }\n            current_note = 1;\n            current_beat\
    \ = 0;\n        } else {\n            current_note += 1;\n            current_beat\
    \ += 1;\n        }\n        notes.pop();\n    }\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    \n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp10zkpo_l.rs:28:30\n\
    \   |\n28 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat = 0;\n    let mut current_note = String::new();\n    let mut\
    \ current_octave = 0;\n    let mut current_note_is_octave = false;\n    let mut\
    \ current_note_is_rest = false;\n    let mut current_note_is_rested = false;\n\
    \    let mut current_note_is_resting = false;\n    let mut current_note_is_resting_octave\
    \ = 0;\n    let mut current_note_is_resting_note = false;\n    let mut current_note_is_resting_note_is_octave\
    \ = false;\n    let mut current_note_is_resting_note_is_rest = false;\n    let\
    \ mut current_note_is_resting_note_is_rested = false;\n    let mut current_note_is_resting_note_is_resting\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_octave = 0;\n\
    \    let mut current_note_is_resting_note_is_resting_note = false;\n    let mut\
    \ current_note_is_resting_note_is_resting_note_is_octave = false;\n    let mut\
    \ current_note_is_resting_note_is_resting_note_is_rest = false;\n    let mut current_note_is_resting_note_is_resting_note_is_rested\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_octave\
    \ = 0;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_octave\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_rest\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_rested\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting_octave\
    \ = 0;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting_note\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting_note_is_octave\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting_note_is_rest\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note_is_resting_note_is_rested\
    \ = false;\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpow9ko6os.rs:41:1\n  \
    \ |\n41 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut notes: Vec<&str> = music_string.split_ascii_whitespace();\n    for\
    \ note in notes {\n        if note == \"o\" {\n            music_vec.push(4);\n\
    \        } else if note == \"o|\" {\n            music_vec.push(2);\n        }\
    \ else if note == \".|\" {\n            music_vec.push(1);\n        } else {\n\
    \            println!(\"Invalid note: {:?}\", note);\n        }\n    }\n    music_vec\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4l4jcww6.rs:10:32\n   |\n\
    10 |     let mut notes: Vec<&str> = music_string.split_ascii_whitespace();\n \
    \  |                    ---------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `SplitAsciiWhitespace`\n   |                    |\n\
    \   |                    expected due to this\n   |\n   = note: expected struct\
    \ `Vec<&str>`\n              found struct `SplitAsciiWhitespace<'_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ notes_len: usize = 0;\n    let mut last_note = String::new();\n    let mut last_beat:\
    \ usize = 0;\n    let mut last_beats: usize = 0;\n    let mut last_beats_len:\
    \ usize = 0;\n    let mut last_beats_len2: usize = 0;\n    let mut last_beats_len3:\
    \ usize = 0;\n    let mut last_beats_len4: usize = 0;\n    let mut last_beats_len5:\
    \ usize = 0;\n    let mut last_beats_len6: usize = 0;\n    let mut last_beats_len7:\
    \ usize = 0;\n    let mut last_beats_len8: usize = 0;\n    let mut last_beats_len9:\
    \ usize = 0;\n    let mut last_beats_len10: usize = 0;\n    let mut last_beats_len11:\
    \ usize = 0;\n    let mut last_beats_len12: usize = 0;\n    let mut last_beats_len13:\
    \ usize = 0;\n    let mut last_beats_len14: usize = 0;\n    let mut last_beats_len15:\
    \ usize = 0;\n    let mut last_beats_len16: usize = 0;\n    let mut last_beats_len17:\
    \ usize = 0;\n    let mut last_beats_len18: usize = 0;\n    let mut last_beats_len19:\
    \ usize = 0;\n    let mut last_beats_len20: usize = 0;\n    let mut last_beats_len21:\
    \ usize = 0;\n    let mut last_beats_len22: usize = 0;\n    let mut last_beats_len23:\
    \ usize = 0;\n    let mut last_beats_len24: usize = 0;\n    let mut last_beats_len25:\
    \ usize = 0;\n    let mut last_beats_len26: usize = 0;\n    let mut last_beats_len27:\
    \ usize = 0;\n    let mut last_beats_len28: usize = 0;\n    let mut last_beats_len29:\
    \ usize = 0;\n    let mut last_beats_len30: usize = 0;\n    let mut last_beats_len31:\
    \ usize = 0;\n    let mut last_beats_len32: usize = 0;\n    let mut last_beats_len33:\
    \ usize = 0;\n    let mut last_beats_len34: u\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph5psu03c.rs:48:32\n   |\n\
    48 |     let mut last_beats_len34: u\n   |                                ^ help:\
    \ add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmph5psu03c.rs:48:31\n   |\n48 |     let mut last_beats_len34:\
    \ u\n   |                               ^ help: a builtin type with a similar\
    \ name exists: `u8`\n\nerror[E0308]: mismatched types\n --> /tmp/tmph5psu03c.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0412.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat: isize = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_note_length_value_next\
    \ = 0;\n    let mut current_note_length_value_next_next = 0;\n    let mut current_note_length_value_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next = 0;\n    let\
    \ mut current_note_length_value_next_next_next_next_next = 0;\n    let mut current_note_length_value_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    let mut current_note_length_value_next_next_next_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8yb6w97t.rs:39:54\n   |\n\
    39 |     let mut current_note_length_value_next_next_next_\n   |             \
    \                                         ^ help: add `;` here\n40 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8yb6w97t.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_string = music_string.to_string();\n\
    \    let mut beats = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note\
    \ = -1;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf4n0ss59.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpf4n0ss59.rs:8:41\n  |\n\
    8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    ----------- \
    \                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |  \
    \  |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = 0;\n    let mut last_beat_size = 0;\n    let mut last_beat_length\
    \ = 0;\n    let mut last_beat_length_size = 0;\n    let mut last_beat_length_length\
    \ = 0;\n    let mut last_beat_length_length_size = 0;\n    let mut last_beat_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_size = 0;\n    let mut\
    \ last_beat_length_length_length_length_length = 0;\n    let mut last_beat_length_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_size = 0;\n    let mut\
    \ last_beat_length_length_length_length_length = 0;\n    let mut last_beat_length_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_size = 0;\n    let mut\
    \ last_beat_length_length_length_length_length = 0;\n    let mut last_beat_length_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_size = 0;\n    let mut\
    \ last_beat_length_length_length_length_length = 0;\n    let mut last_beat_length_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_size = 0;\n    let mut\
    \ last_beat_length_length_length_length_length = 0;\n    let mut last_beat_length_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_size = 0;\n    let mut last_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptd2wxoph.rs:50:18\n   |\n\
    50 |     let mut last_\n   |                  ^ help: add `;` here\n51 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmptd2wxoph.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n  \
    \  let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    let mut current_length_to_beat = -1;\n    let mut current_length_to_note\
    \ = -1;\n    let mut current_length_to_beats = -1;\n    let mut current_length_to_notes\
    \ = -1;\n    let mut current_length_to_beats_note = -1;\n    let mut current_length_to_notes_note\
    \ = -1;\n    let mut current_length_to_beats_notes = -1;\n    let mut current_length_to_notes_beat\
    \ = -1;\n    let mut current_length_to_notes_notes = -1;\n    let mut current_length_to_beats_notes_beat\
    \ = -1;\n    let mut current_length_to_notes_notes_beat = -1;\n    let mut current_length_to_beats_notes_notes_beat\
    \ = -1;\n    let mut current_length_to_notes_notes_notes_beat = -1;\n    let mut\
    \ current_length_to_beats_notes_notes_notes_beat = -1;\n    let mut current_length_to_notes_notes_notes_notes_beat\
    \ = -1;\n    let mut current_length_to_beats_notes_notes_notes_notes_beat = -1;\n\
    \    let mut current_length_to_notes_notes_notes_notes_notes_beat = -1;\n    let\
    \ mut current_length_to_beats_notes_notes_notes_notes_notes_beat = -1;\n    let\
    \ mut current_length_to_notes_notes_notes_notes_notes_beat = -1;\n    let mut\
    \ current_length_to_beats_notes_notes_notes_notes_notes_beat = -1;\n    let mut\
    \ current_length_to_notes_notes_notes_notes_notes_beat = -1;\n    let mut current_length_to_beats_notes_notes_notes_notes_notes_beat\
    \ = -1;\n    let mut current_length_to_notes_notes_notes_notes_notes_beat = -1;\n\
    \    let mut current_length_to_beats_notes_notes_notes_notes_notes_beat = -1;\n\
    \    let mut current_length_to_notes_notes_notes_notes_notes_beat = -1;\n    let\
    \ mut current_length_to_beats_notes_notes_notes_notes_notes_beat = -1;\n    let\
    \ mut current_length_to_notes_notes_notes_notes_notes_beat = -1;\n    let mut\
    \ current_length_to_beat\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp77f7wrhb.rs:41:35\n   |\n\
    41 |     let mut current_length_to_beat\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp77f7wrhb.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_length: usize = 0;\n    let mut\
    \ current_note = String::new();\n    let mut current_length = String::new();\n\
    \    let mut current_beat: usize = 0;\n    let mut current_note_index: usize =\
    \ 0;\n    let mut current_length_index: usize = 0;\n    let mut current_note_length:\
    \ usize = 0;\n    let mut current_beat_length: usize = 0;\n    let mut current_note_index2:\
    \ usize = 0;\n    let mut current_length_index2: usize = 0;\n    let mut current_note_length2:\
    \ usize = 0;\n    let mut current_beat_length2: usize = 0;\n    let mut current_note_index3:\
    \ usize = 0;\n    let mut current_length_index3: usize = 0;\n    let mut current_note_length3:\
    \ usize = 0;\n    let mut current_beat_length3: usize = 0;\n    let mut current_note_index4:\
    \ usize = 0;\n    let mut current_length_index4: usize = 0;\n    let mut current_note_length4:\
    \ usize = 0;\n    let mut current_beat_length4: usize = 0;\n    let mut current_note_index5:\
    \ usize = 0;\n    let mut current_length_index5: usize = 0;\n    let mut current_note_length5:\
    \ usize = 0;\n    let mut current_beat_length5: usize = 0;\n    let mut current_note_index6:\
    \ usize = 0;\n    let mut current_length_index6: usize = 0;\n    let mut current_note_length6:\
    \ usize = 0;\n    let mut current_beat_length6: usize = 0;\n    let mut current_note_index7:\
    \ usize = 0;\n    let mut current_length_index7: usize = 0;\n    let mut current_note_length7:\
    \ usize = 0;\n    let mut current_beat_length7: usize = 0;\n    let mut current_note_index8:\
    \ usize = 0;\n    let mut current_length_index8: usize = 0;\n    let mut current_note_length8:\
    \ usize = 0;\n    let mut current_beat_length8: usize = 0;\n    let mut current_note_index9:\
    \ usize = 0;\n    let mut current_length_index9: usize = 0;\n    let mut current_note_length9:\
    \ usize = 0;\n    let mut current_beat_length9: usize = 0;\n    let mut current_note_index10:\
    \ usize = 0;\n    let mut current_length_index10\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp22cqfpc1.rs:52:35\n   |\n\
    52 |     let mut current_length_index10\n   |                                \
    \   ^ help: add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp22cqfpc1.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ notes: Vec<&str> = vec![];\n    let mut notes_len: usize = 0;\n    let mut notes_len2:\
    \ usize = 0;\n    let mut notes_len3: usize = 0;\n    let mut notes_len4: usize\
    \ = 0;\n    let mut notes_len5: usize = 0;\n    let mut notes_len6: usize = 0;\n\
    \    let mut notes_len7: usize = 0;\n    let mut notes_len8: usize = 0;\n    let\
    \ mut notes_len9: usize = 0;\n    let mut notes_len10: usize = 0;\n    let mut\
    \ notes_len11: usize = 0;\n    let mut notes_len12: usize = 0;\n    let mut notes_len13:\
    \ usize = 0;\n    let mut notes_len14: usize = 0;\n    let mut notes_len15: usize\
    \ = 0;\n    let mut notes_len16: usize = 0;\n    let mut notes_len17: usize =\
    \ 0;\n    let mut notes_len18: usize = 0;\n    let mut notes_len19: usize = 0;\n\
    \    let mut notes_len20: usize = 0;\n    let mut notes_len21: usize = 0;\n  \
    \  let mut notes_len22: usize = 0;\n    let mut notes_len23: usize = 0;\n    let\
    \ mut notes_len24: usize = 0;\n    let mut notes_len25: usize = 0;\n    let mut\
    \ notes_len26: usize = 0;\n    let mut notes_len27: usize = 0;\n    let mut notes_len28:\
    \ usize = 0;\n    let mut notes_len29: usize = 0;\n    let mut notes_len30: usize\
    \ = 0;\n    let mut notes_len31: usize = 0;\n    let mut notes_len32: usize =\
    \ 0;\n    let mut notes_len33: usize = 0;\n    let mut notes_len34: usize = 0;\n\
    \    let mut notes_len35: usize = 0;\n    let mut notes_len36: usize = 0;\n  \
    \  let mut notes_len37: usize = 0;\n    let mut notes_len38: usize = 0;\n    let\
    \ mut notes_len39: usize = 0;\n    let mut notes_len40: usize = 0;\n    let mut\
    \ notes_len4\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk5ybfbm3.rs:51:23\n   |\n\
    51 |     let mut notes_len4\n   |                       ^ help: add `;` here\n\
    52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk5ybfbm3.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_string = music_string.to_string();\n\
    \    let mut music_vec: Vec<isize> = vec![];\n    let mut current_beat = 0;\n\
    \    let mut current_note = 0;\n    let mut current_note_len = 0;\n    let mut\
    \ current_note_char = 0;\n    let mut last_note_len = 0;\n    let mut last_note_char\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_note_len = 0;\n    let mut\
    \ last_note_char = 0;\n    let mut last_note = 0;\n    let mut last_note_len =\
    \ 0;\n    let mut last_note_char = 0;\n    let mut last_note = 0;\n    let mut\
    \ last_note_len = 0;\n    let mut last_note_char = 0;\n    let mut last_note =\
    \ 0;\n    let mut last_note_len = 0;\n    let mut last_note_char = 0;\n    let\
    \ mut last_note = 0;\n    let mut last_note_len = 0;\n    let mut last_note_char\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_note_len = 0;\n    let mut\
    \ last_note_char = 0;\n    let mut last_note = 0;\n    let mut last_note_len =\
    \ 0;\n    let mut last_note_char = 0;\n    let mut last_note = 0;\n    let mut\
    \ last_note_len = 0;\n    let mut last_note_char = 0;\n    let mut last_note =\
    \ 0;\n    let mut last_note_len = 0;\n    let mut last_note_char = 0;\n    let\
    \ mut last_note = 0;\n    let mut last_note_len = 0;\n    let mut last_note_char\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_note_len = 0;\n    let mut\
    \ last_note_char = 0;\n    let mut last_note = 0;\n    let mut last_note_len =\
    \ 0;\n    let mut last_note_char = 0;\n    let mut last_note = 0;\n    let mut\
    \ last_note_len = 0;\n    let mut last_note_char = 0;\n    let mut last_note =\
    \ 0;\n    let mut last_note_len = 0;\n    let mut last_note_char = 0;\n    let\
    \ mut last_note = 0;\n    let mut last_note_len = 0;\n    let mut last_note_char\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_note_len = 0;\n    let mut\
    \ last_note_char = 0;\n    let mut last_note = 0;\n    let mut last_note_len =\
    \ 0;\n    let mut last_note_char = 0;\n    let mut last_note = 0;\n    let mut\
    \ last_note_len = 0;\n    let mut last_note_char = 0;\n    let mut last_note =\
    \ 0;\n    let mut last_note_len = 0;\n    let mut last_note_char = 0;\n\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpuaaxkdz6.rs:8:41\n  |\n8 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------   \
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n\
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n    let mut last_note\
    \ = notes.next();\n    let mut last_beat = last_note.1;\n    let mut last_beats\
    \ = 1;\n    notes.for_each(|(_, c)| {\n        if c == '|' {\n            last_beats\
    \ = 1;\n        } else {\n            beats.push(last_beat * last_beats);\n  \
    \          last_beats *= 2;\n        }\n        last_beat *= 2;\n        last_note\
    \ = c;\n    });\n    beats.push(last_beat * last_beats);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7d3kw6fj.rs:10:72\n\
    \   |\n10 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0609]: no field `1` on type `Option<(usize,\
    \ char)>`\n  --> /tmp/tmp7d3kw6fj.rs:12:35\n   |\n12 |     let mut last_beat =\
    \ last_note.1;\n   |                                   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7d3kw6fj.rs:22:21\n   |\n11 |     let mut last_note = notes.next();\n\
    \   |                         ------------ expected due to this value\n...\n22\
    \ |         last_note = c;\n   |                     ^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<(usize, char)>`\n     \
    \         found type `char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = vec![];\n    let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ note)| note != '|');\n    for note in notes {\n        let mut beat = 0;\n \
    \       let mut note = note.unwrap();\n        match note {\n            'o' =>\
    \ beat += 4,\n            'o|' => beat += 2,\n            '.|' => beat += 1,\n\
    \            _ => (),\n        }\n        beats.push(beat);\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpwb3_nm_3.rs:16:16\n\
    \   |\n16 |             'o|' => beat += 2,\n   |                ^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut music_notes: Vec<&str> = music_string.split('|').collect();\n    for\
    \ note in music_notes {\n        let mut notes: Vec<&str> = note.split('o').collect();\n\
    \        let mut beats: isize = 0;\n        for note in notes {\n            beats\
    \ += note_to_beat(note);\n        }\n        music_vec.push(beats);\n    }\n \
    \   return music_vec;\n}\n\nfn main() {\n    let candidate = parse_music;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `note_to_beat` in this scope\n  -->\
    \ /tmp/tmpp4a3s2bp.rs:15:22\n   |\n15 |             beats += note_to_beat(note);\n\
    \   |                      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = vec![];\n    let mut\
    \ current_beat: isize = 0;\n    let mut current_note = String::new();\n    let\
    \ mut current_note_length = 0;\n    for c in music_string {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                current_note\
    \ += '.';\n            } else if c.to_ascii_lowercase() == 'o|' {\n          \
    \      current_note += '|';\n            } else if c.to_ascii_lowercase() == '.|'\
    \ {\n                current_note += '|';\n            } else {\n            \
    \    println!(\"Unknown note {}\", c);\n            }\n            current_note_length\
    \ += 1;\n        } else {\n            if current_note != \"\" {\n           \
    \     beats.push(current_beat);\n                current_beat = 0;\n         \
    \       current_note = String::new();\n            }\n            current_note\
    \ += c.to_ascii_lowercase();\n            current_note_length += 1;\n        }\n\
    \    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpv33h43gp.rs:17:52\n\
    \   |\n17 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat: isize = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length: isize = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_is_even = false;\n    let mut current_note_length_is_odd\
    \ = false;\n    let mut current_note_length_is_negative = false;\n    let mut\
    \ current_note_length_is_positive = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_length_is_negative = false;\n    let mut current_note_length_is_zero\
    \ = false;\n    let mut current_note_length_is_positive = false;\n    let mut\
    \ current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvug3kvtv.rs:59:26\n   |\n\
    59 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpvug3kvtv.rs:8:41\n  |\n8 | fn parse_music(music_string: String) -> Vec<isize>\
    \ {\n  |    -----------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut current_beat: isize = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave: isize = 0;\n    let mut current_length: isize = 0;\n\
    \    let mut current_length_string: String = String::new();\n    let mut current_length_string_len:\
    \ usize = 0;\n    let mut current_length_string_len2: usize = 0;\n    let mut\
    \ current_length_string_len3: usize = 0;\n    let mut current_length_string_len4:\
    \ usize = 0;\n    let mut current_length_string_len5: usize = 0;\n    let mut\
    \ current_length_string_len6: usize = 0;\n    let mut current_length_string_len7:\
    \ usize = 0;\n    let mut current_length_string_len8: usize = 0;\n    let mut\
    \ current_length_string_len9: usize = 0;\n    let mut current_length_string_len10:\
    \ usize = 0;\n    let mut current_length_string_len11: usize = 0;\n    let mut\
    \ current_length_string_len12: usize = 0;\n    let mut current_length_string_len13:\
    \ usize = 0;\n    let mut current_length_string_len14: usize = 0;\n    let mut\
    \ current_length_string_len15: usize = 0;\n    let mut current_length_string_len16:\
    \ usize = 0;\n    let mut current_length_string_len17: usize = 0;\n    let mut\
    \ current_length_string_len18: usize = 0;\n    let mut current_length_string_len19:\
    \ usize = 0;\n    let mut current_length_string_len20: usize = 0;\n    let mut\
    \ current_length_string_len21: usize = 0;\n    let mut current_length_string_len22:\
    \ usize = 0;\n    let mut current_length_string_len23: usize = 0;\n    let mut\
    \ current_length_string_len24: usize = 0;\n    let mut current_length_string_len25:\
    \ usize = 0;\n    let mut current_length_string_len26: usize = 0;\n    let mut\
    \ current_length_string_len27: usize = 0;\n    let mut current_length_string_len28:\
    \ usize = 0;\n    let mut current_length_string_len29: usize = 0;\n    let mut\
    \ current_length_string_len30: usize = 0;\n    let mut current_length_string_len31:\
    \ usize = 0;\n    let mut current_length_string_len32: usize = 0;\n    let mut\
    \ current_length_string_len33: usize = 0;\n    let mut current_length_string_len34:\
    \ usize = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiahqr_wr.rs:49:21\n   |\n\
    49 |     let mut current_\n   |                     ^ help: add `;` here\n50 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpiahqr_wr.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_vec: Vec<isize> = Vec::new();\n \
    \   let mut music_chars: Vec<char> = music_string.chars().collect();\n    let\
    \ mut music_char: char;\n    let mut music_beats: isize = 0;\n    let mut music_last_char:\
    \ char;\n    let mut music_last_beats: isize = 0;\n    let mut music_last_beats_char:\
    \ char;\n    let mut music_last_beats_chars: Vec<char> = Vec::new();\n    let\
    \ mut music_last_beats_char: char;\n    let mut music_last_beats_beats: isize\
    \ = 0;\n    let mut music_last_beats_beats_char: char;\n    let mut music_last_beats_beats_chars:\
    \ Vec<char> = Vec::new();\n    let mut music_last_beats_beats_char: char;\n  \
    \  let mut music_last_beats_beats_beats: isize = 0;\n    let mut music_last_beats_beats_beats_char:\
    \ char;\n    let mut music_last_beats_beats_beats_chars: Vec<char> = Vec::new();\n\
    \    let mut music_last_beats_beats_beats_char: char;\n    let mut music_last_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut music_last_beats_beats_beats_beats_char: char;\n   \
    \ let mut music_last_beats_beats_beats_beats_chars: Vec<char> = Vec::new();\n\
    \    let mut music_last_beats_beats_beats_beats_char: char;\n    let mut music_last_beats_beats_beats_beats_beats:\
    \ isize = 0;\n    let mut music_last_beats_beats_beats_beats_beats_char: char;\n\
    \    let mut music_last_beats_beats_beats_beats_beats_chars: Vec<char> = Vec::new();\n\
    \    let mut music_last_beats_beats_beats_beats_beats_beats_char: char;\n    let\
    \ mut music_last_beats_beats_beats_beats_beats_beats_beats: isize = 0;\n    let\
    \ mut music_last_beats_beats_beats_beats_beats_beats_beats_char: char;\n    let\
    \ mut music_last_beats_beats_beats_beats_beats_beats_beats_chars: Vec<char> =\
    \ Vec\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpalv8rtax.rs:36:88\n   |\n\
    36 |     let mut music_last_beats_beats_beats_beats_beats_beats_beats_chars: Vec<char>\
    \ = Vec\n   |                                                                \
    \                        ^ help: add `;` here\n37 | }\n   | - unexpected token\n\
    \nerror[E0423]: expected value, found struct `Vec`\n   --> /tmp/tmpalv8rtax.rs:36:85\n\
    \    |\n36  |       let mut music_last_beats_beats_beats_beats_beats_beats_beats_chars:\
    \ Vec<char> = Vec\n    |                                                     \
    \                                  ^^^ help: use struct literal syntax instead:\
    \ `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpalv8rtax.rs:8:41\n\
    \  |\n8 | fn parse_music(music_string: String) -> Vec<isize> {\n  |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut notes\
    \ = music_string.chars().enumerate();\n    let mut last_note = notes.next();\n\
    \    let mut last_beat = 0;\n    loop {\n        let note = notes.next();\n  \
    \      if note.1.unwrap() == '|' {\n            beats.push(last_beat);\n     \
    \       last_beat = 0;\n            last_note = note;\n        } else {\n    \
    \        last_beat = last_beat + 1;\n        }\n    }\n    beats.push(last_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `1` on type `Option<(usize, char)>`\n  --> /tmp/tmp5l9cf2ey.rs:15:17\n\
    \   |\n15 |         if note.1.unwrap() == '|' {\n   |                 ^\n\nwarning:\
    \ unreachable statement\n  --> /tmp/tmp5l9cf2ey.rs:23:5\n   |\n13 | /     loop\
    \ {\n14 | |         let note = notes.next();\n15 | |         if note.1.unwrap()\
    \ == '|' {\n16 | |             beats.push(last_beat);\n...  |\n21 | |        \
    \ }\n22 | |     }\n   | |_____- any code following this expression is unreachable\n\
    23 |       beats.push(last_beat);\n   |       ^^^^^^^^^^^^^^^^^^^^^^ unreachable\
    \ statement\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut music_string = music_string.to_string();\n\
    \    let mut beats: Vec<isize> = vec![];\n    let mut current_beat = 0;\n    let\
    \ mut current_note = music_string.chars().nth(1).unwrap();\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd5n38of0.rs:59:40\n   |\n\
    59 |     let mut current_note_length_index46\n   |                           \
    \             ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpd5n38of0.rs:8:41\n  |\n8 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n  |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = String::new();\n    let mut current_note_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_length = 0;\n        } else if c == '|' {\n          \
    \  current_beat += 1;\n        } else if c == '.' {\n            current_beat\
    \ += 1;\n            current_note_length += 1;\n        } else {\n           \
    \ current_note += c;\n            current_note_length += 1;\n        }\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpdxxzihvh.rs:13:14\n\
    \   |\n13 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpdxxzihvh.rs:14:14\n   |\n14\
    \ |         if c == 'o' {\n   |              ^^ no implementation for `&str ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpdxxzihvh.rs:19:21\n   |\n19 |         } else\
    \ if c == '|' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpdxxzihvh.rs:21:21\n   |\n21 |         } else\
    \ if c == '.' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the follow"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\nfn parse_music(music_string:\
    \ String) -> Vec<isize> {\n    let mut beats: Vec<isize> = Vec::new();\n    let\
    \ mut notes: Vec<&str> = music_string.split_whitespace().collect();\n    let mut\
    \ current_note = notes.last().unwrap();\n    let mut current_beat = 0;\n    let\
    \ mut current_note_index = 0;\n    let mut last_note = notes.last().unwrap();\n\
    \    let mut last_beat = 0;\n    let mut last_note_index = 0;\n    let mut last_note_index2\
    \ = 0;\n    let mut last_note_index3 = 0;\n    let mut last_note_index4 = 0;\n\
    \    let mut last_note_index5 = 0;\n    let mut last_note_index6 = 0;\n    let\
    \ mut last_note_index7 = 0;\n    let mut last_note_index8 = 0;\n    let mut last_note_index9\
    \ = 0;\n    let mut last_note_index10 = 0;\n    let mut last_note_index11 = 0;\n\
    \    let mut last_note_index12 = 0;\n    let mut last_note_index13 = 0;\n    let\
    \ mut last_note_index14 = 0;\n    let mut last_note_index15 = 0;\n    let mut\
    \ last_note_index16 = 0;\n    let mut last_note_index17 = 0;\n    let mut last_note_index18\
    \ = 0;\n    let mut last_note_index19 = 0;\n    let mut last_note_index20 = 0;\n\
    \    let mut last_note_index21 = 0;\n    let mut last_note_index22 = 0;\n    let\
    \ mut last_note_index23 = 0;\n    let mut last_note_index24 = 0;\n    let mut\
    \ last_note_index25 = 0;\n    let mut last_note_index26 = 0;\n    let mut last_note_index27\
    \ = 0;\n    let mut last_note_index28 = 0;\n    let mut last_note_index29 = 0;\n\
    \    let mut last_note_index30 = 0;\n    let mut last_note_index31 = 0;\n    let\
    \ mut last_note_index32 = 0;\n    let mut last_note_index33 = 0;\n    let mut\
    \ last_note_index34 = 0;\n    let mut last_note_index35 = 0;\n    let mut last_note_index36\
    \ = 0;\n    let mut last_note_index37 = 0;\n    let mut last_note_index38 = 0;\n\
    \    let mut last_note_index39 = 0;\n    let mut last_note_index40 = 0;\n    let\
    \ mut last_note_index41 = 0;\n    let mut last_note_index42 = 0;\n    let mut\
    \ last_note_index43 = 0;\n    let mut last_note_index44 = 0;\n    let mut last_note_index45\
    \ = 0;\n    let mut last_note_index46 = 0;\n    let mut last_note_index47 = 0;\n\
    \    let mut last_note_index48 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpqjdx39z2.rs:65:1\n\
    \   |\n65 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976511
