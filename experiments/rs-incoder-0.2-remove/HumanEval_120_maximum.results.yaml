language: rs
name: HumanEval_120_maximum
results:
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_so_far = vec![0; k];\n    let mut\
    \ max_so_far_len = k;\n    let mut max_so_far_pos = 0;\n    let mut max_so_far_max_pos\
    \ = 0;\n    let mut max_so_far_max_neg = 0;\n    let mut max_so_far_max_neg2 =\
    \ 0;\n    let mut max_so_far_max_neg3 = 0;\n    let mut max_so_far_max_neg4 =\
    \ 0;\n    let mut max_so_far_max_neg5 = 0;\n    let mut max_so_far_max_neg6 =\
    \ 0;\n    let mut max_so_far_max_neg7 = 0;\n    let mut max_so_far_max_neg8 =\
    \ 0;\n    let mut max_so_far_max_neg9 = 0;\n    let mut max_so_far_max_neg10 =\
    \ 0;\n    let mut max_so_far_max_neg11 = 0;\n    let mut max_so_far_max_neg12\
    \ = 0;\n    let mut max_so_far_max_neg13 = 0;\n    let mut max_so_far_max_neg14\
    \ = 0;\n    let mut max_so_far_max_neg15 = 0;\n    let mut max_so_far_max_neg16\
    \ = 0;\n    let mut max_so_far_max_neg17 = 0;\n    let mut max_so_far_max_neg18\
    \ = 0;\n    let mut max_so_far_max_neg19 = 0;\n    let mut max_so_far_max_neg20\
    \ = 0;\n    let mut max_so_far_max_neg21 = 0;\n    let mut max_so_far_max_neg22\
    \ = 0;\n    let mut max_so_far_max_neg23 = 0;\n    let mut max_so_far_max_neg24\
    \ = 0;\n    let mut max_so_far_max_neg25 = 0;\n    let mut max_so_far_max_neg26\
    \ = 0;\n    let mut max_so_far_max_neg27 = 0;\n    let mut max_so_far_max_neg28\
    \ = 0;\n    let mut max_so_far_max_neg29 = 0;\n    let mut max_so_far_max_neg30\
    \ = 0;\n    let mut max_so_far_max_neg31 = 0;\n    let mut max_so_far_max_neg32\
    \ = 0;\n    let mut max_so_far_max_neg33 = 0;\n    let mut max_so_far_max_neg34\
    \ = 0;\n    let mut max_so_far_max_neg35 = 0;\n    let mut max_so_far_max_neg36\
    \ = 0;\n    let mut max_so_far_max_neg37 = 0;\n    let mut max_so_far_max_neg38\
    \ = 0;\n    let mut max_so_far_max_neg39 = 0;\n    let mut max_\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpos5xdt84.rs:54:17\n   |\n\
    54 |     let mut max_\n   |                 ^ help: add `;` here\n55 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpos5xdt84.rs:11:34\n\
    \   |\n11 |     let mut max_so_far = vec![0; k];\n   |                       \
    \           ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n11\
    \ |     let mut max_so_far = vec![0; k.try_into().unwrap()];\n   |           \
    \                       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpos5xdt84.rs:10:42\n   |\n10 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |    -------                               ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_idx = 0;\n    for i in 0..arr.len() {\n        if max_arr[k-1][i] >\
    \ arr[i] {\n            max_arr[k-1][i] = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    max_arr.iter().cloned().take(k).collect()\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprstfv2r6.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprstfv2r6.rs:14:12\n   |\n14 |  \
    \       if max_arr[k-1][i] > arr[i] {\n   |            ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmprstfv2r6.rs:15:13\n\
    \   |\n15 |             max_arr[k-1][i] = arr[i];\n   |             ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprstfv2r6.rs:19:34\n   |\n19 |\
    \     max_arr.iter().cloned().take(k).collect()\n   |                        \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n19 |     max_arr.iter().cloned().take(k.try_into().unwrap()).collect()\n\
    \   |                                  ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `Vec<{integer}>`\n  --> /tmp/tmprstfv2r6.rs:19:37\n   |\n19 |     max_arr.iter().cloned().take(k).collect()\n\
    \   |                                     ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=Vec<{integer}>>`\n   |\n "
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in (i + 1)..k {\n            if max_arr[i] > max_arr[j] {\n       \
    \         max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    for i\
    \ in 0..k {\n        arr[i] = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk6fi306k.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpk6fi306k.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpk6fi306k.rs:13:22\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpk6fi306k.rs:17:16\n\
    \   |\n17 |             if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpk6fi306k.rs:17:29\n   |\n17 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_k = k;\n    let\
    \ mut max_val = arr[0];\n    for &x in arr {\n        if x > max_val {\n     \
    \       max_val = x;\n        }\n        if max_k == 0 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if x > max_val {\n            max_arr.push(max_val);\n\
    \            max_k -= 1;\n        }\n        if max_k == 0 {\n            max_arr.push(max_val);\n\
    \            break;\n        }\n        if x > max_val {\n            max_arr.push(max_val);\n\
    \            max_k -= 1;\n        }\n    }\n    max_arr\n}\n\nfn main() {\n  \
    \  let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqxl9m6i6.rs:17:9\n   |\n\
    17 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_value = arr[0];\n    for &x in arr {\n        if x > max_value\
    \ {\n            max_value = x;\n            max_idx = k;\n        }\n       \
    \ max_arr[max_idx] = x;\n        max_idx--;\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpr0ch7ihk.rs:20:18\n\
    \   |\n20 |         max_idx--;\n   |                  ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpr0ch7ihk.rs:11:31\n   |\n11 |  \
    \   let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr0ch7ihk.rs:14:9\n   |\n14 | \
    \    for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0277]: the\
    \ type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpr0ch7ihk.rs:19:9\n\
    \   |\n19 |         max_arr[max_idx] = x;\n   |         ^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_num = vec![0];\n    for i in 0..k {\n        max_arr[i] = max_num.iter().max().unwrap();\n\
    \        max_num[i] = arr[i];\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_num[i] - max_arr[i];\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfkk7nxw_.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfkk7nxw_.rs:14:9\n   |\n14 |   \
    \      max_arr[i] = max_num.iter().max().unwrap();\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpfkk7nxw_.rs:15:9\n\
    \   |\n15 |         max_num[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfkk7nxw_.rs:15:22\n  \
    \ |\n15 |         max_num[i] = arr[i];\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpfkk7nxw_.rs:18:9\n\
    \   |\n18 |         max_arr[i] = max_num[i] - max_arr[i];\n   |         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_idx = k;\n    for &x in arr {\n        if x > max_arr[k - 1][0] {\n\
    \            max_arr[k - 1][0] = x;\n            max_arr[k - 1][1] = x;\n    \
    \    } else {\n            max_arr[k - 1][1] = x;\n        }\n        k += 1;\n\
    \    }\n    max_arr.sort_by_key(|&x| x.0);\n    max_arr\n}\n\nfn main() {\n  \
    \  let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwkm519tl.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwkm519tl.rs:13:9\n   |\n13 |     for &x in arr {\n   |        \
    \ ^^    --- this expression has type `isize`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpwkm519tl.rs:14:16\n   |\n14 |         if\
    \ x > max_arr[k - 1][0] {\n   |                ^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpwkm519tl.rs:15:13\n\
    \   |\n15 |             max_arr[k - 1][0] = x;\n   |             ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpwkm519tl.rs:16:13\n   |\n16 |             max_arr[k - 1][1] = x;\n \
    \  |             ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed "
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqt7vsjak.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqt7vsjak.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqt7vsjak.rs:13:22\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpqt7vsjak.rs:16:9\n\
    \   |\n16 |         max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpqt7vsjak.rs:16:22\n   |\n16 |         max_arr[i] = max_arr[i].max();\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = note: required because of the requirements on\
    \ the impl of `In"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        if\
    \ max_arr.len() < max_k {\n            max_arr.push(arr[max_i]);\n        }\n\
    \        max_i -= 1;\n    }\n    max_arr.sort();\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxju4ypmy.rs:14:19\n   |\n\
    14 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxju4ypmy.rs:15:28\n   |\n15 |         if max_arr.len()\
    \ < max_k {\n   |                            ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |         if max_arr.len() < max_k.try_into().unwrap()\
    \ {\n   |                            ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for i in 1..k {\n\
    \        if max < arr[i] {\n            max = arr[i];\n        }\n    }\n    vec![max]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbt4j1lyl.rs:13:18\n\
    \   |\n13 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbt4j1lyl.rs:14:19\n   |\n14 |  \
    \           max = arr[i];\n   |                   ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max_arr = vec![vec![0]; k];\n    for i in 0..k {\n        max_arr[i]\
    \ = arr[i];\n    }\n    for i in 0..k {\n        let mut max_i = i;\n        for\
    \ j in (i + 1)..k {\n            if max_arr[j] > max_arr[j - 1] {\n          \
    \      max_i = j;\n            }\n        }\n        max_arr[i] = max_arr[max_i];\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0hnms54.rs:11:21\n   |\n\
    11 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj0hnms54.rs:14:37\n   |\n14 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpj0hnms54.rs:16:9\n\
    \   |\n16 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpj0hnms54.rs:16:22\n\
    \   |\n16 |         max_arr[i] = arr[i];\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpj0hnms54.rs:21:16\n\
    \   |\n21 |             if max_arr[j] > max_arr[j - 1] {\n   |               \
    \ ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_num = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_num {\n            max_num = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(max_num);\n            max_num = arr[i];\n        }\n    }\n\
    \    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxecsgrd6.rs:17:12\n\
    \   |\n17 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxecsgrd6.rs:18:23\n   |\n18 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxecsgrd6.rs:22:12\n   |\n22 |  \
    \       if arr[i] > max_num {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxecsgrd6.rs:24:23\n   |\n24 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    let mut max_num = max_arr[i];\n        let mut max_pos = i;\n        for\
    \ j in (i + 1)..k {\n            if max_arr[j] > max_num {\n                max_num\
    \ = max_arr[j];\n                max_pos = j;\n            }\n        }\n    \
    \    max_arr[max_pos] = max_num;\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0kmybq87.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0kmybq87.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp0kmybq87.rs:13:22\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp0kmybq87.rs:16:27\n\
    \   |\n16 |         let mut max_num = max_arr[i];\n   |                      \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp0kmybq87.rs:19:16\n   |\n19 |         \
    \    if max_arr[j] > max_num {\n   |                ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the "
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:15:23\n   |\n15 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:19:12\n   |\n19 |  \
    \       if arr[i] > max_num {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:20:26\n   |\n20 |  \
    \           max_arr.push(arr[i]);\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_val = arr[0];\n    for &i in arr {\n        if i > max_val\
    \ {\n            max_val = i;\n        }\n        if i == max_val {\n        \
    \    max_arr[k - 1] = i;\n        }\n        if i > max_val {\n            max_arr[k\
    \ - 1] = i;\n        }\n        if i == max_val {\n            max_arr[k - 1]\
    \ = i;\n        }\n        if i > max_val {\n            max_arr[k - 1] = i;\n\
    \        }\n        if i == max_val {\n            max_arr[k - 1] = i;\n     \
    \   }\n        if i > max_val {\n            max_arr[k - 1] = i;\n        }\n\
    \        if i == max_val {\n            max_arr[k - 1] = i;\n        }\n     \
    \   if i > max_val {\n            max_arr[k - 1] = i;\n        }\n        if i\
    \ == max_val {\n            max_arr[k - 1] = i;\n        }\n        if i > max_val\
    \ {\n            max_arr[k - 1] = i;\n        }\n        if i == max_val {\n \
    \           max_arr[k - 1] = i;\n        }\n        if i > max_val {\n       \
    \     max_arr[k - 1] = i;\n        }\n        if i == max_val {\n            max_arr[k\
    \ - 1] = i;\n        }\n        if i > max_val {\n            max_arr[k - 1] =\
    \ i;\n        }\n        if i == max_val {\n            max_arr[k - 1] = i;\n\
    \        }\n        if i > max_val {\n            max_arr[k - 1] = i;\n      \
    \  }\n        if i == max_val {\n            max_arr[k - 1] = i;\n        }\n\
    \        if i > max_val {\n            max_arr[k - 1] = i;\n        }\n      \
    \  if i == max_val {\n            max_arr[k - 1] = i;\n        }\n        if i\
    \ > max_val {\n            max_arr[k - 1] = i;\n        }\n        if i == max_val\
    \ {\n            max_arr[k - 1] = i;\n        }\n        if i > max_val {\n  \
    \          max_arr[k - 1] = i;\n        }\n        if i == max_val {\n       \
    \     max_arr[k - 1] = i;\n        }\n        if i > max_val {\n            max_arr[k\
    \ - 1] = i;\n        }\n        if i == max_val {\n            max_arr[k - 1]\
    \ = i;\n        }\n        if i > max_val {\n            max_arr[k - 1] = i;\n\
    \        }\n        if i == max_val {\n            max_arr[k - 1] = i;\n     \
    \   }\n        if i > max_val {\n            max_arr[k - 1] = i;\n        }\n\
    \        if i == max_val {\n            max_arr[k - 1] = i;\n        }\n     \
    \   if i > max_val {\n            max_arr[k - 1] = i;\n        }\n        if i\
    \ == max_val {\n            max_arr[k - 1] = i;\n        }\n        if i > max_\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpnur7peg1.rs:127:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    14  |     for &i in arr {\n    |                   - this delimiter might not\
    \ be properly closed...\n...\n112 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n127 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpnur7peg1.rs:112:1\n    |\n111 |         if i > max_\n  \
    \  |         -- this `if` expression has a condition, but no block\n112 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnur7peg1.rs:11:31\n\
    \   |\n11 |     let mut max_arr = vec![0; k];\n   |                          \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![0; k.try_into().unwrap()];\n   |                        \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnur7peg1.rs:14:9\n\
    \   |\n14 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpnur7peg1.rs:19:13\n\
    \   |\n19 |             max_arr[k - 1] = i;\n   |             ^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpnur7peg1.rs:22:13\n\
    \   |\n22 |             max_arr[k - 1] = i;\n   |             ^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_val = arr[0];\n    for i in 1..arr.len() {\n        if\
    \ arr[i] > max_val {\n            max_val = arr[i];\n        }\n        if max_k\
    \ == i {\n            max_arr.push(max_val);\n        }\n        if max_k > i\
    \ {\n            max_k -= i;\n        }\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8iob826j.rs:18:21\n   |\n\
    18 |         if max_k == i {\n   |                     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |         if max_k == i.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8iob826j.rs:21:20\n   |\n21 |         if max_k > i {\n\
    \   |                    ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n21 |         if max_k > i.try_into().unwrap() {\n   |                 \
    \   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8iob826j.rs:22:22\n\
    \   |\n22 |             max_k -= i;\n   |                      ^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot subtract-assign `usize` from `isize`\n\
    \  --> /tmp/tmp8iob826j.rs:22:19\n   |\n22 |             max_k -= i;\n   |   \
    \                ^^ no implementation for `isize -= usize`\n   |\n   = help: the\
    \ trait `SubAssign<usize>` is not implemented for `isize`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    let mut max_num\
    \ = arr[0];\n    let mut max_idx = 1;\n    for i in 1..arr.len() {\n        if\
    \ arr[i] > max_num {\n            max_num = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        result.push(max_num);\n      \
    \  max_idx += 1;\n        max_num -= arr[i];\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4eqzo6l0.rs:23:20\n\
    \   |\n23 |         max_num -= arr[i];\n   |                    ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_val = arr[0];\n    for i in arr.iter().rev() {\n     \
    \   if i > max_val {\n            max_val = i;\n            max_idx = k;\n   \
    \     }\n        if i == max_val {\n            max_arr[k - 1] = i;\n        \
    \    k -= 1;\n        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk5jm0xor.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk5jm0xor.rs:15:16\n   |\n15 |\
    \         if i > max_val {\n   |                ^^^^^^^\n   |                |\n\
    \   |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk5jm0xor.rs:16:23\n   |\n16 |             max_val = i;\n   |       \
    \                ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             max_val = *i;\n   |                     \
    \  +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpk5jm0xor.rs:19:14\n\
    \   |\n19 |         if i == max_val {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpk5jm0xor.rs:20:13\n   |\n20 |             max_arr[k\
    \ - 1] = i;\n   |             ^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqt7vsjak.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqt7vsjak.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqt7vsjak.rs:13:22\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpqt7vsjak.rs:16:9\n\
    \   |\n16 |         max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpqt7vsjak.rs:16:22\n   |\n16 |         max_arr[i] = max_arr[i].max();\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = note: required because of the requirements on\
    \ the impl of `In"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_so_far\
    \ = arr[0];\n    let mut max_so_far_index = 0;\n    for i in 1..k {\n        if\
    \ arr[i] > max_so_far {\n            max_so_far = arr[i];\n            max_so_far_index\
    \ = i;\n        }\n    }\n    for i in 0..k {\n        if i == max_so_far_index\
    \ {\n            result[i] = max_so_far;\n        } else {\n            result[i]\
    \ = arr[i];\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp673a8lck.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp673a8lck.rs:15:12\n\
    \   |\n15 |         if arr[i] > max_so_far {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp673a8lck.rs:16:26\n   |\n16 |            \
    \ max_so_far = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp673a8lck.rs:22:13\n   |\n22 |         \
    \    result[i] = max_so_far;\n   |             ^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp673a8lck.rs:24:13\n   |\n24 |  \
    \           result[i] = arr[i];\n   |             ^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceInd"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2hpgrlg.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_val = arr[0];\n    for &i in arr {\n        if i > max_val\
    \ {\n            max_val = i;\n            max_idx = k;\n        }\n        if\
    \ i == max_val {\n            max_idx += 1;\n        }\n    }\n    max_arr.copy_from_slice(&arr[..max_idx]);\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp98_w5fy1.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp98_w5fy1.rs:14:9\n   |\n14 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `RangeTo<isize>`\n  --> /tmp/tmp98_w5fy1.rs:23:30\n   |\n\
    23 |     max_arr.copy_from_slice(&arr[..max_idx]);\n   |                     \
    \         ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `RangeTo<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <RangeTo<usize> as SliceIndex<[T]>>\n             <RangeTo<usize> as\
    \ SliceIndex<str>>\n   = note: required because of the requirements on the impl\
    \ of `Index<RangeTo<isize>>` for `Vec<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > max_arr[i][j + 1] {\n\
    \                max_arr[i][j] = max_arr[i][j + 1];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[i] {\n                max_arr[i][j] = arr[i];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxrckk6qx.rs:11:36\n   |\n\
    11 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxrckk6qx.rs:13:9\n   |\n13 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxrckk6qx.rs:13:27\n   |\n13 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpxrckk6qx.rs:17:16\n   |\n17 |         \
    \    if max_arr[i][j] > max_arr[i][j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpxrckk6qx.rs:17:32\n\
    \   |\n17 |             if max_arr[i][j] > max_arr[i][j + 1] {\n   |         \
    \                       ^^^^^^^^^^ slice "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![vec![0]; k];\n    for i\
    \ in 0..k {\n        result[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        let mut max = 0;\n        for j in 0..k {\n            if result[i][j]\
    \ > max {\n                max = result[i][j];\n            }\n        }\n   \
    \     result[i][0] = max;\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if result[i][j] > result[i][j+1] {\n                result[i][j+1]\
    \ = result[i][j];\n            }\n        }\n    }\n    for i in 0..k {\n    \
    \    result[i].pop();\n    }\n    for i in 0..k {\n        for j in 0..k {\n \
    \           if result[i][j] > result[i+1][j] {\n                result[i+1][j]\
    \ = result[i][j];\n            }\n        }\n    }\n    for i in 0..k {\n    \
    \    result[i].pop();\n    }\n    for i in 0..k {\n        result[i].pop();\n\
    \    }\n    for i in 0..k {\n        result[i].pop();\n    }\n    for i in 0..k\
    \ {\n        result[i].pop();\n    }\n    for i in 0..k {\n        result[i].pop();\n\
    \    }\n    for i in 0..k {\n        result[i].pop();\n    }\n    for i in 0..k\
    \ {\n        result[i].pop();\n    }\n    for i in 0..k {\n        result[i].pop();\n\
    \    }\n    for i in 0..k {\n        result[i].pop();\n    }\n    for i in 0..k\
    \ {\n        result[i].pop();\n    }\n    for i in 0..k {\n        result[i].pop();\n\
    \    }\n    for i in 0..k {\n        result[i].pop();\n    }\n    for i in 0..k\
    \ {\n        result[i].pop();\n    }\n    for i in 0..k {\n        result[i].pop();\n\
    \    }\n    for i in 0..k {\n        result[i].pop();\n    }\n    for i in 0..k\
    \ {\n        result[i].pop();\n    }\n    for i in 0..k {\n        result[i].pop();\n\
    \    }\n    for i in 0..k {\n        result[i].pop();\n    }\n    for i in 0..k\
    \ {\n        result[i].pop();\n    }\n    for i in 0..k {\n        result[i].pop();\n\
    \    }\n    for i in 0..k {\n        result[i].pop();\n    }\n    for i in 0..k\
    \ {\n        result[i].pop();\n    }\n    for i in 0..k {\n        result[i].pop();\n\
    \    }\n    for i in 0..k {\n        result[i].pop();\n    }\n    for i in 0..k\
    \ {\n        result[i].pop();\n    }\n    for i in 0..k {\n        result[i].pop();\n\
    \    }\n    for i in 0..k {\n        result[i].pop();\n    }\n    for i in 0..\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp92jbjsd6.rs:123:1\n    |\n\
    123 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp92jbjsd6.rs:11:36\n\
    \   |\n11 |     let mut result = vec![vec![0]; k];\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut result = vec![vec![0]; k.try_into().unwrap()];\n   |        \
    \                             ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp92jbjsd6.rs:13:9\n   |\n13 |   \
    \      result[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp92jbjsd6.rs:13:26\n   |\n13 |  \
    \       result[i] = vec![arr[i]; 1];\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp92jbjsd6.rs:18:16\n   |\n18 |  \
    \           if result[i][j] > max {\n   |                ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_k = k;\n    let mut max_i = 1;\n    let mut max_j = 1;\n    let mut\
    \ max_val = arr[0];\n    for &i in arr {\n        if i > max_val {\n         \
    \   max_val = i;\n            max_i = 1;\n        }\n        if i == max_val {\n\
    \            max_i += 1;\n        }\n        if max_i > max_k {\n            max_k\
    \ = max_i;\n        }\n        if max_j > i {\n            max_j = i;\n      \
    \  }\n    }\n    max_arr.push(max_j);\n    max_arr.push(max_k);\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7r9jjbbt.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7r9jjbbt.rs:16:9\n   |\n16 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7r9jjbbt.rs:31:18\n\
    \   |\n31 |     max_arr.push(max_j);\n   |                  ^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<{integer}>`\n  \
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7r9jjbbt.rs:32:18\n\
    \   |\n32 |     max_arr.push(max_k);\n   |                  ^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<{integer}>`\n  \
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7r9jjbbt.rs:33:5\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n33 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    let mut max_i = i;\n        for j in (i + 1)..k {\n            if max_arr[j]\
    \ > max_arr[j - 1] {\n                max_i = j;\n            }\n        }\n \
    \       max_arr[i] = max_arr[max_i];\n    }\n    for i in 0..k {\n        arr[i]\
    \ = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc5ysw2ei.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc5ysw2ei.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc5ysw2ei.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc5ysw2ei.rs:18:16\n   |\n18 |  \
    \           if max_arr[j] > max_arr[j - 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpc5ysw2ei.rs:18:29\n   |\n18 |             if max_arr[j] > max_arr[j\
    \ - 1] {\n   |                        "
  stdout: ''
  timestamp: 1660009214
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    let mut max_idx = 1;\n    for i in 1..arr.len() {\n        if\
    \ arr[i] > max_num {\n            max_num = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        max_arr.push(max_num);\n     \
    \   max_idx += 1;\n    }\n    max_arr.push(arr[max_idx]);\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 5'', /tmp/tmpjz2hvsuh.rs:24:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp1is3r1c3.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    let mut max_num = max_arr[i];\n        for j in (i + 1)..k {\n          \
    \  if max_arr[j] > max_num {\n                max_num = max_arr[j];\n        \
    \    }\n        }\n        max_arr[i] = max_num;\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp435hv4nh.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp435hv4nh.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp435hv4nh.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp435hv4nh.rs:16:27\n   |\n16 |  \
    \       let mut max_num = max_arr[i];\n   |                           ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp435hv4nh.rs:18:16\n   |\n18 |             if max_arr[j] > max_num {\n\
    \   |                ^^^^^^^^^^ "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = vec![];\n    }\n    for i in 0..arr.len() {\n\
    \        let mut max_i = i;\n        for j in 0..k {\n            if arr[i] >\
    \ max_arr[j].last() {\n                max_i = j;\n            }\n        }\n\
    \        max_arr[max_i].push(arr[i]);\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0fb2gg59.rs:11:36\n   |\n\
    11 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp0fb2gg59.rs:13:9\n   |\n13 |         max_arr[i]\
    \ = vec![];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp0fb2gg59.rs:18:25\n   |\n18 |             if arr[i] >\
    \ max_arr[j].last() {\n   |                         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0fb2gg59.rs:19:25\n\
    \   |\n16 |         let mut max_i = i;\n   |                         - expected\
    \ due to this value\n...\n19 |                 max_i = j;\n   |              \
    \           ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0fb2gg59.rs:24:5\n   |\n10 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n24 |     max_arr\n   |     ^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<isize>>`\n\nerror: aborting due to 5 previous\
    \ errors"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        arr[i]\
    \ = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0v8in2k.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    let mut max_so_far\
    \ = arr[0];\n    let mut max_so_far_i = 1;\n    let mut max_so_far_j = 1;\n  \
    \  for i in 1..k {\n        if arr[i] > max_so_far {\n            max_so_far =\
    \ arr[i];\n            max_so_far_i = i;\n        }\n        if arr[i] > max_so_far\
    \ {\n            max_so_far = arr[i];\n            max_so_far_j = i;\n       \
    \ }\n    }\n    for i in 0..k {\n        if max_so_far_i < max_so_far_j {\n  \
    \          result.push(arr[i]);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4ky1mzca.rs:16:12\n\
    \   |\n16 |         if arr[i] > max_so_far {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp4ky1mzca.rs:17:26\n   |\n17 |            \
    \ max_so_far = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp4ky1mzca.rs:20:12\n   |\n20 |         if arr[i]\
    \ > max_so_far {\n   |            ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp4ky1mzca.rs:21:26\n   |\n21 |             max_so_far = arr[i];\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp4ky1mzca.rs:27:25\n   |\n27 |             result.push(arr[i]);\n\
    \   |                         ^^^^^^ slice indices are of ty"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    for &i in arr {\n        if i > max_arr[k] {\n            max_arr[k]\
    \ = i;\n            max_idx += 1;\n        }\n    }\n    max_arr.sort_unstable();\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4zkwhfoe.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4zkwhfoe.rs:13:9\n   |\n13 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4zkwhfoe.rs:14:16\n   |\n14 |  \
    \       if i > max_arr[k] {\n   |                ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4zkwhfoe.rs:15:13\n   |\n15 |  \
    \           max_arr[k] = i;\n   |             ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_idx = k;\n    for i in 0..arr.len() {\n        if arr[i] > max_arr[k\
    \ - 1][0] {\n            max_arr[k - 1][0] = arr[i];\n            max_arr[k -\
    \ 1][1] = i;\n        }\n        if arr[i] > max_arr[k - 1][1] {\n           \
    \ max_arr[k - 1][1] = arr[i];\n        }\n        if arr[i] > max_arr[k - 1][1]\
    \ && arr[i] > max_arr[k - 1][0] {\n            max_arr[k - 1][0] = arr[i];\n \
    \       }\n        if arr[i] == max_arr[k - 1][0] {\n            max_arr[k - 1][1]\
    \ = i;\n        }\n        if arr[i] == max_arr[k - 1][1] {\n            max_arr[k\
    \ - 1][0] = i;\n        }\n        if arr[i] == max_arr[k - 1][1] && arr[i] ==\
    \ max_arr[k - 1][0] {\n            max_arr[k - 1][1] = i;\n        }\n    }\n\
    \    for i in 0..k {\n        if max_arr[i][0] > max_arr[i][1] {\n           \
    \ max_arr[i][0] = max_arr[i][1];\n        }\n    }\n    for i in 0..k {\n    \
    \    if max_arr[i][0] > max_arr[i][1] {\n            max_arr[i][1] = max_arr[i][0];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i][0] > max_arr[i][1]\
    \ {\n            max_arr[i][0] = max_arr[i][1];\n        }\n    }\n    for i in\
    \ 0..k {\n        if max_arr[i][0] > max_arr[i][1] {\n            max_arr[i][1]\
    \ = max_arr[i][0];\n        }\n    }\n    for i in 0..k {\n        if max_arr[i][0]\
    \ > max_arr[i][1] {\n            max_arr[i][0] = max_arr[i][1];\n        }\n \
    \   }\n    for i in 0..k {\n        if max_arr[i][0] > max_arr[i][1] {\n     \
    \       max_arr[i][1] = max_arr[i][0];\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i][0] > max_arr[i][1] {\n            max_arr[i][0] = max_arr[i][1];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i][0] > max_arr[i][1]\
    \ {\n            max_arr[i][1] = max_arr[i][0];\n        }\n    }\n    for i in\
    \ 0..k {\n        if max_arr[i][0] > max_arr[i][1] {\n            max_arr[i][0]\
    \ = max_arr[i][1];\n        }\n    }\n    for i in 0..k {\n        if max_arr[i][0]\
    \ > max_arr[i][1] {\n            max_arr[i][1] = max_arr[i][0];\n        }\n \
    \   }\n    for i in 0..k {\n        if max_arr[i][0] > max_arr[i][1] {\n     \
    \       max_arr[i][0] = max_arr[i][1];\n        }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqu83beny.rs:103:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    84  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n...\n88  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n103 | }\n    |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqu83beny.rs:11:37\n   |\n11 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpqu83beny.rs:14:21\n\
    \   |\n14 |         if arr[i] > max_arr[k - 1][0] {\n   |                    \
    \ ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpqu83beny.rs:15:13\n   |\n15 |             max_arr[k - 1][0] = arr[i];\n\
    \   |             ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpqu83beny.rs:16:13\n   |\n16 |         \
    \    max_arr[k - 1][1] = i;\n   |             ^^^^^^^^^^^^^^ slice indices are"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    for i in 0..arr.len() {\n        if arr[i] > max_arr[k] {\n      \
    \      max_arr[k] = arr[i];\n            max_idx = k;\n        }\n        if max_idx\
    \ > k {\n            break;\n        }\n        max_idx -= 1;\n    }\n    max_arr.sort_unstable();\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkfi0tly.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpzkfi0tly.rs:14:21\n\
    \   |\n14 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpzkfi0tly.rs:15:13\n\
    \   |\n15 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max_arr = vec![arr[0]; k];\n    let mut max_idx = k;\n    for\
    \ i in 1..arr.len() {\n        if arr[i] > max_arr[k-1] {\n            max_arr[k-1]\
    \ = arr[i];\n            max_idx -= 1;\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxm4jnoy4.rs:11:21\n   |\n\
    11 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxm4jnoy4.rs:14:36\n   |\n14 |     let mut max_arr = vec![arr[0];\
    \ k];\n   |                                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     let mut max_arr = vec![arr[0]; k.try_into().unwrap()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxm4jnoy4.rs:17:21\n\
    \   |\n17 |         if arr[i] > max_arr[k-1] {\n   |                     ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxm4jnoy4.rs:18:13\n\
    \   |\n18 |             max_arr[k-1] = arr[i];\n   |             ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![-1000, 1000]];\n\
    \    let mut max_k = k;\n    let mut max_i = 1;\n    let mut max_j = 1;\n    let\
    \ mut max_value = arr[0];\n    while max_i < max_k {\n        let mut max_i =\
    \ 1;\n        let mut max_j = 1;\n        for j in 0..arr.len() {\n          \
    \  if arr[j] > max_value {\n                max_value = arr[j];\n            \
    \    max_i = j;\n            }\n            if arr[j] > max_arr[j][max_i] {\n\
    \                max_arr[j][max_i] = arr[j];\n                max_j = j;\n   \
    \         }\n        }\n        max_arr[j][max_i] = -max_value;\n        max_k\
    \ = max_j;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpg_mblrh3.rs:29:17\n\
    \   |\n29 |         max_arr[j][max_i] = -max_value;\n   |                 ^ help:\
    \ a local variable with a similar name exists: `k`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg_mblrh3.rs:30:17\n   |\n12 |     let mut max_k = k;\n\
    \   |                     - expected due to this value\n...\n30 |         max_k\
    \ = max_j;\n   |                 ^^^^^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg_mblrh3.rs:32:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n32 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2hpgrlg.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_element = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] > max_element {\n            max_element = arr[i];\n        }\n\
    \        if max_k == i {\n            max_arr.push(max_element);\n        }\n\
    \        if max_k > i {\n            max_k = i;\n        }\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwmqs90cq.rs:18:21\n   |\n\
    18 |         if max_k == i {\n   |                     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |         if max_k == i.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwmqs90cq.rs:21:20\n   |\n21 |         if max_k > i {\n\
    \   |                    ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n21 |         if max_k > i.try_into().unwrap() {\n   |                 \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmqs90cq.rs:22:21\n\
    \   |\n12 |     let mut max_k = k;\n   |                     - expected due to\
    \ this value\n...\n22 |             max_k = i;\n   |                     ^ expected\
    \ `isize`, found `usize`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp1is3r1c3.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n    let mut max_arr = vec![vec![0]; k]\n    for i in 0..k {\n        max_arr[i]\
    \ = arr[i]\n    }\n    for i in 0..k {\n        for j in i+1..k {\n          \
    \  if max_arr[j] < max_arr[i] {\n                max_arr[i] = max_arr[j]\n   \
    \         }\n        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp21f5gwem.rs:14:39\n\
    \   |\n14 |     let mut max_arr = vec![vec![0]; k]\n   |                     \
    \                  ^ help: add `;` here\n15 |     for i in 0..k {\n   |     ---\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp21f5gwem.rs:11:21\n\
    \   |\n11 |     if arr.len() <= k {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n11 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp21f5gwem.rs:14:37\n   |\n14 |     let mut max_arr = vec![vec![0];\
    \ k]\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()]\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp21f5gwem.rs:16:9\n\
    \   |\n16 |         max_arr[i] = arr[i]\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp21f5gwem.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = arr[i]\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp21f5gwem.rs:"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        if\
    \ max_arr.len() < max_k {\n            max_arr.push(arr[max_i]);\n        }\n\
    \        if max_arr[max_i] > arr[max_i] {\n            max_arr[max_i] = arr[max_i];\n\
    \        }\n        max_i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvqjydc3v.rs:14:19\n   |\n\
    14 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvqjydc3v.rs:15:28\n   |\n15 |         if max_arr.len()\
    \ < max_k {\n   |                            ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |         if max_arr.len() < max_k.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in (i + 1)..k {\n            if max_arr[i] > max_arr[j] {\n       \
    \         max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    for i\
    \ in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmvlmv0km.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmvlmv0km.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmvlmv0km.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmvlmv0km.rs:17:16\n   |\n17 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpmvlmv0km.rs:17:29\n   |\n17 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  stdout: ''
  timestamp: 1660009214
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_val = arr[0];\n    for x in arr {\n        if x > max_val\
    \ {\n            max_val = x;\n        }\n        if x > max_k {\n           \
    \ max_k = x;\n        }\n    }\n    for i in 0..max_k {\n        max_arr.push(max_val);\n\
    \    }\n    return max_arr;\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 5, 5, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpv4ctop3l.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for i in 1..k {\n\
    \        if max < arr[i] {\n            max = arr[i];\n        }\n    }\n    vec![max]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbt4j1lyl.rs:13:18\n\
    \   |\n13 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbt4j1lyl.rs:14:19\n   |\n14 |  \
    \           max = arr[i];\n   |                   ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = 0;\n    let mut max_j = arr.len();\n    while max_i\
    \ < max_j {\n        if max_k == 0 {\n            break;\n        }\n        if\
    \ max_k > arr.len() {\n            max_k = arr.len();\n        }\n        if max_k\
    \ > max_j {\n            max_k = max_j;\n        }\n        if max_k == 1 {\n\
    \            max_arr.push(arr[max_i]);\n            break;\n        }\n      \
    \  if max_k == arr.len() {\n            max_arr.push(arr[max_i]);\n          \
    \  break;\n        }\n        if max_k == max_j {\n            max_arr.push(arr[max_i]);\n\
    \            max_i += 1;\n            max_j -= 1;\n            max_k -= 1;\n \
    \       }\n        if max_k > max_j {\n            max_arr.push(arr[max_i]);\n\
    \            max_i += 1;\n        }\n    }\n    return max_arr;\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppu_6k6jl.rs:19:20\n   |\n\
    19 |         if max_k > arr.len() {\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |         if max_k >\
    \ arr.len().try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppu_6k6jl.rs:20:21\n   |\n12 |\
    \     let mut max_k = k;\n   |                     - expected due to this value\n\
    ...\n20 |             max_k = arr.len();\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppu_6k6jl.rs:22:20\n\
    \   |\n22 |         if max_k > max_j {\n   |                    ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |         if max_k >\
    \ max_j.try_into().unwrap() {\n   |                         ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppu_6k6jl.rs:23:21\n   |\n12 |\
    \     let mut max_k = k;\n   |                     - expected due to this value\n\
    ...\n23 |             max_k = max_j;\n   |                     ^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppu_6k6jl.rs:29:21\n\
    \   |\n29 |         if max_k == arr.len() {\n   |                     ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n29 |         if\
    \ max_k == arr.len().try_into().unwrap() {\n   |                             \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppu_6k6jl.rs:33:21\n\
    \   |\n33 |         if max_k == max_j {\n   |                     ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n33 |         if max_k ==\
    \ max_j.try_into().unwrap() {\n   |                          ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  -->"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val\
    \ = arr[0];\n    for i in 0..arr.len() {\n        if arr[i] > min_val {\n    \
    \        max_arr.push(arr[i]);\n            max_k = max_k - 1;\n        }\n  \
    \      if arr[i] < min_val {\n            min_arr.push(arr[i]);\n            min_idx\
    \ = i;\n        }\n        if max_k == 0 {\n            break;\n        }\n  \
    \  }\n    if max_k == 0 {\n        return vec![];\n    }\n    if min_idx == arr.len()\
    \ {\n        return vec![min_val];\n    }\n    if min_idx == 0 {\n        return\
    \ vec![min_val, max_arr[max_k - 1]];\n    }\n    if min_idx == max_idx {\n   \
    \     return vec![min_val, max_arr[max_k - 1], max_arr[max_k - 2]];\n    }\n \
    \   if max_k == 1 {\n        return vec![min_val, max_arr[max_k - 1], max_arr[max_k\
    \ - 2], max_arr[max_k - 3]];\n    }\n    if max_k == 2 {\n        return vec![min_val,\
    \ max_arr[max_k - 1], max_arr[max_k - 2], max_arr[max_k - 3], max_arr[max_k -\
    \ 4]];\n    }\n    if max_k == 3 {\n        return vec![min_val, max_arr[max_k\
    \ - 1], max_arr[max_k - 2], max_arr[max_k - 3], max_arr[max_k - 4], max_arr[max_k\
    \ - 5]];\n    }\n    if max_k == 4 {\n        return vec![min_val, max_arr[max_k\
    \ - 1], max_arr[max_k - 2], max_arr[max_k - 3], max_arr[max_k - 4], max_arr[max_k\
    \ - 5], max_arr[max_k - 6]];\n    }\n    if max_k == 5 {\n        return vec![min_val,\
    \ max_arr[max_k - 1], max_arr[max_k - 2], max_arr[max_k - 3], max_arr[max_k -\
    \ 4], max_arr[max_k - 5], max_arr[max_k - 6], max_arr[max_k - 7]];\n    }\n  \
    \  if max_k == 6 {\n        return vec![min_val, max_arr[max_k - 1], max_arr[max_k\
    \ - 2], max_arr[max_k - 3], max_arr[max_k - 4], max_arr[max_k - 5], max_arr[max_k\
    \ - 6], max_arr[max_k - 7], max_arr[max_k - 8]];\n    }\n    if max_k == 7 {\n\
    \        return vec![min_val, max_arr[max_k - 1], max_arr[max_k - 2], max_arr[max_k\
    \ - 3], max_arr[max_k - 4], max_arr[max_k - 5], max_\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7nhfestv.rs:76:3\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n59\
    \ |     if max_k == 7 {\n   |                   - this delimiter might not be\
    \ properly closed...\n60 |         return vec![min_val, max_arr[max_k - 1], max_arr[max_k\
    \ - 2], max_arr[max_k - 3], max_arr[max_k - 4], max_arr[max_k - 5], max_\n61 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n76 |\
    \ }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp7nhfestv.rs:60:20\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n60 |         return vec![min_val, max_arr[max_k - 1], max_arr[max_k\
    \ - 2], max_arr[max_k - 3], max_arr[max_k - 4], max_arr[max_k - 5], max_\n   |\
    \                    ^ unclosed delimiter\n61 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0425]: cannot find value `min_arr` in this scope\n  --> /tmp/tmp7nhfestv.rs:22:13\n\
    \   |\n22 |             min_arr.push(arr[i]);\n   |             ^^^^^^^ help:\
    \ a local variable with a similar name exists: `max_arr`\n\nerror[E0425]: cannot\
    \ find value `max_` in this scope\n  --> /tmp/tmp7nhfestv.rs:60:130\n   |\n60\
    \ |         return vec![min_val, max_arr[max_k - 1], max_arr[max_k - 2], max_arr[max_k\
    \ - 3], max_arr[max_k - 4], max_arr[max_k - 5], max_\n   |                   \
    \                                                                            \
    \                                   ^^^^ help: a local variable with a similar\
    \ name exists: `max_k`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp7nhfestv.rs:36:30\n   |\n36 |         return vec![min_val,\
    \ max_arr[max_k - 1]];\n   |                              ^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in i+1..k {\n            if max_arr[i] > max_arr[j] {\n           \
    \     max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdclw8m4g.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpdclw8m4g.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpdclw8m4g.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpdclw8m4g.rs:17:16\n   |\n17 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpdclw8m4g.rs:17:29\n   |\n17 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_num = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_num {\n            max_num = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(max_num);\n            max_num = arr[i];\n        }\n    }\n\
    \    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzpvnsn4c.rs:17:12\n\
    \   |\n17 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzpvnsn4c.rs:18:23\n   |\n18 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzpvnsn4c.rs:22:12\n   |\n22 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpzpvnsn4c.rs:24:23\n   |\n24 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp1is3r1c3.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    let mut max_value\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_value {\n          \
    \  max_value = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i]\
    \ > max_value {\n            result.push(max_value);\n            max_value =\
    \ arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_value\
    \ {\n            result.push(arr[i]);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmps29vdwd4.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_value {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmps29vdwd4.rs:15:25\n   |\n15 |            \
    \ max_value = arr[i];\n   |                         ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmps29vdwd4.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_value {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmps29vdwd4.rs:21:25\n   |\n21 |             max_value = arr[i];\n\
    \   |                         ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmps29vdwd4.rs:25:12\n   |\n25 |         if arr[i] > max_value {\n\
    \   |            ^^^^^^ slice indices are of type `usize` or ranges"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_val = arr[0];\n    for i in 1..arr.len() {\n        if\
    \ arr[i] > max_val {\n            max_val = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        result[i] = max_val;\n       \
    \ max_idx -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpljg5dp8o.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpljg5dp8o.rs:17:23\n   |\n12 |\
    \     let mut max_idx = k;\n   |                       - expected due to this\
    \ value\n...\n17 |             max_idx = i;\n   |                       ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpljg5dp8o.rs:21:9\n   |\n21 |         result[i] = max_val;\n\
    \   |         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp1is3r1c3.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n        }\n        max_arr.push(arr[i]);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpsixwn6ci.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpsixwn6ci.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpsixwn6ci.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpsixwn6ci.rs:22:22\n   |\n22 |         max_arr.push(arr[i]);\n \
    \  |                      ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] < max_num {\n            max_arr.push(arr[i]);\n        }\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5rz_9vjo.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5rz_9vjo.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp5rz_9vjo.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp5rz_9vjo.rs:24:12\n   |\n24 |         if arr[i] < max_num {\n \
    \  |            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5rz_9vjo.rs:25:26\n\
    \   |\n25 |             max_arr.push(arr[i]);\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `us"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in (i + 1)..k {\n            if max_arr[i] > max_arr[j] {\n       \
    \         max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_f248r_9.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp_f248r_9.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp_f248r_9.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp_f248r_9.rs:17:16\n   |\n17 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp_f248r_9.rs:17:29\n   |\n17 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpwxtu197l.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_value\
    \ = arr[0];\n    let mut max_pos = 0;\n    for i in 0..arr.len() {\n        if\
    \ arr[i] > max_value {\n            max_value = arr[i];\n            max_pos =\
    \ i;\n        }\n    }\n    for i in 0..k {\n        result[i] = max_value;\n\
    \        max_pos = max_pos + 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp21_zcvra.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp21_zcvra.rs:21:9\n\
    \   |\n21 |         result[i] = max_value;\n   |         ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    let mut result =\
    \ vec![max];\n    for i in 1..k {\n        result.push(arr[max_idx]);\n      \
    \  max_idx += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp0qrejg1m.rs:21:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![vec![0]; k];\n    for i\
    \ in 0..k {\n        result[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        let mut max_num = arr[i];\n        let mut max_index = 0;\n        for\
    \ j in 0..k {\n            if result[j].iter().max().unwrap() < max_num {\n  \
    \              max_num = result[j].iter().max().unwrap();\n                max_index\
    \ = j;\n            }\n        }\n        result[max_index] = vec![max_num; 1];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps5r3mylc.rs:11:36\n   |\n\
    11 |     let mut result = vec![vec![0]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut result = vec![vec![0]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmps5r3mylc.rs:13:9\n   |\n13 |   \
    \      result[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmps5r3mylc.rs:13:26\n   |\n13 |  \
    \       result[i] = vec![arr[i]; 1];\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmps5r3mylc.rs:16:27\n   |\n16 |  \
    \       let mut max_num = arr[i];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmps5r3mylc.rs:19:16\n   |\n19 |  \
    \           if result[j].iter().max().unwrap() < max_num {\n   |             \
    \   ^^^^^^^^^ "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() < k {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_num = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_num {\n            max_num = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(max_num);\n            max_num = arr[i];\n        }\n    }\n\
    \    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzf751hdl.rs:11:30\n   |\n\
    11 |     if k == 0 || arr.len() < k {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     if k == 0 || arr.len()\
    \ < k.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzf751hdl.rs:17:12\n\
    \   |\n17 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzf751hdl.rs:18:23\n   |\n18 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzf751hdl.rs:22:12\n   |\n22 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpzf751hdl.rs:24:23\n   |\n24 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemente"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2hpgrlg.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpwxtu197l.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = 0;\n    let mut max_value = arr[0];\n    for i in 1..arr.len() {\n       \
    \ if arr[i] > max_value {\n            max_value = arr[i];\n            max_idx\
    \ = i;\n        }\n    }\n    for i in 0..k {\n        max_arr[i] = arr[k - i\
    \ - 1];\n    }\n    max_arr[k - 1] = max_value;\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfa692wba.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpfa692wba.rs:21:9\n\
    \   |\n21 |         max_arr[i] = arr[k - i - 1];\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfa692wba.rs:21:22\n\
    \   |\n21 |         max_arr[i] = arr[k - i - 1];\n   |                      ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpfa692wba.rs:23:5\n\
    \   |\n23 |     max_arr[k - 1] = max_value;\n   |     ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n    let mut max_arr = vec![vec![0]; k]\n    for i in 0..k {\n        max_arr[i]\
    \ = arr[i]\n    }\n    for i in 0..k {\n        let mut max_i = i\n        for\
    \ j in 0..k {\n            if max_arr[j] > max_arr[j + 1] {\n                max_i\
    \ = j\n            }\n        }\n        max_arr[i] = max_arr[max_i]\n    }\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpvs2ntm8w.rs:14:39\n\
    \   |\n14 |     let mut max_arr = vec![vec![0]; k]\n   |                     \
    \                  ^ help: add `;` here\n15 |     for i in 0..k {\n   |     ---\
    \ unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpvs2ntm8w.rs:19:26\n\
    \   |\n19 |         let mut max_i = i\n   |                          ^ help: add\
    \ `;` here\n20 |         for j in 0..k {\n   |         --- unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvs2ntm8w.rs:11:21\n   |\n11 |  \
    \   if arr.len() <= k {\n   |                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     if arr.len() <= k.try_into().unwrap() {\n\
    \   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvs2ntm8w.rs:14:37\n   |\n14 |     let mut max_arr = vec![vec![0];\
    \ k]\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()]\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpvs2ntm8w.rs:16:9\n\
    \   |\n16 |         max_arr[i] = arr[i]\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpvs2ntm8w.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = arr[i]\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![-1000, 1000]];\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().max().unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpryx5_v95.rs:95:3\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n78\
    \ |     for i in 0..k {\n   |                   - this delimiter might not be\
    \ properly closed...\n79 |         max_arr[i] = max_arr[i].iter().\n80 | }\n \
    \  | - ...as it matches this but it has different indentation\n...\n95 | }\n \
    \  |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpryx5_v95.rs:80:1\n   |\n\
    80 | }\n   | ^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpryx5_v95.rs:13:9\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].iter().max().unwrap();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpryx5_v95.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = max_arr[i].iter().max().unwrap();\n   |                 \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpryx5_v95.rs:16:9\n   |\n16 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_val\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_val {\n            max_val\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        max_arr.push(max_val);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpdls5if5i.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpdls5if5i.rs:15:23\n   |\n15 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_so_far\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_so_far {\n         \
    \   max_so_far = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i]\
    \ > max_so_far {\n            result[i] = max_so_far;\n        } else {\n    \
    \        result[i] = arr[i];\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6h6vvnxk.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6h6vvnxk.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_so_far {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6h6vvnxk.rs:15:26\n   |\n15 |            \
    \ max_so_far = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6h6vvnxk.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_so_far {\n   |            ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp6h6vvnxk.rs:20:13\n   |\n20 |             result[i] =\
    \ max_so_far;\n   |             ^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_so_far = vec![vec![0]; k];\n    let\
    \ mut max_so_far_iter = max_so_far.iter();\n    let mut max_so_far_iter = max_so_far_iter.map(|&x|\
    \ x.clone());\n    for i in 0..arr.len() {\n        let mut max_so_far_iter =\
    \ max_so_far_iter.map(|&x| x.clone());\n        max_so_far_iter.fold(vec![i],\
    \ |mut acc, &x| {\n            if *acc > x {\n                *acc = x;\n    \
    \        }\n            acc\n        });\n        max_so_far_iter = max_so_far_iter.map(|&x|\
    \ x.clone());\n    }\n    max_so_far\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5v5gi4hb.rs:11:40\n   |\n\
    11 |     let mut max_so_far = vec![vec![0]; k];\n   |                        \
    \                ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut max_so_far = vec![vec![0]; k.try_into().unwrap()];\n   |    \
    \                                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5v5gi4hb.rs:15:56\n   |\n15 |         let mut max_so_far_iter\
    \ = max_so_far_iter.map(|&x| x.clone());\n   |                               \
    \                         ^--\n   |                                          \
    \              ||\n   |                                                      \
    \  |expected due to this\n   |                                               \
    \         expected struct `Vec`, found reference\n   |                       \
    \                                 help: did you mean `x`: `&Vec<{integer}>`\n\
    \   |\n   = note: expected struct `Vec<{integer}>`\n           found reference\
    \ `&_`\n\nerror[E0277]: the size for values of type `[usize]` cannot be known\
    \ at compilation time\n  --> /tmp/tmp5v5gi4hb.rs:16:50\n   |\n16 |         max_so_far_iter.fold(vec![i],\
    \ |mut acc, &x| {\n   |                                                  ^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[usize]`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]:\
    \ the size for values of type `[usize]` cannot be known at compilation time\n\
    \  --> /tmp/tmp5v5gi4hb.rs:18:17\n   |\n18 |                 *acc = x;\n   | \
    \                ^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `[usize]`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5v5gi4hb.rs:22:27\n   |\n13 |     let mut max_so_far_iter\
    \ = max_so_far_iter.map(|&x| x.clone"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_idx = k;\n    for ele in arr {\n        if ele > max_arr[k - 1][0] {\n\
    \            max_arr[k - 1][0] = ele;\n            max_arr[k - 1][1] = 1;\n  \
    \      } else {\n            max_arr[k - 1][1] += 1;\n        }\n    }\n    for\
    \ i in 0..k {\n        max_arr[i][0] = max_arr[i][0] / max_arr[i][1];\n    }\n\
    \    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] / max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] / max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in 0..k {\n        max_arr[i][0] = max_arr[i][0] * max_arr[i][1];\n\
    \    }\n    for i in \n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpf339_n95.rs:85:1\n\
    \   |\n85 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf339_n95.rs:11:37\n   |\n11 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf339_n95.rs:14:18\n\
    \   |\n14 |         if ele > max_arr[k - 1][0] {\n   |                  ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpf339_n95.rs:15:13\n   |\n15 |             max_arr[k - 1][0] = ele;\n\
    \   |             ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpf339_n95.rs:16:13\n   |\n16 |         \
    \    max_arr[k - 1][1] = 1;\n   |             ^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_num = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_num {\n            max_num = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(max_num);\n            max_num = arr[i];\n        }\n    }\n\
    \    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxecsgrd6.rs:17:12\n\
    \   |\n17 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxecsgrd6.rs:18:23\n   |\n18 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxecsgrd6.rs:22:12\n   |\n22 |  \
    \       if arr[i] > max_num {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxecsgrd6.rs:24:23\n   |\n24 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_idx = 0;\n    for i in 0..arr.len() {\n        if arr[i] > max_arr[k][max_idx]\
    \ {\n            max_arr[k][max_idx] = arr[i];\n            max_idx += 1;\n  \
    \      }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0_2bzsty.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0_2bzsty.rs:14:21\n   |\n14 |  \
    \       if arr[i] > max_arr[k][max_idx] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp0_2bzsty.rs:15:13\n   |\n15 |             max_arr[k][max_idx] = arr[i];\n\
    \   |             ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0_2bzsty.rs:19:5\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n19 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:15:23\n   |\n15 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:19:12\n   |\n19 |  \
    \       if arr[i] > max_num {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:20:26\n   |\n20 |  \
    \           max_arr.push(arr[i]);\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > max_arr[i][j + 1] {\n\
    \                max_arr[i][j] = max_arr[i][j + 1];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpflrgg3jx.rs:11:36\n   |\n\
    11 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpflrgg3jx.rs:13:9\n   |\n13 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpflrgg3jx.rs:13:27\n   |\n13 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpflrgg3jx.rs:17:16\n   |\n17 |         \
    \    if max_arr[i][j] > max_arr[i][j + 1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpflrgg3jx.rs:17:32\n\
    \   |\n17 |             if max_arr[i][j] > max_arr[i][j + 1] {\n   |         \
    \                       ^^^^^^^^^^ slice "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > max_arr[i][j+1] {\n \
    \               max_arr[i][j] = max_arr[i][j+1];\n            }\n        }\n \
    \   }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[i] {\n                max_arr[i][j] = arr[i];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j+1] {\n                max_arr[i][j] = arr[j+1];\n            }\n   \
    \     }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[i+1] {\n                max_arr[i][j] = arr[i+1];\n            }\n   \
    \     }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[i+k] {\n                max_arr[i][j] = arr[i+k];\n            }\n   \
    \     }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[k] {\n                max_arr[i][j] = arr[k];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[k-1] {\n                max_arr[i][j] = arr[k-1];\n            }\n   \
    \     }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[k+1] {\n                max_arr[i][j] = arr[k+1];\n            }\n   \
    \     }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[k+k] {\n                max_arr[i][j] = arr[k+k];\n            }\n   \
    \     }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[k+k+1] {\n                max_arr[i][j] = arr[k+k+1];\n            }\n\
    \        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if\
    \ max_arr[i][j] > arr[k+k+k] {\n                max_arr[i][j] = arr[k+k+k];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        for j in 0..k {\n\
    \            if max_arr[i][j] > arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpruil6vku.rs:117:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    99  |     for i in 0..k {\n    |                   - unclosed delimiter\n100 |\
    \         for j in 0..k {\n    |                       - this delimiter might\
    \ not be properly closed...\n101 |             if max_arr[i][j] > arr\n102 | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n117 | }\n\
    \    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpruil6vku.rs:102:1\n\
    \    |\n101 |             if max_arr[i][j] > arr\n    |             -- this `if`\
    \ expression has a condition, but no block\n102 | }\n    | ^ expected `{`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpruil6vku.rs:11:36\n   |\n11 |  \
    \   let mut max_arr = vec![vec![]; k];\n   |                                 \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpruil6vku.rs:13:9\n   |\n13 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpruil6vku.rs:13:27\n   |\n13 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        if\
    \ max_arr\n            .iter()\n            .any(|&x| x > arr[max_i - max_k +\
    \ 1])\n        {\n            max_arr.push(arr[max_i - 1]);\n            max_k\
    \ -= 1;\n        }\n        max_i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqnci0vvr.rs:14:19\n   |\n\
    14 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqnci0vvr.rs:17:39\n   |\n17 |             .any(|&x| x >\
    \ arr[max_i - max_k + 1])\n   |                                       ^^^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n\
    \  --> /tmp/tmpqnci0vvr.rs:17:37\n   |\n17 |             .any(|&x| x > arr[max_i\
    \ - max_k + 1])\n   |                                     ^ no implementation\
    \ for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1is3r1c3.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp1is3r1c3.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        if\
    \ max_arr\n            .iter()\n            .any(|&x| x > arr[max_i])\n      \
    \  {\n            max_arr.push(arr[max_i]);\n            max_k -= 1;\n       \
    \ }\n        max_i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgak3kf39.rs:14:19\n   |\n\
    14 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        arr[i]\
    \ = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0v8in2k.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    for i in 0..k\
    \ {\n        max_arr.push(arr[i]);\n    }\n    for i in 0..k {\n        let mut\
    \ max_element = max_arr[i];\n        for j in (i + 1)..arr.len() {\n         \
    \   if arr[j] > max_element {\n                max_element = arr[j];\n       \
    \     }\n        }\n        max_arr.push(max_element);\n    }\n    max_arr\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmps5mruqjz.rs:13:22\n\
    \   |\n13 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmps5mruqjz.rs:16:31\n   |\n16 |  \
    \       let mut max_element = max_arr[i];\n   |                              \
    \ ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps5mruqjz.rs:17:27\n   |\n17 |         for j\
    \ in (i + 1)..arr.len() {\n   |                           ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmps5mruqjz.rs:18:16\n   |\n18 |             if arr[j] > max_element\
    \ {\n   |                ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmps5mruqjz.rs:19:31\n   |\n19 |                 max_element = arr[j];\n\
    \   |                               ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n        arr[i] = max_arr[i];\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqt7vsjak.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqt7vsjak.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqt7vsjak.rs:13:22\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpqt7vsjak.rs:16:9\n\
    \   |\n16 |         max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpqt7vsjak.rs:16:22\n   |\n16 |         max_arr[i] = max_arr[i].max();\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = note: required because of the requirements on\
    \ the impl of `In"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    let mut max_num = max_arr[i];\n        for j in (i + 1)..k {\n          \
    \  if max_arr[j] > max_num {\n                max_num = max_arr[j];\n        \
    \    }\n        }\n        max_arr[i] = max_num;\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp435hv4nh.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp435hv4nh.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp435hv4nh.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp435hv4nh.rs:16:27\n   |\n16 |  \
    \       let mut max_num = max_arr[i];\n   |                           ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp435hv4nh.rs:18:16\n   |\n18 |             if max_arr[j] > max_num {\n\
    \   |                ^^^^^^^^^^ "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() <= k {\n        return\
    \ arr;\n    }\n    let mut max_arr = vec![arr[0]];\n    let mut max_len = k;\n\
    \    for i in 1..arr.len() {\n        if arr[i] > max_arr[0] {\n            max_arr[0]\
    \ = arr[i];\n            max_len = i;\n        }\n    }\n    for i in 0..max_len\
    \ {\n        max_arr.push(arr[i]);\n    }\n    max_arr\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ogxrfjf.rs:11:31\n   |\n\
    11 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5ogxrfjf.rs:19:23\n   |\n15 |\
    \     let mut max_len = k;\n   |                       - expected due to this\
    \ value\n...\n19 |             max_len = i;\n   |                       ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp5ogxrfjf.rs:23:22\n   |\n23 |         max_arr.push(arr[i]);\n\
    \   |                      ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![-1000, 1000]];\n\
    \    let mut max_k = k;\n    let mut max_idx = 0;\n    let mut max_val = -1000\
    \ + 1000;\n    for i in 0..arr.len() {\n        if max_arr[0].0 > arr[i] {\n \
    \           max_arr[0] = vec![arr[i], -1000 + 1000];\n            max_k = 0;\n\
    \            max_idx = 0;\n            max_val = -1000 + 1000;\n        }\n  \
    \      if max_arr[0].0 > arr[i] {\n            max_arr[0] = vec![arr[i], -1000\
    \ + 1000];\n            max_k = 0;\n            max_idx = 0;\n            max_val\
    \ = -1000 + 1000;\n        }\n        if max_arr[0].0 > arr[i] {\n           \
    \ max_arr[0] = vec![arr[i], -1000 + 1000];\n            max_k = 0;\n         \
    \   max_idx = 0;\n            max_val = -1000 + 1000;\n        }\n        if max_arr[0].0\
    \ > arr[i] {\n            max_arr[0] = vec![arr[i], -1000 + 1000];\n         \
    \   max_k = 0;\n            max_idx = 0;\n            max_val = -1000 + 1000;\n\
    \        }\n        if max_arr[0].0 > arr[i] {\n            max_arr[0] = vec![arr[i],\
    \ -1000 + 1000];\n            max_k = 0;\n            max_idx = 0;\n         \
    \   max_val = -1000 + 1000;\n        }\n        if max_arr[0].0 > arr[i] {\n \
    \           max_arr[0] = vec![arr[i], -1000 + 1000];\n            max_k = 0;\n\
    \            max_idx = 0;\n            max_val = -1000 + 1000;\n        }\n  \
    \      if max_arr[0].0 > arr[i] {\n            max_arr[0] = vec![arr[i], -1000\
    \ + 1000];\n            max_k = 0;\n            max_idx = 0;\n            max_val\
    \ = -1000 + 1000;\n        }\n        if max_arr[0].0 > arr[i] {\n           \
    \ max_arr[0] = vec![arr[i], -1000 + 1000];\n            max_k = 0;\n         \
    \   max_idx = 0;\n            max_val = -1000 + 1000;\n        }\n        if max_arr[0].0\
    \ > arr[i] {\n            max_arr[0] = vec![arr[i], -1000 + 1000];\n         \
    \   max_k = 0;\n            max_idx = 0;\n            max_val = -1000 + 1000;\n\
    \        }\n        if max_arr[0].0 > arr[i] {\n            max_arr[0] = vec![arr[i],\
    \ -1000 + 1000];\n            max_k = 0;\n            max_idx = 0;\n         \
    \   max_val = -1000 + 1000;\n        }\n        if max_arr[0].0 > arr[i] {\n \
    \           max_arr[0] = vec![arr[i], -1000 + 1000];\n            max_k = 0;\n\
    \            max_idx = 0;\n            max_val = -1000 + 1000;\n        }\n  \
    \      if max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5799t1dw.rs:98:3\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n15\
    \ |     for i in 0..arr.len() {\n   |                           - this delimiter\
    \ might not be properly closed...\n...\n83 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n98 | }\n   |   ^\n\nerror: expected `{`,\
    \ found `}`\n  --> /tmp/tmp5799t1dw.rs:83:1\n   |\n82 |         if max_arr\n \
    \  |         -- this `if` expression has a condition, but no block\n83 | }\n \
    \  | ^ expected `{`\n\nerror[E0609]: no field `0` on type `Vec<{integer}>`\n \
    \ --> /tmp/tmp5799t1dw.rs:16:23\n   |\n16 |         if max_arr[0].0 > arr[i] {\n\
    \   |                       ^ unknown field\n\nerror[E0609]: no field `0` on type\
    \ `Vec<isize>`\n  --> /tmp/tmp5799t1dw.rs:22:23\n   |\n22 |         if max_arr[0].0\
    \ > arr[i] {\n   |                       ^ unknown field\n\nerror[E0609]: no field\
    \ `0` on type `Vec<isize>`\n  --> /tmp/tmp5799t1dw.rs:28:23\n   |\n28 |      \
    \   if max_arr[0].0 > arr[i] {\n   |                       ^ unknown field\n\n\
    error[E0609]: no field `0` on type `Vec<isize>`\n  --> /tmp/tmp5799t1dw.rs:34:23\n\
    \   |\n34 |         if max_arr[0].0 > arr[i] {\n   |                       ^ unknown\
    \ field\n\nerror[E0609]: no field `0` on type `Vec<isize>`\n  --> /tmp/tmp5799t1dw.rs:40:23\n\
    \   |\n40 |         if max_arr[0].0 > arr[i] {\n   |                       ^ unknown\
    \ field\n\nerror[E0609]: no field `0` on type `Vec<isize>`\n  --> /tmp/tmp5799t1dw.rs:46:23\n\
    \   |\n46 |         if max_arr[0].0 > arr[i] {\n   |                       ^ unknown\
    \ field\n\nerror[E0609]: no field `0` on type `Vec<isize>`\n  --> /tmp/tmp5799t1dw.rs:52:23\n\
    \   |\n52 |         if max_arr[0].0 > arr[i] {\n   |                       ^ unknown\
    \ field\n\nerror[E0609]: no field `0` on type `Vec<isize>`\n  --> /tmp/tmp5799t1dw.rs:58:23\n\
    \   |\n58 |         if max_arr[0].0 > arr[i] {\n   |                       ^ unknown\
    \ field\n\nerror[E0609]: no field `0` on type `Vec<isize>`\n  --> /tmp/tmp5799t1dw.rs:"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_element\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_element {\n        \
    \    max_element = arr[i];\n        }\n    }\n    for i in 0..k {\n        result[i]\
    \ = max_element;\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps2q_6u4x.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmps2q_6u4x.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_element {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmps2q_6u4x.rs:15:27\n   |\n15 |            \
    \ max_element = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmps2q_6u4x.rs:19:9\n   |\n19 |         result[i]\
    \ = max_element;\n   |         ^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_val = arr[0];\n    for i in 1..arr.len() {\n        if\
    \ arr[i] > max_val {\n            max_val = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_val;\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] - arr[i];\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] / max_idx;\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] * max_idx;\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i] / max_idx;\n    }\n    for i in 0..k {\n     \
    \   max_arr[i] = max_arr[i] * max_idx;\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ / max_idx;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] * max_idx;\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] / max_idx;\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] * max_idx;\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] / max_idx;\n    }\n    for i in 0..k {\n\
    \        max_arr[i] = max_arr[i] * max_idx;\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] / max_idx;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ * max_idx;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] / max_idx;\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] * max_idx;\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] / max_idx;\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] * max_idx\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp36sgpbvo.rs:109:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    92  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n93  |         max_arr[i] = max_arr[i] * max_idx\n94 \
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n109\
    \ | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp36sgpbvo.rs:11:31\n\
    \   |\n11 |     let mut max_arr = vec![0; k];\n   |                          \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![0; k.try_into().unwrap()];\n   |                        \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp36sgpbvo.rs:17:23\n\
    \   |\n12 |     let mut max_idx = k;\n   |                       - expected due\
    \ to this value\n...\n17 |             max_idx = i;\n   |                    \
    \   ^ expected `isize`, found `usize`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp36sgpbvo.rs:21:9\n   |\n21 |   \
    \      max_arr[i] = max_val;\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp36sgpbvo.rs:24:9\n   |\n24 |   \
    \      max_arr[i] = max_arr[i] - arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{int"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in i+1..k {\n            if max_arr[i] > max_arr[j] {\n           \
    \     max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] + 1000;\n    }\n    for i in 0..k {\n\
    \        max_arr[i] = max_arr[i] - 1000;\n    }\n    for i in 0..k {\n       \
    \ max_arr[i] = max_arr[i] / 1000;\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] * 1000;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ % 1000;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].to_i();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].to_string();\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].to_owned();\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i].to_string();\n    }\n  \
    \  for i in 0..k {\n        max_arr[i] = max_arr[i].to_owned();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].to_string();\n    }\n    for i\
    \ in 0..k {\n        max_arr[i] = max_arr[i].to_owned();\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i].to_string();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].to_owned();\n    }\n    for i in 0..k {\n\
    \        max_arr[i] = max_arr[i].to_string();\n    }\n    for i in 0..k {\n  \
    \      max_arr[i] = max_arr[i].to_owned();\n    }\n    for i in 0..k {\n     \
    \   max_arr[i] = max_arr[i].to_string();\n    }\n    for i in 0..k {\n       \
    \ max_arr[i] = max_arr[i].to_owned();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].to_string();\n    }\n    for i in 0..k {\n        max_arr[i] =\
    \ max_arr[i].to_owned();\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].to_string();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].to_owned();\n   \
    \ }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].to_string();\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i].to_owned();\n    }\n   \
    \ for i in 0..k {\n        max_arr[i] = max_arr[i].to_string();\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpm_kuab9v.rs:111:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    94  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n95  |         max_arr[i] = max_arr[i].to_string();\n\
    96  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    111 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm_kuab9v.rs:11:37\n\
    \   |\n11 |     let mut max_arr = vec![vec![0]; k];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpm_kuab9v.rs:13:9\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpm_kuab9v.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpm_kuab9v.rs:17:16\n   |\n17 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usi"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2hpgrlg.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(&arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfz7hj9xd.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfz7hj9xd.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(&arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfz7hj9xd.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = max_arr[i].max(&arr[i]);\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfz7hj9xd.rs:13:38\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(&arr[i]);\n   |              \
    \                        ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfz7hj9xd.rs:15:5\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n      \
    \  for j in i+1..k {\n            if max_arr[j] < max_arr[i] {\n             \
    \   max_arr[j] = max_arr[i];\n            }\n        }\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n    \
    \    for j in i+1..k {\n            if max_arr[j] < max_arr[i] {\n           \
    \     max_arr[j] = max_arr[i];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n\
    \        for j in i+1..k {\n            if max_arr[j] < max_arr[i] {\n       \
    \         max_arr[j] = max_arr[i];\n            }\n        }\n    }\n    for i\
    \ in 0..k {\n        for j in i+1..k {\n            if max_arr[j] < max_arr[i]\
    \ {\n                max_arr[j] = max_arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[j] < max_arr[i]\
    \ {\n                max_arr[j] = max_arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[j] < max_arr[i]\
    \ {\n                max_arr[j] = max_arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[j] < max_arr[i]\
    \ {\n                max_arr[j] = max_arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[j] < max_arr[i]\
    \ {\n                max_arr[j] = max_arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[j] < max_arr[i]\
    \ {\n                max_arr[j] = max_arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[j] < max_arr[i]\
    \ {\n                max_arr[j] = max_arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[j] < max_arr[i]\
    \ {\n                max_arr[j] = max_arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        for j in i+1..k {\n            if max_arr[j] < max_arr[i]\
    \ {\n                max_arr[j] = max_arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5jg8q6ex.rs:122:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    105 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n106 | \n107 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n122 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5jg8q6ex.rs:11:36\n   |\n11 |     let mut max_arr = vec![vec![];\
    \ k];\n   |                                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut max_arr = vec![vec![]; k.try_into().unwrap()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmp5jg8q6ex.rs:13:9\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp5jg8q6ex.rs:13:22\n   |\n13 |         max_arr[i]\
    \ = arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp5jg8q6ex.rs:17:16\n   |\n17 |         \
    \    if max_arr[j] < max_arr[i] {\n   |                ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpwxtu197l.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    let mut max_list\
    \ = vec![];\n    for i in 0..k {\n        if i == max_idx {\n            max_list.push(max);\n\
    \        } else {\n            max_list.push(arr[i]);\n        }\n    }\n    max_list\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3hd747wl.rs:21:17\n   |\n\
    21 |         if i == max_idx {\n   |                 ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if i == max_idx.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3hd747wl.rs:24:27\n  \
    \ |\n24 |             max_list.push(arr[i]);\n   |                           ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    for i in 1..k {\n\
    \        if max < arr[i] {\n            max = arr[i];\n        }\n    }\n    vec![max]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbt4j1lyl.rs:13:18\n\
    \   |\n13 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbt4j1lyl.rs:14:19\n   |\n14 |  \
    \           max = arr[i];\n   |                   ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_k = k;\n    let\
    \ mut max_i = arr.len() - 1;\n    while max_i < max_k {\n        if arr[max_i]\
    \ > arr[max_i + 1] {\n            max_arr.push(arr[max_i]);\n            max_i\
    \ += 1;\n        } else {\n            max_arr.push(arr[max_i + 1]);\n       \
    \     max_k -= 1;\n        }\n    }\n    max_arr.push(arr[max_k]);\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpskf5zimr.rs:17:19\n   |\n\
    17 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpskf5zimr.rs:26:18\n  \
    \ |\n26 |     max_arr.push(arr[max_k]);\n   |                  ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_val\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_val {\n            max_val\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        result[i] = max_val;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9v1n3ddb.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9v1n3ddb.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp9v1n3ddb.rs:15:23\n   |\n15 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp9v1n3ddb.rs:19:9\n   |\n19 |         result[i]\
    \ = max_val;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_k = k;\n    let mut max_idx = 0;\n    for i in 0..arr.len() {\n    \
    \    if max_arr[k - 1] < arr[i] {\n            max_arr[k - 1] = arr[i];\n    \
    \        max_k = k - 1;\n        }\n        if max_arr[k - 1] == arr[i] {\n  \
    \          max_arr[k - 1] = arr[i];\n            max_k = k - 1;\n        }\n \
    \   }\n    for i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n  \
    \  }\n    for i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n   \
    \ }\n    for i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n\
    \    for i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n \
    \   for i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n  \
    \  for i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n   \
    \ for i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for\
    \ i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i\
    \ in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in\
    \ 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k\
    \ {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n\
    \        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n \
    \       max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n  \
    \      max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n   \
    \     max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n    \
    \    max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n     \
    \   max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n      \
    \  max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n       \
    \ max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n        max_arr[i] =\
    \ max_arr[i].unwrap();\n    }\n    for i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    for i in 0..max_k {\n        max_arr[i] = max_arr[i].unwrap();\n \
    \   }\n    for i in 0..max_k {\n        max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0p7_abjv.rs:110:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    93  |     for i in 0..max_k {\n    |                       - this delimiter might\
    \ not be properly closed...\n94  |         max_arr\n95  | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n110 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0p7_abjv.rs:11:37\n   |\n11 |     let mut max_arr\
    \ = vec![vec![0]; k];\n   |                                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n11 |     let mut max_arr = vec![vec![0];\
    \ k.try_into().unwrap()];\n   |                                      ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp0p7_abjv.rs:15:12\n   |\n15 |         if max_arr[k - 1] < arr[i] {\n\
    \   |            ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp0p7_abjv.rs:16:13\n   |\n16 |         \
    \    max_arr[k - 1] = arr[i];\n   |             ^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0p7_abjv.rs:19:12\n   |\n19 |  \
    \       if max_arr[k - 1] == arr[i] {\n   |            ^^^^^^^^^^^^^^ slic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max = arr[0];\n    for i in 1..k {\n        if max\
    \ < arr[i] {\n            max = arr[i];\n        }\n    }\n    vec![max]\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpy6cem9uy.rs:16:18\n\
    \   |\n16 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpy6cem9uy.rs:17:19\n   |\n17 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![vec![0]; k];\n    for i\
    \ in 0..k {\n        result[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        for j in (i + 1)..k {\n            if arr[i] > arr[j] {\n           \
    \     result[i] = vec![arr[i]; 1];\n                result[j] = vec![arr[j]; 1];\n\
    \            }\n        }\n    }\n    for i in 0..k {\n        if result[i].len()\
    \ > result[i+1].len() {\n            result[i+1] = result[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if result[i].len() == 0 {\n            result[i]\
    \ = vec![0];\n        }\n    }\n    for i in 0..k {\n        if result[i].len()\
    \ > result[i+1].len() {\n            result[i+1] = result[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if result[i].len() == 0 {\n            result[i]\
    \ = vec![0];\n        }\n    }\n    for i in 0..k {\n        if result[i].len()\
    \ > result[i+1].len() {\n            result[i+1] = result[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if result[i].len() == 0 {\n            result[i]\
    \ = vec![0];\n        }\n    }\n    for i in 0..k {\n        if result[i].len()\
    \ > result[i+1].len() {\n            result[i+1] = result[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if result[i].len() == 0 {\n            result[i]\
    \ = vec![0];\n        }\n    }\n    for i in 0..k {\n        if result[i].len()\
    \ > result[i+1].len() {\n            result[i+1] = result[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if result[i].len() == 0 {\n            result[i]\
    \ = vec![0];\n        }\n    }\n    for i in 0..k {\n        if result[i].len()\
    \ > result[i+1].len() {\n            result[i+1] = result[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if result[i].len() == 0 {\n            result[i]\
    \ = vec![0];\n        }\n    }\n    for i in 0..k {\n        if result[i].len()\
    \ > result[i+1].len() {\n            result[i+1] = result[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if result[i].len() == 0 {\n            result[i]\
    \ = vec![0];\n        }\n    }\n    for i in 0..k {\n        if result[i].len()\
    \ > result[i+1].len() {\n            result[i+1] = result[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if result[i].len() == 0 {\n            result[i]\
    \ = vec![0];\n        }\n    }\n    for i in 0..k {\n        if result[i].len()\
    \ > result[i+1].len() {\n            result[i+1] = result[i];\n        }\n   \
    \ }\n    for i in 0..k {\n        if result[i].\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp2dmrzf2y.rs:125:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    108 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n109 |         if result[i].\n110 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n125 | }\n    |   ^\n\nerror:\
    \ unexpected token: `}`\n   --> /tmp/tmp2dmrzf2y.rs:110:1\n    |\n110 | }\n  \
    \  | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp2dmrzf2y.rs:110:1\n \
    \   |\n109 |         if result[i].\n    |         -- this `if` expression has\
    \ a condition, but no block\n110 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2dmrzf2y.rs:11:36\n   |\n11 |     let mut result = vec![vec![0];\
    \ k];\n   |                                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut result = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp2dmrzf2y.rs:13:9\n\
    \   |\n13 |         result[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2dmrzf2y.rs:13:26\n\
    \   |\n13 |         result[i] = vec![arr[i]; 1];\n   |                       \
    \   ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   =\
    \ help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the req"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr;\n  \
    \  }\n    let mut max_arr = vec![vec![0]; k];\n    let mut max_k = k;\n    let\
    \ mut max_idx = 0;\n    let mut max_val = arr[0];\n    for i in 1..arr.len() {\n\
    \        if arr[i] > max_val {\n            max_val = arr[i];\n            max_idx\
    \ = i;\n        }\n        if max_k == i {\n            max_arr[i] = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if max_arr[i].len() > max_k {\n\
    \            max_k = max_arr[i].len();\n        }\n    }\n    for i in 0..k {\n\
    \        if max_arr[i].len() < max_k {\n            max_arr[i] = vec![0; max_k\
    \ - max_arr[i].len()];\n        }\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3vguutgo.rs:11:21\n   |\n\
    11 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3vguutgo.rs:14:37\n   |\n14 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3vguutgo.rs:23:21\n   |\n23 |         if max_k\
    \ == i {\n   |                     ^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n23 |         if max_k == i.try_into().unwrap() {\n   |          \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3vguutgo.rs:24:26\n\
    \   |\n24 |             max_arr[i] = arr[i];\n   |             ----------   ^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\n   = note: expected struct `Vec<{integer}>`\n\
    \                found type `isize`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp3vguutgo.rs:28:12\n   |\n28 |  \
    \       if max_arr[i].len() > max_k {\n   |            ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp3vg"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    for i in 0..arr.len() {\n        if arr[i] > max_arr[k] {\n      \
    \      max_arr[k] = arr[i];\n            max_idx = k;\n        }\n        if max_idx\
    \ > k {\n            break;\n        }\n        max_idx -= 1;\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn_knchji.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpn_knchji.rs:14:21\n\
    \   |\n14 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpn_knchji.rs:15:13\n\
    \   |\n15 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_element\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_element {\n        \
    \    max_element = arr[i];\n        }\n    }\n    for i in 0..k {\n        result[i]\
    \ = max_element;\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps2q_6u4x.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmps2q_6u4x.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_element {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmps2q_6u4x.rs:15:27\n   |\n15 |            \
    \ max_element = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmps2q_6u4x.rs:19:9\n   |\n19 |         result[i]\
    \ = max_element;\n   |         ^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_value = arr[0];\n    for i in 1..k {\n        if arr[i]\
    \ > max_value {\n            max_value = arr[i];\n            max_idx = i;\n \
    \       }\n    }\n    for i in 0..k {\n        if arr[i] > max_value {\n     \
    \       max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_value {\n            max_arr[i] = arr[i];\n        }\n    }\n \
    \   for i in 0..k {\n        if arr[i] > max_value {\n            max_arr[i] =\
    \ arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_value\
    \ {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_value {\n            max_arr[i] = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_value {\n            max_arr[i]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_value\
    \ {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_value {\n            max_arr[i] = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_value {\n            max_arr[i]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_value\
    \ {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_value {\n            max_arr[i] = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_value {\n            max_arr[i]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_value\
    \ {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_value {\n            max_arr[i] = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_value {\n            max_arr[i]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_value\
    \ {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..k {\n\
    \        if arr[i] > max_value {\n            max_arr[i] = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_value {\n            max_arr[i]\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_value\
    \ {\n            max_arr[i] = arr[i];\n        }\n    }\n    for i in 0..\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpjzm8wv1f.rs:116:1\n    |\n\
    116 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjzm8wv1f.rs:11:31\n\
    \   |\n11 |     let mut max_arr = vec![0; k];\n   |                          \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![0; k.try_into().unwrap()];\n   |                        \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpjzm8wv1f.rs:15:12\n   |\n15 |         if arr[i] >\
    \ max_value {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpjzm8wv1f.rs:16:25\n   |\n16 |             max_value = arr[i];\n\
    \   |                         ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpjzm8wv1f.rs:21:12\n   |\n21 |         if arr[i] > max_value {\n\
    \   |            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpjzm8wv1f.rs:22:13\n\
    \   |\n22 |             max_arr[i] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ i"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        arr[i]\
    \ = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0v8in2k.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        arr[i]\
    \ = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0v8in2k.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    for &i in arr {\n        if i >= max_arr[k] {\n            max_arr[k]\
    \ = i;\n            max_idx -= 1;\n        }\n    }\n    max_arr.sort_unstable();\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpby4ay0r6.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpby4ay0r6.rs:13:9\n   |\n13 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpby4ay0r6.rs:14:17\n   |\n14 |  \
    \       if i >= max_arr[k] {\n   |                 ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpby4ay0r6.rs:15:13\n   |\n15 |  \
    \           max_arr[k] = i;\n   |             ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    for &i in arr {\n        if i >= max_arr[k] {\n            max_arr[k]\
    \ = i;\n            max_idx -= 1;\n        }\n    }\n    max_arr.sort_unstable();\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpby4ay0r6.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpby4ay0r6.rs:13:9\n   |\n13 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpby4ay0r6.rs:14:17\n   |\n14 |  \
    \       if i >= max_arr[k] {\n   |                 ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpby4ay0r6.rs:15:13\n   |\n15 |  \
    \           max_arr[k] = i;\n   |             ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![-1000, 1000]];\n\
    \    let mut max_k = k;\n    let mut max_i = 1;\n    let mut max_j = arr.len();\n\
    \    while max_i < max_j {\n        if max_arr[0].0 > arr[max_i] {\n         \
    \   max_arr[0] = arr[max_i];\n            max_k -= 1;\n        }\n        if max_arr[1].0\
    \ > arr[max_j] {\n            max_arr[1] = arr[max_j];\n            max_k -= 1;\n\
    \        }\n        if max_arr[0].0 > max_arr[1].0 {\n            max_arr[0] =\
    \ max_arr[1];\n            max_k -= 1;\n        }\n        max_i += 1;\n     \
    \   max_j -= 1;\n    }\n    max_arr.sort_unstable();\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `Vec<{integer}>`\n  --> /tmp/tmpq8s5ukvc.rs:16:23\n\
    \   |\n16 |         if max_arr[0].0 > arr[max_i] {\n   |                     \
    \  ^ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq8s5ukvc.rs:17:26\n\
    \   |\n17 |             max_arr[0] = arr[max_i];\n   |             ----------\
    \   ^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |             |\n   |\
    \             expected due to the type of this binding\n   |\n   = note: expected\
    \ struct `Vec<{integer}>`\n                found type `isize`\n\nerror[E0609]:\
    \ no field `0` on type `Vec<{integer}>`\n  --> /tmp/tmpq8s5ukvc.rs:20:23\n   |\n\
    20 |         if max_arr[1].0 > arr[max_j] {\n   |                       ^ unknown\
    \ field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq8s5ukvc.rs:21:26\n \
    \  |\n21 |             max_arr[1] = arr[max_j];\n   |             ---------- \
    \  ^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |             |\n   | \
    \            expected due to the type of this binding\n   |\n   = note: expected\
    \ struct `Vec<{integer}>`\n                found type `isize`\n\nerror[E0609]:\
    \ no field `0` on type `Vec<{integer}>`\n  --> /tmp/tmpq8s5ukvc.rs:24:23\n   |\n\
    24 |         if max_arr[0].0 > max_arr[1].0 {\n   |                       ^ unknown\
    \ field\n\nerror[E0609]: no field `0` on type `Vec<{integer}>`\n  --> /tmp/tmpq8s5ukvc.rs:24:38\n\
    \   |\n24 |         if max_arr[0].0 > max_arr[1].0 {\n   |                   \
    \                   ^ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq8s5ukvc.rs:32:5\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n32 |     max_arr\n   |     ^^^^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<Vec<{integer}>>`\n\nerror: aborting due to 7 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![vec![0]; k];\n    let mut\
    \ max_value = arr[0];\n    for i in 1..k {\n        if arr[i] > max_value {\n\
    \            max_value = arr[i];\n        }\n    }\n    for i in 0..k {\n    \
    \    result[i] = max_value;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn8qkb75m.rs:11:36\n   |\n\
    11 |     let mut result = vec![vec![0]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut result = vec![vec![0]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpn8qkb75m.rs:14:12\n   |\n14 |         if\
    \ arr[i] > max_value {\n   |            ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpn8qkb75m.rs:15:25\n   |\n15 |            \
    \ max_value = arr[i];\n   |                         ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpn8qkb75m.rs:19:9\n   |\n19 |   \
    \      result[i] = max_value;\n   |         ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn8qkb75m.rs:21:5\n   |\n10 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n..."
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpwxtu197l.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    for i in 0..k\
    \ {\n        max_arr.push(arr[i]);\n    }\n    for i in 0..k {\n        let mut\
    \ max_element = max_arr[i];\n        for j in 0..k {\n            if arr[j] >\
    \ max_element {\n                max_element = arr[j];\n            }\n      \
    \  }\n        max_arr.push(max_element);\n    }\n    max_arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp0dp9d0x9.rs:13:22\n\
    \   |\n13 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp0dp9d0x9.rs:16:31\n   |\n16 |  \
    \       let mut max_element = max_arr[i];\n   |                              \
    \ ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp0dp9d0x9.rs:18:16\n\
    \   |\n18 |             if arr[j] > max_element {\n   |                ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp0dp9d0x9.rs:19:31\n\
    \   |\n19 |                 max_element = arr[j];\n   |                      \
    \         ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max = arr[0];\n    let mut max_idx =\
    \ 1;\n    for i in 1..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    let mut res = vec![max];\n\
    \    for i in 1..k {\n        res.push(arr[max_idx]);\n        max_idx += 1;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmptwetk51w.rs:21:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![-1000, 1000]];\n\
    \    for i in 0..k {\n        max_arr[i] = vec![arr[i], -1000];\n    }\n    for\
    \ i in 0..k {\n        max_arr[i].sort_unstable();\n    }\n    for i in 0..k {\n\
    \        max_arr[i].iter().cloned().collect();\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpp56aa0eu.rs:13:9\n   |\n13 |         max_arr[i] = vec![arr[i],\
    \ -1000];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpp56aa0eu.rs:13:27\n   |\n13 |  \
    \       max_arr[i] = vec![arr[i], -1000];\n   |                           ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpp56aa0eu.rs:16:9\n\
    \   |\n16 |         max_arr[i].sort_unstable();\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpp56aa0eu.rs:19:9\n   |\n19 |         max_arr[i].iter().cloned().collect();\n\
    \   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp56aa0eu.rs:21:5\n\
    \   |\n10 | fn maximum(arr: Vec<is"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    let mut max_so_far\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_so_far {\n         \
    \   max_so_far = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i]\
    \ > max_so_far {\n            result.push(max_so_far);\n            max_so_far\
    \ = arr[i];\n        } else {\n            result.push(arr[i]);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfjgvz3a2.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_so_far {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfjgvz3a2.rs:15:26\n   |\n15 |            \
    \ max_so_far = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfjgvz3a2.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_so_far {\n   |            ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpfjgvz3a2.rs:21:26\n   |\n21 |             max_so_far = arr[i];\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpfjgvz3a2.rs:23:25\n   |\n23 |             result.push(arr[i]);\n\
    \   |                         ^^^^^^ slice indices are of ty"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    let mut max_i = i;\n        for j in 0..k {\n            if max_arr[j] <\
    \ max_arr[j] && arr[j] > max_arr[j] {\n                max_i = j;\n          \
    \  }\n        }\n        max_arr[i] = max_arr[i];\n        max_arr[i] = arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i];\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzqskkyoz.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzqskkyoz.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzqskkyoz.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpzqskkyoz.rs:18:16\n   |\n18 |  \
    \           if max_arr[j] < max_arr[j] && arr[j] > max_arr[j] {\n   |        \
    \        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpzqskkyoz.rs:18:29\n   |\n18 |         \
    \    if max_arr[j] < max_arr[j] && arr[j] > max"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if max_num < arr[i] {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if max_num < arr[i]\
    \ {\n            max_arr.push(max_num);\n        }\n    }\n    for i in 0..k {\n\
    \        if max_num < arr[i] {\n            max_arr.push(arr[i]);\n        }\n\
    \    }\n    for i in 0..k {\n        if max_num < arr[i] {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_num < arr[i] {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ max_num < arr[i] {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if max_num < arr[i] {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_num < arr[i] {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ max_num < arr[i] {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if max_num < arr[i] {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_num < arr[i] {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ max_num < arr[i] {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if max_num < arr[i] {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_num < arr[i] {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ max_num < arr[i] {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if max_num < arr[i] {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_num < arr[i] {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ max_num < arr[i] {\n            max_arr.push(arr[i]);\n        }\n    }\n  \
    \  for i in 0..k {\n        if max_num < arr[i] {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    for i in 0..k {\n        if max_num < arr[i] {\n      \
    \      max_arr.push(arr[i]);\n        }\n    }\n    for i in 0..k {\n        if\
    \ max_num < arr[i] {\n            max_\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmppnbik4gn.rs:131:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    113 |     for i in 0..k {\n    |                   - unclosed delimiter\n114 |\
    \         if max_num < arr[i] {\n    |                             - this delimiter\
    \ might not be properly closed...\n115 |             max_\n116 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n131 | }\n    |   ^\n\n\
    error[E0425]: cannot find value `max_` in this scope\n   --> /tmp/tmppnbik4gn.rs:115:13\n\
    \    |\n115 |             max_\n    |             ^^^^ not found in this scope\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmppnbik4gn.rs:14:22\n\
    \   |\n14 |         if max_num < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmppnbik4gn.rs:15:23\n   |\n15 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmppnbik4gn.rs:19:22\n   |\n19 |         if max_num\
    \ < arr[i] {\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on th"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_so_far\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_so_far {\n         \
    \   max_so_far = arr[i];\n        }\n    }\n    for i in 0..k {\n        result[i]\
    \ = max_so_far;\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6n1r382d.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6n1r382d.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_so_far {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6n1r382d.rs:15:26\n   |\n15 |            \
    \ max_so_far = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp6n1r382d.rs:19:9\n   |\n19 |         result[i]\
    \ = max_so_far;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if max_num < arr[i] {\n            max_num\
    \ = arr[i];\n        }\n    }\n    max_arr.push(max_num);\n    for i in 1..k {\n\
    \        if arr[i] > max_num {\n            max_arr.push(arr[i]);\n        }\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcwep95sm.rs:14:22\n\
    \   |\n14 |         if max_num < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpcwep95sm.rs:15:23\n   |\n15 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpcwep95sm.rs:20:12\n   |\n20 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpcwep95sm.rs:21:26\n   |\n21 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k {\n        return vec![];\n\
    \    }\n    let mut max_arr = vec![];\n    let mut max_num = arr[0];\n    for\
    \ i in 1..k {\n        if arr[i] > max_num {\n            max_num = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(max_num);\n            max_num = arr[i];\n        }\n    }\n\
    \    max_arr.push(max_num);\n    return max_arr;\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp061wb10i.rs:11:20\n   |\n\
    11 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp061wb10i.rs:17:12\n   |\n17 |  \
    \       if arr[i] > max_num {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp061wb10i.rs:18:23\n   |\n18 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp061wb10i.rs:22:12\n   |\n22 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp061wb10i.rs:24:23\n   |\n24 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `Slic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_num = arr[0];\n    let mut max_idx = 1;\n  \
    \  let mut max_idx2 = 1;\n    for i in 1..arr.len() {\n        if arr[i] > max_num\
    \ {\n            max_num = arr[i];\n            max_idx = i;\n        }\n    \
    \    if arr[i] > max_num {\n            max_num2 = arr[i];\n            max_idx2\
    \ = i;\n        }\n    }\n    let mut max_list = vec![];\n    for i in 0..k {\n\
    \        if max_idx == max_idx2 {\n            max_list.push(max_num);\n     \
    \       max_idx += 1;\n        } else {\n            max_list.push(max_num2);\n\
    \            max_idx2 += 1;\n        }\n    }\n    max_list\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_num2` in this scope\n  --> /tmp/tmpzzdwv47d.rs:23:13\n\
    \   |\n23 |             max_num2 = arr[i];\n   |             ^^^^^^^^ help: a\
    \ local variable with a similar name exists: `max_num`\n\nerror[E0425]: cannot\
    \ find value `max_num2` in this scope\n  --> /tmp/tmpzzdwv47d.rs:33:27\n   |\n\
    33 |             max_list.push(max_num2);\n   |                           ^^^^^^^^\
    \ help: a local variable with a similar name exists: `max_num`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] {\n            max_arr[1] = arr[i];\n           \
    \ max_k = 1;\n        }\n        if arr[i] > max_arr[1] {\n            max_arr[2]\
    \ = arr[i];\n            max_k = 2;\n        }\n        if arr[i] > max_arr[2]\
    \ {\n            max_arr[3] = arr[i];\n            max_k = 3;\n        }\n   \
    \     if arr[i] > max_arr[3] {\n            max_arr[4] = arr[i];\n           \
    \ max_k = 4;\n        }\n        if arr[i] > max_arr[4] {\n            max_arr[5]\
    \ = arr[i];\n            max_k = 5;\n        }\n        if arr[i] > max_arr[5]\
    \ {\n            max_arr[6] = arr[i];\n            max_k = 6;\n        }\n   \
    \     if arr[i] > max_arr[6] {\n            max_arr[7] = arr[i];\n           \
    \ max_k = 7;\n        }\n        if arr[i] > max_arr[7] {\n            max_arr[8]\
    \ = arr[i];\n            max_k = 8;\n        }\n        if arr[i] > max_arr[8]\
    \ {\n            max_arr[9] = arr[i];\n            max_k = 9;\n        }\n   \
    \     if arr[i] > max_arr[9] {\n            max_arr[10] = arr[i];\n          \
    \  max_k = 10;\n        }\n        if arr[i] > max_arr[10] {\n            max_arr[11]\
    \ = arr[i];\n            max_k = 11;\n        }\n        if arr[i] > max_arr[11]\
    \ {\n            max_arr[12] = arr[i];\n            max_k = 12;\n        }\n \
    \       if arr[i] > max_arr[12] {\n            max_arr[13] = arr[i];\n       \
    \     max_k = 13;\n        }\n        if arr[i] > max_arr[13] {\n            max_arr[14]\
    \ = arr[i];\n            max_k = 14;\n        }\n        if arr[i] > max_arr[14]\
    \ {\n            max_arr[15] = arr[i];\n            max_k = 15;\n        }\n \
    \       if arr[i] > max_arr[15] {\n            max_arr[16] = arr[i];\n       \
    \     max_k = 16;\n        }\n        if arr[i] > max_arr[16] {\n            max_arr[17]\
    \ = arr[i];\n            max_k = 17;\n        }\n        if arr[i] > max_arr[17]\
    \ {\n            max_arr[18] = arr[i];\n            max_k = 18;\n        }\n \
    \       if arr[i] > max_arr[18] {\n            max_arr[19] = arr[i];\n       \
    \     max_k = 19;\n        }\n        if arr[i] > max_arr[19] {\n            max_arr[20]\
    \ = arr[i];\n            max_k = 20;\n        }\n        if arr[i] > max_arr[20]\
    \ {\n            max_arr[21] = arr[i];\n            max_k = 21;\n        }\n \
    \       if \n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpu8qw51e2.rs:119:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    14  |     while i < arr.len() {\n    |                         - this delimiter\
    \ might not be properly closed...\n...\n104 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n119 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpu8qw51e2.rs:104:1\n    |\n104 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu8qw51e2.rs:10:42\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------\
    \                               ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![vec![0]; k];\n    for i\
    \ in 0..k {\n        result[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        let mut max_val = arr[i];\n        for j in (i + 1)..k {\n          \
    \  if result[j].iter().max().unwrap() > max_val {\n                max_val = result[j].iter().max().unwrap();\n\
    \            }\n        }\n        result[i] = vec![max_val; 1];\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbgttuoed.rs:11:36\n   |\n\
    11 |     let mut result = vec![vec![0]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut result = vec![vec![0]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbgttuoed.rs:13:9\n   |\n13 |   \
    \      result[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbgttuoed.rs:13:26\n   |\n13 |  \
    \       result[i] = vec![arr[i]; 1];\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbgttuoed.rs:16:27\n   |\n16 |  \
    \       let mut max_val = arr[i];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbgttuoed.rs:18:16\n   |\n18 |  \
    \           if result[j].iter().max().unwrap() > max_val {\n   |             \
    \   ^^^^^^^^^ "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] > max_arr[0]\
    \ {\n            max_arr[0] = arr[i];\n            max_k = 0;\n        }\n   \
    \     if arr[i] > max_arr[0] && arr[i] > max_arr[1] {\n            max_arr[1]\
    \ = arr[i];\n            max_k = 1;\n        }\n        if arr[i] > max_arr[1]\
    \ && arr[i] > max_arr[2] {\n            max_arr[2] = arr[i];\n            max_k\
    \ = 2;\n        }\n        if arr[i] > max_arr[2] && arr[i] > max_arr[3] {\n \
    \           max_arr[3] = arr[i];\n            max_k = 3;\n        }\n        if\
    \ arr[i] > max_arr[3] && arr[i] > max_arr[4] {\n            max_arr[4] = arr[i];\n\
    \            max_k = 4;\n        }\n        if arr[i] > max_arr[4] && arr[i] >\
    \ max_arr[5] {\n            max_arr[5] = arr[i];\n            max_k = 5;\n   \
    \     }\n        if arr[i] > max_arr[5] && arr[i] > max_arr[6] {\n           \
    \ max_arr[6] = arr[i];\n            max_k = 6;\n        }\n        if arr[i] >\
    \ max_arr[6] && arr[i] > max_arr[7] {\n            max_arr[7] = arr[i];\n    \
    \        max_k = 7;\n        }\n        if arr[i] > max_arr[7] && arr[i] > max_arr[8]\
    \ {\n            max_arr[8] = arr[i];\n            max_k = 8;\n        }\n   \
    \     if arr[i] > max_arr[8] && arr[i] > max_arr[9] {\n            max_arr[9]\
    \ = arr[i];\n            max_k = 9;\n        }\n        if arr[i] > max_arr[9]\
    \ && arr[i] > max_arr[10] {\n            max_arr[10] = arr[i];\n            max_k\
    \ = 10;\n        }\n        if arr[i] > max_arr[10] && arr[i] > max_arr[11] {\n\
    \            max_arr[11] = arr[i];\n            max_k = 11;\n        }\n     \
    \   if arr[i] > max_arr[11] && arr[i] > max_arr[12] {\n            max_arr[12]\
    \ = arr[i];\n            max_k = 12;\n        }\n        if arr[i] > max_arr[12]\
    \ && arr[i] > max_arr[13] {\n            max_arr[13] = arr[i];\n            max_k\
    \ = 13;\n        }\n        if arr[i] > max_arr[13] && arr[i] > max_arr[14] {\n\
    \            max_arr[14] = arr[i];\n            max_k = 14;\n        }\n     \
    \   if arr[i] > max_arr[14] && arr[i] > max_arr[15] {\n            max_arr[15]\
    \ = arr[i];\n            max_k = 15;\n        }\n        if arr[i] > max_arr[15]\
    \ && arr[i] > max_arr[16] {\n            max_arr[16] = arr[i];\n            max_k\
    \ = 16;\n        }\n        if arr[i] \n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmkxuesn8.rs:99:3\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n14\
    \ |     while i < arr.len() {\n   |                         - this delimiter might\
    \ not be properly closed...\n...\n84 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n99 | }\n   |   ^\n\nerror: expected `{`, found\
    \ `}`\n  --> /tmp/tmpmkxuesn8.rs:84:1\n   |\n83 |         if arr[i] \n   |   \
    \      -- this `if` expression has a condition, but no block\n84 | }\n   | ^ expected\
    \ `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmkxuesn8.rs:10:42\n   |\n\
    10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------  \
    \                             ^^^^^^^^^^ expected struct `Vec`, found `()`\n \
    \  |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_value\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_value {\n          \
    \  max_value = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i]\
    \ > max_value {\n            result[i] = max_value;\n        } else {\n      \
    \      result[i] = arr[i];\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkwnx7a1k.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkwnx7a1k.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_value {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkwnx7a1k.rs:15:25\n   |\n15 |            \
    \ max_value = arr[i];\n   |                         ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkwnx7a1k.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_value {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpkwnx7a1k.rs:20:13\n   |\n20 |             result[i] =\
    \ max_value;\n   |             ^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    let mut max_i = i;\n        for j in 0..k {\n            if max_arr[j] >\
    \ max_arr[j+1] {\n                max_i = j;\n            }\n        }\n     \
    \   max_arr[i] = max_arr[i];\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[max_i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..\n}\n\nfn main() {\n    let candidate = maximum;\n   \
    \ assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpa931kvnq.rs:80:1\n   |\n\
    80 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa931kvnq.rs:11:37\n\
    \   |\n11 |     let mut max_arr = vec![vec![0]; k];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpa931kvnq.rs:13:9\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpa931kvnq.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpa931kvnq.rs:18:16\n   |\n18 |  \
    \           if max_arr[j] > max_arr[j+1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpa931kvnq"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in 0..k {\n            if max_arr[j] < max_arr[i] {\n             \
    \   max_arr[j] = max_arr[i];\n            }\n        }\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr8pu3lr3.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpr8pu3lr3.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpr8pu3lr3.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpr8pu3lr3.rs:17:16\n   |\n17 |  \
    \           if max_arr[j] < max_arr[i] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpr8pu3lr3.rs:17:29\n   |\n17 |             if max_arr[j] < max_arr[i]\
    \ {\n   |                             ^^^"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(&arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfz7hj9xd.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfz7hj9xd.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(&arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfz7hj9xd.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = max_arr[i].max(&arr[i]);\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfz7hj9xd.rs:13:38\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(&arr[i]);\n   |              \
    \                        ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfz7hj9xd.rs:15:5\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > max_arr[i][j + 1] {\n\
    \                max_arr[i][j] = max_arr[i][j + 1];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[i] {\n                max_arr[i][j] = arr[i];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0.\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjn791zlp.rs:123:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    106 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n107 |         for j in 0.\n108 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n123 | }\n    |   ^\n\nerror:\
    \ expected `{`, found `}`\n   --> /tmp/tmpjn791zlp.rs:108:1\n    |\n108 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn791zlp.rs:11:36\n\
    \   |\n11 |     let mut max_arr = vec![vec![]; k];\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |        \
    \                             ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpjn791zlp.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpjn791zlp.rs:13:27\n   |\n13 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpjn791zlp.rs:17:16\n   |\n17 |         \
    \    if max_arr[i][j] > max_arr[i"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_value\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_value {\n          \
    \  max_value = arr[i];\n        }\n    }\n    for i in 0..k {\n        result[i]\
    \ = max_value;\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp67vlqkrf.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp67vlqkrf.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_value {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp67vlqkrf.rs:15:25\n   |\n15 |            \
    \ max_value = arr[i];\n   |                         ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp67vlqkrf.rs:19:9\n   |\n19 |         result[i]\
    \ = max_value;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2hpgrlg.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![-1000, 1000]];\n\
    \    let mut max_k = k;\n    let mut i = 0;\n    while i < arr.len() {\n     \
    \   if arr[i] > max_arr[0][0] || (arr[i] > max_arr[0][1] &&\n            arr[i]\
    \ > max_arr[1][0]) {\n            max_arr[0] = vec![arr[i], -1000, 1000];\n  \
    \          max_k = 1;\n        } else if arr[i] > max_arr[1][0] || (arr[i] > max_arr[1][1]\
    \ &&\n            arr[i] > max_arr[2][0]) {\n            max_arr[1] = vec![arr[i],\
    \ -1000, 1000];\n            max_k = 2;\n        } else {\n            max_arr[2]\
    \ = vec![arr[i], -1000, 1000];\n            max_k = 3;\n        }\n        i +=\
    \ 1;\n    }\n    max_arr\n        .iter()\n        .take_while(|&x| x.len() <=\
    \ max_k)\n        .collect()\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplmdaci2n.rs:31:37\n   |\n\
    31 |         .take_while(|&x| x.len() <= max_k)\n   |                        \
    \             ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    31 |         .take_while(|&x| x.len() <= max_k.try_into().unwrap())\n   |    \
    \                                      ++++++++++++++++++++\n\nerror[E0277]: a\
    \ value of type `Vec<isize>` cannot be built from an iterator over elements of\
    \ type `&Vec<isize>`\n    --> /tmp/tmplmdaci2n.rs:32:10\n     |\n32   |      \
    \   .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot be built\
    \ from `std::iter::Iterator<Item=&Vec<isize>>`\n     |\n     = help: the trait\
    \ `FromIterator<&Vec<isize>>` is not implemented for `Vec<isize>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    for i in 0..arr.len() {\n        if arr[i] > max_arr[k] {\n      \
    \      max_arr[k] = arr[i];\n            max_idx = k;\n        }\n        if max_idx\
    \ < k {\n            max_arr[k] = 0;\n        }\n    }\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6fapw_zt.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp6fapw_zt.rs:14:21\n\
    \   |\n14 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp6fapw_zt.rs:15:13\n\
    \   |\n15 |             max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp6fapw_zt.rs:19:13\n\
    \   |\n19 |             max_arr[k] = 0;\n   |             ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_num = arr[0];\n    let mut max_idx\
    \ = 1;\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    vec![max_num; max_idx\
    \ + 1]\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzt0dz2c_.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzt0dz2c_.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzt0dz2c_.rs:19:19\n\
    \   |\n19 |     vec![max_num; max_idx + 1]\n   |                   ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n19 |     vec![max_num;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                   +           +++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_len = k;\n    let mut max_idx = k;\n    for ele in arr {\n        if\
    \ ele > max_arr[k-1].last() {\n            max_arr[k-1].push(ele);\n         \
    \   max_len -= 1;\n        } else {\n            max_arr[k-1].last() = ele;\n\
    \        }\n        if max_len == 0 {\n            break;\n        }\n       \
    \ if max_len == k {\n            max_idx = k;\n        }\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx25py237.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpx25py237.rs:15:18\n   |\n15 |  \
    \       if ele > max_arr[k-1].last() {\n   |                  ^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpx25py237.rs:16:13\n   |\n16 |             max_arr[k-1].push(ele);\n\
    \   |             ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0070]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpx25py237.rs:19:33\n   |\n19 |             max_arr[k-1].last() =\
    \ ele;\n   |             ------------------- ^\n   |             |\n   |     \
    \        cannot assign to this expression\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpx25py237.rs:19:13\n   |\n19 |  \
    \           max_arr[k-1].last() = ele;\n   |             ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   ="
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_num = arr[0];\n    let mut max_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ > max_num {\n            max_num = arr[i];\n            max_pos = i;\n     \
    \   }\n    }\n    let mut max_arr = vec![max_num];\n    for i in 0..k {\n    \
    \    max_arr.push(arr[i]);\n    }\n    for i in 0..max_pos {\n        max_arr.push(arr[i]);\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpydc52ki3.rs:22:22\n\
    \   |\n22 |         max_arr.push(arr[i]);\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    let mut max_i = i;\n        for j in i..k {\n            if max_arr[j] >\
    \ max_arr[j+1] {\n                max_i = j;\n            }\n        }\n     \
    \   max_arr[i] = max_arr[i];\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[max_i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i] - max_arr[i];\n\
    \    }\n    for i in 0..\n}\n\nfn main() {\n    let candidate = maximum;\n   \
    \ assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmprca47z3s.rs:80:1\n   |\n\
    80 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprca47z3s.rs:11:37\n\
    \   |\n11 |     let mut max_arr = vec![vec![0]; k];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmprca47z3s.rs:13:9\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprca47z3s.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprca47z3s.rs:18:16\n   |\n18 |  \
    \           if max_arr[j] > max_arr[j+1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmprca47z3s"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in i+1..k {\n            if max_arr[i] > max_arr[j] {\n           \
    \     max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        arr[i] = max_arr[i];\n    }\n    return arr;\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ytr4p34.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4ytr4p34.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4ytr4p34.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4ytr4p34.rs:17:16\n   |\n17 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp4ytr4p34.rs:17:29\n   |\n17 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_val = arr[0];\n    for &x in arr {\n        if x > max_val\
    \ {\n            max_val = x;\n            max_idx = k;\n        }\n        if\
    \ x == max_val {\n            max_idx += 1;\n        }\n        max_arr[k - max_idx]\
    \ = x;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n \
    \   assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg53synub.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg53synub.rs:14:9\n   |\n14 | \
    \    for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpg53synub.rs:22:9\n   |\n22 |   \
    \      max_arr[k - max_idx] = x;\n   |         ^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in 0..k {\n            if max_arr[j] > max_arr[j+1] {\n           \
    \     max_arr[j] = max_arr[j+1];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphk4sq9k_.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphk4sq9k_.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphk4sq9k_.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphk4sq9k_.rs:17:16\n   |\n17 |  \
    \           if max_arr[j] > max_arr[j+1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmphk4sq9k_.rs:17:29\n   |\n17 |             if max_arr[j] > max_arr[j+1]\
    \ {\n   |                            "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_val = arr[0];\n    for i in 1..arr.len() {\n        if\
    \ arr[i] > max_val {\n            max_val = arr[i];\n        }\n        if max_k\
    \ == 0 {\n            break;\n        }\n        if max_k == i {\n           \
    \ max_arr.push(max_val);\n            max_k -= 1;\n        }\n        if max_k\
    \ > i {\n            max_arr.push(arr[i]);\n            max_k -= 1;\n        }\n\
    \    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0ly64j0z.rs:21:21\n   |\n\
    21 |         if max_k == i {\n   |                     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |         if max_k == i.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0ly64j0z.rs:25:20\n   |\n25 |         if max_k > i {\n\
    \   |                    ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n25 |         if max_k > i.try_into().unwrap() {\n   |                 \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2hpgrlg.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpc2hpgrlg.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:15:23\n   |\n15 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:19:12\n   |\n19 |  \
    \       if arr[i] > max_num {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:20:26\n   |\n20 |  \
    \           max_arr.push(arr[i]);\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].unwrap();\n    }\n    for i in 0..k {\n        max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6pkyf8vu.rs:116:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    99  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n100 |         max_arr\n101 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n116 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6pkyf8vu.rs:11:37\n   |\n11 |     let mut max_arr\
    \ = vec![vec![0]; k];\n   |                                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n11 |     let mut max_arr = vec![vec![0];\
    \ k.try_into().unwrap()];\n   |                                      ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp6pkyf8vu.rs:13:9\n   |\n13 |         max_arr[i] = arr[i];\n   |    \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6pkyf8vu.rs:13:22\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp6pkyf8vu.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpv9v5vs5y.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpv9v5vs5y.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpv9v5vs5y.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpv9v5vs5y.rs:20:26\n   |\n20 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n    let mut max_arr = vec![arr[0]; k]\n    for i in 1..k {\n        if arr[i]\
    \ > max_arr[0] {\n            max_arr[0] = arr[i];\n        }\n    }\n    for\
    \ i in 1..k {\n        if arr[i] > max_arr[1] {\n            max_arr[1] = arr[i];\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp4t8av_t8.rs:14:38\n\
    \   |\n14 |     let mut max_arr = vec![arr[0]; k]\n   |                      \
    \                ^ help: add `;` here\n15 |     for i in 1..k {\n   |     ---\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4t8av_t8.rs:11:21\n\
    \   |\n11 |     if arr.len() <= k {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n11 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4t8av_t8.rs:14:36\n   |\n14 |     let mut max_arr = vec![arr[0];\
    \ k]\n   |                                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     let mut max_arr = vec![arr[0]; k.try_into().unwrap()]\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4t8av_t8.rs:16:12\n\
    \   |\n16 |         if arr[i] > max_arr[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp4t8av_t8.rs:17:26\n   |\n17 |            \
    \ max_arr[0] = arr[i];\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp4t8av_t8.rs:21:12\n   |\n21 |         if a"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_val\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_val {\n            max_val\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_val\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpebhbtyur.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpebhbtyur.rs:15:23\n   |\n15 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpebhbtyur.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_val {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpebhbtyur.rs:20:26\n   |\n20 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_num = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_num {\n            max_num = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(max_num);\n            max_num = arr[i];\n        }\n    }\n\
    \    max_arr.push(max_num);\n    return max_arr;\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpy51x9f83.rs:17:12\n\
    \   |\n17 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpy51x9f83.rs:18:23\n   |\n18 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpy51x9f83.rs:22:12\n   |\n22 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpy51x9f83.rs:24:23\n   |\n24 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in (i + 1)..k {\n            if max_arr[i] > max_arr[j] {\n       \
    \         max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    for i\
    \ in 0..k {\n        arr[i] = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk6fi306k.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpk6fi306k.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpk6fi306k.rs:13:22\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpk6fi306k.rs:17:16\n\
    \   |\n17 |             if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpk6fi306k.rs:17:29\n   |\n17 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpwxtu197l.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = vec![];\n    }\n    for i in 0..arr.len() {\n\
    \        let mut max_i = i;\n        for j in 0..k {\n            if arr[i] >\
    \ arr[j] {\n                max_i = j;\n            }\n        }\n        max_arr[k\
    \ - i - 1].unshift(arr[max_i]);\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu27_01i5.rs:11:36\n   |\n\
    11 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpu27_01i5.rs:13:9\n   |\n13 |         max_arr[i]\
    \ = vec![];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpu27_01i5.rs:18:25\n   |\n18 |             if arr[i] > arr[j] {\n\
    \   |                         ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu27_01i5.rs:19:25\n\
    \   |\n16 |         let mut max_i = i;\n   |                         - expected\
    \ due to this value\n...\n19 |                 max_i = j;\n   |              \
    \           ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu27_01i5.rs:22:21\n   |\n22 |         max_arr[k - i - 1].unshift(arr[max_i]);\n\
    \   |                     ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ subtract `usize` from `isize`\n  --> /tmp/tmpu27_01i5.rs:22:19\n   |\n22 | \
    \        max_arr[k - i - 1].unshift(arr[max_i]);\n   |                   ^ no\
    \ implementation for `isize - usize`\n   |\n   = help: the trait `Sub<usize>`\
    \ is not implemented for `isiz"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_element = arr[0];\n    for i in 1..arr.len() {\n     \
    \   if arr[i] > max_element {\n            max_element = arr[i];\n        }\n\
    \    }\n    for i in 0..k {\n        if arr[i] > max_element {\n            max_arr.push(arr[i]);\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfq3t89og.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_element {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfq3t89og.rs:21:26\n   |\n21 |            \
    \ max_arr.push(arr[i]);\n   |                          ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![-1000, 1000]];\n\
    \    let mut max_k = k;\n    let mut max_idx = 0;\n    let mut max_val = -1000isize;\n\
    \    for v in arr.iter() {\n        if v > max_val {\n            max_val = v;\n\
    \            max_idx = max_arr.len() - 1;\n        }\n        if v > max_arr[max_idx][k]\
    \ {\n            max_arr[max_idx][k] = v;\n        }\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9rx10sq5.rs:16:16\n   |\n\
    16 |         if v > max_val {\n   |                ^^^^^^^\n   |             \
    \   |\n   |                expected `&isize`, found `isize`\n   |            \
    \    help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9rx10sq5.rs:17:23\n   |\n14 |     let mut max_val = -1000isize;\n\
    \   |                       ---------- expected due to this value\n...\n17 | \
    \            max_val = v;\n   |                       ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |        \
    \     max_val = *v;\n   |                       +\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp9rx10sq5.rs:20:16\n   |\n20 |  \
    \       if v > max_arr[max_idx][k] {\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp9rx10sq5.rs:21:13\n\
    \   |\n21 |             max_arr[max_idx][k] = v;\n   |             ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9rx10sq5.rs:24:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n24 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<{integer}>>`\n\
    \nerror: aborting due to 5 previou"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    let\
    \ mut max_idx = vec![0];\n    for i in 0..k {\n        let mut max_val = arr[i];\n\
    \        let mut max_idx = i;\n        for j in i + 1..arr.len() {\n         \
    \   if arr[j] > max_val {\n                max_val = arr[j];\n               \
    \ max_idx = j;\n            }\n        }\n        max_arr[i] = max_val;\n    \
    \    max_idx[i] = max_idx;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp49mfmp16.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp49mfmp16.rs:14:27\n   |\n14 |  \
    \       let mut max_val = arr[i];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp49mfmp16.rs:16:25\n   |\n16 |         for j in i + 1..arr.len()\
    \ {\n   |                         ^^^^^^^^^ expected `isize`, found `usize`\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp49mfmp16.rs:17:16\n\
    \   |\n17 |             if arr[j] > max_val {\n   |                ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp49mfmp16.rs:18:27\n   |\n18 |  \
    \               max_val = arr[j];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ ca"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    for i in 0..k\
    \ {\n        max_arr[i] = std::cmp::max(arr[i], max_arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu4ucgryu.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpu4ucgryu.rs:13:9\n\
    \   |\n13 |         max_arr[i] = std::cmp::max(arr[i], max_arr[i]);\n   |    \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpu4ucgryu.rs:13:36\n\
    \   |\n13 |         max_arr[i] = std::cmp::max(arr[i], max_arr[i]);\n   |    \
    \                                ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpu4ucgryu.rs:13:44\n   |\n13 |         max_arr[i] = std::cmp::max(arr[i],\
    \ max_arr[i]);\n   |                                            ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![-1000, 1000]];\n\
    \    let mut max_k = k;\n    let mut max_idx = 0;\n    let mut min_idx = 1;\n\
    \    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let mut max_idx\
    \ = 0;\n    let mut min_idx = 1;\n    let mut min_val = arr[0];\n    let mut max_val\
    \ = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx = 1;\n    let mut min_val\
    \ = arr[0];\n    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let\
    \ mut min_idx = 1;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n\
    \    let mut max_idx = 0;\n    let mut min_idx = 1;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 1;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 1;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 1;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 1;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 1;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 1;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 1;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 1;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 1;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut min_idx = 1;\n    let mut min_val = arr[0];\n\
    \    let mut max_val = arr[0];\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 1;\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpvofo0yos.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(&arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfz7hj9xd.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfz7hj9xd.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(&arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfz7hj9xd.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = max_arr[i].max(&arr[i]);\n   |                      ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfz7hj9xd.rs:13:38\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(&arr[i]);\n   |              \
    \                        ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfz7hj9xd.rs:15:5\n\
    \   |\n10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in (i + 1)..k {\n            if max_arr[i] > max_arr[j] {\n       \
    \         max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    for i\
    \ in 0..k {\n        for j in (i + 1)..k {\n            if max_arr[i] > max_arr[j]\
    \ {\n                max_arr[i] = max_arr[j];\n            }\n        }\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i];\n    }\n \
    \   for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i];\n    }\n  \
    \  for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i];\n    }\n   \
    \ for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i\
    \ in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n\
    \        max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n  \
    \      max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n   \
    \     max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n     \
    \   max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n       \
    \ max_arr[i] = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] =\
    \ max_arr[i] + max_arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ + max_arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] +\
    \ max_arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + max_arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = \n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4qv8nbuk.rs:109:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    92  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n93  |         max_arr[i] = \n94  | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n109 | }\n    |   ^\n\nerror:\
    \ expected expression, found `}`\n  --> /tmp/tmp4qv8nbuk.rs:94:1\n   |\n94 | }\n\
    \   | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4qv8nbuk.rs:11:37\n\
    \   |\n11 |     let mut max_arr = vec![vec![0]; k];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp4qv8nbuk.rs:13:9\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4qv8nbuk.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4qv8nbuk.rs:17:16\n   |\n17 |  \
    \           if m"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![0; k];\n    let mut max_val\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_val {\n            max_val\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        result[i] = max_val;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1rytf0y5.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1rytf0y5.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1rytf0y5.rs:15:23\n   |\n15 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp1rytf0y5.rs:19:9\n   |\n19 |         result[i]\
    \ = max_val;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    max_arr[i] = max_arr[i].max();\n    }\n    for i in 0..k {\n        arr[i]\
    \ = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0v8in2k.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:9\n   |\n16 |   \
    \      max_arr[i] = max_arr[i].max();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpt0v8in2k.rs:16:22\n   |\n16 |  \
    \       max_arr[i] = max_arr[i].max();\n   |                      ^^^^^^^^^^ slice\
    \ indic"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i].max(arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = max_arr[i].max(arr[i]);\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:22\n\
    \   |\n13 |         max_arr[i] = max_arr[i].max(arr[i]);\n   |               \
    \       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpf_2sy2ac.rs:13:37\n   |\n13 |         max_arr[i] =\
    \ max_arr[i].max(arr[i]);\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_2sy2ac.rs:15:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n15 |\
    \     max_arr\n   |     ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected str"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    let mut max_element\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_element {\n        \
    \    max_element = arr[i];\n        }\n    }\n    for i in 0..k {\n        if\
    \ arr[i] > max_element {\n            result.push(max_element);\n            max_element\
    \ = arr[i];\n        }\n    }\n    result.push(max_element);\n    result\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpaofabf1t.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_element {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpaofabf1t.rs:15:27\n   |\n15 |            \
    \ max_element = arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpaofabf1t.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_element {\n   |            ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpaofabf1t.rs:21:27\n   |\n21 |             max_element = arr[i];\n\
    \   |                           ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:15:23\n   |\n15 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:19:12\n   |\n19 |  \
    \       if arr[i] > max_num {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:20:26\n   |\n20 |  \
    \           max_arr.push(arr[i]);\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() < k {\n        return vec![];\n\
    \    }\n    let mut max_arr = vec![vec![0]; k];\n    let mut max_idx = vec![0;\
    \ k];\n    let mut max_val = vec![0];\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] + arr[i];\n        max_idx[i] = i;\n        max_val[i] = max_arr[i];\n\
    \    }\n    for i in 0..k {\n        if max_arr[i] > max_val[i] {\n          \
    \  max_arr[i] = max_val[i];\n            max_idx[i] = i;\n        }\n    }\n \
    \   for i in 0..k {\n        arr[i] = max_arr[i];\n    }\n    return arr;\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7dqkbx82.rs:11:20\n   |\n\
    11 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7dqkbx82.rs:14:37\n   |\n14 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7dqkbx82.rs:15:31\n   |\n15 |     let mut max_idx\
    \ = vec![0; k];\n   |                               ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n15 |     let mut max_idx = vec![0; k.try_into().unwrap()];\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp7dqkbx82.rs:18:9\n\
    \   |\n18 |         max_arr[i] = max_arr[i] + arr[i];\n   |         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp7dqkbx82.rs:18:22\n   |\n18 |         max_arr[i] = max_arr[i] + arr[i];\n\
    \   |                      ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        if\
    \ max_arr\n            .iter()\n            .any(|&x| x > arr[max_i - max_k +\
    \ 1])\n        {\n            max_arr.push(arr[max_i - 1]);\n            max_k\
    \ -= 1;\n        } else {\n            max_arr.push(arr[max_i]);\n        }\n\
    \        max_i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqfv70z1r.rs:14:19\n   |\n\
    14 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqfv70z1r.rs:17:39\n   |\n17 |             .any(|&x| x >\
    \ arr[max_i - max_k + 1])\n   |                                       ^^^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n\
    \  --> /tmp/tmpqfv70z1r.rs:17:37\n   |\n17 |             .any(|&x| x > arr[max_i\
    \ - max_k + 1])\n   |                                     ^ no implementation\
    \ for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > max_arr[i][j + 1] {\n\
    \                max_arr[i][j] = max_arr[i][j + 1];\n            }\n        }\n\
    \    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[i] {\n                max_arr[i][j] = arr[i];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        for j in 0.\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjn791zlp.rs:123:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    106 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n107 |         for j in 0.\n108 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n123 | }\n    |   ^\n\nerror:\
    \ expected `{`, found `}`\n   --> /tmp/tmpjn791zlp.rs:108:1\n    |\n108 | }\n\
    \    | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn791zlp.rs:11:36\n\
    \   |\n11 |     let mut max_arr = vec![vec![]; k];\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |        \
    \                             ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpjn791zlp.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpjn791zlp.rs:13:27\n   |\n13 |         max_arr[i]\
    \ = vec![arr[i]; 1];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpjn791zlp.rs:17:16\n   |\n17 |         \
    \    if max_arr[i][j] > max_arr[i"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_so_far = vec![vec![0]; k];\n    let\
    \ mut max_so_far_len = k;\n    let mut max_so_far_pos = 0;\n    let mut max_so_far_pos_len\
    \ = 0;\n    let mut max_so_far_pos_len2 = 0;\n    let mut max_so_far_pos_len3\
    \ = 0;\n    let mut max_so_far_pos_len4 = 0;\n    let mut max_so_far_pos_len5\
    \ = 0;\n    let mut max_so_far_pos_len6 = 0;\n    let mut max_so_far_pos_len7\
    \ = 0;\n    let mut max_so_far_pos_len8 = 0;\n    let mut max_so_far_pos_len9\
    \ = 0;\n    let mut max_so_far_pos_len10 = 0;\n    let mut max_so_far_pos_len11\
    \ = 0;\n    let mut max_so_far_pos_len12 = 0;\n    let mut max_so_far_pos_len13\
    \ = 0;\n    let mut max_so_far_pos_len14 = 0;\n    let mut max_so_far_pos_len15\
    \ = 0;\n    let mut max_so_far_pos_len16 = 0;\n    let mut max_so_far_pos_len17\
    \ = 0;\n    let mut max_so_far_pos_len18 = 0;\n    let mut max_so_far_pos_len19\
    \ = 0;\n    let mut max_so_far_pos_len20 = 0;\n    let mut max_so_far_pos_len21\
    \ = 0;\n    let mut max_so_far_pos_len22 = 0;\n    let mut max_so_far_pos_len23\
    \ = 0;\n    let mut max_so_far_pos_len24 = 0;\n    let mut max_so_far_pos_len25\
    \ = 0;\n    let mut max_so_far_pos_len26 = 0;\n    let mut max_so_far_pos_len27\
    \ = 0;\n    let mut max_so_far_pos_len28 = 0;\n    let mut max_so_far_pos_len29\
    \ = 0;\n    let mut max_so_far_pos_len30 = 0;\n    let mut max_so_far_pos_len31\
    \ = 0;\n    let mut max_so_far_pos_len32 = 0;\n    let mut max_so_far_pos_len33\
    \ = 0;\n    let mut max_so_far_pos_len34 = 0;\n    let mut max_so_far_pos_len35\
    \ = 0;\n    let mut max_so_far_pos_len36 = 0;\n    let mut max_so_far_pos_len37\
    \ = 0;\n    let mut max_so_far_pos_len38 = 0;\n    let mut max_so_far_pos_len39\
    \ = 0;\n    let mut max_so_far_pos_len40 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk54va7sk.rs:11:40\n   |\n\
    11 |     let mut max_so_far = vec![vec![0]; k];\n   |                        \
    \                ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut max_so_far = vec![vec![0]; k.try_into().unwrap()];\n   |    \
    \                                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk54va7sk.rs:10:42\n   |\n10 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |    -------                               ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    return max_arr;\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmps0gtl0wk.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmps0gtl0wk.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmps0gtl0wk.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmps0gtl0wk.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_so_far = vec![vec![0; k]; arr.len()];\n\
    \    for i in 0..arr.len() {\n        for j in 0..k {\n            if arr[i] >\
    \ max_so_far[i][j] {\n                max_so_far[i][j] = arr[i];\n           \
    \ }\n        }\n    }\n    max_so_far\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt74cz6r2.rs:11:39\n   |\n\
    11 |     let mut max_so_far = vec![vec![0; k]; arr.len()];\n   |             \
    \                          ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n11 |     let mut max_so_far = vec![vec![0; k.try_into().unwrap()];\
    \ arr.len()];\n   |                                        ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpt74cz6r2.rs:14:25\n\
    \   |\n14 |             if arr[i] > max_so_far[i][j] {\n   |                 \
    \        ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpt74cz6r2.rs:15:17\n\
    \   |\n15 |                 max_so_far[i][j] = arr[i];\n   |                 ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt74cz6r2.rs:19:5\n   |\n10 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                \
    \          ---------- expected `Vec<isize>` because of return type\n...\n19 |\
    \     max_so_far\n   |     ^^^^^^^^^^ expected `isize`, found struct `Vec`\n \
    \  |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<{integer}>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in i+1..k {\n            if max_arr[i] > max_arr[j] {\n           \
    \     max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] + 1000;\n    }\n    for i in 0..k {\n\
    \        max_arr[i] = max_arr[i] - 1000;\n    }\n    for i in 0..k {\n       \
    \ max_arr[i] = max_arr[i] + 1000;\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] - 1000;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ + 1000;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] - 1000;\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + 1000;\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] - 1000;\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] + 1000;\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] - 1000;\n    }\n    for i in 0..k {\n   \
    \     max_arr[i] = max_arr[i] + 1000;\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] - 1000;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ + 1000;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] - 1000;\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + 1000;\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] - 1000;\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] + 1000;\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] - 1000;\n    }\n    for i in 0..k {\n   \
    \     max_arr[i] = max_arr[i] + 1000;\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] - 1000;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ + 1000;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] - 1000;\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + 1000;\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] - 1000;\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] + 100\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpff1ilf1z.rs:111:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    94  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n95  |         max_arr[i] = max_arr[i] + 100\n96  | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n111 | }\n\
    \    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpff1ilf1z.rs:11:37\n\
    \   |\n11 |     let mut max_arr = vec![vec![0]; k];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpff1ilf1z.rs:13:9\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpff1ilf1z.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpff1ilf1z.rs:17:16\n   |\n17 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_val = arr[0];\n    for i in 1..arr.len() {\n        if\
    \ arr[i] > max_val {\n            max_val = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        max_arr[i] = max_val;\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] as isize;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ as isize;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] as isize;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ as isize;\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] as isize;\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i] \n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8213ylbx.rs:112:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    95  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n96  |         max_arr[i] = max_arr[i] \n97  | }\n   \
    \ | - ...as it matches this but it has different indentation\n...\n112 | }\n \
    \   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8213ylbx.rs:11:31\n\
    \   |\n11 |     let mut max_arr = vec![0; k];\n   |                          \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![0; k.try_into().unwrap()];\n   |                        \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8213ylbx.rs:17:23\n\
    \   |\n12 |     let mut max_idx = k;\n   |                       - expected due\
    \ to this value\n...\n17 |             max_idx = i;\n   |                    \
    \   ^ expected `isize`, found `usize`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp8213ylbx.rs:21:9\n   |\n21 |   \
    \      max_arr[i] = max_val;\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp8213ylbx.rs:24:9\n   |\n24 |   \
    \      max_arr[i] = max_arr[i] as isize;\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n      \
    \  for j in 0..k {\n            if max_arr[j] < max_arr[i] {\n               \
    \ max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    for i in 0..k\
    \ {\n        arr[i] = max_arr[i];\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjya2es9k.rs:11:36\n   |\n\
    11 |     let mut max_arr = vec![vec![]; k];\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![]; k.try_into().unwrap()];\n   |                   \
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpjya2es9k.rs:13:9\n   |\n13 |         max_arr[i]\
    \ = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpjya2es9k.rs:13:22\n   |\n13 |         max_arr[i] = arr[i];\n  \
    \ |                      ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpjya2es9k.rs:17:16\n   |\n17 |             if max_arr[j] < max_arr[i]\
    \ {\n   |                ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpjya2es9k.rs:17:29\n   |\n17 |             if max_arr[j]\
    \ < max_arr[i] {\n   |                             ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usiz"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_num = arr[0];\n    let mut max_idx\
    \ = 1;\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n            max_idx = i;\n        }\n    }\n    vec![max_num; max_idx\
    \ + 1]\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzt0dz2c_.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpzt0dz2c_.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzt0dz2c_.rs:19:19\n\
    \   |\n19 |     vec![max_num; max_idx + 1]\n   |                   ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n19 |     vec![max_num;\
    \ (max_idx + 1).try_into().unwrap()]\n   |                   +           +++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_idx = -1;\n    for idx in 0..arr.len() {\n        if idx\
    \ > max_idx {\n            max_idx = idx;\n        }\n        if arr[idx] > max_arr[0]\
    \ {\n            max_arr[0] = arr[idx];\n            max_k = max_k - 1;\n    \
    \    }\n        if max_k == 0 {\n            break;\n        }\n        if arr[idx]\
    \ > max_arr[1] {\n            max_arr[1] = arr[idx];\n            max_k = max_k\
    \ - 1;\n        }\n    }\n    max_arr.sort_unstable();\n    max_arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2ru_42mx.rs:13:23\n\
    \   |\n13 |     let mut max_idx = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:15:23\n   |\n15 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:19:12\n   |\n19 |  \
    \       if arr[i] > max_num {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:20:26\n   |\n20 |  \
    \           max_arr.push(arr[i]);\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![]; k];\n    for i\
    \ in 0..k {\n        max_arr[i] = vec![arr[i]; 1];\n    }\n    for i in 0..k {\n\
    \        for j in 0..k {\n            if max_arr[i][j] > max_arr[i][j+1] {\n \
    \               max_arr[i][j] = max_arr[i][j+1];\n            }\n        }\n \
    \   }\n    for i in 0..k {\n        for j in 0..k {\n            if max_arr[i][j]\
    \ > arr[j] {\n                max_arr[i][j] = arr[j];\n            }\n       \
    \ }\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].iter().cloned().collect();\n\
    \    }\n    for i in 0..k {\n        max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpn3z29fy6.rs:100:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    83  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n84  |         max_arr\n85  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n100 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn3z29fy6.rs:11:36\n   |\n11 |     let mut max_arr\
    \ = vec![vec![]; k];\n   |                                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n11 |     let mut max_arr = vec![vec![];\
    \ k.try_into().unwrap()];\n   |                                     ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpn3z29fy6.rs:13:9\n\
    \   |\n13 |         max_arr[i] = vec![arr[i]; 1];\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpn3z29fy6.rs:13:27\n\
    \   |\n13 |         max_arr[i] = vec![arr[i]; 1];\n   |                      \
    \     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   =\
    \ help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpn3z29fy6.rs:17:16\n\
    \   |\n17 |             if max_arr[i][j] > max_arr[i][j+1] {\n   |           \
    \     ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   ="
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    for i in 0..k\
    \ {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n        let mut\
    \ max_num = max_arr[i];\n        for j in 0..k {\n            if max_arr[j] >\
    \ max_num {\n                max_num = max_arr[j];\n            }\n        }\n\
    \        max_arr[i] = max_num;\n    }\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkrkcfzs.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmppkrkcfzs.rs:13:9\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmppkrkcfzs.rs:13:22\n   |\n13 |         max_arr[i]\
    \ = arr[i];\n   |                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmppkrkcfzs.rs:16:27\n   |\n16 |         let\
    \ mut max_num = max_arr[i];\n   |                           ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmppkrkcfzs.rs:18:16\n   |\n18 |  \
    \           if max_arr[j] > max_num {\n   |                ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if k == 0 || arr.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut max_arr = vec![];\n    let mut max_num = arr[0];\n\
    \    for i in 1..k {\n        if arr[i] > max_num {\n            max_num = arr[i];\n\
    \        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num {\n      \
    \      max_arr.push(max_num);\n            max_num = arr[i];\n        } else {\n\
    \            max_arr.push(arr[i]);\n        }\n    }\n    max_arr.push(max_num);\n\
    \    return max_arr;\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpybahh66_.rs:17:12\n\
    \   |\n17 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpybahh66_.rs:18:23\n   |\n18 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpybahh66_.rs:22:12\n   |\n22 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpybahh66_.rs:24:23\n   |\n24 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpybahh66_.rs:26:26\n   |\n26 |             max_arr.push(arr[i]);\n\
    \   |                          ^^^^^^ slice indices are of type `usize` or ra"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    let mut max_i = i;\n        for j in 0..k {\n            if max_arr[j] <\
    \ max_arr[max_i] {\n                max_i = j;\n            }\n        }\n   \
    \     max_arr[max_i] = max_arr[max_i] + 1;\n    }\n    for i in 0..k {\n     \
    \   max_arr[i] = max_arr[i] * arr[i];\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] / max_arr[k];\n    }\n    for i in 0..k {\n        max_arr[i] =\
    \ max_arr[i] % max_arr[k];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ / max_arr[k];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] %\
    \ max_arr[k];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] / max_arr[k];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] % max_arr[k];\n \
    \   }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] / max_arr[k];\n  \
    \  }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] % max_arr[k];\n   \
    \ }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] / max_arr[k];\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] % max_arr[k];\n    }\n \
    \   for i in 0..k {\n        max_arr[i] = max_arr[i] / max_arr[k];\n    }\n  \
    \  for i in 0..k {\n        max_arr[i] = max_arr[i] % max_arr[k];\n    }\n   \
    \ for i in 0..k {\n        max_arr[i] = max_arr[i] / max_arr[k];\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] % max_arr[k];\n    }\n    for i\
    \ in 0..k {\n        max_arr[i] = max_arr[i] / max_arr[k];\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] % max_arr[k];\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] / max_arr[k];\n    }\n    for i in 0..k {\n\
    \        max_arr[i] = max_arr[i] % max_arr[k];\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i] / max_arr[k];\n    }\n    for i in 0..k {\n  \
    \      max_arr[i] = max_arr[i] % max_arr[k];\n    }\n    for i in 0..k {\n   \
    \     max_arr[i] = max_arr[i] / \n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpbi2rz38f.rs:104:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    87  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n88  |         max_arr[i] = max_arr[i] / \n89  | }\n \
    \   | - ...as it matches this but it has different indentation\n...\n104 | }\n\
    \    |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpbi2rz38f.rs:89:1\n\
    \   |\n89 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbi2rz38f.rs:11:37\n   |\n11 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpbi2rz38f.rs:13:9\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbi2rz38f.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbi2rz38f.rs:18:16\n   |\n18 |  \
    \  "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![-1000, 1000]];\n\
    \    let mut max_k = k;\n    let mut i = 0;\n    while i < arr.len() {\n     \
    \   let mut j = i;\n        while j < arr.len() {\n            if arr[j] > arr[j\
    \ + 1] {\n                max_arr[0] = vec![arr[j], arr[j + 1]];\n           \
    \     max_k = 0;\n            } else {\n                max_arr[0] = vec![arr[j],\
    \ max_arr[0][0].clone()];\n                max_k = 1;\n            }\n       \
    \     i += 1;\n        }\n        max_arr[0] = vec![arr[i], max_arr[0][0].clone()];\n\
    \        max_k = 1;\n        i += 1;\n    }\n    max_arr\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk8my7nf5.rs:30:5\n   |\n\
    10 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n30 |     max_arr\n   |     ^^^^^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<Vec<isize>>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in (i + 1)..k {\n            if max_arr[i] > max_arr[j] {\n       \
    \         max_arr[i] = max_arr[j];\n            }\n        }\n    }\n    for i\
    \ in 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmvlmv0km.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmvlmv0km.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmvlmv0km.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmvlmv0km.rs:17:16\n   |\n17 |  \
    \           if max_arr[i] > max_arr[j] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpmvlmv0km.rs:17:29\n   |\n17 |             if max_arr[i] > max_arr[j]\
    \ {\n   |                             ^^^"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in 0..k {\n            if max_arr[j] > max_arr[j+1] {\n           \
    \     max_arr[j] = max_arr[j+1];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ + arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i]\
    \ + arr[i];\n    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n\
    \    for i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for\
    \ i in 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k\
    \ {\n        max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i] + arr[i];\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i] + \n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpussup4i3.rs:111:3\n\
    \    |\n10  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    94  |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n95  |         max_arr[i] = max_arr[i] + \n96  | }\n \
    \   | - ...as it matches this but it has different indentation\n...\n111 | }\n\
    \    |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpussup4i3.rs:96:1\n\
    \   |\n96 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpussup4i3.rs:11:37\n   |\n11 |     let mut max_arr = vec![vec![0];\
    \ k];\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmpussup4i3.rs:13:9\n\
    \   |\n13 |         max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpussup4i3.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpussup4i3.rs:17:16\n   |\n17 |  \
    \  "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = 0;\n    let mut max_val = arr[0];\n    for i in 0..arr.len() {\n        if\
    \ arr[i] > max_val {\n            max_val = arr[i];\n            max_idx = i;\n\
    \        }\n    }\n    for i in 0..k {\n        max_arr[i] = arr[k - i - 1];\n\
    \    }\n    max_arr[k - 1] = max_val;\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph0170bm8.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmph0170bm8.rs:21:9\n\
    \   |\n21 |         max_arr[i] = arr[k - i - 1];\n   |         ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmph0170bm8.rs:21:22\n\
    \   |\n21 |         max_arr[i] = arr[k - i - 1];\n   |                      ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmph0170bm8.rs:23:5\n\
    \   |\n23 |     max_arr[k - 1] = max_val;\n   |     ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(arr[i]);\n        }\n    }\n    max_arr\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:15:23\n   |\n15 |  \
    \           max_num = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:19:12\n   |\n19 |  \
    \       if arr[i] > max_num {\n   |            ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp4kkvp9pj.rs:20:26\n   |\n20 |  \
    \           max_arr.push(arr[i]);\n   |                          ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_num\
    \ = arr[0];\n    for i in 1..k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        if arr[i] > max_num\
    \ {\n            max_arr.push(max_num);\n            max_num = arr[i];\n     \
    \   }\n    }\n    max_arr.push(max_num);\n    max_arr\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:14:12\n\
    \   |\n14 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:15:23\n   |\n15 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwxtu197l.rs:19:12\n   |\n19 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpwxtu197l.rs:21:23\n   |\n21 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in 0..k {\n            if max_arr[j] > max_arr[j+1] {\n           \
    \     max_arr[j] = max_arr[j+1];\n            }\n        }\n    }\n    for i in\
    \ 0..k {\n        max_arr[i] = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphk4sq9k_.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphk4sq9k_.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphk4sq9k_.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmphk4sq9k_.rs:17:16\n   |\n17 |  \
    \           if max_arr[j] > max_arr[j+1] {\n   |                ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmphk4sq9k_.rs:17:29\n   |\n17 |             if max_arr[j] > max_arr[j+1]\
    \ {\n   |                            "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = 0;\n    for idx in 0..arr.len() {\n        if idx > max_idx {\n          \
    \  max_idx = idx;\n        }\n        if arr[idx] > max_arr[0] {\n           \
    \ max_arr[0] = arr[idx];\n        }\n    }\n    max_arr.sort();\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb841xcqq.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![];\n    let mut max_k\
    \ = k;\n    let mut max_i = arr.len();\n    while max_i < max_k {\n        if\
    \ max_arr.len() < max_k {\n            max_arr.push(arr[max_i]);\n        }\n\
    \        if max_arr[0] > arr[max_i] {\n            max_k = max_i - 1;\n      \
    \  }\n        max_i -= 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplyvoqhrb.rs:14:19\n   |\n\
    14 |     while max_i < max_k {\n   |                   ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     while max_i < max_k.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplyvoqhrb.rs:15:28\n   |\n15 |         if max_arr.len()\
    \ < max_k {\n   |                            ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |         if max_arr.len() < max_k.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplyvoqhrb.rs:19:21\n   |\n12 |     let mut max_k\
    \ = k;\n   |                     - expected due to this value\n...\n19 |     \
    \        max_k = max_i - 1;\n   |                     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![vec![0]; k];\n    for\
    \ i in 0..k {\n        max_arr[i] = arr[i];\n    }\n    for i in 0..k {\n    \
    \    for j in (i + 1)..k {\n            if arr[i] > arr[j] {\n               \
    \ max_arr[i] = arr[i];\n                arr[i] = arr[j];\n                arr[j]\
    \ = max_arr[i];\n            }\n        }\n    }\n    for i in 0..k {\n      \
    \  max_arr[i] = max_arr[i].unwrap();\n    }\n    max_arr\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppj__en72.rs:11:37\n   |\n\
    11 |     let mut max_arr = vec![vec![0]; k];\n   |                           \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let\
    \ mut max_arr = vec![vec![0]; k.try_into().unwrap()];\n   |                  \
    \                    ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmppj__en72.rs:13:9\n   |\n13 |   \
    \      max_arr[i] = arr[i];\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmppj__en72.rs:13:22\n   |\n13 |  \
    \       max_arr[i] = arr[i];\n   |                      ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmppj__en72.rs:17:16\n   |\n17 |            \
    \ if arr[i] > arr[j] {\n   |                ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmppj__en72.rs:17:25\n   |\n17 |            \
    \ if arr[i] > arr[j] {\n   |                         ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n "
  stdout: ''
  timestamp: 1660009214
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx\
    \ = k;\n    let mut max_val = arr[0];\n    for i in arr.iter().rev() {\n     \
    \   if i > max_val {\n            max_val = i;\n            max_idx = k;\n   \
    \     }\n        if i == max_val {\n            max_arr[k - 1] = i;\n        \
    \    k -= 1;\n        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk5jm0xor.rs:11:31\n   |\n\
    11 |     let mut max_arr = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut max_arr\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk5jm0xor.rs:15:16\n   |\n15 |\
    \         if i > max_val {\n   |                ^^^^^^^\n   |                |\n\
    \   |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk5jm0xor.rs:16:23\n   |\n16 |             max_val = i;\n   |       \
    \                ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n16 |             max_val = *i;\n   |                     \
    \  +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpk5jm0xor.rs:19:14\n\
    \   |\n19 |         if i == max_val {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpk5jm0xor.rs:20:13\n   |\n20 |             max_arr[k\
    \ - 1] = i;\n   |             ^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747240
- exit_code: 1
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    if arr.len() <= k {\n        return arr\n   \
    \ }\n    let mut max_arr = vec![vec![-1000, 1000]];\n    let mut max_k = k;\n\
    \    let mut max_idx = 0;\n    let mut max_val = -1000.0;\n    for idx in 0..arr.len()\
    \ {\n        if idx < max_k {\n            max_arr[idx] = vec![arr[idx], max_val];\n\
    \        } else {\n            if arr[idx] > max_val {\n                max_val\
    \ = arr[idx];\n                max_idx = idx;\n            }\n        }\n    }\n\
    \    max_arr.sort_by_key(|x| x.1);\n    max_arr.truncate(max_k);\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyqojmc17.rs:11:21\n   |\n\
    11 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyqojmc17.rs:19:18\n   |\n19 |         if idx < max_k {\n\
    \   |                  ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n19 |         if idx < max_k.try_into().unwrap() {\n   |         \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyqojmc17.rs:20:43\n\
    \   |\n20 |             max_arr[idx] = vec![arr[idx], max_val];\n   |        \
    \                                   ^^^^^^^ expected `isize`, found floating-point\
    \ number\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyqojmc17.rs:22:27\n\
    \   |\n22 |             if arr[idx] > max_val {\n   |                        \
    \   ^^^^^^^ expected `isize`, found floating-point number\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyqojmc17.rs:23:27\n   |\n17 |     let mut max_val = -1000.0;\n\
    \   |                       ------- expected due to this value\n...\n23 |    \
    \             max_val = arr[idx];\n   |                           ^^^^^^^^ expected\
    \ floating-point number, found `isize`\n\nerror[E0609]: no field `1` on type `&Vec<isize>`\n\
    \  --> /tmp/tmpyqojmc17.rs:28:31\n   |\n28 |     max_arr.sort_by_key(|x| x.1);\n\
    \   |                               ^ unknown field\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyqojmc17.rs:29:22\n   |\n29 |     max_arr.truncate(max_k);\n\
    \   |                      ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n29 |     max_arr.truncate(max_k.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyqojmc17.rs:30:5\n   "
  stdout: ''
  timestamp: 1660009214
- exit_code: 101
  program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array\
    \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be\
    \ in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    for i in 0..k {\n\
    \        let mut max_element = arr[0];\n        for j in 1..arr.len() {\n    \
    \        if arr[j] > max_element {\n                max_element = arr[j];\n  \
    \          }\n        }\n        result.push(max_element);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpewboozy4.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009215
