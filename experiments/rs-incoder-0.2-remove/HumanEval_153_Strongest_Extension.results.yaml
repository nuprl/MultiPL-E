language: rs
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for extension in extensions {\n  \
    \      let mut extension = extension.clone();\n        let mut count = 0;\n  \
    \      for c in extension.chars() {\n            if c.is_uppercase() {\n     \
    \           count += 1;\n            }\n            if c.is_lowercase() {\n  \
    \              count += 1;\n            }\n        }\n        if count > strength\
    \ {\n            strength = count;\n            extension = extension.clone();\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpvqkw24y7.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for e in extensions {\n        let\
    \ cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let sm =\
    \ e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        let strength =\
    \ cap - sm;\n        if strength > 0 {\n            extension = e.to_string();\n\
    \            break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6u5tw2y.rs:19:45\n   |\n\
    19 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz6u5tw2y.rs:19:57\n   |\n19 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz6u5tw2y.rs:20:44\n   |\n20 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpz6u5tw2y.rs:20:56\n   |\n20 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for e in extensions {\n        let\
    \ cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let sm =\
    \ e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        let strength =\
    \ if cap > sm { cap - sm } else { sm - cap };\n        if strength > strength\
    \ {\n            extension = e;\n            strength = strength;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_svatmzw.rs:19:45\n   |\n\
    19 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_svatmzw.rs:19:57\n   |\n19 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_svatmzw.rs:20:44\n   |\n20 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_svatmzw.rs:20:56\n   |\n20 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for e in extensions {\n        let\
    \ cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let sm =\
    \ e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    return class_name.concat(extension).concat(\"\
    .\")\n        .concat(extensions[extensions.iter().position(|e| e == extension).unwrap()])\n\
    \        .concat(\".\")\n        .concat(extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extension).unwrap()]).unwrap()])\n\
    \        .concat(\".\")\n        .concat(extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == extension).unwrap()]).unwrap()]).unwrap()])\n        .concat(\".\")\n \
    \       .concat(extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == extension).unwrap()]).unwrap()]).unwrap()]).unwrap()])\n        .concat(\"\
    .\")\n        .concat(extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extension).unwrap()]).unwrap()]).unwrap()]).unwrap()]).unwrap()])\n\
    \        .concat(\".\")\n        .concat(extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extension).unwrap()]).unwrap()]).unwrap()]).unwrap()]).unwrap()])\n\
    \        .concat(\".\")\n        .concat(extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == \n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmp4twnz6dh.rs:42:1\n\
    \   |\n42 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp4twnz6dh.rs:41:242\n   |\n15 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                         \
    \                                                      - closing delimiter possibly\
    \ meant for this\n...\n41 |         .concat(extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|\
    \ e == extensions[extensions.iter().position(|e| e == extensions[extensions.iter().position(|e|...\n\
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                  ^ unclosed delimiter\n42 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4twnz6dh.rs:19:45\n   |\n19 |\
    \         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n   |\
    \                                             ^^^\n   |                      \
    \                       |\n   |                                             expected\
    \ `&char`, found `char`\n   |                                             help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4twnz6dh.rs:19:57\n\
    \   |\n19 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                         ^^^\n   |      \
    \                                                   |\n   |                  \
    \                                       expected `&char`, found `char`\n   | \
    \                                                        help: consider borrowing\
    \ here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4twnz6dh.rs:20:44\n\
    \   |\n20 |         let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                            ^^^\n   |   "
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(c) {\n            \
    \    extension_map.insert(c, strength + 1);\n            } else {\n          \
    \      extension_map.insert(c, 1);\n            }\n            if strength > extension_strength\
    \ {\n                extension_strength = strength;\n            }\n        }\n\
    \        extensions_map.insert(extension, extension_map);\n    }\n    let mut\
    \ strongest_extension = String::new();\n    let mut strongest_extension_strength\
    \ = -1;\n    for extension in extensions_map.keys() {\n        let extension_map\
    \ = extensions_map.get(extension);\n        let mut extension_strength = -1;\n\
    \        for c in extension.chars() {\n            if let Some(strength) = extension_map.get(c)\
    \ {\n                extension_map.insert(c, strength + 1);\n            } else\
    \ {\n                extension_map.insert(c, 1);\n            }\n            if\
    \ strength > extension_strength {\n                extension_strength = strength;\n\
    \            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension;\n            strongest_extension_strength\
    \ = extension_strength;\n        }\n    }\n    strongest_extension.push_str(class_name);\n\
    \    strongest_extension.push_str(&strongest_extension_strength.to_string());\n\
    \    strongest_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp1brlj0u0.rs:16:30\n   |\n16 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp1brlj0u0.rs:18:33\n   |\n18 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `strength` in this scope\n  --> /tmp/tmp1brlj0u0.rs:26:16\n\
    \   |\n26 |             if strength > extension_strength {\n   |             \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `strength`\
    \ in this scope\n  --> /tmp/tmp1brlj0u0.rs:27:38\n   |\n27 |                 extension_strength\
    \ = strength;\n   |                                      ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `strength` in this scope\n  -->\
    \ /tmp/tmp1brlj0u0.rs:43:16\n   |\n43 |             if strength > extension_strength\
    \ {\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `strength` in this scope\n  --> /tmp/tmp1brlj0u0.rs:44:38\n   |\n\
    44 |                 extension_strength = strength;\n   |                    \
    \                  ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1brlj0u0.rs:52:34\n   |\n52 |     strongest_extension.push_str(class_name);\n\
    \   |                                  ^^^^^^^^^^\n   |                      \
    \            |\n   |                                  expected `&str`, found struct\
    \ `String`\n   |                                  help: consider borrowing here:\
    \ `&class_name`\n\nerror: aborting due to 7 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for extension in extensions {\n  \
    \      let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n   \
    \     let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n     \
    \   if cap > sm {\n            strength = cap - sm;\n            extension = extension.to_lowercase();\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpcjyucvw0.rs:16:24\n\
    \   |\n16 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for extension in extensions {\n  \
    \      let mut extension_length = extension.len();\n        let mut class_length\
    \ = class_name.len();\n        while extension_length >= class_length {\n    \
    \        extension = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>();\n\
    \            extension_length -= class_length;\n            class_length += 1;\n\
    \        }\n        let mut class_length = extension.len();\n        while class_length\
    \ >= extension_length {\n            class_length -= extension_length;\n     \
    \       extension += extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>();\n\
    \        }\n        let mut class_length = extension.len();\n        while class_length\
    \ >= extension_length {\n            class_length -= extension_length;\n     \
    \       extension += extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>();\n\
    \        }\n        let mut class_length = extension.len();\n        while class_length\
    \ >= extension_length {\n            class_length -= extension_length;\n     \
    \       extension += extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>();\n\
    \        }\n        let mut class_length = extension.len();\n        while class_length\
    \ >= extension_length {\n            class_length -= extension_length;\n     \
    \       extension += extension.chars().filter(|c| *c >= '0' && *c <= '9').collect::<String>();\n\
    \        }\n        let mut class_length = extension.len();\n        while class_length\
    \ >= extension_length {\n            class_length -= extension_length;\n     \
    \       extension += extension.chars().filter(|c| *c >= '0' && *c <= '9').collect::<String>();\n\
    \        }\n        let mut class_length = extension.len();\n        while class_length\
    \ >= extension_length {\n            class_length -= extension_length;\n     \
    \       extension += extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>();\n\
    \        }\n        let mut class_length = extension.len();\n        while class_length\
    \ >= extension_length {\n            class_length -= extension_length;\n     \
    \       extension += extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>();\n\
    \        }\n        let mu\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvnfq81xg.rs:75:3\n\
    \   |\n15 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n18 |     for extension in extensions\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n62 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n75 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpvnfq81xg.rs:61:15\n\
    \   |\n61 |         let mu\n   |               ^ help: add `;` here\n62 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvnfq81xg.rs:29:26\n\
    \   |\n29 |             extension += extension.chars().filter(|c| *c >= 'a' &&\
    \ *c <= 'z').collect::<String>();\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                          |\n   |                          expected `&str`,\
    \ found struct `String`\n   |                          help: consider borrowing\
    \ here: `&extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvnfq81xg.rs:34:26\n   |\n34 |\
    \             extension += extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>();\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                          |\n   |                          expected `&str`,\
    \ found struct `String`\n   |                          help: consider borrowing\
    \ here: `&extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvnfq81xg.rs:39:26\n   |\n39 |\
    \             extension += extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>();\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                          |\n   |                          expected `&str`,\
    \ found stru"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for extension in extensions {\n  \
    \      let mut class_name = class_name.to_lowercase();\n        let mut extension\
    \ = extension.to_lowercase();\n        let mut count = 0;\n        while class_name.contains(&extension)\
    \ {\n            class_name = class_name.remove(&extension);\n            count++;\n\
    \        }\n        strength = if count > 0 {\n            count as i32 / extension.chars().count()\
    \ as i32\n        } else {\n            -1\n        };\n    }\n    format!(\"\
    {}.{}\", class_name, extensions[strength])\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp4ufjx1o9.rs:24:19\n\
    \   |\n24 |             count++;\n   |                   ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4ufjx1o9.rs:23:44\n   |\n23 |\
    \             class_name = class_name.remove(&extension);\n   |              \
    \                              ^^^^^^^^^^ expected `usize`, found `&String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4ufjx1o9.rs:23:26\n   |\n23 |  \
    \           class_name = class_name.remove(&extension);\n   |                \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                          |\n   |                      \
    \    expected struct `String`, found `char`\n\nerror[E0277]: the type `[String]`\
    \ cannot be indexed by `i32`\n  --> /tmp/tmp4ufjx1o9.rs:32:34\n   |\n32 |    \
    \ format!(\"{}.{}\", class_name, extensions[strength])\n   |                 \
    \                 ^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not implemented\
    \ for `i32`\n   = note: required because of the requirements on the impl of `Index<i32>`\
    \ for `Vec<String>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for extension in extensions {\n  \
    \      let mut cap = String::new();\n        let mut sm = String::new();\n   \
    \     for c in extension.chars() {\n            if c.is_uppercase() {\n      \
    \          cap.push(c);\n            } else {\n                sm.push(c);\n \
    \           }\n        }\n        let cap_len = cap.chars().count();\n       \
    \ let sm_len = sm.chars().count();\n        let cap_diff = cap_len - sm_len;\n\
    \        let strength = if cap_diff > 0 {\n            cap_diff / cap_len\n  \
    \      } else {\n            sm_len / cap_len\n        };\n        if strength\
    \ > strength {\n            extension = extension;\n            strength = strength;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmpnustvupf.rs:16:13\n\
    \   |\n16 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `extension`\
    \ is never read\n  --> /tmp/tmpnustvupf.rs:37:13\n   |\n37 |             extension\
    \ = extension;\n   |             ^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `strength` is never read\n  --> /tmp/tmpnustvupf.rs:38:13\n\
    \   |\n38 |             strength = strength;\n   |             ^^^^^^^^\n   |\n\
    \   = help: maybe it is overwritten before being read?\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpnustvupf.rs:16:9\n   |\n16 |     let mut\
    \ strength = -1;\n   |         ----^^^^^^^^\n   |         |\n   |         help:\
    \ remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\n\
    warning: variable does not need to be mutable\n  --> /tmp/tmpnustvupf.rs:17:9\n\
    \   |\n17 |     let mut extension = String::new();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nerror[E0384]: cannot\
    \ assign twice to immutable variable `extension`\n  --> /tmp/tmpnustvupf.rs:37:13\n\
    \   |\n18 |     for extension in extensions {\n   |         ---------\n   |  \
    \       |\n   |         first assignment to `extension`\n   |         help: consider\
    \ making this binding mutable: `mut extension`\n...\n37 |             extension\
    \ = extension;\n   |             ^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror[E0384]: cannot assign twice to immutable variable `strength`\n  --> /tmp/tmpnustvupf.rs:38:13\n\
    \   |\n31 |         let strength = if cap_diff > 0 {\n   |             --------\n\
    \   |             |\n   |             first assignment to `strength`\n   |   \
    \          help: consider making this binding mutable: `mut strength`\n...\n38\
    \ |             strength = strength;\n   |             ^^^^^^^^^^^^^^^^^^^ cannot\
    \ assign twice to immutable vari"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for e in extensions {\n        let\
    \ cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm = e.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let strength = if cap > sm {\n         \
    \   cap - sm\n        } else {\n            sm - cap\n        };\n        if strength\
    \ > strength {\n            extension = e;\n            strength = strength;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmp795bxivi.rs:16:13\n\
    \   |\n16 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `strength`\
    \ is never read\n  --> /tmp/tmp795bxivi.rs:28:13\n   |\n28 |             strength\
    \ = strength;\n   |             ^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmp795bxivi.rs:16:9\n   |\n\
    16 |     let mut strength = -1;\n   |         ----^^^^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0384]: cannot assign twice to immutable variable `strength`\n\
    \  --> /tmp/tmp795bxivi.rs:28:13\n   |\n21 |         let strength = if cap > sm\
    \ {\n   |             --------\n   |             |\n   |             first assignment\
    \ to `strength`\n   |             help: consider making this binding mutable:\
    \ `mut strength`\n...\n28 |             strength = strength;\n   |           \
    \  ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to previous error; 3 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_uppercase(),\
    \ c.to_lowercase());\n        }\n        extensions_map.insert(extension.clone(),\
    \ extension_map);\n    }\n    let mut strength = -1;\n    let mut best_extension\
    \ = String::new();\n    for (extension, extension_map) in extensions_map.iter()\
    \ {\n        let mut extension_strength = -1;\n        for (key, value) in extension_map.iter()\
    \ {\n            let c = key.chars().filter(|c| c.to_uppercase() == c).count();\n\
    \            let s = key.chars().filter(|c| c.to_lowercase() == c).count();\n\
    \            extension_strength = extension_strength.max(|a, b| a.cmp(b));\n \
    \           extension_strength = extension_strength.max(|a, b| a.cmp(b));\n  \
    \      }\n        if extension_strength > strength {\n            strength = extension_strength;\n\
    \            best_extension = extension.clone();\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, best_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpl83gnvn7.rs:16:30\n   |\n16 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpl83gnvn7.rs:18:33\n   |\n18 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension {\n            match extension_map.entry(c) {\n  \
    \              hash_map::Entry::Occupied(mut e) => {\n                    let\
    \ count = e.get_or_insert(0);\n                    *count += 1;\n            \
    \    }\n                hash_map::Entry::Vacant(e) => {\n                    *e.insert(1);\n\
    \                }\n            }\n        }\n        extensions_map.insert(extension,\
    \ extension_map);\n    }\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let \n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpnc7_3ei5.rs:69:1\n  \
    \ |\n69 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared crate or module `hash_map`\n  --> /tmp/tmpnc7_3ei5.rs:21:17\n   |\n\
    21 |                 hash_map::Entry::Occupied(mut e) => {\n   |             \
    \    ^^^^^^^^ use of undeclared crate or module `hash_map`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `hash_map`\n  --> /tmp/tmpnc7_3ei5.rs:25:17\n\
    \   |\n25 |                 hash_map::Entry::Vacant(e) => {\n   |            \
    \     ^^^^^^^^ use of undeclared crate or module `hash_map`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpnc7_3ei5.rs:16:30\n\
    \   |\n16 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpnc7_3ei5.rs:18:33\n\
    \   |\n18 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ `String` is not an iterator\n   --> /tmp/tmpnc7_3ei5.rs:19:18\n    |\n19  |\
    \         for c in extension {\n    |                  ^^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait\
    \ `Iterator` is not implemented for `String`\n    = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = 0;\n        for c in extension.chars() {\n\
    \            if c.is_uppercase() {\n                extension_map.insert(c.to_string(),\
    \ 1);\n            } else {\n                extension_map.insert(c.to_string(),\
    \ -1);\n            }\n            extension_strength += extension_map.get(&c.to_string()).unwrap();\n\
    \        }\n        extensions_map.insert(extension.to_string(), extension_strength);\n\
    \    }\n    let mut max_strength = -1;\n    let mut max_extension = String::new();\n\
    \    for extension in extensions_map.keys() {\n        if extensions_map.get(extension).unwrap()\
    \ > max_strength {\n            max_strength = extensions_map.get(extension).unwrap();\n\
    \            max_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpzrjbks18.rs:16:30\n   |\n16 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpzrjbks18.rs:18:33\n   |\n18 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzrjbks18.rs:38:31\n   |\n\
    38 |     return class_name + \".\" + max_extension;\n   |                    \
    \           ^^^^^^^^^^^^^\n   |                               |\n   |        \
    \                       expected `&str`, found struct `String`\n   |         \
    \                      help: consider borrowing here: `&max_extension`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut strongest_extension_strength = -1;\n    for extension\
    \ in extensions {\n        let mut extension_strength = extension.chars().filter(|c|\
    \ c.is_uppercase()).count() - extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension;\n            strongest_extension_strength = extension_strength;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdpecm0iw.rs:17:44\n\
    \   |\n17 |     let mut strongest_extension_strength = -1;\n   |             \
    \                               ^^ the trait `Neg` is not implemented for `usize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for e in extensions {\n        let\
    \ cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm = e.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        strength = if cap > sm {\n            cap\
    \ - sm\n        } else {\n            sm\n        };\n        extension = extension.concat(e);\n\
    \    }\n    extension.concat(\".\").concat(class_name.to_lowercase()).concat(\"\
    .\").concat(extensions[extensions.iter().position(|e| e.to_lowercase().contains(extension.to_lowercase())).unwrap()].to_lowercase());\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbdy9cctw.rs:26:31\n   |\n26 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpbdy9cctw.rs:16:24\n   |\n16 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbdy9cctw.rs:28:15\n   |\n28 |     extension.concat(\".\"\
    ).concat(class_name.to_lowercase()).concat(\".\").concat(extensions[extensions.iter().position(|e|\
    \ e.to_lowercase()...\n   |               ^^^^^^ method not found in `String`\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  --> /tmp/tmpbdy9cctw.rs:28:148\n\
    \   |\n28 | ....to_lowercase().contains(extension.to_lowercase())).unwrap()].to_lowercase());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^\n   |             \
    \                |\n   |                             expected an implementor of\
    \ trait `Pattern<'_>`\n   |                             help: consider borrowing\
    \ here: `&extension.to_lowercase()`\n   |\n   = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbdy9cctw.rs:15:72\n   |\n15 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_uppercase(),\
    \ c.to_lowercase());\n        }\n        extensions_map.insert(extension.clone(),\
    \ extension_map);\n    }\n    let mut strength = -1;\n    let mut extension =\
    \ String::new();\n    let mut extension_map = extensions_map.get(&class_name);\n\
    \    if extension_map.is_none() {\n        return \"\";\n    }\n    for c in extension_map.keys().cloned()\
    \ {\n        if strength == -1 || strength > extension_map.get(c).len() {\n  \
    \          extension = c.to_string();\n            strength = extension_map.get(c).len();\n\
    \        }\n    }\n    extension.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpe5grbd4i.rs:16:30\n   |\n16 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpe5grbd4i.rs:18:33\n   |\n18 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe5grbd4i.rs:28:16\n   |\n\
    15 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |                                                                    \
    \    ------ expected `String` because of return type\n...\n28 |         return\
    \ \"\";\n   |                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                |\n   |                expected struct `String`, found `&str`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for e in extensions {\n        let\
    \ mut c = e.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n        let mut\
    \ s = e.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n        if c > s\
    \ {\n            strength = -1;\n            extension = e;\n        } else if\
    \ c < s {\n            strength = s;\n            extension = e;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpklf0kh3b.rs:16:24\n\
    \   |\n16 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpklf0kh3b.rs:22:24\n   |\n22 |         \
    \    strength = -1;\n   |                        ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for extension in extensions {\n  \
    \      let mut class_name = class_name.to_string();\n        let mut extension\
    \ = extension.to_string();\n        let mut cap = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let mut sm = class_name.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let strength = cap - sm;\n        if\
    \ strength > 0 {\n            break;\n        }\n    }\n    extension.to_string().to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkr9g9eb6.rs:21:58\n   |\n\
    21 |         let mut cap = class_name.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                          ^^^\n   |     \
    \                                                     |\n   |                \
    \                                          expected `&char`, found `char`\n  \
    \ |                                                          help: consider borrowing\
    \ here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkr9g9eb6.rs:21:70\n\
    \   |\n21 |         let mut cap = class_name.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').count();\n   |                                                     \
    \                 ^^^\n   |                                                  \
    \                    |\n   |                                                 \
    \                     expected `&char`, found `char`\n   |                   \
    \                                                   help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkr9g9eb6.rs:22:57\n\
    \   |\n22 |         let mut sm = class_name.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count();\n   |                                                        \
    \ ^^^\n   |                                                         |\n   |  \
    \                                                       expected `&char`, found\
    \ `char`\n   |                                                         help: consider\
    \ borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkr9g9eb6.rs:22:69\n\
    \   |\n22 |         let mut sm = class_name.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count();\n   |                                                        \
    \             ^^^\n   |                                                      \
    \               |\n   |                                                      \
    \               expected `&char`, found `char`\n   |                         \
    \                                            help: consider borrowing here: `&'z'`\n\
    \nerror: aborting due to 4 previous errors\n\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strongest_extension\
    \ = String::new();\n    let mut extensions_count = extensions.length;\n    let\
    \ mut extensions_cap = extensions_count.to_f64();\n    let mut extensions_sm =\
    \ extensions_count.to_f64();\n    let mut extensions_strength = -1;\n    let mut\
    \ extensions_index = -1;\n    let mut extensions_name = String::new();\n    \n\
    \    while extensions_count > 0 {\n        extensions_index = extensions_cap.floor();\n\
    \        extensions_cap = extensions_cap.sub(1.0);\n        extensions_sm = extensions_sm.sub(1.0);\n\
    \        extensions_strength = extensions_cap - extensions_sm;\n        extensions_name\
    \ = extensions[extensions_index];\n        \n        if extensions_strength >\
    \ 0 {\n            strongest_extension = format!(\"{}.{}\", class_name, extensions_name);\n\
    \            break;\n        }\n        \n        extensions_count--;\n    }\n\
    \    \n    return strongest_extension;\n}\n\nfn main() {\n    let candidate =\
    \ Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"\
    tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"\
    Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpbcwp8w32.rs:36:27\n\
    \   |\n36 |         extensions_count--;\n   |                           ^ expected\
    \ expression\n\nerror[E0609]: no field `length` on type `Vec<String>`\n  --> /tmp/tmpbcwp8w32.rs:17:43\n\
    \   |\n17 |     let mut extensions_count = extensions.length;\n   |          \
    \                                 ^^^^^^ unknown field\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpbcwp8w32.rs:21:32\n   |\n\
    21 |     let mut extensions_index = -1;\n   |                                ^^\
    \ the trait `Neg` is not implemented for `usize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749028
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::new();\n    for e in extensions {\n        let\
    \ cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm = e.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        strength = if cap > sm {\n            cap\
    \ - sm\n        } else {\n            sm\n        };\n        extension = extension.concat(e);\n\
    \    }\n    extension.concat(\".\").concat(class_name.to_lowercase()).concat(\"\
    .\").concat(extensions[strength].to_lowercase());\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp4nfj9cxl.rs:26:31\n   |\n26 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp4nfj9cxl.rs:16:24\n   |\n16 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp4nfj9cxl.rs:28:15\n   |\n28 |     extension.concat(\".\"\
    ).concat(class_name.to_lowercase()).concat(\".\").concat(extensions[strength].to_lowercase());\n\
    \   |               ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4nfj9cxl.rs:15:72\n   |\n15 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749028
