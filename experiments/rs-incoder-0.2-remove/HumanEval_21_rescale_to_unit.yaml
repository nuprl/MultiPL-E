name: HumanEval_21_rescale_to_unit
language: rs
prompt: "/// Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n/// such that the smallest number will become 0 and the largest\
  \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n"
tests: "}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
  \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
  \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
  \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
  \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
  \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
completions: ["    let mut min_number = numbers.iter().min().unwrap();\n    let mut\
    \ max_number = numbers.iter().max().unwrap();\n    let mut new_numbers = Vec::new();\n\
    \    new_numbers.extend_from_slice(&numbers);\n    new_numbers.sort_unstable();\n\
    \    new_numbers.iter_mut().for_each(|n| {\n        *n = ((*n - min_number) /\
    \ (max_number - min_number)) * 2.0 + 0.0;\n    });\n    new_numbers", "    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers", "    let mut min = numbers[0];\n    let mut max\
    \ = numbers[0];\n    for n in numbers {\n        if n < min {\n            min\
    \ = n;\n        }\n        if n > max {\n            max = n;\n        }\n   \
    \ }\n    let mut rescaled: Vec<f64> = Vec::new();\n    for n in numbers {\n  \
    \      rescaled.push((n - min) / (max - min));\n    }\n    rescaled", "    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min_val)\
    \ / (max_val - min_val));\n    }\n    rescaled_numbers", "    let mut min_value\
    \ = numbers[0];\n    let mut max_value = numbers[0];\n    for n in numbers {\n\
    \        if n < min_value {\n            min_value = n;\n        }\n        if\
    \ n > max_value {\n            max_value = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min_value)\
    \ / (max_value - min_value));\n    }\n    rescaled_numbers", "    let mut min\
    \ = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n     \
    \   if n < min {\n            min = n;\n        }\n        if n > max {\n    \
    \        max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers", "    let mut min_value = numbers[0];\n    let mut\
    \ max_value = numbers[0];\n    for &n in numbers {\n        if n < min_value {\n\
    \            min_value = n;\n        }\n        if n > max_value {\n         \
    \   max_value = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for &n in numbers {\n        let new_n = ((n - min_value) / (max_value -\
    \ min_value)) * 2.0 + 0.0;\n        new_numbers.push_back(new_n);\n    }\n   \
    \ new_numbers", "    let mut min_value = numbers[0];\n    let mut max_value =\
    \ numbers[0];\n    for n in numbers {\n        if n < min_value {\n          \
    \  min_value = n;\n        }\n        if n > max_value {\n            max_value\
    \ = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n    for\
    \ n in numbers {\n        rescaled_numbers.push(n / max_value - min_value / max_value);\n\
    \    }\n    rescaled_numbers", "    let mut min_value = numbers[0];\n    let mut\
    \ max_value = numbers[0];\n    for n in numbers {\n        if n < min_value {\n\
    \            min_value = n;\n        }\n        if n > max_value {\n         \
    \   max_value = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min_value) / (max_value\
    \ - min_value));\n    }\n    rescaled_numbers", "    let mut min_value = numbers[0];\n\
    \    let mut max_value = numbers[0];\n    for n in numbers {\n        if n < min_value\
    \ {\n            min_value = n;\n        }\n        if n > max_value {\n     \
    \       max_value = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min_value) / (max_value\
    \ - min_value));\n    }\n    rescaled_numbers", "    let mut min = numbers[0];\n\
    \    let mut max = numbers[0];\n    for n in numbers {\n        if n < min {\n\
    \            min = n;\n        }\n        if n > max {\n            max = n;\n\
    \        }\n    }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers\
    \ {\n        rescaled_numbers.push((n - min) / (max - min));\n    }\n    rescaled_numbers",
  "    let mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers", "    let mut rescaled_numbers = Vec::new();\n \
    \   let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ number in numbers {\n        if number < smallest {\n            smallest =\
    \ number;\n        }\n        if number > largest {\n            largest = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest);\n        rescaled_numbers.push(number - largest);\n    }\n    rescaled_numbers",
  "    let mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let\
    \ mut largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n\
    \            smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        rescaled.push((n - smallest)\
    \ / (largest - smallest));\n    }\n    rescaled", "    let mut new_numbers = Vec::new();\n\
    \    let mut min_number = numbers.iter().min().unwrap();\n    let mut max_number\
    \ = numbers.iter().max().unwrap();\n    new_numbers.extend_from_slice(&[min_number]);\n\
    \    new_numbers.extend_from_slice(&[max_number]);\n    new_numbers", "    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers", "    let mut rescaled_numbers = Vec::new();\n \
    \   let mut smallest_number = numbers[0];\n    let mut largest_number = numbers[0];\n\
    \    for number in numbers {\n        if number < smallest_number {\n        \
    \    smallest_number = number;\n        }\n        if number > largest_number\
    \ {\n            largest_number = number;\n        }\n    }\n    for number in\
    \ numbers {\n        rescaled_numbers.push(smallest_number + (number - smallest_number)\
    \ / (largest_number - smallest_number) * (largest_number - smallest_number));\n\
    \    }\n    rescaled_numbers", "    let mut min_value = numbers[0];\n    let mut\
    \ max_value = numbers[0];\n    for n in numbers {\n        if n < min_value {\n\
    \            min_value = n;\n        }\n        if n > max_value {\n         \
    \   max_value = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let new_n = ((n - min_value) / (max_value - min_value))\
    \ * 2.0 + 0.0;\n        new_numbers.push(new_n);\n    }\n    new_numbers", " \
    \   let mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let\
    \ mut largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n\
    \            smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        rescaled.push((n - smallest)\
    \ / (largest - smallest));\n    }\n    rescaled", "    let mut rescaled_numbers\
    \ = Vec::new();\n    let mut smallest_number = numbers[0];\n    let mut largest_number\
    \ = numbers[0];\n    for number in numbers {\n        if number < smallest_number\
    \ {\n            smallest_number = number;\n        }\n        if number > largest_number\
    \ {\n            largest_number = number;\n        }\n    }\n    for number in\
    \ numbers {\n        rescaled_numbers.push(number - smallest_number);\n      \
    \  rescaled_numbers.push(number - largest_number);\n    }\n    rescaled_numbers"]
stop_tokens:
- "\n}"
