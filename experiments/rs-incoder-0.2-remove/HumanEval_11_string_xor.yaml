name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
  \ String, b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        result.push_str(&a[i..].iter().map(|c|\
    \ match c {\n            0 => \"0\",\n            1 => \"1\",\n            _ =>\
    \ unreachable!(),\n        }).collect::<String>());\n    }\n    for i in 0..b.len()\
    \ {\n        result.push_str(&b[i..].iter().map(|c| match c {\n            0 =>\
    \ \"0\",\n            1 => \"1\",\n            _ => unreachable!(),\n        }).collect::<String>());\n\
    \    }\n    result", "    let mut result = String::new();\n    for &c in &a {\
    \ result.push(c); }\n    for &c in &b { result.push(c); }\n    result", "    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in a.chars() {\n        result.push((c ^ b.chars().nth(0)).to_string());\n\
    \    }\n    result", "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n    }\n    res",
  '    a.to_owned() + b.to_owned()', "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut res = String::new();\n    for i in 0..a.len() {\n \
    \       res.push_str(&a[i..].iter().filter(|&x| x == b[i]).collect::<String>());\n\
    \    }\n    res", "    let mut res = String::new();\n    for i in 0..a.len() {\n\
    \        res.push_str(&a[i] ^ b[i]);\n    }\n    res", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", '    a.to_owned() + b.to_owned()', '    a.to_owned() + b.to_owned()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', "    let mut result\
    \ = String::new();\n    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c);\
    \ }\n    result", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n\
    \    }\n    result", "    let mut result = String::new();\n    for &c in &a {\
    \ result.push(c); }\n    for &c in &b { result.push(c); }\n    result", "    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&c|\
    \ c == '1').collect::<String>());\n        res.push_str(&b[i..].iter().filter(|&c|\
    \ c == '1').collect::<String>());\n    }\n    res", "    let mut res = String::new();\n\
    \    for &c in &a { res.push(c); }\n    for &c in &b { res.push(c); }\n    res",
  "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars()) {\n\
    \        if *c != *c {\n            result.push(*c);\n        }\n    }\n    result",
  '    a.to_owned() + b.to_owned()', "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut res = String::new();\n    for i in\
    \ 0..a.len() {\n        res.push_str(&a[i ^ b.len()]);\n    }\n    res", "   \
    \ let mut result = String::new();\n    for &c in a.chars().zip(b.chars()) {\n\
    \        if *c != *c {\n            result.push(*c);\n        }\n    }\n    result",
  "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars()) {\n\
    \        result.push((*c).xor(*c).to_string());\n    }\n    result", "    let\
    \ mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n       \
    \ res.push_str(c.0);\n        res.push_str(c.1);\n    }\n    res", "    let mut\
    \ res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a.chars()\n\
    \            .skip(i)\n            .take(b.len())\n            .filter(|c| c.to_digit(16).is_some())\n\
    \            .collect::<Vec<_>>()\n            .join(\"\"));\n    }\n    for i\
    \ in 0..b.len() {\n        res.push_str(&b.chars()\n            .skip(i)\n   \
    \         .take(a.len())\n            .filter(|c| c.to_digit(16).is_some())\n\
    \            .collect::<Vec<_>>()\n            .join(\"\"));\n    }\n    res",
  '    String::from_utf8(a.chars().zip(b.chars()).filter(|(a, b)| a != b).map(|(a,
    b)| a ^ b).collect())', "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        result.push((*c).xor(*c).to_string());\n    }\n    result", "   \
    \ let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result", " \
    \   let mut result = String::new();\n    for &c in &a { result.push(c); }\n  \
    \  for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in a.chars().zip(b.chars()) {\n        result.push((*c).0 ^ (*c).1);\n\
    \    }\n    result", "    let mut result = String::new();\n    for &c in &a {\
    \ result.push(c); }\n    for &c in &b { result.push(c); }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result", "  \
    \  let mut res = String::new();\n    for &c in &a { res += &c ^ &b[c.to_digit(10).unwrap()];\
    \ }\n    res", "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        result.push((*c).xor(*c).to_string());\n    }\n    result", "   \
    \ let mut result = String::new();\n    for &c in &a { result.push(c); }\n    for\
    \ &c in &b { result.push(c); }\n    result", '    a.to_owned() + b.to_owned()',
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n           \
    \ result.push(*c);\n        }\n    }\n    result", "    let mut result = String::new();\n\
    \    for &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n           \
    \ result.push(*c);\n        }\n    }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut result = String::new();\n    for i in 0..a.len() {\n\
    \        result.push(a[i] ^ b[i]);\n    }\n    result", "    let mut result =\
    \ String::new();\n    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c);\
    \ }\n    result", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut result =\
    \ String::new();\n    for &c in a.chars().cloned() {\n        result.push((c ^\
    \ b.chars().next().unwrap()).to_string());\n    }\n    result", "    let mut result\
    \ = String::new();\n    for &c in a.chars().cloned() {\n        result.push((c\
    \ ^ b[a.chars().index(c)]).to_string());\n    }\n    result", "    let mut result\
    \ = String::new();\n    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n\
    \    }\n    result", "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].chars().filter(|c| b[i] == c).collect::<String>());\n\
    \    }\n    res", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n\
    \    }\n    result", "    let mut result = String::new();\n    for &c in a.chars().cloned()\
    \ {\n        result.push((c ^ b.chars().nth(c.len() - 1)).to_string());\n    }\n\
    \    result", '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', " \
    \   let mut result = String::new();\n    for &c in &a { result.push(c); }\n  \
    \  for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut res = String::new();\n    for i in 0..a.len() {\n \
    \       res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n    }\n    res",
  '    a.to_owned() & b.to_owned()', "    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result", "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        result.push_str(&a[i] ^ b[i]);\n\
    \    }\n    result", "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a[i] != b[i] {\n            result.push('a');\n        } else\
    \ {\n            result.push('0');\n        }\n    }\n    result", "    let mut\
    \ result = String::new();\n    for &c in &a { result.push(c); }\n    for &c in\
    \ &b { result.push(c); }\n    result", '    a.to_owned() + b.to_owned()', "  \
    \  let mut result = String::new();\n    for &c in a.chars() {\n        result.push((c\
    \ ^ b[c.to_digit()]).to_string());\n    }\n    result", "    let mut result =\
    \ String::new();\n    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c);\
    \ }\n    result", "    let mut res = String::new();\n    for i in 0..a.len() {\n\
    \        res.push_str(&a[i] ^ b[i]);\n    }\n    res", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result .push_char(a ^ b);\n    }\n    result", "    let mut result\
    \ = String::new();\n    for &c in a.chars().zip(b.chars()) {\n        if *c !=\
    \ *c {\n            result.push(*c);\n        }\n    }\n    result", "    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut res = String::new();\n\
    \    for &c in &a { res.push(c); }\n    for &c in &b { res.push(c); }\n    res",
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).0 ^ (*c).1);\n  \
    \  }\n    result", "    let mut result = String::new();\n    for &c in a.chars().cloned()\
    \ {\n        result.push(c);\n    }\n    for &c in b.chars().cloned() {\n    \
    \    result.push(c);\n    }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut res = String::new();\n    for i in 0..a.len() {\n \
    \       res.push_str(&a[i..].iter().map(|c| match c {\n            0 => \"0\"\
    ,\n            1 => \"1\",\n            _ => unreachable!(),\n        }).collect::<String>());\n\
    \        res.push_str(&b[i..].iter().map(|c| match c {\n            0 => \"0\"\
    ,\n            1 => \"1\",\n            _ => unreachable!(),\n        }).collect::<String>());\n\
    \    }\n    res", "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push_str(&a.chars()[i].xor(&b.chars()[i]).to_string());\n\
    \    }\n    result", "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        result.push((*c).xor(*c).to_string());\n    }\n    result", "   \
    \ let mut result = String::new();\n    for &c in &a { result.push(c); }\n    for\
    \ &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars()) {\n\
    \        if *c != *c {\n            result.push(*c);\n        }\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push_str(&a.chars().nth(i).unwrap()\
    \ ^ b.chars().nth(i).unwrap());\n    }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", '    a.to_owned() + b.to_owned()', "    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_owned()\n        .to_string()", "    let mut\
    \ res = String::new();\n    for &c in a.chars().cloned() {\n        res.push_str(&format!(\"\
    {:02x}\", c ^ b.chars().nth(c.to_digit(16).unwrap()).unwrap()));\n    }\n    res",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result", "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        if *c != *c {\n            result.push(*c);\n        }\n    }\n \
    \   result", '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", '    a.to_owned() + b.to_owned()', "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut res = String::new();\n\
    \    for &c in a.chars() {\n        res.push_str(&c.to_string() ^ b.chars().next().unwrap().to_string());\n\
    \    }\n    res", "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        result .push_str(&format!(\"{:02x}\", c ^ c));\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  \
    \      .iter()\n        .map(|x| format!(\"{:02b}\", x))\n        .collect::<Vec<_>>()\n\
    \        .to_string()", "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i ^ b.as_bytes()[i]]);\n    }\n    res", '    a.to_owned()
    + b.to_owned()', "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n\
    \    }\n    result", "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a[i] != b[i] {\n            result.push('a');\n        } else\
    \ {\n            result.push('0');\n        }\n    }\n    result", "    let mut\
    \ res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a.chars()[i\
    \ ^ b.chars().nth(i).unwrap()]);\n    }\n    res", "    let mut res = String::new();\n\
    \    for &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n           \
    \ res.push_str(&format!(\"{}\", *c));\n        } else {\n            res.push_str(&format!(\"\
    {}\", *c));\n        }\n    }\n    res", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n\
    \    }\n    result", "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result", "    let mut result\
    \ = String::new();\n    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c);\
    \ }\n    result", "    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_owned()\n        .to_string()", "    let mut\
    \ res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n        res.push_str(&format!(\"\
    {:02x}\", c ^ c));\n    }\n    res", "    let mut res = String::new();\n    for\
    \ i in 0..a.len() {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res", " \
    \   let mut result = String::new();\n    for &c in &a { result.push(c); }\n  \
    \  for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n    }\n    result", '    a.to_owned() & b.to_owned()',
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut res = String::new();\n    for i in\
    \ 0..a.len() {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res", "    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        if a[i] != b[i]\
    \ {\n            result.push('a');\n        } else {\n            result.push('0');\n\
    \        }\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", '    a.to_owned() + b.to_owned()',
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n           \
    \ result.push(*c);\n        }\n    }\n    result", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result", '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  '    a.to_owned() + b.to_owned()', "    let mut res = String::new();\n    for &c\
    \ in &a { res.push(c); }\n    for &c in &b { res.push(c); }\n    res", "    let\
    \ mut result = String::new();\n    for &c in a.chars().zip(b.chars()) {\n    \
    \    result.push((*c).xor(*c).to_string());\n    }\n    result", "    let mut\
    \ result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n    \
    \    result .push((a ^ b) as char);\n    }\n    result", '    a.to_owned() + b.to_owned()',
  '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()', "    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result",
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', "    let mut result\
    \ = String::new();\n    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c);\
    \ }\n    result", '    a.to_owned() + b.to_owned()', "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  "    let mut res = String::new();\n    for &c in a.chars().cloned() {\n        res.push_str(&format!(\"\
    {:02x}\", c ^ b.chars().nth(c.to_digit(16).unwrap()).unwrap()));\n    }\n    res",
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut res = String::new();\n    for &c\
    \ in a.chars().zip(b.chars()).filter(|&(c1, _)| c1 != 0) {\n        res.push_str(&format!(\"\
    {:02x}\", c));\n    }\n    res", "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        if a != b {\n            result.push('a');\n        } else {\n  \
    \          result.push('0');\n        }\n    }\n    result", "    let mut result\
    \ = String::new();\n    for &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result", "    let mut result = String::new();\n    for &c in a.chars().chain(b.chars())\
    \ {\n        match c {\n            '1' => result.push(c),\n            '0' =>\
    \ result.push(c),\n            _ => result.push(c),\n        }\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut res = String::new();\n\
    \    for &c in a.chars() {\n        res.push_str(&format!(\"{:?}\", c ^ b.chars().nth(c.to_digit(10).unwrap())));\n\
    \    }\n    res", "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result", "    let mut result\
    \ = String::new();\n    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c);\
    \ }\n    result", '    a.to_owned() + b.to_owned()', "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars()) {\n\
    \        if *c != *c {\n            result.push(*c);\n        }\n    }\n    result",
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', "    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_owned()\n        .to_string()", "    let mut\
    \ result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()\n\
    \        .to_string()", "    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result", "  \
    \  let mut result = String::new();\n    for &c in a.chars().cloned() {\n     \
    \   result.push((c ^ b.chars().nth(c.as_bytes().unwrap())).to_string());\n   \
    \ }\n    result", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut result =\
    \ String::new();\n    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c);\
    \ }\n    result", "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        result.push((c as u8) ^ c.to_digit(10));\n    }\n    result", " \
    \   let mut result = String::new();\n    for &c in &a { result.push(c); }\n  \
    \  for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut result = String::new();\n    for i in 0..a.len() {\n\
    \        result.push(a[i] ^ b[i]);\n    }\n    result", "    let mut res = String::new();\n\
    \    for i in 0..a.len() {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res",
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push_str(&a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result", '    a.to_owned()
    & b.to_owned()', "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut res = String::new();\n\
    \    for i in 0..a.len() {\n        res.push_str(&a.chars()[i].xor(&b.chars()[i]).to_string());\n\
    \    }\n    res", "    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \        .to_owned()\n        .to_string() + b.chars().to_owned()\n        .to_string()\
    \ + a.chars().to_owned()\n        .to_string()", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        result.push((*c).0 ^ (*c).1);\n    }\n    result"]
stop_tokens:
- "\n}"
