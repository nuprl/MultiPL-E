name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
  \ String, b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        result.push_str(&a[i..].iter().map(|c|\
    \ match c {\n            0 => \"0\",\n            1 => \"1\",\n            _ =>\
    \ unreachable!(),\n        }).collect::<String>());\n    }\n    for i in 0..b.len()\
    \ {\n        result.push_str(&b[i..].iter().map(|c| match c {\n            0 =>\
    \ \"0\",\n            1 => \"1\",\n            _ => unreachable!(),\n        }).collect::<String>());\n\
    \    }\n    result", "    let mut result = String::new();\n    for &c in &a {\
    \ result.push(c); }\n    for &c in &b { result.push(c); }\n    result", "    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in a.chars() {\n        result.push((c ^ b.chars().nth(0)).to_string());\n\
    \    }\n    result", "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n    }\n    res",
  '    a.to_owned() + b.to_owned()', "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut res = String::new();\n    for i in 0..a.len() {\n \
    \       res.push_str(&a[i..].iter().filter(|&x| x == b[i]).collect::<String>());\n\
    \    }\n    res", "    let mut res = String::new();\n    for i in 0..a.len() {\n\
    \        res.push_str(&a[i] ^ b[i]);\n    }\n    res", "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", '    a.to_owned() + b.to_owned()', '    a.to_owned() + b.to_owned()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', "    let mut result\
    \ = String::new();\n    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c);\
    \ }\n    result", "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result"]
stop_tokens:
- "\n}"
