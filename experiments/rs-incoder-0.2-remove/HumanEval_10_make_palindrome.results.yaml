language: rs
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reverse_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9zvek0l8.rs:53:29\n   |\n\
    53 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp9zvek0l8.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45 = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_4godlq.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9_4godlq.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp69w81leg.rs:53:34\n   |\n\
    53 |     let mut longest_postfix_index\n   |                                 \
    \ ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp69w81leg.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for pos in 0..string.len() {\n        let postfix_length = string.len()\
    \ - pos - 1;\n        if postfix_length > longest_postfix_length {\n         \
    \   longest_postfix_length = postfix_length;\n        }\n    }\n    let mut postfix_length\
    \ = longest_postfix_length;\n    let mut postfix_string = \"\";\n    while postfix_length\
    \ >= 0 {\n        let postfix_char = string[postfix_length];\n        let postfix_char_code\
    \ = postfix_char.code();\n        let postfix_char_code_hex = postfix_char_code.to_hex();\n\
    \        let postfix_char_code_hex_str = format!(\"{:x}\", postfix_char_code_hex);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_string();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_owned();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_lowercase();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_uppercase();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_lowercase();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_uppercase();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_digit(10);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_digit(10);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(10);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfkvfz0w2.rs:50:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while postfix_length\
    \ >= 0 {\n   |                               - this delimiter might not be properly\
    \ closed...\n...\n41 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n50 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpfkvfz0w2.rs:40:21\n\
    \   |\n40 |         let postfix_\n   |                     ^ help: add `;` here\n\
    41 | }\n   | - unexpected token\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpfkvfz0w2.rs:17:28\n   |\n17 |         let postfix_char\
    \ = string[postfix_length];\n   |                            ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0599]: no method named `to_digit`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpfkvfz0w2.rs:27:67\n\
    \   |\n27 |         let postfix_char_code_hex_str = postfix_char_code_hex_str.to_digit(10);\n\
    \   |                                                                   ^^^^^^^^\
    \ method not found in `String`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfkvfz0w2.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_length_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_length_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_length_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_length_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_length_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_length_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_length_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_length_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_length_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_length_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_length_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_length_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_length_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_length_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_length_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_length_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_length_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_length_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_length_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_length_index21\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpatd2_ti6.rs:52:21\n   |\n\
    52 |     let mut longest_\n   |                     ^ help: add `;` here\n53 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpatd2_ti6.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = String::new();\n\
    \    let mut longest_postfix_length_start = String::new();\n    let mut longest_postfix_length_end\
    \ = String::new();\n    let mut longest_postfix_length_start_index = String::new();\n\
    \    let mut longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpvvt9x16h.rs:41:1\n\
    \   |\n41 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = 0;\n    let mut longest_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_index = -1;\n    let mut\
    \ longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n   \
    \ let mut longest_postfix_postfix_postfix_postfix_postfix = String::new();\n \
    \   let mut longest_postfix_postfix_postfix_postfix_postfix_index = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_length = 0;\n    let mut\
    \ longest_postfix_postfix_postfix_postfix_postfix_postfix = String::new();\n \
    \   let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_length =\
    \ 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_post\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptsir126s.rs:33:65\n   |\n\
    33 |     let mut longest_postfix_postfix_postfix_postfix_postfix_post\n   |  \
    \                                                               ^ help: add `;`\
    \ here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmptsir126s.rs:5:39\n  |\n5 | fn make_palindrome(string: String) -> String\
    \ {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = 0;\n\n    for &c in string.chars() {\n \
    \       if longest_postfix_length < c.len() {\n            longest_postfix_length\
    \ = c.len();\n            longest_postfix = c.to_string();\n            longest_postfix_index\
    \ = longest_postfix.len();\n        }\n        if longest_postfix_length == c.len()\
    \ {\n            longest_postfix_length += 1;\n            longest_postfix = longest_postfix.to_string()\
    \ + &c.to_string();\n        }\n    }\n\n    for &c in string.chars() {\n    \
    \    if longest_postfix_length == c.len() {\n            reversed_string += &c.to_string();\n\
    \        }\n        if longest_postfix_length < c.len() {\n            reversed_string\
    \ += &c.to_string();\n        }\n    }\n\n    reversed_string += &longest_postfix.to_string();\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp83xqop9l.rs:11:9\n   |\n\
    11 |     for &c in string.chars() {\n   |         ^^    -------------- this expression\
    \ has type `char`\n   |         |\n   |         expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp83xqop9l.rs:8:37\n\
    \  |\n8 |     let mut longest_postfix_index = -1;\n  |                       \
    \              ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp83xqop9l.rs:23:9\n   |\n23 |     for &c in string.chars()\
    \ {\n   |         ^^    -------------- this expression has type `char`\n   | \
    \        |\n   |         expected `char`, found reference\n   |\n   = note:  \
    \ expected type `char`\n           found reference `&_`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix = String::new();\n\
    \    let mut longest_postfix_index = -1;\n    let mut longest_postfix_index2 =\
    \ 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4hwblr61.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplynphxtf.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = String::new();\n    let mut prefix_len\
    \ = string.len();\n    let mut suffix_len = string.len();\n    let mut suffix_pos\
    \ = 0;\n    let mut suffix_len = string.len();\n    let mut prefix_pos = 0;\n\
    \    let mut prefix_len = string.len();\n    let mut prefix_pos = 0;\n    let\
    \ mut prefix_len = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n\
    \    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let\
    \ mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos\
    \ = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n\
    \    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let\
    \ mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n\
    \    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let\
    \ mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos\
    \ = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n\
    \    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let\
    \ mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n\
    \    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let\
    \ mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos\
    \ = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n\
    \    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let\
    \ mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n\
    \    let mut suffix_pos = 0;\n    let mut suffix_len = string.len\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwnct0655.rs:62:36\n   |\n\
    62 |     let mut suffix_len = string.len\n   |                               \
    \     ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0615]: attempted\
    \ to take value of method `len` on type `String`\n  --> /tmp/tmpwnct0655.rs:62:33\n\
    \   |\n62 |     let mut suffix_len = string.len\n   |                        \
    \         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n62 |     let mut suffix_len = string.len()\n   |                      \
    \              ++\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwnct0655.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0615.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_index = 0;\n    let mut\
    \ longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n    let\
    \ mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 = 0;\n \
    \   let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7 =\
    \ 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjbc6zaz2.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjbc6zaz2.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpou6_100s.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = string.chars().take_while(|c| !c.is_ascii_lowercase()).count();\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2 =\
    \ 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv8yb87fm.rs:52:11\n   |\n\
    52 |     let mu\n   |           ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpv8yb87fm.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk2nlhorv.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk2nlhorv.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_len = String::new();\n\
    \    let mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start_len = String::new();\n \
    \   let mut longest_postfix_end_len = String::new();\n    let mut longest_postfix_start_pos\
    \ = String::new();\n    let mut longest_postfix_end_pos = String::new();\n   \
    \ let mut longest_postfix_start_pos_len = String::new();\n    let mut longest_postfix_end_pos_len\
    \ = String::new();\n    let mut longest_postfix_start_pos_pos = String::new();\n\
    \    let mut longest_postfix_end_pos_pos = String::new();\n    let mut longest_postfix_start_pos_pos_len\
    \ = String::new();\n    let mut longest_postfix_end_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_start_pos_pos_pos = String::new();\n    let mut longest_postfix_end_pos_pos_pos\
    \ = String::new();\n    let mut longest_postfix_start_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_end_pos_pos_pos_len = String::new();\n    let mut\
    \ longest_postfix_start_pos_pos_pos_len = String::new();\n    let mut longest_postfix_end_pos_pos_pos_len\
    \ = String::new();\n    let mut longest_postfix_start_pos_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_end_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_start_pos_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_end_pos_pos_pos_pos_pos_len = String::new();\n    let mut\
    \ longest_postfix_start_pos_pos_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_end_pos_pos_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_start_pos_pos_pos_pos_pos_pos_len = String::new();\n   \
    \ let mut longest_postfix_end_pos_pos_pos_pos_pos_pos_len = String::new();\n \
    \   let mut longest_postfix_start_pos_pos_pos_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_end_pos_pos_pos_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7bggtpjo.rs:37:29\n   |\n\
    37 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp7bggtpjo.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string_to_reverse = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphtnduhw_.rs:53:29\n   |\n\
    53 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmphtnduhw_.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut palindrome =\
    \ string;\n    let mut reversed_string = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut i = 0;\n    let mut j = 0;\n    while i < string.len()\
    \ && j < palindrome.len() {\n        if string[i] != palindrome[j] {\n       \
    \     break;\n        }\n        i += 1;\n        j += 1;\n    }\n    while i\
    \ < string.len() {\n        reversed_string += string[i];\n        i += 1;\n \
    \   }\n    while j < palindrome.len() {\n        reversed_palindrome += palindrome[j];\n\
    \        j += 1;\n    }\n    reversed_palindrome += reversed_string;\n    reversed_palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpag0bir4p.rs:13:12\n\
    \   |\n13 |         if string[i] != palindrome[j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpag0bir4p.rs:13:25\n   |\n13 |         if string[i]\
    \ != palindrome[j] {\n   |                         ^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpag0bir4p.rs:20:28\n   |\n20 |         reversed_string += string[i];\n\
    \   |                            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpag0bir4p.rs:24:32\n\
    \   |\n24 |         reversed_palindrome += palindrome[j];\n   |              \
    \                  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpag0bir4p.rs:27:28\n   |\n27 |     reversed_palindrome\
    \ += reversed_string;\n   |                            ^^^^^^^^^^^^^^^\n   | \
    \                           |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&reversed_string`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix = \"\";\n\n    while let Some(index)\
    \ = reversed_string.rfind(' ', longest_postfix_length) {\n        let postfix_length\
    \ = index - longest_postfix_start;\n        let postfix = &reversed_string[longest_postfix_start..index];\n\
    \        let postfix_reversed = &reversed_string[index..];\n        if postfix_length\
    \ < longest_postfix_length {\n            longest_postfix_length = postfix_length;\n\
    \            longest_postfix_start = index;\n            longest_postfix_end =\
    \ index;\n            longest_postfix_postfix = postfix;\n        }\n        if\
    \ postfix_length == longest_postfix_length {\n            longest_postfix_postfix\
    \ = postfix_reversed;\n        }\n    }\n\n    longest_postfix_postfix.reverse();\n\
    \    longest_postfix_postfix + &string[longest_postfix_start..]\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpyuoz0xcw.rs:12:45\n     |\n12   |     while let Some(index) =\
    \ reversed_string.rfind(' ', longest_postfix_length) {\n     |               \
    \                              ^^^^^ ---  ---------------------- supplied 2 arguments\n\
    \     |                                             |\n     |                \
    \                             expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \ --> /tmp/tmpyuoz0xcw.rs:8:37\n  |\n8 |     let mut longest_postfix_start = -1;\n\
    \  |                                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \ --> /tmp/tmpyuoz0xcw.rs:9:35\n  |\n9 |     let mut longest_postfix_end = -1;\n\
    \  |                                   ^^ the trait `Neg` is not implemented for\
    \ `usize`\n\nerror[E0599]: no method named `reverse` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpyuoz0xcw.rs:27:29\n   |\n27 |     longest_postfix_postfix.reverse();\n\
    \   |                             ^^^^^^^ method not found in `&str`\n\nerror[E0369]:\
    \ cannot add `&str` to `&str`\n  --> /tmp/tmpyuoz0xcw.rs:28:29\n   |\n28 |   \
    \  longest_postfix_postfix + &string[longest_postfix_start..]\n   |     -----------------------\
    \ ^ -------------------------------- &str\n   |     |                       |\n\
    \   |     |                       `+` cannot be used to concatenate two `&str`\
    \ strings\n   |     &str\n   |\nhelp: `to_owned()` can be used to create an owned\
    \ `String` from a string reference. String concatenation appends the string on\
    \ the right to the string on the left and may require reallocation. This requires\
    \ ownership of the string on the left\n   |\n28 |     longest_postfix_postfix.to_owned()\
    \ + &string[longest_postfix_start..]\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0369, E0599.\nFor more information about an err"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n  \
    \  while suffix_length < palindrome.len() {\n        let mut suffix_start = suffix_length;\n\
    \        while suffix_start < palindrome.len() && palindrome[suffix_start] ==\
    \ palindrome[suffix_start + 1] {\n            suffix_start += 1;\n        }\n\
    \        let mut suffix_end = suffix_start + 1;\n        while suffix_end < palindrome.len()\
    \ && palindrome[suffix_end - 1] == palindrome[suffix_end] {\n            suffix_end\
    \ += 1;\n        }\n        let mut suffix_length = suffix_end - suffix_start\
    \ + 1;\n        let mut prefix_start = prefix_length;\n        while prefix_start\
    \ < suffix_start && palindrome[prefix_start] == palindrome[prefix_start + 1] {\n\
    \            prefix_start += 1;\n        }\n        let mut prefix_end = prefix_start\
    \ + 1;\n        while prefix_end < suffix_end && palindrome[prefix_end - 1] ==\
    \ palindrome[prefix_end] {\n            prefix_end += 1;\n        }\n        let\
    \ mut prefix_length = prefix_end - prefix_start + 1;\n        reversed_string\
    \ += &palindrome[prefix_start..suffix_start];\n        palindrome = &palindrome[suffix_end..];\n\
    \    }\n    reversed_string += &palindrome[prefix_length..];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:12:50\n\
    \   |\n12 |         while suffix_start < palindrome.len() && palindrome[suffix_start]\
    \ == palindrome[suffix_start + 1] {\n   |                                    \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:12:78\n\
    \   |\n12 |         while suffix_start < palindrome.len() && palindrome[suffix_start]\
    \ == palindrome[suffix_start + 1] {\n   |                                    \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:16:48\n   |\n16 |         while suffix_end\
    \ < palindrome.len() && palindrome[suffix_end - 1] == palindrome[suffix_end] {\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:16:78\n   |\n16 |         while\
    \ suffix_end < palindrome.len() && palindrome[suffix_end - 1] == palindrome[suffix_end]\
    \ {\n   |                                                                    \
    \          ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:21:46\n\
    \   |\n21 |         while prefix_start < suffix_start && palindrome[prefix_start]\
    \ == palindrome[prefix_start + 1] {\n   |                                    \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n"
  stdout: ''
  timestamp: 1659805901
