language: rs
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reverse_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9zvek0l8.rs:53:29\n   |\n\
    53 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp9zvek0l8.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45 = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_4godlq.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9_4godlq.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp69w81leg.rs:53:34\n   |\n\
    53 |     let mut longest_postfix_index\n   |                                 \
    \ ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp69w81leg.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for pos in 0..string.len() {\n        let postfix_length = string.len()\
    \ - pos - 1;\n        if postfix_length > longest_postfix_length {\n         \
    \   longest_postfix_length = postfix_length;\n        }\n    }\n    let mut postfix_length\
    \ = longest_postfix_length;\n    let mut postfix_string = \"\";\n    while postfix_length\
    \ >= 0 {\n        let postfix_char = string[postfix_length];\n        let postfix_char_code\
    \ = postfix_char.code();\n        let postfix_char_code_hex = postfix_char_code.to_hex();\n\
    \        let postfix_char_code_hex_str = format!(\"{:x}\", postfix_char_code_hex);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_string();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_owned();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_lowercase();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_uppercase();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_lowercase();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_uppercase();\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_digit(10);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_digit(10);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(10);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_char_code_hex_str = postfix_char_code_hex_str.to_ascii_hex_digit(16);\n\
    \        let postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfkvfz0w2.rs:50:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while postfix_length\
    \ >= 0 {\n   |                               - this delimiter might not be properly\
    \ closed...\n...\n41 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n50 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpfkvfz0w2.rs:40:21\n\
    \   |\n40 |         let postfix_\n   |                     ^ help: add `;` here\n\
    41 | }\n   | - unexpected token\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpfkvfz0w2.rs:17:28\n   |\n17 |         let postfix_char\
    \ = string[postfix_length];\n   |                            ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0599]: no method named `to_digit`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpfkvfz0w2.rs:27:67\n\
    \   |\n27 |         let postfix_char_code_hex_str = postfix_char_code_hex_str.to_digit(10);\n\
    \   |                                                                   ^^^^^^^^\
    \ method not found in `String`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfkvfz0w2.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_length_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_length_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_length_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_length_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_length_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_length_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_length_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_length_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_length_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_length_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_length_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_length_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_length_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_length_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_length_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_length_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_length_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_length_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_length_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_length_index21\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpatd2_ti6.rs:52:21\n   |\n\
    52 |     let mut longest_\n   |                     ^ help: add `;` here\n53 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpatd2_ti6.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = String::new();\n\
    \    let mut longest_postfix_length_start = String::new();\n    let mut longest_postfix_length_end\
    \ = String::new();\n    let mut longest_postfix_length_start_index = String::new();\n\
    \    let mut longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::new();\n    let mut longest_postfix_length_start_index\
    \ = String::new();\n    let mut longest_postfix_length_end_index = String::new();\n\
    \    let mut longest_postfix_length_start_index = String::new();\n    let mut\
    \ longest_postfix_length_end_index = String::\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpvvt9x16h.rs:41:1\n\
    \   |\n41 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = 0;\n    let mut longest_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_index = -1;\n    let mut\
    \ longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n   \
    \ let mut longest_postfix_postfix_postfix_postfix_postfix = String::new();\n \
    \   let mut longest_postfix_postfix_postfix_postfix_postfix_index = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_length = 0;\n    let mut\
    \ longest_postfix_postfix_postfix_postfix_postfix_postfix = String::new();\n \
    \   let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_length =\
    \ 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_post\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptsir126s.rs:33:65\n   |\n\
    33 |     let mut longest_postfix_postfix_postfix_postfix_postfix_post\n   |  \
    \                                                               ^ help: add `;`\
    \ here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmptsir126s.rs:5:39\n  |\n5 | fn make_palindrome(string: String) -> String\
    \ {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = 0;\n\n    for &c in string.chars() {\n \
    \       if longest_postfix_length < c.len() {\n            longest_postfix_length\
    \ = c.len();\n            longest_postfix = c.to_string();\n            longest_postfix_index\
    \ = longest_postfix.len();\n        }\n        if longest_postfix_length == c.len()\
    \ {\n            longest_postfix_length += 1;\n            longest_postfix = longest_postfix.to_string()\
    \ + &c.to_string();\n        }\n    }\n\n    for &c in string.chars() {\n    \
    \    if longest_postfix_length == c.len() {\n            reversed_string += &c.to_string();\n\
    \        }\n        if longest_postfix_length < c.len() {\n            reversed_string\
    \ += &c.to_string();\n        }\n    }\n\n    reversed_string += &longest_postfix.to_string();\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp83xqop9l.rs:11:9\n   |\n\
    11 |     for &c in string.chars() {\n   |         ^^    -------------- this expression\
    \ has type `char`\n   |         |\n   |         expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp83xqop9l.rs:8:37\n\
    \  |\n8 |     let mut longest_postfix_index = -1;\n  |                       \
    \              ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp83xqop9l.rs:23:9\n   |\n23 |     for &c in string.chars()\
    \ {\n   |         ^^    -------------- this expression has type `char`\n   | \
    \        |\n   |         expected `char`, found reference\n   |\n   = note:  \
    \ expected type `char`\n           found reference `&_`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix = String::new();\n\
    \    let mut longest_postfix_index = -1;\n    let mut longest_postfix_index2 =\
    \ 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4hwblr61.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_reversed_string = \"\";\n    let mut longest_postfix_reversed_length\
    \ = 0;\n    let mut longest_postfix_reversed_index = 0;\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n    let mut longest_postfix_reversed_length = 0;\n    let mut longest_postfix_reversed_index\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplynphxtf.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = String::new();\n    let mut prefix_len\
    \ = string.len();\n    let mut suffix_len = string.len();\n    let mut suffix_pos\
    \ = 0;\n    let mut suffix_len = string.len();\n    let mut prefix_pos = 0;\n\
    \    let mut prefix_len = string.len();\n    let mut prefix_pos = 0;\n    let\
    \ mut prefix_len = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n\
    \    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let\
    \ mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos\
    \ = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n\
    \    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let\
    \ mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n\
    \    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let\
    \ mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos\
    \ = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n\
    \    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let\
    \ mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n\
    \    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let\
    \ mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos\
    \ = 0;\n    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n\
    \    let mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let\
    \ mut suffix_len = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n\
    \    let mut suffix_pos = 0;\n    let mut suffix_len = string.len\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwnct0655.rs:62:36\n   |\n\
    62 |     let mut suffix_len = string.len\n   |                               \
    \     ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0615]: attempted\
    \ to take value of method `len` on type `String`\n  --> /tmp/tmpwnct0655.rs:62:33\n\
    \   |\n62 |     let mut suffix_len = string.len\n   |                        \
    \         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n62 |     let mut suffix_len = string.len()\n   |                      \
    \              ++\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwnct0655.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0615.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_index = 0;\n    let mut\
    \ longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n    let\
    \ mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 = 0;\n \
    \   let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7 =\
    \ 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjbc6zaz2.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjbc6zaz2.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpou6_100s.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = string.chars().take_while(|c| !c.is_ascii_lowercase()).count();\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2 =\
    \ 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv8yb87fm.rs:52:11\n   |\n\
    52 |     let mu\n   |           ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpv8yb87fm.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk2nlhorv.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk2nlhorv.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_len = String::new();\n\
    \    let mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start_len = String::new();\n \
    \   let mut longest_postfix_end_len = String::new();\n    let mut longest_postfix_start_pos\
    \ = String::new();\n    let mut longest_postfix_end_pos = String::new();\n   \
    \ let mut longest_postfix_start_pos_len = String::new();\n    let mut longest_postfix_end_pos_len\
    \ = String::new();\n    let mut longest_postfix_start_pos_pos = String::new();\n\
    \    let mut longest_postfix_end_pos_pos = String::new();\n    let mut longest_postfix_start_pos_pos_len\
    \ = String::new();\n    let mut longest_postfix_end_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_start_pos_pos_pos = String::new();\n    let mut longest_postfix_end_pos_pos_pos\
    \ = String::new();\n    let mut longest_postfix_start_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_end_pos_pos_pos_len = String::new();\n    let mut\
    \ longest_postfix_start_pos_pos_pos_len = String::new();\n    let mut longest_postfix_end_pos_pos_pos_len\
    \ = String::new();\n    let mut longest_postfix_start_pos_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_end_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_start_pos_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_end_pos_pos_pos_pos_pos_len = String::new();\n    let mut\
    \ longest_postfix_start_pos_pos_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_end_pos_pos_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_start_pos_pos_pos_pos_pos_pos_len = String::new();\n   \
    \ let mut longest_postfix_end_pos_pos_pos_pos_pos_pos_len = String::new();\n \
    \   let mut longest_postfix_start_pos_pos_pos_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_end_pos_pos_pos_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7bggtpjo.rs:37:29\n   |\n\
    37 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp7bggtpjo.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string_to_reverse = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphtnduhw_.rs:53:29\n   |\n\
    53 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmphtnduhw_.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut palindrome =\
    \ string;\n    let mut reversed_string = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut i = 0;\n    let mut j = 0;\n    while i < string.len()\
    \ && j < palindrome.len() {\n        if string[i] != palindrome[j] {\n       \
    \     break;\n        }\n        i += 1;\n        j += 1;\n    }\n    while i\
    \ < string.len() {\n        reversed_string += string[i];\n        i += 1;\n \
    \   }\n    while j < palindrome.len() {\n        reversed_palindrome += palindrome[j];\n\
    \        j += 1;\n    }\n    reversed_palindrome += reversed_string;\n    reversed_palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpag0bir4p.rs:13:12\n\
    \   |\n13 |         if string[i] != palindrome[j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpag0bir4p.rs:13:25\n   |\n13 |         if string[i]\
    \ != palindrome[j] {\n   |                         ^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpag0bir4p.rs:20:28\n   |\n20 |         reversed_string += string[i];\n\
    \   |                            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpag0bir4p.rs:24:32\n\
    \   |\n24 |         reversed_palindrome += palindrome[j];\n   |              \
    \                  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpag0bir4p.rs:27:28\n   |\n27 |     reversed_palindrome\
    \ += reversed_string;\n   |                            ^^^^^^^^^^^^^^^\n   | \
    \                           |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&reversed_string`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix = \"\";\n\n    while let Some(index)\
    \ = reversed_string.rfind(' ', longest_postfix_length) {\n        let postfix_length\
    \ = index - longest_postfix_start;\n        let postfix = &reversed_string[longest_postfix_start..index];\n\
    \        let postfix_reversed = &reversed_string[index..];\n        if postfix_length\
    \ < longest_postfix_length {\n            longest_postfix_length = postfix_length;\n\
    \            longest_postfix_start = index;\n            longest_postfix_end =\
    \ index;\n            longest_postfix_postfix = postfix;\n        }\n        if\
    \ postfix_length == longest_postfix_length {\n            longest_postfix_postfix\
    \ = postfix_reversed;\n        }\n    }\n\n    longest_postfix_postfix.reverse();\n\
    \    longest_postfix_postfix + &string[longest_postfix_start..]\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpyuoz0xcw.rs:12:45\n     |\n12   |     while let Some(index) =\
    \ reversed_string.rfind(' ', longest_postfix_length) {\n     |               \
    \                              ^^^^^ ---  ---------------------- supplied 2 arguments\n\
    \     |                                             |\n     |                \
    \                             expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \ --> /tmp/tmpyuoz0xcw.rs:8:37\n  |\n8 |     let mut longest_postfix_start = -1;\n\
    \  |                                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \ --> /tmp/tmpyuoz0xcw.rs:9:35\n  |\n9 |     let mut longest_postfix_end = -1;\n\
    \  |                                   ^^ the trait `Neg` is not implemented for\
    \ `usize`\n\nerror[E0599]: no method named `reverse` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpyuoz0xcw.rs:27:29\n   |\n27 |     longest_postfix_postfix.reverse();\n\
    \   |                             ^^^^^^^ method not found in `&str`\n\nerror[E0369]:\
    \ cannot add `&str` to `&str`\n  --> /tmp/tmpyuoz0xcw.rs:28:29\n   |\n28 |   \
    \  longest_postfix_postfix + &string[longest_postfix_start..]\n   |     -----------------------\
    \ ^ -------------------------------- &str\n   |     |                       |\n\
    \   |     |                       `+` cannot be used to concatenate two `&str`\
    \ strings\n   |     &str\n   |\nhelp: `to_owned()` can be used to create an owned\
    \ `String` from a string reference. String concatenation appends the string on\
    \ the right to the string on the left and may require reallocation. This requires\
    \ ownership of the string on the left\n   |\n28 |     longest_postfix_postfix.to_owned()\
    \ + &string[longest_postfix_start..]\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0369, E0599.\nFor more information about an err"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n  \
    \  while suffix_length < palindrome.len() {\n        let mut suffix_start = suffix_length;\n\
    \        while suffix_start < palindrome.len() && palindrome[suffix_start] ==\
    \ palindrome[suffix_start + 1] {\n            suffix_start += 1;\n        }\n\
    \        let mut suffix_end = suffix_start + 1;\n        while suffix_end < palindrome.len()\
    \ && palindrome[suffix_end - 1] == palindrome[suffix_end] {\n            suffix_end\
    \ += 1;\n        }\n        let mut suffix_length = suffix_end - suffix_start\
    \ + 1;\n        let mut prefix_start = prefix_length;\n        while prefix_start\
    \ < suffix_start && palindrome[prefix_start] == palindrome[prefix_start + 1] {\n\
    \            prefix_start += 1;\n        }\n        let mut prefix_end = prefix_start\
    \ + 1;\n        while prefix_end < suffix_end && palindrome[prefix_end - 1] ==\
    \ palindrome[prefix_end] {\n            prefix_end += 1;\n        }\n        let\
    \ mut prefix_length = prefix_end - prefix_start + 1;\n        reversed_string\
    \ += &palindrome[prefix_start..suffix_start];\n        palindrome = &palindrome[suffix_end..];\n\
    \    }\n    reversed_string += &palindrome[prefix_length..];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:12:50\n\
    \   |\n12 |         while suffix_start < palindrome.len() && palindrome[suffix_start]\
    \ == palindrome[suffix_start + 1] {\n   |                                    \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:12:78\n\
    \   |\n12 |         while suffix_start < palindrome.len() && palindrome[suffix_start]\
    \ == palindrome[suffix_start + 1] {\n   |                                    \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:16:48\n   |\n16 |         while suffix_end\
    \ < palindrome.len() && palindrome[suffix_end - 1] == palindrome[suffix_end] {\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:16:78\n   |\n16 |         while\
    \ suffix_end < palindrome.len() && palindrome[suffix_end - 1] == palindrome[suffix_end]\
    \ {\n   |                                                                    \
    \          ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwf5_4v4b.rs:21:46\n\
    \   |\n21 |         while prefix_start < suffix_start && palindrome[prefix_start]\
    \ == palindrome[prefix_start + 1] {\n   |                                    \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_index = 0;\n    let mut\
    \ longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n    let\
    \ mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 = 0;\n \
    \   let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7 =\
    \ 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjbc6zaz2.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjbc6zaz2.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp29ihdkeh.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp29ihdkeh.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut reversed_string_index\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    while longest_postfix_length < reversed_string.len() {\n        let\
    \ mut longest_postfix_length = 0;\n        for index in 0..=reversed_string.len()\
    \ {\n            let mut current_index = index;\n            while current_index\
    \ > 0 && reversed_string[current_index] != reversed_string[current_index - 1]\
    \ {\n                current_index -= 1;\n            }\n            if current_index\
    \ == 0 {\n                longest_postfix_length = index - 1;\n              \
    \  longest_postfix_index = index;\n            }\n        }\n        reversed_string\
    \ = reversed_string[longest_postfix_length..];\n        reversed_string_index\
    \ += longest_postfix_length;\n    }\n    let mut reversed_string_reversed_index\
    \ = reversed_string_index;\n    while reversed_string_reversed_index > 0 {\n \
    \       let mut reversed_string_reversed_index = 0;\n        for index in 0..=reversed_string.len()\
    \ {\n            let mut current_index = index;\n            while current_index\
    \ > 0 && reversed_string[current_index] != reversed_string[current_index - 1]\
    \ {\n                current_index -= 1;\n            }\n            if current_index\
    \ == 0 {\n                reversed_string_reversed_index = index - 1;\n      \
    \          break;\n            }\n        }\n        reversed_string = reversed_string[..reversed_string_reversed_index];\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf91q_5lw.rs:14:40\n\
    \   |\n14 |             while current_index > 0 && reversed_string[current_index]\
    \ != reversed_string[current_index - 1] {\n   |                              \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf91q_5lw.rs:14:74\n   |\n14 |             while current_index >\
    \ 0 && reversed_string[current_index] != reversed_string[current_index - 1] {\n\
    \   |                                                                        \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf91q_5lw.rs:22:27\n\
    \   |\n6  |     let mut reversed_string = string;\n   |                      \
    \         ------ expected due to this value\n...\n22 |         reversed_string\
    \ = reversed_string[longest_postfix_length..];\n   |                         \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_suffix_index = 0;\n    let mut longest_postfix_suffix_length\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_index = 0;\n    let mut longest_postfix_suffix_reversed_length\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string = \"\";\n    let mut\
    \ longest_postfix_suffix_reversed_string_index = 0;\n    let mut longest_postfix_suffix_reversed_string_length\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string_reversed_index = 0;\n\
    \    let mut longest_postfix_suffix_reversed_string_reversed_length = 0;\n   \
    \ let mut longest_postfix_suffix_reversed_string_reversed_string = \"\";\n   \
    \ let mut longest_postfix_suffix_reversed_string_reversed_string_index = 0;\n\
    \    let mut longest_postfix_suffix_reversed_string_reversed_string_length = 0;\n\
    \    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_index\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_length\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_string\
    \ = \"\";\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_string_index\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_string_length\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_string_reversed_index\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_string_reversed_length\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_string_reversed_string\
    \ = \"\";\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_string_reversed_string_index\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_string_reversed_string_length\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string_reversed_string_reversed_string_reversed_string_reversed_index\
    \ = 0;\n    let mut longest_postfix_suffix_reversed_string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3g6w44y6.rs:33:51\n   |\n\
    33 |     let mut longest_postfix_suffix_reversed_string\n   |                \
    \                                   ^ help: add `;` here\n34 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3g6w44y6.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start =\
    \ -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp4ii_ann0.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_len = string.len();\n    let mut longest_postfix = String::new();\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_post\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpik28oqat.rs:56:25\n   |\n\
    56 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    57 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpik28oqat.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n\
    \    while suffix_length != palindrome.len() {\n        suffix_length = palindrome.len();\n\
    \        let mut suffix_start = suffix_length;\n        while suffix_start > 0\
    \ {\n            let mut suffix_end = suffix_start;\n            while suffix_end\
    \ < palindrome.len() {\n                suffix_end += 1;\n                if palindrome[suffix_end\
    \ - 1] != palindrome[suffix_end] {\n                    break;\n             \
    \   }\n            }\n            if suffix_end == palindrome.len() {\n      \
    \          break;\n            }\n            palindrome = &palindrome[..suffix_end\
    \ - 1];\n            suffix_start -= 1;\n        }\n        prefix_length = palindrome.len();\n\
    \        let mut prefix_start = prefix_length;\n        while prefix_start > 0\
    \ {\n            let mut prefix_end = prefix_start;\n            while prefix_end\
    \ < palindrome.len() {\n                prefix_end += 1;\n                if palindrome[prefix_end\
    \ - 1] != palindrome[prefix_end] {\n                    break;\n             \
    \   }\n            }\n            if prefix_end == palindrome.len() {\n      \
    \          break;\n            }\n            palindrome = &palindrome[..prefix_end\
    \ - 1];\n            prefix_start -= 1;\n        }\n        reversed_string +=\
    \ &palindrome[..suffix_length];\n        reversed_string += &palindrome[..prefix_length];\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4fihmk3y.rs:17:20\n\
    \   |\n17 |                 if palindrome[suffix_end - 1] != palindrome[suffix_end]\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4fihmk3y.rs:17:50\n   |\n17 |                 if palindrome[suffix_end\
    \ - 1] != palindrome[suffix_end] {\n   |                                     \
    \             ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4fihmk3y.rs:24:26\n\
    \   |\n6  |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n24 |             palindrome = &palindrome[..suffix_end\
    \ - 1];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n24 |             palindrome = (&palindrome[..suffix_end - 1]).to_string();\n\
    \   |                          +                             +++++++++++++\n\n\
    error[E027"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = string;\n    let mut i = 0;\n    let mut j = 0;\n    while i < string.len()\
    \ && j < reversed_string.len() {\n        if string[i] != reversed_string[j] {\n\
    \            break;\n        }\n        i += 1;\n        j += 1;\n    }\n    string\
    \ = &string[i..];\n    reversed_string = &reversed_string[j..];\n    string +\
    \ &reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4eh8ez2i.rs:11:12\n\
    \   |\n11 |         if string[i] != reversed_string[j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4eh8ez2i.rs:11:25\n   |\n11 |         if string[i] != reversed_string[j]\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4eh8ez2i.rs:17:14\n\
    \   |\n6  |     let mut string = string;\n   |                      ------ expected\
    \ due to this value\n...\n17 |     string = &string[i..];\n   |              ^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n17 |     string = (&string[i..]).to_string();\n   |              +    \
    \        +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4eh8ez2i.rs:18:23\n\
    \   |\n7  |     let mut reversed_string = string;\n   |                      \
    \         ------ expected due to this value\n...\n18 |     reversed_string = &reversed_string[j..];\n\
    \   |        "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_char\
    \ = 0;\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_char_length\
    \ = 0;\n    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_index2\
    \ = 0;\n    let mut longest_postfix_char_length_index3 = 0;\n    let mut longest_postfix_char_length_index4\
    \ = 0;\n    let mut longest_postfix_char_length_index5 = 0;\n    let mut longest_postfix_char_length_index6\
    \ = 0;\n    let mut longest_postfix_char_length_index7 = 0;\n    let mut longest_postfix_char_length_index8\
    \ = 0;\n    let mut longest_postfix_char_length_index9 = 0;\n    let mut longest_postfix_char_length_index10\
    \ = 0;\n    let mut longest_postfix_char_length_index11 = 0;\n    let mut longest_postfix_char_length_index12\
    \ = 0;\n    let mut longest_postfix_char_length_index13 = 0;\n    let mut longest_postfix_char_length_index14\
    \ = 0;\n    let mut longest_postfix_char_length_index15 = 0;\n    let mut longest_postfix_char_length_index16\
    \ = 0;\n    let mut longest_postfix_char_length_index17 = 0;\n    let mut longest_postfix_char_length_index18\
    \ = 0;\n    let mut longest_postfix_char_length_index19 = 0;\n    let mut longest_postfix_char_length_index20\
    \ = 0;\n    let mut longest_postfix_char_length_index21 = 0;\n    let mut longest_postfix_char_length_index22\
    \ = 0;\n    let mut longest_postfix_char_length_index23 = 0;\n    let mut longest_postfix_char_length_index24\
    \ = 0;\n    let mut longest_postfix_char_length_index25 = 0;\n    let mut longest_postfix_char_length_index26\
    \ = 0;\n    let mut longest_postfix_char_length_index27 = 0;\n    let mut longest_postfix_char_length_index28\
    \ = 0;\n    let mut longest_postfix_char_length_index29 = 0;\n    let mut longest_postfix_char_length_index30\
    \ = 0;\n    let mut longest_postfix_char_length_index31 = 0;\n    let mut longest_postfix_char_length_index32\
    \ = 0;\n    let mut longest_postfix_char_length_index33 = 0;\n    let mut longest_postfix_char_length_index34\
    \ = 0;\n    let mut longest_postfix_char_length_index35 = 0;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjz_wllnu.rs:47:11\n   |\n\
    47 |     let mu\n   |           ^ help: add `;` here\n48 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjz_wllnu.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix = \"\";\n    for c in reversed_string {\n\
    \        if longest_postfix_length == 0 {\n            longest_postfix_length\
    \ = longest_postfix.len();\n            longest_postfix = c;\n        }\n    \
    \    if longest_postfix_length < c.len() {\n            longest_postfix_length\
    \ = longest_postfix.len();\n            longest_postfix = c;\n        }\n    }\n\
    \    let mut reversed_postfix = longest_postfix.chars().collect::<Vec<_>>().reverse();\n\
    \    reversed_postfix.extend(longest_postfix.chars().collect::<Vec<_>>());\n \
    \   reversed_postfix.append(longest_postfix_length);\n    reversed_postfix.reverse();\n\
    \    reversed_postfix.to_string()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n --> /tmp/tmp1u2rapix.rs:9:14\n\
    \  |\n9 |     for c in reversed_string {\n  |              ^^^^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the\
    \ trait `Iterator` is not implemented for `String`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0271]:\
    \ type mismatch resolving `<Vec<char> as IntoIterator>::Item == ()`\n   --> /tmp/tmp1u2rapix.rs:20:22\n\
    \    |\n20  |     reversed_postfix.extend(longest_postfix.chars().collect::<Vec<_>>());\n\
    \    |                      ^^^^^^ expected `()`, found `char`\n    |\nnote: required\
    \ by a bound in `extend`\n\nerror[E0599]: no method named `append` found for unit\
    \ type `()` in the current scope\n  --> /tmp/tmp1u2rapix.rs:21:22\n   |\n21 |\
    \     reversed_postfix.append(longest_postfix_length);\n   |                 \
    \     ^^^^^^ method not found in `()`\n\nerror[E0599]: no method named `reverse`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmp1u2rapix.rs:22:22\n\
    \   |\n22 |     reversed_postfix.reverse();\n   |                      ^^^^^^^\
    \ method not found in `()`\n\nerror[E0599]: `()` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmp1u2rapix.rs:23:22\n   |\n23 |     reversed_postfix.to_string()\n\
    \   |                      ^^^^^^^^^ `()` cannot be formatted with the default\
    \ formatter\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): std::fmt::Display`\n           which is required by `(): ToString`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0277, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_postfix\
    \ = \"\";\n\n    while !reversed_string.is_empty() {\n        let mut postfix_len\
    \ = reversed_string.len();\n        let mut postfix = reversed_string;\n     \
    \   let mut postfix_postfix = \"\";\n\n        while !postfix.is_empty() {\n \
    \           if postfix.chars().next().unwrap() == postfix.chars().next().unwrap()\
    \ {\n                postfix_postfix.push_front(postfix.chars().next().unwrap());\n\
    \                postfix.pop();\n            } else {\n                break;\n\
    \            }\n        }\n\n        if postfix_len > longest_postfix_len {\n\
    \            longest_postfix_len = postfix_len;\n            longest_postfix =\
    \ postfix_postfix;\n        }\n\n        reversed_string = postfix.clone();\n\
    \    }\n\n    longest_postfix.push_str(&longest_postfix_postfix);\n    longest_postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_front` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpw7prwfyu.rs:18:33\n   |\n18 |             \
    \    postfix_postfix.push_front(postfix.chars().next().unwrap());\n   |      \
    \                           ^^^^^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw7prwfyu.rs:27:31\n   |\n7  |     let mut longest_postfix\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n27 |             longest_postfix = postfix_postfix;\n   |               \
    \                ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                               |\n   |                               expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while !palindrome.is_empty() {\n        let mut index = palindrome.len()\
    \ - 1;\n        while index >= 0 {\n            if palindrome[index] != palindrome[index].to_ascii_lowercase()\
    \ {\n                break;\n            }\n            index -= 1;\n        }\n\
    \        if index >= 0 {\n            suffix_length += 1;\n            palindrome\
    \ = &palindrome[index..];\n        } else {\n            prefix_length += 1;\n\
    \            palindrome = &palindrome[0..index];\n        }\n    }\n    if prefix_length\
    \ == 0 {\n        palindrome = &palindrome[0..suffix_length];\n    }\n    if suffix_length\
    \ == 0 {\n        palindrome = &palindrome[prefix_length..];\n    }\n    palindrome\
    \ = &palindrome[prefix_length..suffix_length];\n    reversed_palindrome = &reversed_palindrome[prefix_length..suffix_length];\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpov6b5rcj.rs:13:16\n\
    \   |\n13 |             if palindrome[index] != palindrome[index].to_ascii_lowercase()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpov6b5rcj.rs:13:37\n   |\n13 |             if palindrome[index]\
    \ != palindrome[index].to_ascii_lowercase() {\n   |                          \
    \           ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpov6b5rcj.rs:20:26\n   |\n6  |     let mut palindrome\
    \ = string;\n   |                          ------ expected due to this value\n\
    ...\n20 |             palindrome = &palindrome[index..];\n   |               \
    \           ^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n20 |             palindrome = (&palindrome[index..]).to_string();\n\
    \   |                          +                    +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpov6b5rcj.rs:23:26\n   |\n6  "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string_to_reverse = string;\n    let mut reverse_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_string_length\
    \ = 0;\n    let mut longest_postfix_string_length_index = 0;\n    let mut longest_postfix_string_length_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index = 0;\n   \
    \ let mut longest_postfix_string_length_index_index_index_index = 0;\n    let\
    \ mut longest_postfix_string_length_index_index_index_index_index = 0;\n    let\
    \ mut longest_postfix_string_length_index_index_index_index_index_index = 0;\n\
    \    let mut longest_postfix_string_length_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz7sxkevh.rs:34:36\n   |\n\
    34 |     let mut longest_postfix_string_\n   |                               \
    \     ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpz7sxkevh.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string_to_reverse = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_string = \"\";\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_length_string_length = 0;\n    let mut\
    \ longest_postfix_string_length = 0;\n    let mut longest_postfix_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string = \"\";\n    let mut\
    \ longest_postfix_string_index = 0;\n    let mut longest_postfix_string_length_string_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length = 0;\n    let\
    \ mut longest_postfix_string_length_string_index = 0;\n    let mut longest_postfix_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_index = 0;\n \
    \   let mut longest_postfix_string_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_string_length_string_length_index = 0;\n    let mut longest_postfix_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_index = 0;\n \
    \   let mut longest_postfix_string_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_string_length_string_length_index = 0;\n    let mut longest_postfix_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_index = 0;\n \
    \   let mut longest_postfix_string_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_string_length_string_length_index = 0;\n    let mut longest_postfix_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_index = 0;\n \
    \   let mut longest_postfix_string_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_string_length_string_length_index = 0;\n    let mut longest_postfix_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_index = 0;\n \
    \   let mut longest_postfix_string_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_string_length_string_length_index = 0;\n    let mut longest_postfix_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_index = 0;\n \
    \   let mut longest_postfix_string_length_string_length_index = 0;\n    let mut\
    \ longest_postfix_string_length_string_length_index = 0;\n\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplzshvg95.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_reverse = 0;\n    let mut longest_postfix_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix = 0;\n    let mut longest_postfix_length_reverse_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_reverse = 0;\n    let\
    \ mut longest_postfix_length_reverse_suffix_reverse_index = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_index = 0;\n\
    \    let mut longest_postfix_length_reverse_suffix_suffix_reverse = 0;\n    let\
    \ mut longest_postfix_length_reverse_suffix_suffix_reverse_index = 0;\n    let\
    \ mut longest_postfix_length_reverse_suffix_suffix_suffix = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix_suffix_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6ugpumee.rs:34:44\n   |\n\
    34 |     let mut longest_postfix_length_reverse_\n   |                       \
    \                     ^ help: add `;` here\n35 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp6ugpumee.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_index = -1;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length2 = 0;\n    let mut longest_postfix_index_length3\
    \ = 0;\n    let mut longest_postfix_index_length4 = 0;\n    let mut longest_postfix_index_length5\
    \ = 0;\n    let mut longest_postfix_index_length6 = 0;\n    let mut longest_postfix_index_length7\
    \ = 0;\n    let mut longest_postfix_index_length8 = 0;\n    let mut longest_postfix_index_length9\
    \ = 0;\n    let mut longest_postfix_index_length10 = 0;\n    let mut longest_postfix_index_length11\
    \ = 0;\n    let mut longest_postfix_index_length12 = 0;\n    let mut longest_postfix_index_length13\
    \ = 0;\n    let mut longest_postfix_index_length14 = 0;\n    let mut longest_postfix_index_length15\
    \ = 0;\n    let mut longest_postfix_index_length16 = 0;\n    let mut longest_postfix_index_length17\
    \ = 0;\n    let mut longest_postfix_index_length18 = 0;\n    let mut longest_postfix_index_length19\
    \ = 0;\n    let mut longest_postfix_index_length20 = 0;\n    let mut longest_postfix_index_length21\
    \ = 0;\n    let mut longest_postfix_index_length22 = 0;\n    let mut longest_postfix_index_length23\
    \ = 0;\n    let mut longest_postfix_index_length24 = 0;\n    let mut longest_postfix_index_length25\
    \ = 0;\n    let mut longest_postfix_index_length26 = 0;\n    let mut longest_postfix_index_length27\
    \ = 0;\n    let mut longest_postfix_index_length28 = 0;\n    let mut longest_postfix_index_length29\
    \ = 0;\n    let mut longest_postfix_index_length30 = 0;\n    let mut longest_postfix_index_length31\
    \ = 0;\n    let mut longest_postfix_index_length32 = 0;\n    let mut longest_postfix_index_length33\
    \ = 0;\n    let mut longest_postfix_index_length34 = 0;\n    let mut longest_postfix_index_length35\
    \ = 0;\n    let mut longest_postfix_index_length36 = 0;\n    let mut longest_postfix_index_length37\
    \ = 0;\n    let mut longest_postfix_index_length38 = 0;\n    let mut longest_postfix_index_length39\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpss0tpxyw.rs:51:1\n  \
    \ |\n51 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for c in reversed_string.chars() {\n        if longest_postfix_length\
    \ < c.len_utf8() {\n            longest_postfix_length = c.len_utf8();\n     \
    \   }\n    }\n    let mut postfix_length = 0;\n    for c in reversed_string.chars()\
    \ {\n        if postfix_length < longest_postfix_length {\n            postfix_length\
    \ = longest_postfix_length;\n        }\n    }\n    let mut postfix_string = reversed_string.clone();\n\
    \    for _ in 0..longest_postfix_length {\n        postfix_string.push('_');\n\
    \    }\n    for _ in 0..postfix_length {\n        postfix_string.push('_');\n\
    \    }\n    postfix_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"x__\"`,\n right: `\"x\"`', /tmp/tmp2objdze1.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ prefix_length = string.len() - 1;\n    while prefix_length > 0 {\n        reversed_string.push_str(&string[prefix_length..]);\n\
    \        prefix_length -= 1;\n    }\n    reversed_string.push_str(&string[prefix_length..]);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp3yk2pxl0.rs:7:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut suffix_length\
    \ = 0;\n    let mut prefix_length = 0;\n    while suffix_length < palindrome.len()\
    \ {\n        let mut suffix_start = suffix_length;\n        while suffix_start\
    \ < palindrome.len() {\n            if palindrome[suffix_start] != palindrome[suffix_start\
    \ + 1] {\n                break;\n            }\n            suffix_start += 1;\n\
    \        }\n        let mut prefix_start = prefix_length;\n        while prefix_start\
    \ < suffix_start {\n            if palindrome[prefix_start] != palindrome[prefix_start\
    \ + 1] {\n                break;\n            }\n            prefix_start += 1;\n\
    \        }\n        if prefix_start == suffix_start {\n            break;\n  \
    \      }\n        palindrome = &palindrome[..suffix_start].to_string() + &palindrome[prefix_start..].to_string();\n\
    \        suffix_length += 1;\n        prefix_length += 1;\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy_v80hf4.rs:12:16\n\
    \   |\n12 |             if palindrome[suffix_start] != palindrome[suffix_start\
    \ + 1] {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy_v80hf4.rs:12:44\n   |\n12 |             if palindrome[suffix_start]\
    \ != palindrome[suffix_start + 1] {\n   |                                    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy_v80hf4.rs:19:16\n   |\n19 |             if palindrome[prefix_start]\
    \ != palindrome[prefix_start + 1] {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \ "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_len = String::new();\n\
    \    let mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start_len = String::new();\n \
    \   let mut longest_postfix_end_len = String::new();\n    let mut longest_postfix_start_pos\
    \ = String::new();\n    let mut longest_postfix_end_pos = String::new();\n   \
    \ let mut longest_postfix_start_pos_len = String::new();\n    let mut longest_postfix_end_pos_len\
    \ = String::new();\n    let mut longest_postfix_start_pos_pos = String::new();\n\
    \    let mut longest_postfix_end_pos_pos = String::new();\n    let mut longest_postfix_start_pos_pos_len\
    \ = String::new();\n    let mut longest_postfix_end_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_start_pos_pos_pos = String::new();\n    let mut longest_postfix_end_pos_pos_pos\
    \ = String::new();\n    let mut longest_postfix_start_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_end_pos_pos_pos_len = String::new();\n    let mut\
    \ longest_postfix_start_pos_pos_pos_len = String::new();\n    let mut longest_postfix_end_pos_pos_pos_len\
    \ = String::new();\n    let mut longest_postfix_start_pos_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_end_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_start_pos_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_end_pos_pos_pos_pos_pos_len = String::new();\n    let mut\
    \ longest_postfix_start_pos_pos_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_end_pos_pos_pos_pos_pos_pos_len = String::new();\n    let\
    \ mut longest_postfix_start_pos_pos_pos_pos_pos_pos_len = String::new();\n   \
    \ let mut longest_postfix_end_pos_pos_pos_pos_pos_pos_len = String::new();\n \
    \   let mut longest_postfix_start_pos_pos_pos_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_end_pos_pos_pos_pos_pos_pos_len = String::new();\n\
    \    let mut longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7bggtpjo.rs:37:29\n   |\n\
    37 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp7bggtpjo.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut palindrome\
    \ = String::new();\n    let mut suffix_length = 0;\n    let mut prefix_length\
    \ = 0;\n    while suffix_length != string.length {\n        let mut suffix_length\
    \ = string.len();\n        while suffix_length != string.length {\n          \
    \  let mut suffix_length = string.len();\n            let mut prefix_length =\
    \ string.len();\n            while suffix_length != string.length {\n        \
    \        let mut suffix_length = string.len();\n                while suffix_length\
    \ != string.length {\n                    let mut suffix_length = string.len();\n\
    \                    let mut prefix_length = string.len();\n                 \
    \   while suffix_length != string.length {\n                        let mut suffix_length\
    \ = string.len();\n                        while suffix_length != string.length\
    \ {\n                            let mut suffix_length = string.len();\n     \
    \                       while suffix_length != string.length {\n             \
    \                   let mut suffix_length = string.len();\n                  \
    \              while suffix_length != string.length {\n                      \
    \              let mut suffix_length = string.len();\n                       \
    \             while suffix_length != string.length {\n                       \
    \                 let mut suffix_length = string.len();\n                    \
    \                    while suffix_length != string.length {\n                \
    \                            let mut suffix_length = string.len();\n         \
    \                                   if suffix_length == string.length {\n    \
    \                                            break;\n                        \
    \                    }\n                                            let mut suffix_length\
    \ = string.len();\n                                        }\n               \
    \                     }\n                                }\n                 \
    \           }\n                        }\n                    }\n            \
    \    }\n            }\n        }\n    }\n    palindrome = string.to_owned() +\
    \ palindrome;\n    palindrome = String::from_utf8(palindrome).unwrap();\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmpkyhs9xk_.rs:10:35\n\
    \   |\n10 |     while suffix_length != string.length {\n   |                 \
    \                  ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on\
    \ type `String`\n  --> /tmp/tmpkyhs9xk_.rs:12:39\n   |\n12 |         while suffix_length\
    \ != string.length {\n   |                                       ^^^^^^ unknown\
    \ field\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpkyhs9xk_.rs:15:43\n\
    \   |\n15 |             while suffix_length != string.length {\n   |         \
    \                                  ^^^^^^ unknown field\n\nerror[E0609]: no field\
    \ `length` on type `String`\n  --> /tmp/tmpkyhs9xk_.rs:17:47\n   |\n17 |     \
    \            while suffix_length != string.length {\n   |                    \
    \                           ^^^^^^ unknown field\n\nerror[E0609]: no field `length`\
    \ on type `String`\n  --> /tmp/tmpkyhs9xk_.rs:20:51\n   |\n20 |              \
    \       while suffix_length != string.length {\n   |                         \
    \                          ^^^^^^ unknown field\n\nerror[E0609]: no field `length`\
    \ on type `String`\n  --> /tmp/tmpkyhs9xk_.rs:22:55\n   |\n22 |              \
    \           while suffix_length != string.length {\n   |                     \
    \                                  ^^^^^^ unknown field\n\nerror[E0609]: no field\
    \ `length` on type `String`\n  --> /tmp/tmpkyhs9xk_.rs:24:59\n   |\n24 | ... \
    \                  while suffix_length != string.length {\n   |              \
    \                                       ^^^^^^ unknown field\n\nerror[E0609]:\
    \ no field `length` on type `String`\n  --> /tmp/tmpkyhs9xk_.rs:26:63\n   |\n\
    26 | ...                   while suffix_length != string.length {\n   |      \
    \                                               ^^^^^^ unknown field\n\nerror[E0609]:\
    \ no field `length` on type `String`\n  --> /tmp/tmpkyhs9xk_.rs:28:67\n   |\n\
    28 | ...                   while suffix_length != string.length {\n   |      \
    \                                               ^^^^^^ unknown field\n\nerror[E0609]:\
    \ no field `length` on type `String`\n  --> /tmp/tmpky"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxqszn1k2.rs:53:36\n   |\n\
    53 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpxqszn1k2.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ prefix_length = string.len() - 1;\n    while prefix_length > 0 {\n        reversed_string.push_str(&string[prefix_length..]);\n\
    \        prefix_length -= 1;\n    }\n    reversed_string.push_str(&string[prefix_length..]);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp3yk2pxl0.rs:7:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ prefix_length = string.len() - 1;\n    let mut suffix_length = string.len()\
    \ - 1;\n    let mut suffix_start = -1;\n    let mut suffix_end = -1;\n    let\
    \ mut suffix_palindrome = String::new();\n\n    while suffix_start < suffix_end\
    \ {\n        if suffix_start < suffix_end {\n            suffix_palindrome = suffix_palindrome\n\
    \                + &string[suffix_start + prefix_length..suffix_end]\n       \
    \         + &string[suffix_start..suffix_end];\n        }\n        suffix_start\
    \ = suffix_end;\n        suffix_end = suffix_start + 1;\n        suffix_length\
    \ = suffix_end - suffix_start + 1;\n    }\n\n    reversed_string = reversed_string\n\
    \        + &string[suffix_start + prefix_length..suffix_end]\n        + &string[suffix_start..suffix_end];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpb6df4fym.rs:9:28\n\
    \  |\n9 |     let mut suffix_start = -1;\n  |                            ^^ the\
    \ trait `Neg` is not implemented for `usize`\n  |\n  = help: the following other\
    \ types implement trait `Neg`:\n            &f32\n            &f64\n         \
    \   &i128\n            &i16\n            &i32\n            &i64\n            &i8\n\
    \            &isize\n          and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpb6df4fym.rs:10:26\n   |\n10 |     let mut\
    \ suffix_end = -1;\n   |                          ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reverse_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_length_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_length_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_length_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_length_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_length_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_length_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_length_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_length_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_length_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_length_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_length_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_length_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_length_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_length_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_length_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_length_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_length_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_length_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_length_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_length_index21\
    \ = 0;\n    let mut longest_post\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfzidp0sb.rs:52:25\n   |\n\
    52 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfzidp0sb.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n    let mut longest_postfix_char = String::new();\n    let\
    \ mut longest_postfix_char_length = 0;\n    let mut longest_postfix_char_start\
    \ = String::new();\n    let mut longest_postfix_char_end = String::new();\n  \
    \  let mut longest_postfix_char_start = String::new();\n    let mut longest_postfix_char_end\
    \ = String::new();\n    let mut longest_postfix_char_start = String::new();\n\
    \    let mut longest_postfix_char_end = String::new();\n    let mut longest_postfix_char_start\
    \ = String::new();\n    let mut longest_postfix_char_end = String::new();\n  \
    \  let mut longest_postfix_char_start = String::new();\n    let mut longest_postfix_char_end\
    \ = String::new();\n    let mut longest_postfix_char_start = String::new();\n\
    \    let mut longest_postfix_char_end = String::new();\n    let mut longest_postfix_char_start\
    \ = String::new();\n    let mut longest_postfix_char_end = String::new();\n  \
    \  let mut longest_postfix_char_start = String::new();\n    let mut longest_postfix_char_end\
    \ = String::new();\n    let mut longest_postfix_char_start = String::new();\n\
    \    let mut longest_postfix_char_end = String::new();\n    let mut longest_postfix_char_start\
    \ = String::new();\n    let mut longest_postfix_char_end = String::new();\n  \
    \  let mut longest_postfix_char_start = String::new();\n    let mut longest_postfix_char_end\
    \ = String::new();\n    let mut longest_postfix_char_start = String::new();\n\
    \    let mut longest_postfix_char_end = String::new();\n    let mut longest_postfix_char_start\
    \ = String::new();\n    let mut longest_postfix_char_end = String::new();\n  \
    \  let mut longest_postfix_char_start = String::new();\n    let mut longest_postfix_char_end\
    \ = String::new();\n    let mut longest_postfix_char_start = String::new();\n\
    \    let mut longest_postfix_char_end = String::new();\n    let mut longest_postfix_char_start\
    \ = String::new();\n    let mut longest_postfix_char_end = String::new\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfuv_ws3e.rs:43:51\n   |\n\
    43 |     let mut longest_postfix_char_end = String::new\n   |                \
    \                                   ^ help: add `;` here\n44 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfuv_ws3e.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_string2 = \"\";\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_string3 = \"\";\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_string4 = \"\";\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_string5 = \"\";\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_string6 = \"\";\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_string7 = \"\";\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_string8 = \"\";\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_string9 = \"\";\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_string10 = \"\";\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_string11 = \"\";\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_string12 = \"\";\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_string13 = \"\";\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_string14 = \"\";\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_string15 = \"\";\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_string16 = \"\";\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_string17 = \"\";\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_string18 = \"\";\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_string19 = \"\";\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_string20 = \"\";\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_string21 = \"\";\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_string22 = \"\";\n    let mut longest_postfix_index23\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq3edrji0.rs:53:36\n   |\n\
    53 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpq3edrji0.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp69w81leg.rs:53:34\n   |\n\
    53 |     let mut longest_postfix_index\n   |                                 \
    \ ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp69w81leg.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_index = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length = 0;\n    let mut longest_postfix_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_index = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_p\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi1gtifv9.rs:28:73\n   |\n\
    28 |     let mut longest_postfix_length_palindrome_length_palindrome_length_p\n\
    \   |                                                                        \
    \ ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpi1gtifv9.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_index = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_post\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvltzv6lt.rs:47:25\n   |\n\
    47 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvltzv6lt.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut prefix_length\
    \ = 0;\n    let mut suffix_length = 0;\n    while suffix_length < reversed_string.len()\
    \ {\n        let mut suffix_start = suffix_length;\n        let mut suffix_end\
    \ = suffix_length;\n        while suffix_end < reversed_string.len() {\n     \
    \       if reversed_string[suffix_end] != string[suffix_start] {\n           \
    \     break;\n            }\n            suffix_end += 1;\n        }\n       \
    \ let mut prefix_start = prefix_length;\n        let mut prefix_end = prefix_length;\n\
    \        while prefix_end < reversed_string.len() {\n            if reversed_string[prefix_end]\
    \ != string[prefix_start] {\n                break;\n            }\n         \
    \   prefix_end += 1;\n        }\n        if suffix_end == reversed_string.len()\
    \ {\n            suffix_length += 1;\n        }\n        if prefix_end == reversed_string.len()\
    \ {\n            prefix_length += 1;\n        }\n    }\n    let mut result = String::new();\n\
    \    while suffix_length >= prefix_length {\n        result.push_str(&string[prefix_length..suffix_length]);\n\
    \        result.push(reversed_string[suffix_length..]);\n        suffix_length\
    \ -= 1;\n        prefix_length -= 1;\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp984duzf2.rs:13:16\n\
    \   |\n13 |             if reversed_string[suffix_end] != string[suffix_start]\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp984duzf2.rs:13:47\n   |\n13 |             if reversed_string[suffix_end]\
    \ != string[suffix_start] {\n   |                                            \
    \   ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp984duzf2.rs:21:16\n   |\n21 |             if reversed_string[prefix_end]\
    \ != string[prefix_start] {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <S"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ prefix_length = string.len() - 1;\n    while prefix_length > 0 {\n        reversed_string.insert(0,\
    \ string[prefix_length]);\n        prefix_length -= 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpglhv18b6.rs:9:35\n\
    \  |\n9 |         reversed_string.insert(0, string[prefix_length]);\n  |     \
    \                              ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_index = -1;\n    let mut longest_postfix_length = 0;\n\n   \
    \ for &c in string.chars() {\n        if longest_postfix_length == 0 {\n     \
    \       longest_postfix_length = 1;\n            longest_postfix_index = -1;\n\
    \        }\n\n        if longest_postfix_length == 1 && longest_postfix_index\
    \ == -1 {\n            longest_postfix_length = 2;\n            longest_postfix_index\
    \ = 0;\n        }\n\n        if longest_postfix_length == 2 && longest_postfix_index\
    \ != -1 {\n            longest_postfix_length = 1;\n            longest_postfix_index\
    \ = -1;\n        }\n\n        if longest_postfix_length == 1 && longest_postfix_index\
    \ != -1 {\n            longest_postfix_length += 1;\n        }\n\n        if longest_postfix_length\
    \ == 2 && longest_postfix_index == -1 {\n            longest_postfix_length +=\
    \ 1;\n        }\n\n        if longest_postfix_length == 1 && longest_postfix_index\
    \ == -1 {\n            longest_postfix_length += 1;\n        }\n\n        if longest_postfix_length\
    \ == 2 && longest_postfix_index != -1 {\n            longest_postfix_length +=\
    \ 1;\n        }\n\n        if longest_postfix_length == 1 && longest_postfix_index\
    \ == -1 {\n            longest_postfix_length += 1;\n        }\n\n        if longest_postfix_length\
    \ == 2 && longest_postfix_index == -1 {\n            longest_postfix_length +=\
    \ 1;\n        }\n\n        if longest_postfix_length == 1 && longest_postfix_index\
    \ != -1 {\n            longest_postfix_length += 1;\n        }\n\n        if longest_postfix_length\
    \ == 2 && longest_postfix_index != -1 {\n            longest_postfix_length +=\
    \ 1;\n        }\n\n        if longest_postfix_length == 1 && longest_postfix_index\
    \ != -1 {\n            longest_postfix_length += 1;\n        }\n\n        if longest_postfix_length\
    \ == 2 && longest_postfix_index == -1 {\n            longest_postfix_length +=\
    \ 1;\n        }\n\n        if longest_postfix_length == 1 && longest_postfix_index\
    \ == -1 {\n            longest_postfix_length += 1;\n        }\n\n        if longest_postfix_length\
    \ == 2 && longest_postfix_index != -1 {\n            longest_postfix_length +=\
    \ 1;\n        }\n\n        if longest_postfix_length == 1 && longest_postfix_index\
    \ != -1 {\n            longest_postfix_length += 1;\n        }\n\n        if longest_postfix_length\
    \ == 2 && longest_postfix_index == -1 {\n            longest_postfix_length +=\
    \ 1;\n        }\n\n        if \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_pu7uatu.rs:92:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n10 |     for &c in\
    \ string.chars() {\n   |                              - this delimiter might not\
    \ be properly closed...\n...\n83 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n92 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmp_pu7uatu.rs:83:1\n   |\n83 | }\n   | ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_pu7uatu.rs:10:9\n   |\n10 | \
    \    for &c in string.chars() {\n   |         ^^    -------------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp_pu7uatu.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n\n    while !string.is_empty() {\n        let mut postfix = string;\n\
    \        let mut postfix_length = 0;\n\n        while !postfix.is_empty() {\n\
    \            if postfix.chars().next().unwrap() != postfix.chars().next().unwrap()\
    \ {\n                break;\n            }\n            postfix_length += 1;\n\
    \            postfix = postfix.chars().next().unwrap();\n        }\n\n       \
    \ if postfix_length > longest_postfix_length {\n            longest_postfix =\
    \ postfix.to_string();\n            longest_postfix_length = postfix_length;\n\
    \        }\n\n        string = string.chars().next().unwrap();\n        reversed_string\
    \ += postfix.to_string();\n    }\n\n    longest_postfix.push_str(reversed_string);\n\
    \    longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpefg0aycw.rs:20:23\n   |\n\
    12 |         let mut postfix = string;\n   |                           ------\
    \ expected due to this value\n...\n20 |             postfix = postfix.chars().next().unwrap();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                       |\n   |      \
    \                 expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpefg0aycw.rs:24:31\n   |\n8  |     let mut longest_postfix\
    \ = \"\";\n   |                               -- expected due to this value\n\
    ...\n24 |             longest_postfix = postfix.to_string();\n   |           \
    \                    ^^^^^^^^^^^^^^^^^^^\n   |                               |\n\
    \   |                               expected `&str`, found struct `String`\n \
    \  |                               help: consider borrowing here: `&postfix.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpefg0aycw.rs:28:18\n   |\n6  |\
    \     let mut string = string;\n   |                      ------ expected due\
    \ to this value\n...\n28 |         string = string.chars().next().unwrap();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                  |\n   |                  expected\
    \ struct `String`, found `char`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `&str`\n  --> /tmp/tmpefg0aycw.rs:29:9\n   |\n29 |\
    \         reversed_string += postfix.to_string();\n   |         ---------------^--^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |               |\n   |         |               `+` cannot be used\
    \ to concatenate a `&str` with a `String`\n   |         cannot use `+=` on type\
    \ `&str`\n   |\n   = note: string concatenation requires an owned `String` on\
    \ the left\n\nerror[E0599]: no method named `push_str` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpefg0aycw.rs:32:21\n   |\n32 |     longest_postfix.push_str(reversed_string);\n\
    \   |                     ^^^^^^^^ method not found in `&str`\n\nerr"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_len = string.len();\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix =\
    \ String::new();\n    let mut longest_postfix_postfix_start = -1;\n    let mut\
    \ longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix = String::new();\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_start = -1;\n    let mut\
    \ longest_postfix_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprm1c9kck.rs:33:69\n   |\n\
    33 |     let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_\n  \
    \ |                                                                     ^ help:\
    \ add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmprm1c9kck.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpowh1gg2x.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpowh1gg2x.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string_to_reverse = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_string2 = \"\";\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_string3 = \"\";\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_string4 = \"\";\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_string5 = \"\";\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_string6 = \"\";\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_string7 = \"\";\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_string8 = \"\";\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_string9 = \"\";\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_string10 = \"\";\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_string11 = \"\";\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_string12 = \"\";\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_string13 = \"\";\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_string14 = \"\";\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_string15 = \"\";\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_string16 = \"\";\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_string17 = \"\";\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_string18 = \"\";\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_string19 = \"\";\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_string20 = \"\";\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_string21 = \"\";\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_string22 = \"\";\n    let mut longest_post\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplz6o8rsj.rs:53:25\n   |\n\
    53 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmplz6o8rsj.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_index = 0;\n    let mut longest_postfix_length_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_palindrome = 0;\n   \
    \ let mut longest_postfix_length_suffix_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_suffix_index = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix_suffix_suffix_palindrome = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_index = 0;\n \
    \   let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqpisy09k.rs:34:21\n   |\n\
    34 |     let mut longest_\n   |                     ^ help: add `;` here\n35 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpqpisy09k.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reverse\
    \ = String::new();\n    let mut start = 0;\n    let mut end = string.len() - 1;\n\
    \    while start < end {\n        if string[start] != string[end] {\n        \
    \    break;\n        }\n        reverse.push_str(&string[start..end]);\n     \
    \   start += 1;\n        end -= 1;\n    }\n    reverse.push_str(&string[start..end]);\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvagzln73.rs:11:12\n\
    \   |\n11 |         if string[start] != string[end] {\n   |            ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvagzln73.rs:11:29\n   |\n11 |         if string[start] != string[end]\
    \ {\n   |                             ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = 0;\n    let mut longest_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_index = -1;\n    let mut\
    \ longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n   \
    \ let mut longest_postfix_postfix_postfix_postfix_postfix = String::new();\n \
    \   let mut longest_postfix_postfix_postfix_postfix_postfix_index = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_length = 0;\n    let mut\
    \ longest_postfix_postfix_postfix_postfix_postfix_postfix = String::new();\n \
    \   let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_length =\
    \ 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_post\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ncv2cg4.rs:33:57\n   |\n\
    33 |     let mut longest_postfix_postfix_postfix_postfix_post\n   |          \
    \                                               ^ help: add `;` here\n34 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_ncv2cg4.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_start = String::new();\n\
    \    let mut longest_postfix_end = String::new();\n    let mut longest_postfix_start_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_end = String::new();\n    let mut\
    \ longest_postfix_start_end_start_end_end = String::new();\n    let mut longest_postfix_start_end_start_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String::new();\n    let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiwc024kt.rs:29:121\n   |\n\
    29 |     let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String\n   |                                                             \
    \                                                            ^ help: add `;` here\n\
    30 | }\n   | - unexpected token\n\nerror[E0423]: expected value, found struct\
    \ `String`\n   --> /tmp/tmpiwc024kt.rs:29:115\n    |\n29  |       let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String\n    |                                                            \
    \                                                         ^^^^^^\n    |\nhelp:\
    \ use struct literal syntax instead\n    |\n29  |     let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = String { vec: val }\n    |                                               \
    \                                                                    ~~~~~~~~~~~~~~~~~~~\n\
    help: a local variable with a similar name exists\n    |\n29  |     let mut longest_postfix_start_end_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = string\n    |                                                            \
    \                                                       ~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpiwc024kt.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for pos in string.rchars().enumerate().rev() {\n        if pos.1 ==\
    \ 0 {\n            longest_postfix_length = pos.0;\n            break;\n     \
    \   }\n        let postfix = &string[pos.0..pos.1];\n        if postfix.chars().all(|c|\
    \ !c.is_ascii_letter()) {\n            longest_postfix_length = pos.0;\n     \
    \       break;\n        }\n    }\n    let mut reversed_postfix = &string[longest_postfix_length..];\n\
    \    reversed_postfix.reverse();\n    reversed_string += &reversed_postfix;\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rchars` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpyb9f795r.rs:8:23\n  |\n8 |     for pos in string.rchars().enumerate().rev()\
    \ {\n  |                       ^^^^^^ help: there is an associated function with\
    \ a similar name: `chars`\n\nerror[E0599]: no method named `is_ascii_letter` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpyb9f795r.rs:14:39\n   |\n\
    14 |         if postfix.chars().all(|c| !c.is_ascii_letter()) {\n   |        \
    \                               ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `reverse` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpyb9f795r.rs:20:22\n\
    \   |\n20 |     reversed_postfix.reverse();\n   |                      ^^^^^^^\
    \ method not found in `&str`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix = String::new();\n\
    \    let mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start_index = String::new();\n\
    \    let mut longest_postfix_end_index = String::new();\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_post\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa8kb6yss.rs:51:25\n   |\n\
    51 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpa8kb6yss.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk2nlhorv.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk2nlhorv.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = String::new();\n\
    \    let mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start_length = String::new();\n\
    \    let mut longest_postfix_end_length = String::new();\n    let mut longest_postfix_start_start\
    \ = String::new();\n    let mut longest_postfix_end_start = String::new();\n \
    \   let mut longest_postfix_start_end = String::new();\n    let mut longest_postfix_end_end\
    \ = String::new();\n    let mut longest_postfix_start_start_length = String::new();\n\
    \    let mut longest_postfix_end_start_length = String::new();\n    let mut longest_postfix_start_end_length\
    \ = String::new();\n    let mut longest_postfix_end_end_length = String::new();\n\
    \    let mut longest_postfix_start_start_start = String::new();\n    let mut longest_postfix_end_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start = String::new();\n\
    \    let mut longest_postfix_end_end_start = String::new();\n    let mut longest_postfix_start_start_end\
    \ = String::new();\n    let mut longest_postfix_end_start_end = String::new();\n\
    \    let mut longest_postfix_start_end_end = String::new();\n    let mut longest_postfix_start_start_end_length\
    \ = String::new();\n    let mut longest_postfix_end_start_end_length = String::new();\n\
    \    let mut longest_postfix_start_end_end_length = String::new();\n    let mut\
    \ longest_postfix_start_start_end_start = String::new();\n    let mut longest_postfix_end_start_end_start\
    \ = String::new();\n    let mut longest_postfix_start_end_end_start = String::new();\n\
    \    let mut longest_postfix_start_start_end_end = String::new();\n    let mut\
    \ longest_postfix_end_start_end_end = String::new();\n    let mut longest_postfix_start_start_end_end_length\
    \ = String::new();\n    let mut longest_postfix_end_start_end_end_length = String::new();\n\
    \    let mut longest_postfix_start_end_end_end_length = String::new();\n    let\
    \ mut longest_postfix_start_start_end_end_start = String::new();\n    let mut\
    \ lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwgmt4alc.rs:40:16\n   |\n\
    40 |     let mut lon\n   |                ^ help: add `;` here\n41 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwgmt4alc.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_index = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length = 0;\n    let mut longest_postfix_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_index = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_p\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi1gtifv9.rs:28:73\n   |\n\
    28 |     let mut longest_postfix_length_palindrome_length_palindrome_length_p\n\
    \   |                                                                        \
    \ ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpi1gtifv9.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut suffix =\
    \ 0;\n    while palindrome.len() > 0 {\n        let mut start = palindrome.len()\
    \ - 1;\n        while start >= 0 {\n            if palindrome[start] != palindrome[start\
    \ + 1] {\n                break;\n            }\n            start -= 1;\n   \
    \     }\n        palindrome = &palindrome[..start + 1];\n        suffix += 1;\n\
    \    }\n    palindrome = &palindrome[..suffix];\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnwwl06va.rs:11:16\n\
    \   |\n11 |             if palindrome[start] != palindrome[start + 1] {\n   |\
    \                ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnwwl06va.rs:11:37\n\
    \   |\n11 |             if palindrome[start] != palindrome[start + 1] {\n   |\
    \                                     ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnwwl06va.rs:16:22\n\
    \   |\n6  |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n16 |         palindrome = &palindrome[..start\
    \ + 1];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n16 |        \
    \ palindrome = (&palindrome[..start + 1]).to_string();\n   |                 \
    \     +                        +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnwwl06va.rs:19:18\n   |\n6  |     let mut palindrome = str"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_string2 = \"\";\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_string3 = \"\";\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_string4 = \"\";\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_string5 = \"\";\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_string6 = \"\";\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_string7 = \"\";\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_string8 = \"\";\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_string9 = \"\";\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_string10 = \"\";\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_string11 = \"\";\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_string12 = \"\";\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_string13 = \"\";\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_string14 = \"\";\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_string15 = \"\";\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_string16 = \"\";\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_string17 = \"\";\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_string18 = \"\";\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_string19 = \"\";\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_string20 = \"\";\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_string21 = \"\";\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_string22 = \"\";\n    let mut longest_postfix_index23\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq3edrji0.rs:53:36\n   |\n\
    53 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpq3edrji0.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for pos in string.rfind('a') {\n        if pos == string.len() - 1\
    \ {\n            break;\n        }\n        let mut postfix = &string[..pos];\n\
    \        let mut reverse_postfix = &string[..pos];\n        for _ in 0..(longest_postfix_length\
    \ - postfix.len()) {\n            postfix.reverse();\n            reverse_postfix.reverse();\n\
    \        }\n        if postfix != reverse_postfix {\n            break;\n    \
    \    }\n        longest_postfix_length = pos;\n    }\n    reversed_string += &string[longest_postfix_length..];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpc29uskr2.rs:15:21\n   |\n15 |             postfix.reverse();\n\
    \   |                     ^^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `reverse` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpc29uskr2.rs:16:29\n   |\n16 |             reverse_postfix.reverse();\n\
    \   |                             ^^^^^^^ method not found in `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut suffix_pos = 0;\n    let mut prefix_pos = 0;\n    while\
    \ suffix_pos < palindrome.len() {\n        let mut suffix_len = palindrome.len()\
    \ - suffix_pos;\n        let mut prefix_len = suffix_len;\n        while prefix_len\
    \ > 0 && palindrome[suffix_pos + prefix_len - 1] == palindrome[suffix_pos + prefix_len]\
    \ {\n            prefix_len -= 1;\n        }\n        if prefix_len > 0 {\n  \
    \          palindrome = &palindrome[..suffix_pos + prefix_len];\n            reversed_palindrome\
    \ = &reversed_palindrome[..prefix_len + suffix_len];\n            suffix_pos +=\
    \ prefix_len;\n            prefix_pos = 0;\n        }\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp7dquuin.rs:13:33\n\
    \   |\n13 |         while prefix_len > 0 && palindrome[suffix_pos + prefix_len\
    \ - 1] == palindrome[suffix_pos + prefix_len] {\n   |                        \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp7dquuin.rs:13:76\n   |\n13 |         while prefix_len > 0 && palindrome[suffix_pos\
    \ + prefix_len - 1] == palindrome[suffix_pos + prefix_len] {\n   |           \
    \                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp7dquuin.rs:17:26\n\
    \   |\n6  |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n17 |             palindrome = &palindrome[..suffix_pos\
    \ + prefix_len];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_post\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqwbrzep_.rs:42:41\n   |\n\
    42 |     let mut longest_postfix_postfix_post\n   |                          \
    \               ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpqwbrzep_.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n    let mut longest_postfix_chars\
    \ = \"\";\n    let mut longest_postfix_char_index = 0;\n\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzhv0yxva.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_index\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_suffix\
    \ = string;\n    let mut longest_postfix_suffix_index = -1;\n    let mut longest_postfix_suffix_length\
    \ = -1;\n    let mut longest_postfix_suffix_reversed_string = string;\n    let\
    \ mut longest_postfix_suffix_reversed_index = -1;\n    let mut longest_postfix_suffix_reversed_length\
    \ = -1;\n    let mut longest_postfix_suffix_reversed_suffix = string;\n    let\
    \ mut longest_postfix_suffix_reversed_suffix_index = -1;\n    let mut longest_postfix_suffix_reversed_suffix_length\
    \ = -1;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_string =\
    \ string;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_index =\
    \ -1;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_length = -1;\n\
    \    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix = string;\n\
    \    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_index = -1;\n\
    \    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_length = -1;\n\
    \    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_string\
    \ = string;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_index\
    \ = -1;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_length\
    \ = -1;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_suffix\
    \ = string;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_suffix_index\
    \ = -1;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_suffix_length\
    \ = -1;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_suffix_reversed_string\
    \ = string;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_suffix_reversed_index\
    \ = -1;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_suffix_reversed_length\
    \ = -1;\n    let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_suffi\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvv4tfgmc.rs:35:82\n   |\n\
    35 |     let mut longest_postfix_suffix_reversed_suffix_reversed_suffix_reversed_suffi\n\
    \   |                                                                        \
    \          ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpvv4tfgmc.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n\n    while !palindrome.is_empty() {\n        let mut index = palindrome.len()\
    \ - 1;\n        let mut char = String::new();\n\n        while index >= 0 {\n\
    \            char = char.to_string() + palindrome[index];\n            index -=\
    \ 1;\n        }\n\n        reversed_string += char;\n        palindrome = palindrome.chars().skip_while(|c|\
    \ !c.is_ascii_lowercase()).collect();\n    }\n\n    reversed_string += palindrome;\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn6qp9hsz.rs:14:39\n\
    \   |\n14 |             char = char.to_string() + palindrome[index];\n   |   \
    \                                    ^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpn6qp9hsz.rs:18:9\n   |\n18 |         reversed_string\
    \ += char;\n   |         ---------------^--^^^^^\n   |         |             \
    \  |\n   |         |               `+` cannot be used to concatenate a `&str`\
    \ with a `String`\n   |         cannot use `+=` on type `&str`\n   |\n   = note:\
    \ string concatenation requires an owned `String` on the left\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpn6qp9hsz.rs:22:5\n\
    \   |\n22 |     reversed_string += palindrome;\n   |     ---------------^--^^^^^^^^^^^\n\
    \   |     |               |\n   |     |               `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n  \
    \ = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn6qp9hsz.rs:23:5\n   |\n5  | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n23 |     reversed_string\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reversed_string\
    \ = String::new();\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_suffix_start\
    \ = -1;\n    let mut longest_postfix_suffix_end = -1;\n    let mut longest_postfix_suffix_length\
    \ = -1;\n    let mut longest_postfix_suffix_start = -1;\n    let mut longest_postfix_suffix_end\
    \ = -1;\n    let mut longest_postfix_suffix_length = -1;\n    let mut longest_postfix_suffix_start\
    \ = -1;\n    let mut longest_postfix_suffix_end = -1;\n    let mut longest_postfix_suffix_length\
    \ = -1;\n    let mut longest_postfix_suffix_start = -1;\n    let mut longest_postfix_suffix_end\
    \ = -1;\n    let mut longest_postfix_suffix_length = -1;\n    let mut longest_postfix_suffix_start\
    \ = -1;\n    let mut longest_postfix_suffix_end = -1;\n    let mut longest_postfix_suffix_length\
    \ = -1;\n    let mut longest_postfix_suffix_start = -1;\n    let mut longest_postfix_suffix_end\
    \ = -1;\n    let mut longest_postfix_suffix_length = -1;\n    let mut longest_postfix_suffix_start\
    \ = -1;\n    let mut longest_postfix_suffix_end = -1;\n    let mut longest_postfix_suffix_length\
    \ = -1;\n    let mut longest_postfix_suffix_start = -1;\n    let mut longest_postfix_suffix_end\
    \ = -1;\n    let mut longest_postfix_suffix_length = -1;\n    let mut longest_postfix_suffix_start\
    \ = -1;\n    let mut longest_postfix_suffix_end = -1;\n    let mut longest_postfix_suffix_length\
    \ = -1;\n    let mut longest_postfix_suffix_start = -1;\n    let mut longest_postfix_suffix_end\
    \ = -1;\n    let mut longest_postfix_suffix_length = -1;\n    let mut longest_postfix_suffix_start\
    \ = -1;\n    let mut longest_postfix_suffix_end = -1;\n    let mut longest_postfix_suffix_length\
    \ = -1;\n    let mut longest_postfix_suffix_start = -1;\n    let mut longest_postfix_suffix_end\
    \ = -1;\n    let mut longest_postfix_suffix_length = -1;\n    let mut longest_postfix_suffix_start\
    \ = -1;\n    let mut longest_postfix_suffix_end = -1;\n    let mut longest_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0iej8bpc.rs:49:29\n   |\n\
    49 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp0iej8bpc.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_char:\
    \ char;\n    for c in reversed_string {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n            longest_postfix_index\
    \ = longest_postfix_length;\n            longest_postfix_char = c;\n        }\
    \ else {\n            if longest_postfix_length < c.len_utf8() {\n           \
    \     longest_postfix_length = c.len_utf8();\n                longest_postfix_index\
    \ = longest_postfix_length;\n                longest_postfix_char = c;\n     \
    \       }\n        }\n    }\n    let mut reversed_postfix_string = reversed_string.clone();\n\
    \    reversed_postfix_string[longest_postfix_index..].swap(reversed_postfix_string[longest_postfix_index..longest_postfix_index\
    \ - 1]);\n    reversed_postfix_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpk_zjaxyg.rs:10:14\n\
    \   |\n10 |     for c in reversed_string {\n   |              ^^^^^^^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]:\
    \ no method named `swap` found for type `str` in the current scope\n  --> /tmp/tmpk_zjaxyg.rs:24:54\n\
    \   |\n24 |     reversed_postfix_string[longest_postfix_index..].swap(reversed_postfix_string[longest_postfix_index..longest_postfix_index\
    \ - 1]);\n   |                                                      ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45 = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsemyp4s6.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsemyp4s6.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_start = -1;\n    let\
    \ mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n   \
    \ let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpbb_sbk3e.rs:58:1\n  \
    \ |\n58 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk2nlhorv.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk2nlhorv.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_len = string.len();\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2y9u7b63.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = String::new();\n    let mut longest_postfix_start =\
    \ String::new();\n    let mut longest_postfix_end = String::new();\n    let mut\
    \ longest_postfix_start = String::new();\n    let mut longest_postfix_end = String::new();\n\
    \    let mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprgf8a2nx.rs:45:29\n   |\n\
    45 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmprgf8a2nx.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut palindrome\
    \ = string;\n    let mut postfix = string.chars().take_while(|c| !c.is_alphanumeric()).collect::<Vec<_>>();\n\
    \    let mut prefix_length = prefix.len();\n    while !postfix.is_empty() {\n\
    \        let mut postfix_length = postfix.len();\n        while postfix_length\
    \ >= prefix_length {\n            let mut prefix = postfix.split_off(prefix_length);\n\
    \            let mut suffix = postfix.split_off(postfix_length);\n           \
    \ reversed_string.push_str(&suffix);\n            palindrome.push_str(&prefix);\n\
    \            postfix.pop();\n            postfix.pop();\n            prefix_length\
    \ -= 1;\n        }\n        postfix.pop();\n    }\n    reversed_string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `prefix` in this scope\n --> /tmp/tmp282j1rsx.rs:9:29\n\
    \  |\n9 |     let mut prefix_length = prefix.len();\n  |                     \
    \        ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp282j1rsx.rs:15:38\n   |\n15 |             reversed_string.push_str(&suffix);\n\
    \   |                                      ^^^^^^^ expected `str`, found struct\
    \ `Vec`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp282j1rsx.rs:16:33\n\
    \   |\n16 |             palindrome.push_str(&prefix);\n   |                  \
    \               ^^^^^^^ expected `str`, found struct `Vec`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&Vec<char>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n\n    while palindrome.len() > 0 {\n        let mut index = palindrome.len()\
    \ - 1;\n        let mut char = String::new();\n\n        while index >= 0 {\n\
    \            char.push(palindrome[index]);\n            index -= 1;\n        }\n\
    \n        reversed_string.push(char);\n        palindrome = palindrome.chars().skip_while(|c|\
    \ !c.is_ascii_lowercase()).collect();\n    }\n\n    reversed_string.reverse();\n\
    \    palindrome.push_str(reversed_string);\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpww8pzwjr.rs:14:23\n\
    \   |\n14 |             char.push(palindrome[index]);\n   |                  \
    \     ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `push` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpww8pzwjr.rs:18:25\n   |\n18 |         reversed_string.push(char);\n\
    \   |                         ^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `reverse` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpww8pzwjr.rs:22:21\n   |\n22 |     reversed_string.reverse();\n\
    \   |                     ^^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start =\
    \ -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_length\
    \ = -1;\n    let mut longest_postfix_end_length = -1;\n    let mut longest_postfix_start_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpal7l8q0t.rs:52:35\n   |\n\
    52 |     let mut longest_postfix_start_\n   |                                \
    \   ^ help: add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpal7l8q0t.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = String::new();\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome = String::new();\n    let\
    \ mut longest_postfix_length_postfix = String::new();\n    let mut longest_postfix_length_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_postfix_palindrome = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix = String::new();\n    let\
    \ mut longest_postfix_length_postfix_postfix_index = 0;\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ 0;\n    let mut longest_postfix_length_postfix_postfix_palindrome = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix_index = 0;\n    let\
    \ mut longest_postfix_length_postfix_postfix_postfix_palindrome = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix_postfix = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix_index = 0;\n    let\
    \ mut longest_postfix_length_postfix_postfix_postfix_palindrome = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix_postfix = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix_postfix = 0;\n   \
    \ let mut longest_postfix_length_postfix_postfix_postfix_palindrome = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix_postfix = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix_postfix = 0;\n   \
    \ let mut longest_postfix_length_postfix_postfix_postfix_palindrome = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix_postfix = String::new();\n\
    \    let mut longest_postfix_length_postfix_postfix_postfix_postfix = 0;\n   \
    \ let mut longest_postfix_length_postfix_post\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1qjg8yvf.rs:33:48\n   |\n\
    33 |     let mut longest_postfix_length_postfix_post\n   |                   \
    \                             ^ help: add `;` here\n34 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1qjg8yvf.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ prefix_length = string.len();\n    let mut suffix_length = 0;\n    let mut longest_palindrome\
    \ = String::new();\n\n    while suffix_length < string.len() {\n        let mut\
    \ suffix_postfix = String::new();\n        let mut suffix_postfix_length = string.len()\
    \ - suffix_length;\n\n        while suffix_postfix_length >= 0 {\n           \
    \ suffix_postfix.push(string[suffix_postfix_length]);\n            suffix_postfix_length\
    \ -= 1;\n        }\n\n        let mut suffix_postfix_reversed = suffix_postfix.chars().collect::<Vec<_>>().rev();\n\
    \        let mut suffix_postfix_reversed_length = suffix_postfix_reversed.len();\n\
    \n        while suffix_postfix_reversed_length >= 0 {\n            suffix_postfix_reversed.push(suffix_postfix_reversed[suffix_postfix_reversed_length]);\n\
    \            suffix_postfix_reversed_length -= 1;\n        }\n\n        let mut\
    \ suffix_postfix_reversed_reversed = suffix_postfix_reversed.chars().collect::<Vec<_>>().rev();\n\
    \n        if suffix_postfix_reversed.is_empty() {\n            break;\n      \
    \  }\n\n        let mut suffix_postfix_reversed_reversed_length = suffix_postfix_reversed_reversed.len();\n\
    \n        while suffix_postfix_reversed_reversed_length >= 0 {\n            suffix_postfix_reversed_reversed.push(suffix_postfix_reversed_reversed[suffix_postfix_reversed_reversed_length]);\n\
    \            suffix_postfix_reversed_reversed_length -= 1;\n        }\n\n    \
    \    let mut suffix_postfix_reversed_reversed_reversed = suffix_postfix_reversed_reversed.chars().collect::<Vec<_>>().rev();\n\
    \n        if suffix_postfix_reversed_reversed.is_empty() {\n            break;\n\
    \        }\n\n        let mut suffix_postfix_reversed_reversed_reversed_length\
    \ = suffix_postfix_reversed_reversed_reversed.len();\n\n        while suffix_postfix_reversed_reversed_reversed_length\
    \ >= 0 {\n            suffix_postfix_reversed_reversed_reversed.push(suffix_postfix_reversed_reversed_reversed[suffix_postfix_reversed_reversed_reversed_length]);\n\
    \            suffix_postfix_reversed_reversed_reversed_length -= 1;\n        }\n\
    \n        let mut suffix_postfix_reversed_reversed_reversed_reversed = suffix_postfix_reversed_reversed_reversed.chars().collect::<Vec<_>>().rev();\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxyof4kqg.rs:64:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n11 |     while suffix_length\
    \ < string.len() {\n   |                                        - this delimiter\
    \ might not be properly closed...\n...\n55 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n64 | }\n   |   ^\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpxyof4kqg.rs:16:33\n   |\n\
    16 |             suffix_postfix.push(string[suffix_postfix_length]);\n   |   \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmpxyof4kqg.rs:20:86\n\
    \    |\n20  |           let mut suffix_postfix_reversed = suffix_postfix.chars().collect::<Vec<_>>().rev();\n\
    \    |                                                                       \
    \                 ^^^ `Vec<char>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<char>: Iterator`\n      \
    \      which is required by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n\
    \            which is required by `&mut [char]: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpxyof4kqg.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut last_char: char;\n    let mut last_char_pos: usize =\
    \ 0;\n    let mut last_char_pos_reverse: usize = 0;\n    let mut last_char_pos_reverse_index:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index2: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index3: usize = 0;\n    let mut last_char_pos_reverse_index4:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index5: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index6: usize = 0;\n    let mut last_char_pos_reverse_index7:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index8: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index9: usize = 0;\n    let mut last_char_pos_reverse_index10:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index11: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index12: usize = 0;\n    let mut last_char_pos_reverse_index13:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index14: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index15: usize = 0;\n    let mut last_char_pos_reverse_index16:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index17: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index18: usize = 0;\n    let mut last_char_pos_reverse_index19:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index20: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index21: usize = 0;\n    let mut last_char_pos_reverse_index22:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index23: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index24: usize = 0;\n    let mut last_char_pos_reverse_index25:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index26: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index27: usize = 0;\n    let mut last_char_pos_reverse_index28:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index29: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index30: usize = 0;\n    let mut last_char_pos_reverse_index31:\
    \ usize = 0;\n    let mut last_char_pos_reverse_index32: usize = 0;\n    let mut\
    \ last_char_pos_reverse_index33: usize = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpt7l4gp2h.rs:45:1\n  \
    \ |\n45 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for pos in string.rfind('a') {\n        if pos == 0 {\n          \
    \  break;\n        }\n        let mut suffix = &string[..pos];\n        let mut\
    \ prefix_length = longest_postfix_length;\n        while suffix.len() > prefix_length\
    \ {\n            if suffix[prefix_length..].chars().all(|c| !c.is_alphanumeric())\
    \ {\n                prefix_length += 1;\n            } else {\n             \
    \   break;\n            }\n        }\n        reversed_string.push('a');\n   \
    \     reversed_string.push(suffix);\n        longest_postfix_length = prefix_length;\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmand_jo_.rs:22:30\n   |\n\
    22 |         reversed_string.push(suffix);\n   |                             \
    \ ^^^^^^ expected `char`, found `&str`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ prefix_string = String::new();\n    let mut suffix_string = String::new();\n\
    \    let mut longest_postfix_string = String::new();\n    let mut longest_postfix_string_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length = String::new();\n\
    \    let mut longest_postfix_string_length_length_length = String::new();\n  \
    \  let mut longest_postfix_string_length_length_length_length = String::new();\n\
    \    let mut longest_postfix_string_length_length_length_length_length = String::new();\n\
    \    let mut longest_postfix_string_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = String::new();\n    let mut longest_postfix_string_length_length_length_length_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoaga5iru.rs:30:64\n   |\n\
    30 |     let mut longest_postfix_string_length_length_length_length_\n   |   \
    \                                                             ^ help: add `;`\
    \ here\n31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpoaga5iru.rs:5:39\n  |\n5 | fn make_palindrome(string: String) -> String\
    \ {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4lt9dc03.rs:57:16\n   |\n\
    57 |     let mut lon\n   |                ^ help: add `;` here\n58 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4lt9dc03.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string_to_reverse = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgs3g2_yd.rs:53:29\n   |\n\
    53 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpgs3g2_yd.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_chars\
    \ = String::new();\n\n    while longest_postfix_length < string.len() {\n    \
    \    let mut longest_postfix_char = string[longest_postfix_index];\n        let\
    \ mut longest_postfix_char_length = 0;\n\n        while longest_postfix_char_length\
    \ < longest_postfix_chars.len() {\n            if longest_postfix_char == longest_postfix_chars[longest_postfix_char_length]\
    \ {\n                longest_postfix_char_length += 1;\n            } else {\n\
    \                break;\n            }\n        }\n\n        if longest_postfix_char_length\
    \ == longest_postfix_chars.len() {\n            longest_postfix_chars.push_str(&longest_postfix_char);\n\
    \            longest_postfix_length += 1;\n        } else {\n            break;\n\
    \        }\n\n        longest_postfix_index += 1;\n    }\n\n    reversed_string.push_str(&longest_postfix_chars);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp_q0yucrq.rs:12:40\n   |\n12 |         let mut longest_postfix_char =\
    \ string[longest_postfix_index];\n   |                                       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n  \
    \ |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_q0yucrq.rs:16:40\n   |\n16 |             if longest_postfix_char\
    \ == longest_postfix_chars[longest_postfix_char_length] {\n   |              \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmp_q0yucrq.rs:12:13\n   |\n12 |         let\
    \ mut longest_postfix_char = string[longest_postfix_index];\n   |            \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n \
    \  = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = string\n        .chars()\n        .enumerate()\n  \
    \      .filter(|&(_, c)| c.is_alphanumeric())\n        .map(|(_, c)| c.to_digit(10))\n\
    \        .max()\n        .unwrap();\n    let mut longest_postfix_string = String::new();\n\
    \    let mut longest_postfix_string_length = longest_postfix_string.len();\n \
    \   let mut longest_postfix_string_start = longest_postfix_string.len();\n   \
    \ let mut longest_postfix_string_end = longest_postfix_string.len();\n    let\
    \ mut longest_postfix_string_start_index = longest_postfix_string.len();\n   \
    \ let mut longest_postfix_string_end_index = longest_postfix_string.len();\n \
    \   let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n    let mut longest_postfix_string_end_index\
    \ = 0;\n    let mut longest_postfix_string_start_index = 0;\n\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_bw8dh11.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk2nlhorv.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk2nlhorv.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n\n    while !palindrome.is_empty() {\n        let mut index = palindrome.len()\
    \ - 1;\n        let mut char = String::new();\n\n        while index >= 0 {\n\
    \            char.push(palindrome[index]);\n            index -= 1;\n        }\n\
    \n        palindrome = &char.reverse();\n        reversed_string.push(palindrome);\n\
    \    }\n\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpi1gsixc9.rs:14:23\n\
    \   |\n14 |             char.push(palindrome[index]);\n   |                  \
    \     ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpi1gsixc9.rs:18:28\n   |\n18 |         palindrome\
    \ = &char.reverse();\n   |                            ^^^^^^^ help: there is an\
    \ associated function with a similar name: `reserve`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi1gsixc9.rs:19:30\n   |\n19 |         reversed_string.push(palindrome);\n\
    \   |                              ^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut postfix_length\
    \ = 0;\n    let mut prefix_length = 0;\n    while !reversed_string.is_empty()\
    \ {\n        let mut postfix = reversed_string.split_last_mut().unwrap();\n  \
    \      let mut prefix = reversed_string.split_first_mut().unwrap();\n        let\
    \ mut i = 0;\n        while i < prefix.len() {\n            if prefix[i] != postfix[i]\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == prefix.len() {\n            postfix_length += 1;\n           \
    \ reversed_string = reversed_string.split_first_mut().unwrap();\n        } else\
    \ {\n            prefix_length += 1;\n            reversed_string = reversed_string.split_last_mut().unwrap();\n\
    \        }\n    }\n    let mut palindrome = String::new();\n    palindrome.push_str(&string);\n\
    \    palindrome.push_str(&reversed_string);\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpcmk3cfen.rs:10:43\n   |\n10 |         let\
    \ mut postfix = reversed_string.split_last_mut().unwrap();\n   |             \
    \                              ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `split_at`\n\nerror[E0599]: no method named `split_first_mut`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpcmk3cfen.rs:11:42\n\
    \   |\n11 |         let mut prefix = reversed_string.split_first_mut().unwrap();\n\
    \   |                                          ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `split_at_mut`\n\nerror[E0599]:\
    \ no method named `split_first_mut` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpcmk3cfen.rs:21:47\n   |\n21 |             reversed_string = reversed_string.split_first_mut().unwrap();\n\
    \   |                                               ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `split_at_mut`\n\nerror[E0599]:\
    \ no method named `split_last_mut` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpcmk3cfen.rs:24:47\n   |\n24 |             reversed_string = reversed_string.split_last_mut().unwrap();\n\
    \   |                                               ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `split_at`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_post\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqwbrzep_.rs:42:41\n   |\n\
    42 |     let mut longest_postfix_postfix_post\n   |                          \
    \               ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpqwbrzep_.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    for c in string.chars() {\n        if longest_postfix_length < c.len_utf8()\
    \ {\n            longest_postfix_length = c.len_utf8();\n        }\n    }\n  \
    \  for c in string.chars() {\n        if longest_postfix_length < c.len_utf8()\
    \ {\n            reversed_string += &c.to_ascii_lowercase()[longest_postfix_length..];\n\
    \        }\n    }\n    reversed_string += &string[longest_postfix_length..];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmp_1a_lrfd.rs:15:33\n\
    \   |\n15 |             reversed_string += &c.to_ascii_lowercase()[longest_postfix_length..];\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmp_1a_lrfd.rs:18:5\n   |\n18 |     reversed_string += &string[longest_postfix_length..];\n\
    \   |     ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |     |\n \
    \  |     cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_1a_lrfd.rs:19:5\n   |\n5  | fn make_palindrome(string: String) -> String\
    \ {\n   |                                       ------ expected `String` because\
    \ of return type\n...\n19 |     reversed_string\n   |     ^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_count = 0;\n    let mut longest_postfix_length_reverse_count2\
    \ = 0;\n    let mut longest_postfix_length_reverse_count3 = 0;\n    let mut longest_postfix_length_reverse_count4\
    \ = 0;\n    let mut longest_postfix_length_reverse_count5 = 0;\n    let mut longest_postfix_length_reverse_count6\
    \ = 0;\n    let mut longest_postfix_length_reverse_count7 = 0;\n    let mut longest_postfix_length_reverse_count8\
    \ = 0;\n    let mut longest_postfix_length_reverse_count9 = 0;\n    let mut longest_postfix_length_reverse_count10\
    \ = 0;\n    let mut longest_postfix_length_reverse_count11 = 0;\n    let mut longest_postfix_length_reverse_count12\
    \ = 0;\n    let mut longest_postfix_length_reverse_count13 = 0;\n    let mut longest_postfix_length_reverse_count14\
    \ = 0;\n    let mut longest_postfix_length_reverse_count15 = 0;\n    let mut longest_postfix_length_reverse_count16\
    \ = 0;\n    let mut longest_postfix_length_reverse_count17 = 0;\n    let mut longest_postfix_length_reverse_count18\
    \ = 0;\n    let mut longest_postfix_length_reverse_count19 = 0;\n    let mut longest_postfix_length_reverse_count20\
    \ = 0;\n    let mut longest_postfix_length_reverse_count21 = 0;\n    let mut longest_postfix_length_reverse_count22\
    \ = 0;\n    let mut longest_postfix_length_reverse_count23 = 0;\n    let mut longest_postfix_length_reverse_count24\
    \ = 0;\n    let mut longest_postfix_length_reverse_count25 = 0;\n    let mut longest_postfix_length_reverse_count26\
    \ = 0;\n    let mut longest_postfix_length_reverse_count27 = 0;\n    let mut longest_postfix_length_reverse_count28\
    \ = 0;\n    let mut longest_postfix_length_reverse_count29 = 0;\n    let mut longest_postfix_length_reverse_count30\
    \ = 0;\n    let mut longest_postfix_length_reverse_count31 = 0;\n    let mut longest_postfix_length_reverse_count32\
    \ = 0;\n    let mut longest_postfix_length_re\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd0m9xwvy.rs:44:38\n   |\n\
    44 |     let mut longest_postfix_length_re\n   |                             \
    \         ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpd0m9xwvy.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut prefix_length\
    \ = 0;\n    let mut suffix_length = 0;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_string\
    \ = String::new();\n    let mut longest_postfix_length_string_length = String::new();\n\
    \    let mut longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length\
    \ = String::new();\n    let mut longest_postfix_length_string_length_index = 0;\n\
    \    let mut longest_postfix_length_string_length = String::new();\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length\
    \ = String::new();\n    let mut longest_postfix_length_string_length_index = 0;\n\
    \    let mut longest_postfix_length_string_length = String::new();\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length\
    \ = String::new();\n    let mut longest_postfix_length_string_length_index = 0;\n\
    \    let mut longest_postfix_length_string_length = String::new();\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length\
    \ = String::new();\n    let mut longest_postfix_length_string_length_index = 0;\n\
    \    let mut longest_postfix_length_string_length = String::new();\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length\
    \ = String::new();\n    let mut longest_postfix_length_string_length_index = 0;\n\
    \    let mut longest_postfix_length_string_length = String::new();\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length\
    \ = String::new();\n    let mut longest_postfix_length_string_length_index = 0;\n\
    \    let mut longest_postfix_length_string_length = String::new();\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length\
    \ = String::new();\n    let mut longest_postfix_length_string_length_index = 0;\n\
    \    let mut longest_postfix_length_string_length = String::new();\n    let mut\
    \ longest_postfix_length_string_length_index = 0;\n    let mut longest_postfix_length_string_length\
    \ = String::new();\n    let mut longest_postfix_length_string_length_index = 0;\n\
    \    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppcii1ztz.rs:44:21\n   |\n\
    44 |     let mut longest_\n   |                     ^ help: add `;` here\n45 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmppcii1ztz.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_len\
    \ = string.len();\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_start = -1;\n    let mut\
    \ longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_start = -1;\n \
    \   let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_start = -1;\n \
    \   let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_start =\
    \ -1;\n    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_start = -1;\n    let mut\
    \ longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_start =\
    \ -1;\n    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_start = -1;\n    let mut\
    \ longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_start =\
    \ -1;\n    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_post\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwrelnqgu.rs:38:33\n   |\n\
    38 |     let mut longest_postfix_post\n   |                                 ^\
    \ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpwrelnqgu.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = String::new();\n\
    \    let mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwyuzhynf.rs:45:29\n   |\n\
    45 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpwyuzhynf.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut palindrome\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    let mut suffix_index = 0;\n    let mut suffix_length_index = 0;\n    while\
    \ suffix_length_index < suffix_length {\n        let mut suffix_char = &mut suffix_string[suffix_index];\n\
    \        let mut suffix_char_length = suffix_char.len();\n        while suffix_char_length\
    \ >= prefix_length {\n            let mut prefix_char = &mut prefix_string[prefix_length];\n\
    \            let mut prefix_char_length = prefix_char.len();\n            while\
    \ prefix_char_length >= suffix_char_length {\n                let mut suffix_char\
    \ = &mut suffix_string[suffix_length_index];\n                let mut suffix_char_length\
    \ = suffix_char.len();\n                while suffix_char_length >= prefix_char_length\
    \ {\n                    let mut prefix_char = &mut prefix_string[prefix_length];\n\
    \                    let mut prefix_char_length = prefix_char.len();\n       \
    \             while prefix_char_length >= suffix_char_length {\n             \
    \           let mut suffix_char = &mut suffix_string[suffix_length_index];\n \
    \                       let mut suffix_char_length = suffix_char.len();\n    \
    \                    while suffix_char_length >= prefix_char_length {\n      \
    \                      let mut prefix_char = &mut prefix_string[prefix_length];\n\
    \                            let mut prefix_char_length = prefix_char.len();\n\
    \                            while prefix_char_length >= suffix_char_length {\n\
    \                                let mut suffix_char = &mut suffix_string[suffix_length_index];\n\
    \                                let mut suffix_char_length = suffix_char.len();\n\
    \                                while suffix_char_length >= prefix_char_length\
    \ {\n                                    let mut prefix_char = &mut prefix_string[prefix_length];\n\
    \                                    let mut prefix_char_length = prefix_char.len();\n\
    \                                    while prefix_char_length >= suffix_char_length\
    \ {\n                                        let mut suffix_char = &mut suffix_string[suffix_length_index];\n\
    \                                        let mut suffix_char_length = suffix_char.len();\n\
    \                                        while suffix_char_length >= prefix_char_length\
    \ {\n                                            let mut prefix_char = &mut prefix_string[prefix_length];\n\
    \                                            let mut prefix_char_length = prefix_char.len();\n\
    \                                            while prefix_char_length >= suffix_char_length\
    \ {\n                                                let mut suffix_char = &mut\
    \ suffix_string[suffix_length_index];\n\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp83oqvls_.rs:54:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n12 |     while suffix_length_index\
    \ < suffix_length {\n   |                                               - unclosed\
    \ delimiter\n...\n15 |         while suffix_char_length >= prefix_length {\n \
    \  |                                                   - unclosed delimiter\n\
    ...\n18 |             while prefix_char_length >= suffix_char_length {\n   | \
    \                                                           - unclosed delimiter\n\
    ...\n21 |                 while suffix_char_length >= prefix_char_length {\n \
    \  |                                                                - unclosed\
    \ delimiter\n...\n24 |                     while prefix_char_length >= suffix_char_length\
    \ {\n   |                                                                    -\
    \ unclosed delimiter\n...\n27 |                         while suffix_char_length\
    \ >= prefix_char_length {\n   |                                              \
    \                          - unclosed delimiter\n...\n30 |                   \
    \          while prefix_char_length >= suffix_char_length {\n   |            \
    \                                                                - unclosed delimiter\n\
    ...\n33 |                                 while suffix_char_length >= prefix_char_length\
    \ {\n   |                                                                    \
    \            - unclosed delimiter\n...\n36 |                                 \
    \    while prefix_char_length >= suffix_char_length {\n   |                  \
    \                                                                  - unclosed\
    \ delimiter\n...\n39 |                                         while suffix_char_length\
    \ >= prefix_char_length {\n   |                                              \
    \                                          - unclosed delimiter\n...\n42 |   \
    \                                          while prefix_char_length >= suffix_char_length\
    \ {\n   |     "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45 = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_4godlq.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9_4godlq.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length_index = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindro\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4adx5z38.rs:29:44\n   |\n\
    29 |     let mut longest_postfix_length_palindro\n   |                       \
    \                     ^ help: add `;` here\n30 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp4adx5z38.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut palindrome =\
    \ string;\n    let mut reversed_string = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut i = 0;\n    let mut j = 0;\n    while i < string.len()\
    \ && j < palindrome.len() {\n        if string[i] != palindrome[j] {\n       \
    \     break;\n        }\n        i += 1;\n        j += 1;\n    }\n    while i\
    \ < string.len() {\n        reversed_string += string[i];\n        i += 1;\n \
    \   }\n    while j < palindrome.len() {\n        reversed_palindrome += palindrome[j];\n\
    \        j += 1;\n    }\n    reversed_palindrome += reversed_string;\n    return\
    \ reversed_palindrome;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx1_aok1m.rs:13:12\n\
    \   |\n13 |         if string[i] != palindrome[j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx1_aok1m.rs:13:25\n   |\n13 |         if string[i] != palindrome[j]\
    \ {\n   |                         ^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx1_aok1m.rs:20:28\n   |\n20 |         reversed_string += string[i];\n\
    \   |                            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n   "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start =\
    \ -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp4ii_ann0.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for pos in string.len() {\n        let mut postfix_length = pos;\n\
    \        while postfix_length >= 0 && string[postfix_length] != string[postfix_length\
    \ - 1] {\n            postfix_length -= 1;\n        }\n        if postfix_length\
    \ >= 0 {\n            longest_postfix_length = std::cmp::max(longest_postfix_length,\
    \ postfix_length);\n        }\n    }\n    let mut postfix_length = longest_postfix_length;\n\
    \    let mut postfix_length_to_append = longest_postfix_length;\n    while postfix_length\
    \ >= 0 {\n        let mut postfix_length_to_append = postfix_length_to_append\
    \ - 1;\n        while postfix_length >= 0 && string[postfix_length] == string[postfix_length_to_append]\
    \ {\n            postfix_length -= 1;\n            postfix_length_to_append -=\
    \ 1;\n        }\n        if postfix_length >= 0 {\n            break;\n      \
    \  }\n    }\n    reversed_string += &string[postfix_length_to_append..];\n   \
    \ reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `usize` is not an iterator\n --> /tmp/tmp640amekn.rs:8:16\n\
    \  |\n8 |     for pos in string.len() {\n  |                ^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `usize`\n  = note: if you want to iterate between `start` until a value `end`,\
    \ use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `usize`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp640amekn.rs:10:38\n   |\n10 |         while postfix_length >= 0\
    \ && string[postfix_length] != string[postfix_length - 1] {\n   |            \
    \                          ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp640amekn.rs:21:38\n   |\n21 |         while postfix_length >= 0\
    \ && string[postfix_length] == string[postfix_length_to_append] {\n   |      \
    \                                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ I"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut postfix_length\
    \ = 0;\n    let mut postfix_start = -1;\n    let mut postfix_end = -1;\n    while\
    \ postfix_length < string.len() {\n        let mut postfix_start = -1;\n     \
    \   let mut postfix_end = -1;\n        for (i, c) in string.chars().enumerate()\
    \ {\n            if postfix_length == i {\n                postfix_start = i;\n\
    \            }\n            if postfix_length + 1 == i {\n                postfix_end\
    \ = i;\n            }\n            if postfix_length + 1 == i && postfix_start\
    \ != i {\n                postfix_length += 1;\n            }\n        }\n   \
    \     if postfix_length >= string.len() {\n            break;\n        }\n   \
    \     let mut postfix_string = &string[postfix_start..postfix_end];\n        let\
    \ mut reversed_postfix_string = &string[postfix_end..postfix_start];\n       \
    \ if postfix_string.chars().all(|c| !c.is_alphanumeric()) {\n            reversed_postfix_string\
    \ = reversed_postfix_string.chars().collect::<String>();\n        }\n        reversed_string\
    \ += &reversed_postfix_string[..];\n        postfix_length += 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpewxocra5.rs:11:33\n\
    \   |\n11 |         let mut postfix_start = -1;\n   |                        \
    \         ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpewxocra5.rs:12:31\n\
    \   |\n12 |         let mut postfix_end = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpewxocra5.rs:30:39\n   |\n28 |  \
    \       let mut reversed_postfix_string = &string[postfix_end..postfix_start];\n\
    \   |                                           -----------------------------------\
    \ expected due to this value\n29 |         if postfix_string.chars().all(|c| !c.is_alphanumeric())\
    \ {\n30 |             reversed_postfix_string = reversed_postfix_string.chars().collect::<String>();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                       |\n   |                          \
    \             expected `&str`, found struct `String`\n   |                   \
    \                    help: consider borrowing here: `&reversed_postfix_string.chars().collect::<String>()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmdrelx33.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_string2 = \"\";\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_string3 = \"\";\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_string4 = \"\";\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_string5 = \"\";\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_string6 = \"\";\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_string7 = \"\";\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_string8 = \"\";\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_string9 = \"\";\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_string10 = \"\";\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_string11 = \"\";\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_string12 = \"\";\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_string13 = \"\";\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_string14 = \"\";\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_string15 = \"\";\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_string16 = \"\";\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_string17 = \"\";\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_string18 = \"\";\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_string19 = \"\";\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_string20 = \"\";\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_string21 = \"\";\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_string22 = \"\";\n    let mut longest_postfix_index23\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq3edrji0.rs:53:36\n   |\n\
    53 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpq3edrji0.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut palindrome\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_index = 0;\n    let\
    \ mut longest_postfix_length_reverse_suffix_reverse = 0;\n    let mut longest_postfix_length_reverse_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_reverse_suffix_suffix_index = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix = 0;\n\
    \    let mut longest_postfix_length_reverse_suffix_suffix_suffix_reverse = 0;\n\
    \    let mut longest_postfix_length_reverse_suffix_suffix_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix_suffix_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_reverse_suffix_suffi\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2_fh46vr.rs:34:56\n   |\n\
    34 |     let mut longest_postfix_length_reverse_suffix_suffi\n   |           \
    \                                             ^ help: add `;` here\n35 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2_fh46vr.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_index = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3d_fjcqc.rs:57:16\n   |\n\
    57 |     let mut lon\n   |                ^ help: add `;` here\n58 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3d_fjcqc.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n\
    \    while suffix_length != palindrome.len() {\n        let mut suffix_length\
    \ = 0;\n        while suffix_length != palindrome.len() {\n            suffix_length\
    \ = palindrome.len();\n            palindrome = &palindrome[..suffix_length];\n\
    \        }\n        let mut prefix_length = 0;\n        while prefix_length !=\
    \ palindrome.len() {\n            prefix_length = palindrome.len();\n        \
    \    palindrome = &palindrome[..prefix_length];\n        }\n        reversed_palindrome\
    \ = &reversed_palindrome[..prefix_length];\n        reversed_palindrome = &reversed_palindrome[..suffix_length];\n\
    \    }\n    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_palindrome[..];\n\
    \    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_palindrome[..];\n\
    \    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_palindrome[..];\n\
    \    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_palindrome[..];\n\
    \    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_palindrome[..];\n\
    \    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_palindrome[..];\n\
    \    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_palindrome[..];\n\
    \    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_palindrome[..];\n\
    \    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_palindrome[..];\n\
    \    palindrome = &palindrome[..];\n    reversed_palindrome = &reversed_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `reversed_` in this scope\n  --> /tmp/tmp1igbh0xl.rs:43:28\n\
    \   |\n43 |     reversed_palindrome = &reversed_\n   |                       \
    \     ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1igbh0xl.rs:14:26\n   |\n6  |     let mut palindrome = string;\n   |\
    \                          ------ expected due to this value\n...\n14 |      \
    \       palindrome = &palindrome[..suffix_length];\n   |                     \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n  \
    \ |\nhelp: try using a conversion method\n   |\n14 |             palindrome =\
    \ (&palindrome[..suffix_length]).to_string();\n   |                          +\
    \                            +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1igbh0xl.rs:19:26\n   |\n6  |     let mut palindrome = string;\n\
    \   |                          ------ expected due to this value\n...\n19 |  \
    \           palindrome = &palindrome[..prefix_length];\n   |                 \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n19 |             palindrome\
    \ = (&palindrome[..prefix_length]).to_string();\n   |                        \
    \  +                            +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1igbh0xl.rs:21:31\n   |\n7  |     let mut reversed_palindrome =\
    \ string;\n   |                                   ------ expected due to this\
    \ value\n...\n21 |         reversed_palindrome = &reversed_palindrome[..prefix_length];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n21 |         reversed_palindrome = (&reversed_palindrome[..prefix_length]).to_string();\n\
    \   |                               +                                     +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1igbh0xl.rs:22:31\n   |\n7  |\
    \     let mut reversed_palindrome = string;\n   |                            \
    \       ------ expected due to this value\n...\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n\
    \    while !palindrome.is_empty() {\n        let mut suffix_length = palindrome.len();\n\
    \        while suffix_length > 0 {\n            let mut prefix_length = suffix_length;\n\
    \            while prefix_length > 0 {\n                let mut index = suffix_length\
    \ - prefix_length;\n                while index >= 0 {\n                    let\
    \ mut char = reversed_string[index];\n                    reversed_string[index]\
    \ = reversed_string[prefix_length];\n                    reversed_string[prefix_length]\
    \ = char;\n                    index -= 1;\n                    prefix_length\
    \ -= 1;\n                }\n                suffix_length -= 1;\n            }\n\
    \            palindrome = &palindrome[..suffix_length];\n        }\n    }\n  \
    \  palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws9malyp.rs:17:36\n\
    \   |\n17 |                     let mut char = reversed_string[index];\n   | \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpws9malyp.rs:18:21\n   |\n18 |                     reversed_string[index]\
    \ = reversed_string[prefix_length];\n   |                     ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpws9malyp.rs:18:46\n   |\n18 |                     reversed_string[index]\
    \ = reversed_string[prefix_length];\n   |                                    \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeIncl"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk2nlhorv.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk2nlhorv.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut reversed_string_length\
    \ = 0;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_post\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj6zay98s.rs:53:25\n   |\n\
    53 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpj6zay98s.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut palindrome =\
    \ string;\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_string2\
    \ = \"\";\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_string3\
    \ = \"\";\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_string4\
    \ = \"\";\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_string5\
    \ = \"\";\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_string6\
    \ = \"\";\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_string7\
    \ = \"\";\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_string8\
    \ = \"\";\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_string9\
    \ = \"\";\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_string10\
    \ = \"\";\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_string11\
    \ = \"\";\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_string12\
    \ = \"\";\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_string13\
    \ = \"\";\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_string14\
    \ = \"\";\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_string15\
    \ = \"\";\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_string16\
    \ = \"\";\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_string17\
    \ = \"\";\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_string18\
    \ = \"\";\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_string19\
    \ = \"\";\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_string20\
    \ = \"\";\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_string21\
    \ = \"\";\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_string22\
    \ = \"\";\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfc2ta1s4.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_index\
    \ = -1;\n    for index in 0..string.len() {\n        let mut postfix_index = index;\n\
    \        let mut postfix_char = string[index];\n        while postfix_index >=\
    \ 0 && postfix_char != string[postfix_index] {\n            postfix_index -= 1;\n\
    \            postfix_char = string[postfix_index];\n        }\n        if postfix_index\
    \ >= 0 {\n            longest_postfix_index = index;\n        }\n    }\n    let\
    \ mut postfix_string = string;\n    for index in longest_postfix_index..string.len()\
    \ {\n        let mut postfix_char = string[index];\n        while index >= 0 &&\
    \ postfix_char != string[index] {\n            index -= 1;\n            postfix_char\
    \ = string[index];\n        }\n        if index >= 0 {\n            postfix_string\
    \ = postfix_string.insert(index, reversed_string[index]);\n        }\n    }\n\
    \    postfix_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9exci9ch.rs:10:32\n\
    \   |\n10 |         let mut postfix_char = string[index];\n   |              \
    \                  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9exci9ch.rs:11:53\n\
    \   |\n11 |         while postfix_index >= 0 && postfix_char != string[postfix_index]\
    \ {\n   |                                                     ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9exci9ch.rs:13:28\n   |\n13 |             postfix_char = string[postfix_index];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<Range"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_reverse\
    \ = \"\";\n    let mut longest_postfix_postfix_reverse_index = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index2 = 0;\n    let mut longest_postfix_postfix_reverse_index3\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index4 = 0;\n    let mut longest_postfix_postfix_reverse_index5\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index6 = 0;\n    let mut longest_postfix_postfix_reverse_index7\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index8 = 0;\n    let mut longest_postfix_postfix_reverse_index9\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index10 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index11 = 0;\n    let mut longest_postfix_postfix_reverse_index12\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index13 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index14 = 0;\n    let mut longest_postfix_postfix_reverse_index15\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index16 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index17 = 0;\n    let mut longest_postfix_postfix_reverse_index18\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index19 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index20 = 0;\n    let mut longest_postfix_postfix_reverse_index21\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index22 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index23 = 0;\n    let mut longest_postfix_postfix_reverse_index24\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index25 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index26 = 0;\n    let mut longest_postfix_postfix_reverse_index27\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index28 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index29 = 0;\n    let mut longest_postfix_postfix_reverse_index30\
    \ = 0;\n    let mut longest_postfix_postfix_reverse_index31 = 0;\n    let mut\
    \ longest_postfix_postfix_reverse_index32 = 0;\n    let mut longest_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpis6xp9x5.rs:44:29\n   |\n\
    44 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpis6xp9x5.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = String::new();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_start_length = String::new();\n\
    \    let mut longest_postfix_start_length = longest_postfix_start.len();\n   \
    \ let mut longest_postfix_start_start = String::new();\n    let mut longest_postfix_start_start_length\
    \ = String::new();\n    let mut longest_postfix_start_start_length = longest_postfix_start_start.len();\n\
    \    let mut longest_postfix_start_start_start = String::new();\n    let mut longest_postfix_start_start_start_length\
    \ = String::new();\n    let mut longest_postfix_start_start_start_length = longest_postfix_start_start_start.len();\n\
    \    let mut longest_postfix_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_start_start_start_length = String::new();\n    let\
    \ mut longest_postfix_start_start_start_start_length = longest_postfix_start_start_start_start.len();\n\
    \    let mut longest_postfix_start_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_start_start_start_length = String::new();\n\
    \    let mut longest_postfix_start_start_start_start_length = longest_postfix_start_start_start_start.len();\n\
    \    let mut longest_postfix_start_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_start_start_start_start_length = String::new();\n\
    \    let mut longest_postfix_start_start_start_start_start_length = longest_postfix_start_start_start_start_start.len();\n\
    \    let mut longest_postfix_start_start_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_start_start_start_start_start_length = String::new();\n\
    \    let mut longest_postfix_start_start_start_start_start_start_start_length\
    \ = longest_postfix_start_start_start_start_start_start.len();\n    let mut longest_postfix_start_start_start_start_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_start_start_start_start_start_start_length\
    \ = String::new();\n    let mut longest_postfix_start_start_start_start_start_start_start_length\
    \ = longest_postfix_start_start_start_start_start_start_start.len();\n    let\
    \ mut longest_postfix_start_start_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfdjkxcsp.rs:34:41\n   |\n\
    34 |     let mut longest_postfix_start_start_\n   |                          \
    \               ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpfdjkxcsp.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reversed_string\
    \ = String::new();\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpv8sry3sj.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_char:\
    \ char;\n    for c in reversed_string.chars() {\n        if longest_postfix_length\
    \ < c.len() {\n            longest_postfix_length = c.len();\n            longest_postfix_index\
    \ = longest_postfix_length;\n            longest_postfix_char = c;\n        }\n\
    \    }\n    let mut longest_postfix_string = String::new();\n    for c in reversed_string.chars()\
    \ {\n        if longest_postfix_length == c.len() {\n            longest_postfix_string\
    \ += &c[longest_postfix_index..];\n        }\n    }\n    reversed_string += longest_postfix_string;\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpcpo9wu55.rs:11:39\n   |\n11 |         if longest_postfix_length\
    \ < c.len() {\n   |                                       ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpcpo9wu55.rs:12:40\n   |\n12 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpcpo9wu55.rs:19:40\n   |\n19 |         if longest_postfix_length\
    \ == c.len() {\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpcpo9wu55.rs:20:40\n\
    \   |\n20 |             longest_postfix_string += &c[longest_postfix_index..];\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcpo9wu55.rs:23:24\n   |\n23 |     reversed_string\
    \ += longest_postfix_string;\n   |                        ^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&longest_postfix_string`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut suffix =\
    \ 0;\n    while palindrome.len() > 0 {\n        let mut start = palindrome.len()\
    \ - 1;\n        while start >= 0 {\n            if palindrome[start] != palindrome[start\
    \ + 1] {\n                break;\n            }\n            start -= 1;\n   \
    \     }\n        palindrome = palindrome[..start + 1];\n        suffix += 1;\n\
    \    }\n    palindrome += &string[..suffix];\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0pekgcz5.rs:11:16\n\
    \   |\n11 |             if palindrome[start] != palindrome[start + 1] {\n   |\
    \                ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0pekgcz5.rs:11:37\n\
    \   |\n11 |             if palindrome[start] != palindrome[start + 1] {\n   |\
    \                                     ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0pekgcz5.rs:16:22\n\
    \   |\n6  |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n16 |         palindrome = palindrome[..start\
    \ + 1];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                      |\n   |       \
    \               expected struct `String`, found `str`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_string2\
    \ = \"\";\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_string3\
    \ = \"\";\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_string4\
    \ = \"\";\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_string5\
    \ = \"\";\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_string6\
    \ = \"\";\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_string7\
    \ = \"\";\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_string8\
    \ = \"\";\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_string9\
    \ = \"\";\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_string10\
    \ = \"\";\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_string11\
    \ = \"\";\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_string12\
    \ = \"\";\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_string13\
    \ = \"\";\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_string14\
    \ = \"\";\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_string15\
    \ = \"\";\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_string16\
    \ = \"\";\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_string17\
    \ = \"\";\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_string18\
    \ = \"\";\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_string19\
    \ = \"\";\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_string20\
    \ = \"\";\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_string21\
    \ = \"\";\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_string22\
    \ = \"\";\n    let mut longest_postfix_index23 = 0;\n    let mut lon\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjrrufjau.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjrrufjau.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n\n    while !string.is_empty() {\n        let mut index = string.len()\
    \ - 1;\n        let mut char = string[index];\n\n        while index >= 0 {\n\
    \            reversed_string += char;\n            index -= 1;\n            char\
    \ = string[index];\n        }\n\n        string = &string[index..];\n    }\n\n\
    \    reversed_string += string;\n    reversed_string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9l2y40r1.rs:11:24\n\
    \   |\n11 |         let mut char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmp9l2y40r1.rs:14:13\n   |\n14 |             reversed_string\
    \ += char;\n   |             ---------------^^^^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `&str`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp9l2y40r1.rs:16:20\n   |\n16 |  \
    \           char = string[index];\n   |                    ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9l2y40r1.rs:19:18\n\
    \   |\n6  |     let mut string = string;\n   |                      ------ expected\
    \ due to this value\n...\n19 |         string = &string[index..];\n   |      \
    \            ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n19 |         string = (&string[index..]).to_string();\n\
    \   |        "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_start = -1;\n    let\
    \ mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix = String::new();\n\
    \    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = String::new();\n    let\
    \ mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = String::new();\n\
    \    let mut longest_postfix_postfix_postfix_postfix_start = -1;\n    let mut\
    \ longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_end = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix = String::new();\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_end = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix =\
    \ String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxskze8z8.rs:33:77\n   |\n\
    33 |     let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_\n\
    \   |                                                                        \
    \     ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpxskze8z8.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_index = -1;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mut longest_postfix_index_length\
    \ = 0;\n    let mut longest_postfix_index_length = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqem5at6y.rs:53:11\n   |\n\
    53 |     let mu\n   |           ^ help: add `;` here\n54 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpqem5at6y.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut palindrome =\
    \ string;\n    let mut reversed_string = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut i = 0;\n    let mut j = 0;\n    while i < string.len()\
    \ && j < palindrome.len() {\n        if string[i] == palindrome[j] {\n       \
    \     i += 1;\n            j += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    while i < string.len() {\n        reversed_string += string[i];\n\
    \        i += 1;\n    }\n    while j < palindrome.len() {\n        reversed_palindrome\
    \ += palindrome[j];\n        j += 1;\n    }\n    reversed_palindrome += reversed_string;\n\
    \    reversed_palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp80i0yycu.rs:13:12\n\
    \   |\n13 |         if string[i] == palindrome[j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp80i0yycu.rs:13:25\n   |\n13 |         if string[i] == palindrome[j]\
    \ {\n   |                         ^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp80i0yycu.rs:21:28\n   |\n21 |         reversed_string += string[i];\n\
    \   |                            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n   "
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = String::new();\n\
    \    let mut longest_postfix_index = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n    let mut longest_postfix_index_length\
    \ = String::new();\n    let mut longest_postfix_index_length = String::new();\n\
    \    let mut longest_postfix_index_length = String::new();\n\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp27wincud.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for pos in string.rfind('a'..='z') {\n        let postfix_length =\
    \ string.len() - pos - 1;\n        if postfix_length > longest_postfix_length\
    \ {\n            longest_postfix_length = postfix_length;\n        }\n    }\n\
    \    let mut postfix_length = 0;\n    let mut postfix_string = \"\";\n    while\
    \ longest_postfix_length > postfix_length {\n        let postfix_length = longest_postfix_length\
    \ - postfix_length;\n        postfix_string += &string[..postfix_length];\n  \
    \  }\n    reversed_string += &string[..postfix_length];\n    reversed_string +=\
    \ &string[postfix_length..];\n    reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `RangeInclusive<char>`\n\
    \ --> /tmp/tmp1v32_hf4.rs:8:29\n  |\n8 |     for pos in string.rfind('a'..='z')\
    \ {\n  |                       ----- ^^^^^^^^^ expected an `FnMut<(char,)>` closure,\
    \ found `RangeInclusive<char>`\n  |                       |\n  |             \
    \          required by a bound introduced by this call\n  |\n  = help: the trait\
    \ `FnMut<(char,)>` is not implemented for `RangeInclusive<char>`\n  = help: the\
    \ following other types implement trait `Pattern<'a>`:\n            &'b String\n\
    \            &'b [char; N]\n            &'b [char]\n            &'b str\n    \
    \        &'c &'b str\n            [char; N]\n            char\n            pattern::MultiCharEqPattern<C>\n\
    \  = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `RangeInclusive<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&str`\n  --> /tmp/tmp1v32_hf4.rs:18:9\n   |\n18 |      \
    \   postfix_string += &string[..postfix_length];\n   |         --------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0368.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut palindrome =\
    \ string;\n    let mut reversed_string = string;\n    let mut reversed_palindrome\
    \ = string;\n\n    while !string.is_empty() {\n        let mut i = string.len();\n\
    \        let mut j = string.len();\n\n        while i >= 0 {\n            i -=\
    \ 1;\n            j = j - 1;\n            if string[i] == string[j] {\n      \
    \          reversed_palindrome = reversed_palindrome.append(&string[i]);\n   \
    \             reversed_string = reversed_string.append(&string[j]);\n        \
    \    }\n        }\n\n        palindrome = palindrome.append(&reversed_palindrome);\n\
    \        reversed_palindrome = reversed_palindrome.append(&reversed_string);\n\
    \        reversed_string = reversed_string.append(&string);\n    }\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgeo5kwli.rs:18:16\n\
    \   |\n18 |             if string[i] == string[j] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgeo5kwli.rs:18:29\n   |\n18 |             if string[i] == string[j]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpgeo5kwli.rs:19:59\n   |\n19 |          \
    \       reversed_palindrome = reversed_palindrome.append(&string[i]);\n   |  \
    \                                                         ^^^^^^ method not found\
    \ in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgeo5kwli.rs:19:67\n   |\n19 |                 reversed_palindrome\
    \ = reversed_palindrome.append(&string[i]);\n   |                            \
    \                                       ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implement"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix = String::new();\n\
    \    let mut longest_postfix_length_postfix_index = String::new();\n    let mut\
    \ longest_postfix_length_postfix_palindrome = String::new();\n    let mut longest_postfix_length_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_postfix_index =\
    \ String::new();\n    let mut longest_postfix_length_postfix_postfix_palindrome\
    \ = \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp9tdmbplg.rs:34:1\n\
    \   |\n34 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_post\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqwbrzep_.rs:42:41\n   |\n\
    42 |     let mut longest_postfix_postfix_post\n   |                          \
    \               ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpqwbrzep_.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_index = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut longest_postfix_end_index\
    \ = -1;\n    let mut longest_postfix_start_length = -1;\n    let mut longest_postfix_end_length\
    \ = -1;\n    let mut longest_postfix_start_index = -1;\n    let mut \n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpz3dubrez.rs:54:1\n\
    \   |\n54 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_index = -1;\n    let mut longest_postfix_length = 0;\n    for\
    \ index in 0..string.len() {\n        let char = string[index];\n        if char\
    \ == char.to_string().chars().next().unwrap() {\n            longest_postfix_length\
    \ = index;\n            longest_postfix_index = index;\n        }\n    }\n   \
    \ if longest_postfix_length == 0 {\n        return string;\n    }\n    let mut\
    \ longest_postfix_string = String::new();\n    for index in 0..longest_postfix_length\
    \ {\n        let char = string[index];\n        longest_postfix_string.push(char);\n\
    \    }\n    let mut longest_postfix_reversed_string = String::new();\n    for\
    \ index in 0..longest_postfix_length {\n        let char = longest_postfix_string[index];\n\
    \        longest_postfix_reversed_string.push(char);\n    }\n    for index in\
    \ 0..longest_postfix_length {\n        let char = longest_postfix_string[index];\n\
    \        reversed_string.push(char);\n    }\n    reversed_string.push(reversed_string[longest_postfix_length..]);\n\
    \    reversed_string.push(reversed_string[0..longest_postfix_length]);\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4omrkep7.rs:10:20\n\
    \   |\n10 |         let char = string[index];\n   |                    ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n -->\
    \ /tmp/tmp4omrkep7.rs:7:37\n  |\n7 |     let mut longest_postfix_index = -1;\n\
    \  |                                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n  |\n  = help: the following other types implement trait `Neg`:\n\
    \            &f32\n            &f64\n            &i128\n            &i16\n   \
    \         &i32\n            &i64\n            &i8\n            &isize\n      \
    \    and 8 others\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4omrkep7.rs:21:20\n   |\n21 |         let char = string[index];\n\
    \   |                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4omrkep7.rs:26:20\n   |\n26 |         let char = longest_postfix_string[index];\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` can"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = 0;\n\n    for &c in string.chars() {\n \
    \       if longest_postfix_length < c.len() {\n            longest_postfix_length\
    \ = c.len();\n            longest_postfix = c.to_string();\n            longest_postfix_index\
    \ = longest_postfix.len();\n        }\n        if longest_postfix_length == c.len()\
    \ {\n            reversed_string.push(c);\n        }\n        if longest_postfix_length\
    \ < c.len() {\n            longest_postfix_length = c.len();\n            longest_postfix\
    \ = c.to_string();\n            longest_postfix_index = longest_postfix.len();\n\
    \        }\n    }\n\n    let mut reversed_postfix = String::new();\n    let mut\
    \ reversed_postfix_index = -1;\n    let mut reversed_postfix_length = 0;\n\n \
    \   for &c in reversed_string.chars() {\n        if reversed_postfix_length <\
    \ c.len() {\n            reversed_postfix_length = c.len();\n            reversed_postfix\
    \ = c.to_string();\n            reversed_postfix_index = reversed_postfix.len();\n\
    \        }\n        if reversed_postfix_length == c.len() {\n            reversed_postfix.push(c);\n\
    \        }\n        if reversed_postfix_length < c.len() {\n            reversed_postfix_length\
    \ = c.len();\n            reversed_postfix = c.to_string();\n            reversed_postfix_index\
    \ = reversed_postfix.len();\n        }\n    }\n\n    longest_postfix.push_str(&reversed_postfix);\n\
    \    longest_postfix.push_str(&string[longest_postfix_index..]);\n\n    longest_postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvtlfn2cf.rs:11:9\n   |\n\
    11 |     for &c in string.chars() {\n   |         ^^    -------------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpvtlfn2cf.rs:8:37\n\
    \  |\n8 |     let mut longest_postfix_index = -1;\n  |                       \
    \              ^^ the trait `Neg` is not implemented for `usize`\n  |\n  = help:\
    \ the following other types implement trait `Neg`:\n            &f32\n       \
    \     &f64\n            &i128\n            &i16\n            &i32\n          \
    \  &i64\n            &i8\n            &isize\n          and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvtlfn2cf.rs:31:9\n   |\n31 |     for &c in reversed_string.chars()\
    \ {\n   |         ^^    ----------------------- this expression has type `Option<char>`\n\
    \   |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpvtlfn2cf.rs:28:38\n   |\n28 | \
    \    let mut reversed_postfix_index = -1;\n   |                              \
    \        ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_post\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplujuxv_4.rs:53:25\n   |\n\
    53 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmplujuxv_4.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut prefix_length\
    \ = 0;\n    let mut suffix_length = 0;\n    while suffix_length < reversed_string.len()\
    \ {\n        let mut suffix_start = suffix_length;\n        let mut suffix_end\
    \ = suffix_length;\n        while suffix_end < reversed_string.len() {\n     \
    \       if reversed_string[suffix_end] != string[suffix_start] {\n           \
    \     break;\n            }\n            suffix_end += 1;\n        }\n       \
    \ if suffix_end == reversed_string.len() {\n            break;\n        }\n  \
    \      let mut prefix_start = prefix_length;\n        let mut prefix_end = prefix_length;\n\
    \        while prefix_end < reversed_string.len() {\n            if reversed_string[prefix_end]\
    \ != string[prefix_start] {\n                break;\n            }\n         \
    \   prefix_end += 1;\n        }\n        if prefix_end == reversed_string.len()\
    \ {\n            break;\n        }\n        reversed_string = &reversed_string[prefix_end..suffix_start];\n\
    \        suffix_length -= prefix_end - suffix_start + 1;\n        prefix_length\
    \ -= suffix_end - suffix_start + 1;\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2l95rzra.rs:13:16\n\
    \   |\n13 |             if reversed_string[suffix_end] != string[suffix_start]\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2l95rzra.rs:13:47\n   |\n13 |             if reversed_string[suffix_end]\
    \ != string[suffix_start] {\n   |                                            \
    \   ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2l95rzra.rs:24:16\n   |\n24 |             if reversed_string[prefix_end]\
    \ != string[prefix_start] {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <S"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz1r09b23.rs:53:34\n   |\n\
    53 |     let mut longest_postfix_index\n   |                                 \
    \ ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpz1r09b23.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for pos in string.rchars().rev() {\n        if pos == 0 {\n      \
    \      break;\n        }\n        let mut suffix = &string[..pos];\n        let\
    \ mut prefix = &string[..pos - 1];\n        let mut reversed_suffix = suffix;\n\
    \        let mut reversed_prefix = prefix;\n        while reversed_suffix.len()\
    \ > 0 {\n            let mut reversed_reversed_suffix = reversed_suffix;\n   \
    \         let mut reversed_reversed_prefix = reversed_prefix;\n            while\
    \ reversed_reversed_suffix.len() > 0 {\n                reversed_reversed_suffix\
    \ += reversed_reversed_suffix[..1];\n                reversed_reversed_prefix\
    \ += reversed_reversed_prefix[..1];\n            }\n            if reversed_suffix\
    \ != reversed_reversed_suffix {\n                break;\n            }\n     \
    \       reversed_suffix += reversed_reversed_suffix;\n            reversed_prefix\
    \ += reversed_reversed_prefix;\n        }\n        if reversed_suffix != suffix\
    \ {\n            break;\n        }\n        longest_postfix_length = pos;\n  \
    \      reversed_string += &prefix;\n        reversed_string += &reversed_suffix;\n\
    \    }\n    reversed_string += &string[..longest_postfix_length];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rchars` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp5d0t5pbi.rs:8:23\n  |\n8 |     for pos in string.rchars().rev()\
    \ {\n  |                       ^^^^^^ help: there is an associated function with\
    \ a similar name: `chars`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&str`\n  --> /tmp/tmp5d0t5pbi.rs:20:17\n   |\n20 |     \
    \            reversed_reversed_suffix += reversed_reversed_suffix[..1];\n   |\
    \                 ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmp5d0t5pbi.rs:21:17\n   |\n21 |                 reversed_reversed_prefix\
    \ += reversed_reversed_prefix[..1];\n   |                 ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmp5d0t5pbi.rs:26:13\n   |\n26 |             reversed_suffix += reversed_reversed_suffix;\n\
    \   |             ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |          \
    \   |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp5d0t5pbi.rs:27:13\n\
    \   |\n27 |             reversed_prefix += reversed_reversed_prefix;\n   |   \
    \          ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             |\n \
    \  |             cannot use `+=` on type `&str`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reverse_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n\n    while !string.is_empty() {\n        let mut postfix = string;\n\
    \        let mut postfix_length = 0;\n\n        while !postfix.is_empty() {\n\
    \            if postfix.chars().next().unwrap() == postfix.chars().last().unwrap()\
    \ {\n                postfix.pop();\n                postfix_length += 1;\n  \
    \          } else {\n                break;\n            }\n        }\n\n    \
    \    if postfix_length > longest_postfix_length {\n            longest_postfix\
    \ = postfix.to_string();\n            longest_postfix_length = postfix_length;\n\
    \        }\n\n        string = postfix.to_string();\n        reverse_string +=\
    \ &string[postfix_length..].to_string();\n    }\n\n    longest_postfix.push_str(&reverse_string);\n\
    \    longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu_vvc_hb.rs:25:31\n   |\n\
    8  |     let mut longest_postfix = \"\";\n   |                               --\
    \ expected due to this value\n...\n25 |             longest_postfix = postfix.to_string();\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^\n   |                \
    \               |\n   |                               expected `&str`, found struct\
    \ `String`\n   |                               help: consider borrowing here:\
    \ `&postfix.to_string()`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&str`\n  --> /tmp/tmpu_vvc_hb.rs:30:9\n   |\n30 |      \
    \   reverse_string += &string[postfix_length..].to_string();\n   |         --------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpu_vvc_hb.rs:33:21\n   |\n33 |     longest_postfix.push_str(&reverse_string);\n\
    \   |                     ^^^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu_vvc_hb.rs:34:5\n   |\n5  | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n34 |     longest_postfix\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_len\
    \ = string.len();\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mut longest_postfix_end\
    \ = 0;\n    let mut longest_postfix_start = 0;\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1yggpaxy.rs:57:11\n   |\n\
    57 |     let mu\n   |           ^ help: add `;` here\n58 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1yggpaxy.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix = String::new();\n\
    \    let mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::new();\n    let mut longest_postfix_end\
    \ = String::new();\n    let mut longest_postfix_start = String::new();\n    let\
    \ mut longest_postfix_end = String::new();\n    let mut longest_postfix_start\
    \ = String::new();\n    let mut longest_postfix_end = String::new();\n    let\
    \ mut longest_postfix_start = String::\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp52cduik2.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length_index = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzwwf2sjf.rs:29:53\n   |\n\
    29 |     let mut longest_postfix_length_palindrome_length\n   |              \
    \                                       ^ help: add `;` here\n30 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpzwwf2sjf.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut reversed_string_size\
    \ = string.len();\n    while reversed_string_size != 0 {\n        reversed_string\
    \ = reversed_string[..(reversed_string_size - 1)].to_string() + reversed_string[reversed_string_size\
    \ - 1..].to_string();\n        reversed_string_size -= 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjzqq1h34.rs:9:87\n  |\n9 |\
    \ ...tring_size - 1)].to_string() + reversed_string[reversed_string_size - 1..].to_string();\n\
    \  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |                                   |\n  |                                \
    \   expected `&str`, found struct `String`\n  |                              \
    \     help: consider borrowing here: `&reversed_string[reversed_string_size -\
    \ 1..].to_string()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplso30jjy.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmplso30jjy.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for c in reversed_string.chars() {\n        if longest_postfix_length\
    \ < c.len() {\n            longest_postfix_length = c.len();\n        }\n    }\n\
    \    let mut postfix_length = 0;\n    for c in string.chars() {\n        if postfix_length\
    \ < longest_postfix_length {\n            postfix_length = longest_postfix_length;\n\
    \        }\n        if postfix_length == longest_postfix_length {\n          \
    \  reversed_string += &c.to_string() + &c.to_string()[longest_postfix_length..];\n\
    \        }\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n --> /tmp/tmpgycr5t7e.rs:9:39\n  |\n9 |         if longest_postfix_length\
    \ < c.len() {\n  |                                       ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpgycr5t7e.rs:10:40\n   |\n10 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0369]: cannot add `&str` to `&String`\n  --> /tmp/tmpgycr5t7e.rs:19:47\n\
    \   |\n19 |             reversed_string += &c.to_string() + &c.to_string()[longest_postfix_length..];\n\
    \   |                                -------------- ^ ----------------------------------------\
    \ &str\n   |                                |              |\n   |           \
    \                     |              `+` cannot be used to concatenate two `&str`\
    \ strings\n   |                                &String\n   |\n   = note: string\
    \ concatenation requires an owned `String` on the left\nhelp: remove the borrow\
    \ to obtain an owned `String`\n   |\n19 -             reversed_string += &c.to_string()\
    \ + &c.to_string()[longest_postfix_length..];\n19 +             reversed_string\
    \ += c.to_string() + &c.to_string()[longest_postfix_length..];\n   | \n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = 0;\n    for c in string.chars() {\n        if longest_postfix_length\
    \ == 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n    \
    \    if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut longest_postfix = String::new();\n\
    \    for c in string.chars() {\n        if longest_postfix_length == 0 {\n   \
    \         longest_postfix = longest_postfix.append(c);\n        }\n        if\
    \ longest_postfix_length < c.len_utf8() {\n            longest_postfix = longest_postfix.append(c);\n\
    \        }\n    }\n    for c in longest_postfix.chars() {\n        reversed_string\
    \ = reversed_string.append(c);\n    }\n    reversed_string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp4yldcsef.rs:19:47\n   |\n19 |             longest_postfix\
    \ = longest_postfix.append(c);\n   |                                         \
    \      ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp4yldcsef.rs:22:47\n\
    \   |\n22 |             longest_postfix = longest_postfix.append(c);\n   |   \
    \                                            ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp4yldcsef.rs:26:43\n   |\n26 |         reversed_string =\
    \ reversed_string.append(c);\n   |                                           ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = string.len();\n    let mut longest_postfix_index =\
    \ -1;\n    let mut longest_postfix_postfix = String::new();\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_length = -1;\n\
    \    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_length = -1;\n\
    \    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_length = -1;\n\
    \    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_length = -1;\n\
    \    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_length = -1;\n\
    \    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_length = -1;\n\
    \    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_length = -1;\n\
    \    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_length = -1;\n\
    \    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_length = -1;\n\
    \    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpiw1gy0b8.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_index = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzncs46_4.rs:57:16\n   |\n\
    57 |     let mut lon\n   |                ^ help: add `;` here\n58 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpzncs46_4.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut reversed_string_len\
    \ = 0;\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let \n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmphtrp8avn.rs:56:1\n  \
    \ |\n56 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ prefix_length = string.len() - 1;\n    let mut suffix_length = string.len()\
    \ - 1;\n    let mut palindrome = String::new();\n\n    while suffix_length >=\
    \ 0 {\n        if string[suffix_length] == string[suffix_length][suffix_length]\
    \ {\n            palindrome.push(string[suffix_length]);\n            suffix_length\
    \ -= 1;\n        } else {\n            palindrome.push(string[suffix_length]);\n\
    \            suffix_length -= 1;\n            prefix_length -= 1;\n        }\n\
    \    }\n\n    while prefix_length >= 0 {\n        if string[prefix_length] ==\
    \ string[prefix_length][prefix_length] {\n            palindrome.push(string[prefix_length]);\n\
    \            prefix_length -= 1;\n        } else {\n            palindrome.push(string[prefix_length]);\n\
    \            prefix_length -= 1;\n            suffix_length -= 1;\n        }\n\
    \    }\n\n    palindrome.push(reversed_string);\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdpv2s1fp.rs:12:12\n\
    \   |\n12 |         if string[suffix_length] == string[suffix_length][suffix_length]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdpv2s1fp.rs:12:37\n   |\n12 |         if string[suffix_length]\
    \ == string[suffix_length][suffix_length] {\n   |                            \
    \         ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdpv2s1fp.rs:13:29\n\
    \   |\n13 |             palindrome.push(string[suffix_length]);\n   |        \
    \                     ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<Ra"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut prefix_length\
    \ = 0;\n    let mut suffix_length = 0;\n    while suffix_length < reversed_string.len()\
    \ {\n        let mut suffix_start = suffix_length;\n        while suffix_start\
    \ < reversed_string.len() && reversed_string[suffix_start] != ' ' {\n        \
    \    suffix_start++;\n        }\n        let mut suffix_end = suffix_length;\n\
    \        while suffix_end < reversed_string.len() && reversed_string[suffix_end]\
    \ != ' ' {\n            suffix_end++;\n        }\n        let mut suffix_prefix\
    \ = reversed_string.chars().skip(suffix_start).take(suffix_end - suffix_start).collect::<String>();\n\
    \        let mut suffix_suffix = reversed_string.chars().skip(suffix_end).take(suffix_end\
    \ - suffix_start).collect::<String>();\n        let mut suffix_reversed = suffix_suffix;\n\
    \        suffix_reversed.reverse();\n        let mut suffix_reversed_string =\
    \ suffix_reversed.to_string();\n        suffix_reversed_string.push_str(&mut suffix_prefix);\n\
    \        reversed_string.push_str(&mut suffix_reversed_string);\n        suffix_length\
    \ += suffix_end - suffix_start;\n        prefix_length += suffix_end - suffix_start;\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpjbdzwu2l.rs:12:25\n\
    \   |\n12 |             suffix_start++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n12 |         \
    \    { let tmp = suffix_start; suffix_start += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n12 -             suffix_start++;\n12\
    \ +             suffix_start += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpjbdzwu2l.rs:16:23\n   |\n16 |             suffix_end++;\n\
    \   |                       ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n16 |             { let tmp = suffix_end; suffix_end += 1;\
    \ tmp };\n   |             +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n16\
    \ -             suffix_end++;\n16 +             suffix_end += 1;\n   | \n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjbdzwu2l.rs:11:55\n\
    \   |\n11 |         while suffix_start < reversed_string.len() && reversed_string[suffix_start]\
    \ != ' ' {\n   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjbdzwu2l.rs:15:53\n   |\n15 |         while suffix_end < reversed_string.len()\
    \ && reversed_string[suffix_end] != ' ' {\n   |                              \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following oth"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut postfix\
    \ = string.clone();\n    let mut prefix_length = 0;\n    while let Some(prefix_length)\
    \ = postfix.rfind(' ', prefix_length) {\n        let mut suffix = postfix.clone();\n\
    \        suffix.truncate(prefix_length);\n        let mut suffix_length = 0;\n\
    \        while let Some(suffix_length) = suffix.rfind(' ', suffix_length) {\n\
    \            let mut prefix = suffix.clone();\n            prefix.truncate(suffix_length);\n\
    \            let mut prefix_length = 0;\n            while let Some(prefix_length)\
    \ = prefix.rfind(' ', prefix_length) {\n                let mut palindrome = prefix.clone();\n\
    \                palindrome.truncate(prefix_length);\n                if palindrome\
    \ == suffix {\n                    let mut palindrome_length = 0;\n          \
    \          while let Some(palindrome_length) = palindrome.rfind(' ', palindrome_length)\
    \ {\n                        let mut palindrome_suffix = palindrome.clone();\n\
    \                        palindrome_suffix.truncate(palindrome_length);\n    \
    \                    let mut palindrome_suffix_length = 0;\n                 \
    \       while let Some(palindrome_suffix_length) = palindrome_suffix.rfind(' ',\
    \ palindrome_suffix_length) {\n                            let mut palindrome_prefix\
    \ = palindrome_suffix.clone();\n                            palindrome_prefix.truncate(palindrome_suffix_length);\n\
    \                            let mut palindrome_prefix_length = 0;\n         \
    \                   while let Some(palindrome_prefix_length) = palindrome_prefix.rfind('\
    \ ', palindrome_prefix_length) {\n                                let mut palindrome_suffix\
    \ = palindrome_prefix.clone();\n                                palindrome_suffix.truncate(palindrome_prefix_length);\n\
    \                                let mut palindrome_suffix_length = 0;\n     \
    \                           while let Some(palindrome_suffix_length) = palindrome_suffix.rfind('\
    \ ', palindrome_suffix_length) {\n                                    let mut\
    \ palindrome = palindrome_prefix.clone();\n                                  \
    \  palindrome.truncate(palindrome_prefix_length);\n                          \
    \          let mut palindrome_prefix_length = 0;\n                           \
    \         while let Some(palindrome_prefix_length) = palindrome.rfind(' ', palindrome_prefix_length)\
    \ {\n                                        let mut palindrome_suffix = palindrome.clone();\n\
    \                                        palindrome_suffix.truncate(palindrome_prefix_length);\n\
    \                                        let mut palindrome_suffix_length = 0;\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9ifd_vq0.rs:51:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n9  |     while let\
    \ Some(prefix_length) = postfix.rfind(' ', prefix_length) {\n   |            \
    \                                                           - unclosed delimiter\n\
    ...\n13 |         while let Some(suffix_length) = suffix.rfind(' ', suffix_length)\
    \ {\n   |                                                                    \
    \      - unclosed delimiter\n...\n17 |             while let Some(prefix_length)\
    \ = prefix.rfind(' ', prefix_length) {\n   |                                 \
    \                                             - unclosed delimiter\n...\n20 |\
    \                 if palindrome == suffix {\n   |                            \
    \             - unclosed delimiter\n21 |                     let mut palindrome_length\
    \ = 0;\n22 |                     while let Some(palindrome_length) = palindrome.rfind('\
    \ ', palindrome_length) {\n   |                                              \
    \                                                    - unclosed delimiter\n...\n\
    26 |                         while let Some(palindrome_suffix_length) = palindrome_suffix.rfind('\
    \ ', palindrome_suffix_length) {\n   |                                       \
    \                                                                            \
    \        - unclosed delimiter\n...\n30 |                             while let\
    \ Some(palindrome_prefix_length) = palindrome_prefix.rfind(' ', palindrome_prefix_length)\
    \ {\n   |                                                                    \
    \                                                           - unclosed delimiter\n\
    ...\n34 |                                 while let Some(palindrome_suffix_length)\
    \ = palindrome_suffix.rfind(' ', palindrome_suffix_length) {\n   |           \
    \                                                                            \
    \                                            - unclosed delimiter\n...\n38 | \
    \              "
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reverse_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzxkkcsew.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut reversed_string_length\
    \ = 0;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_length = 0;\n    let mut\
    \ longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_start = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_start = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgmub6amp.rs:41:37\n   |\n\
    41 |     let mut longest_postfix_postfix_\n   |                              \
    \       ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpgmub6amp.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix = String::new();\n\
    \    let mut longest_postfix_length_postfix_reversed = String::new();\n    let\
    \ mut longest_postfix_length_postfix_reversed_index = 0;\n    let mut longest_postfix_length_postfix_reversed_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_postfix\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_postfix_reversed\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_postfix_reversed_index\
    \ = 0;\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_postfix_reversed_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_postfix_reversed_postfix\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_postfix_reversed_postfix_reversed\
    \ = String::new();\n    let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_postfix_reversed_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6n_2d5jv.rs:28:104\n   |\n\
    28 |     let mut longest_postfix_length_postfix_reversed_postfix_reversed_postfix_reversed_postfix_reversed_\n\
    \   |                                                                        \
    \                                ^ help: add `;` here\n29 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp6n_2d5jv.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n \
    \   let mut longest_postfix_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_post\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqwbrzep_.rs:42:41\n   |\n\
    42 |     let mut longest_postfix_postfix_post\n   |                          \
    \               ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpqwbrzep_.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_length_index2 = 0;\n    let mut longest_postfix_length2\
    \ = 0;\n    let mut longest_postfix_length2_index = 0;\n    let mut longest_postfix_length2_index2\
    \ = 0;\n    let mut longest_postfix_length2_index2 = 0;\n    let mut longest_postfix_length2_index3\
    \ = 0;\n    let mut longest_postfix_length2_index4 = 0;\n    let mut longest_postfix_length2_index5\
    \ = 0;\n    let mut longest_postfix_length2_index6 = 0;\n    let mut longest_postfix_length2_index7\
    \ = 0;\n    let mut longest_postfix_length2_index8 = 0;\n    let mut longest_postfix_length2_index9\
    \ = 0;\n    let mut longest_postfix_length2_index10 = 0;\n    let mut longest_postfix_length2_index11\
    \ = 0;\n    let mut longest_postfix_length2_index12 = 0;\n    let mut longest_postfix_length2_index13\
    \ = 0;\n    let mut longest_postfix_length2_index14 = 0;\n    let mut longest_postfix_length2_index15\
    \ = 0;\n    let mut longest_postfix_length2_index16 = 0;\n    let mut longest_postfix_length2_index17\
    \ = 0;\n    let mut longest_postfix_length2_index18 = 0;\n    let mut longest_postfix_length2_index19\
    \ = 0;\n    let mut longest_postfix_length2_index20 = 0;\n    let mut longest_postfix_length2_index21\
    \ = 0;\n    let mut longest_postfix_length2_index22 = 0;\n    let mut longest_postfix_length2_index23\
    \ = 0;\n    let mut longest_postfix_length2_index24 = 0;\n    let mut longest_postfix_length2_index25\
    \ = 0;\n    let mut longest_postfix_length2_index26 = 0;\n    let mut longest_postfix_length2_index27\
    \ = 0;\n    let mut longest_postfix_length2_index28 = 0;\n    let mut longest_postfix_length2_index29\
    \ = 0;\n    let mut longest_postfix_length2_index30 = 0;\n    let mut longest_postfix_length2_index31\
    \ = 0;\n    let mut longest_postfix_length2_index32 = 0;\n    let mut longest_postfix_length2\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppaw3cio0.rs:47:36\n   |\n\
    47 |     let mut longest_postfix_length2\n   |                               \
    \     ^ help: add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmppaw3cio0.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n    let mut longest_postfix_string_length = 0;\n    let mut longest_postfix_string_start\
    \ = 0;\n    let mut longest_postfix_string_end = 0;\n    let mut longest_postfix_string_start2\
    \ = 0;\n    let mut longest_postfix_string_end2 = 0;\n    let mut longest_postfix_string_start3\
    \ = 0;\n    let mut longest_postfix_string_end3 = 0;\n    let mut longest_postfix_string_start4\
    \ = 0;\n    let mut longest_postfix_string_end4 = 0;\n    let mut longest_postfix_string_start5\
    \ = 0;\n    let mut longest_postfix_string_end5 = 0;\n    let mut longest_postfix_string_start6\
    \ = 0;\n    let mut longest_postfix_string_end6 = 0;\n    let mut longest_postfix_string_start7\
    \ = 0;\n    let mut longest_postfix_string_end7 = 0;\n    let mut longest_postfix_string_start8\
    \ = 0;\n    let mut longest_postfix_string_end8 = 0;\n    let mut longest_postfix_string_start9\
    \ = 0;\n    let mut longest_postfix_string_end9 = 0;\n    let mut longest_postfix_string_start10\
    \ = 0;\n    let mut longest_postfix_string_end10 = 0;\n    let mut longest_postfix_string_start11\
    \ = 0;\n    let mut longest_postfix_string_end11 = 0;\n    let mut longest_postfix_string_start12\
    \ = 0;\n    let mut longest_postfix_string_end12 = 0;\n    let mut longest_postfix_string_start13\
    \ = 0;\n    let mut longest_postfix_string_end13 = 0;\n    let mut longest_postfix_string_start14\
    \ = 0;\n    let mut longest_postfix_string_end14 = 0;\n    let mut longest_postfix_string_start15\
    \ = 0;\n    let mut longest_postfix_string_end15 = 0;\n    let mut longest_postfix_string_start16\
    \ = 0;\n    let mut longest_postfix_string_end16 = 0;\n    let mut longest_postfix_string_start17\
    \ = 0;\n    let mut longest_postfix_string_end17 = 0;\n    let mut longest_postfix_string_start18\
    \ = 0;\n    let mut longest_postfix_string_end18 = 0;\n    let mut longest_postfix_string_start19\
    \ = 0;\n    let mut longest_postfix_string_end19 = 0;\n    let mut longest_postfix_string_start20\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzr4498cy.rs:50:21\n   |\n\
    50 |     let mut longest_\n   |                     ^ help: add `;` here\n51 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpzr4498cy.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_length = 0;\n    for c in string.chars() {\n        if longest_postfix_length\
    \ == 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n    \
    \    if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4jdc1x01.rs:88:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n72 |     for c in\
    \ string.chars() {\n   |                             - unclosed delimiter\n...\n\
    76 |         if longest_postfix_length < c.len_utf8() {\n   |                \
    \                                  - this delimiter might not be properly closed...\n\
    ...\n79 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    88 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4jdc1x01.rs:72:5\n\
    \   |\n5  |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n72 | /     for c in string.chars() {\n73 | |         if longest_postfix_length\
    \ == 0 {\n74 | |             longest_postfix_length = c.len_utf8();\n75 | |  \
    \       }\n...  |\n87 | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\"));\n88 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut palindrome =\
    \ string;\n    let mut reversed_string = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut i = 0;\n    let mut j = 0;\n    while i < string.len()\
    \ && j < palindrome.len() {\n        if string[i] == palindrome[j] {\n       \
    \     palindrome = &string[i..j];\n            i += 1;\n            j += 1;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    while i < string.len()\
    \ {\n        palindrome = &string[i..];\n        i += 1;\n    }\n    while j <\
    \ palindrome.len() {\n        reversed_palindrome = &palindrome[j..];\n      \
    \  j += 1;\n    }\n    string = reversed_palindrome;\n    palindrome = reversed_string;\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxpxn0pl5.rs:13:12\n\
    \   |\n13 |         if string[i] == palindrome[j] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxpxn0pl5.rs:13:25\n   |\n13 |         if string[i] == palindrome[j]\
    \ {\n   |                         ^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpxn0pl5.rs:14:26\n\
    \   |\n7  |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n14 |             palindrome = &string[i..j];\n\
    \   |                          ^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n14 |             palindrome\
    \ = (&string[i..j]).to_string();\n   |                          +            \
    \ +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpxn0pl5.rs:22:22\n\
    \   |\n7  |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n22 |         palindrome = &"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n\n    while !palindrome.is_empty() {\n        let mut index = palindrome.len()\
    \ - 1;\n        let mut char = String::new();\n\n        while index >= 0 {\n\
    \            char.push(palindrome[index]);\n            index -= 1;\n        }\n\
    \n        reversed_string.push(char);\n        palindrome = palindrome.chars().skip_while(|&c|\
    \ !c.is_alphanumeric()).collect();\n    }\n\n    reversed_string.reverse();\n\
    \    palindrome.push_str(&reversed_string);\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpunpwy4up.rs:14:23\n\
    \   |\n14 |             char.push(palindrome[index]);\n   |                  \
    \     ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `push` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpunpwy4up.rs:18:25\n   |\n18 |         reversed_string.push(char);\n\
    \   |                         ^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `reverse` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpunpwy4up.rs:22:21\n   |\n22 |     reversed_string.reverse();\n\
    \   |                     ^^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reverse_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n\n    while !string.is_empty() {\n        let mut postfix = string;\n\
    \        let mut postfix_length = 0;\n\n        while !postfix.is_empty() {\n\
    \            let mut postfix_char = postfix.chars().next().unwrap();\n       \
    \     postfix_length += 1;\n\n            if postfix_char == &postfix_char.reverse()\
    \ {\n                postfix = postfix.chars().skip(postfix_length).collect();\n\
    \                postfix_length = 0;\n            } else {\n                break;\n\
    \            }\n        }\n\n        if postfix_length > longest_postfix_length\
    \ {\n            longest_postfix = postfix.to_string();\n            longest_postfix_length\
    \ = postfix_length;\n        }\n\n        string = string.chars().skip(postfix_length).collect();\n\
    \    }\n\n    longest_postfix.append(&reverse_string);\n    longest_postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp60ydnl52.rs:19:46\n   |\n19 |             if postfix_char\
    \ == &postfix_char.reverse() {\n   |                                         \
    \     ^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp60ydnl52.rs:28:31\n   |\n8  |     let mut longest_postfix = \"\"\
    ;\n   |                               -- expected due to this value\n...\n28 |\
    \             longest_postfix = postfix.to_string();\n   |                   \
    \            ^^^^^^^^^^^^^^^^^^^\n   |                               |\n   | \
    \                              expected `&str`, found struct `String`\n   |  \
    \                             help: consider borrowing here: `&postfix.to_string()`\n\
    \nerror[E0599]: no method named `append` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmp60ydnl52.rs:35:21\n   |\n35 |     longest_postfix.append(&reverse_string);\n\
    \   |                     ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp60ydnl52.rs:36:5\n   |\n5  | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n36 |     longest_postfix\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = 0;\n    let mut longest_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_index = -1;\n    let mut\
    \ longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_length = 0;\n   \
    \ let mut longest_postfix_postfix_postfix_postfix_postfix = String::new();\n \
    \   let mut longest_postfix_postfix_postfix_postfix_postfix_index = -1;\n    let\
    \ mut longest_postfix_postfix_postfix_postfix_postfix_length = 0;\n    let mut\
    \ longest_postfix_postfix_postfix_postfix_postfix_postfix = String::new();\n \
    \   let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_length =\
    \ 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_post\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ncv2cg4.rs:33:57\n   |\n\
    33 |     let mut longest_postfix_postfix_postfix_postfix_post\n   |          \
    \                                               ^ help: add `;` here\n34 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_ncv2cg4.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_length = 0;\n\n    while !reversed_string.is_empty()\
    \ {\n        let mut postfix = reversed_string;\n        let mut postfix_length\
    \ = 0;\n\n        while !postfix.is_empty() {\n            if postfix.chars().next().unwrap()\
    \ != longest_postfix.chars().next().unwrap() {\n                break;\n     \
    \       }\n            postfix_length += 1;\n            postfix = postfix.chars().next().unwrap();\n\
    \        }\n\n        if postfix_length > longest_postfix_length {\n         \
    \   longest_postfix_length = postfix_length;\n            longest_postfix = postfix;\n\
    \        }\n\n        reversed_string = reversed_string.chars().next().unwrap();\n\
    \    }\n\n    longest_postfix.append(&reversed_string[longest_postfix_length..]);\n\
    \n    longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqfl9r6dg.rs:19:23\n   |\n\
    11 |         let mut postfix = reversed_string;\n   |                        \
    \   --------------- expected due to this value\n...\n19 |             postfix\
    \ = postfix.chars().next().unwrap();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \     |\n   |                       expected struct `String`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqfl9r6dg.rs:27:27\n   |\n6  |  \
    \   let mut reversed_string = string;\n   |                               ------\
    \ expected due to this value\n...\n27 |         reversed_string = reversed_string.chars().next().unwrap();\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \   |\n   |                           expected struct `String`, found `char`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpqfl9r6dg.rs:30:21\n   |\n30 |     longest_postfix.append(&reversed_string[longest_postfix_length..]);\n\
    \   |                     ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ prefix_length = string.len();\n    let mut suffix_length = string.len();\n \
    \   let mut palindrome = String::new();\n\n    while suffix_length > 0 {\n   \
    \     let mut suffix_char = string[suffix_length - 1];\n        let mut suffix_char_length\
    \ = suffix_char.len();\n\n        while suffix_char_length > 0 {\n           \
    \ let mut suffix_char_char = suffix_char[suffix_char_length - 1];\n          \
    \  let mut suffix_char_char_length = suffix_char_char.len();\n\n            while\
    \ suffix_char_char_length > 0 {\n                let mut suffix_char_char_char\
    \ = suffix_char_char[suffix_char_char_length - 1];\n                let mut suffix_char_char_char_length\
    \ = suffix_char_char_char.len();\n\n                while suffix_char_char_char_length\
    \ > 0 {\n                    let mut suffix_char_char_char_char = suffix_char_char_char[suffix_char_char_char_length\
    \ - 1];\n                    let mut suffix_char_char_char_char_length = suffix_char_char_char_char.len();\n\
    \n                    while suffix_char_char_char_char_length > 0 {\n        \
    \                let mut suffix_char_char_char_char_char = suffix_char_char_char_char[suffix_char_char_char_char_length\
    \ - 1];\n                        let mut suffix_char_char_char_char_char_length\
    \ = suffix_char_char_char_char_char.len();\n\n                        while suffix_char_char_char_char_char_length\
    \ > 0 {\n                            let mut suffix_char_char_char_char_char_char\
    \ = suffix_char_char_char_char_char[suffix_char_char_char_char_char_char_length\
    \ - 1];\n                            let mut suffix_char_char_char_char_char_char_length\
    \ = suffix_char_char_char_char_char_char.len();\n\n                          \
    \  while suffix_char_char_char_char_char_char_char_length > 0 {\n            \
    \                    let mut suffix_char_char_char_char_char_char_char_char =\
    \ suffix_char_char_char_char_char_char_char_char[suffix_char_char_char_char_char_char_char_length\
    \ - 1];\n                                let mut suffix_char_char_char_char_char_char_char_char_length\
    \ = suffix_char_char_char_char_char_char_char_char.len();\n\n                \
    \                while suffix_char_char_char_char_char_char_char_char_length >\
    \ 0 {\n                                    let mut suffix_char_char_char_char_char_char_char_char_char\
    \ = suffix_char_char_char_char_char_char_char_char_char[suffix_char_char_char_char_char_char_char_char_char_char_length\
    \ - 1];\n                                    let mut suffix_char_char_char_char_char_char_char_char_char_char_length\
    \ = suffix_char_char_char_char_char_char_char_char_char\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwjbblhym.rs:51:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n11 |     while suffix_length\
    \ > 0 {\n   |                             - unclosed delimiter\n...\n15 |    \
    \     while suffix_char_length > 0 {\n   |                                   \
    \   - unclosed delimiter\n...\n19 |             while suffix_char_char_length\
    \ > 0 {\n   |                                               - unclosed delimiter\n\
    ...\n23 |                 while suffix_char_char_char_length > 0 {\n   |     \
    \                                                   - unclosed delimiter\n...\n\
    27 |                     while suffix_char_char_char_char_length > 0 {\n   | \
    \                                                                - unclosed delimiter\n\
    ...\n31 |                         while suffix_char_char_char_char_char_length\
    \ > 0 {\n   |                                                                \
    \          - unclosed delimiter\n...\n35 |                             while suffix_char_char_char_char_char_char_char_length\
    \ > 0 {\n   |                                                                \
    \                        - unclosed delimiter\n...\n39 |                     \
    \            while suffix_char_char_char_char_char_char_char_char_length > 0 {\n\
    \   |                                                                        \
    \                         - this delimiter might not be properly closed...\n...\n\
    42 | }\n   | - ...as it matches this but it has different indentation\n...\n51\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpwjbblhym.rs:41:162\n\
    \   |\n41 |                                     let mut suffix_char_char_char_char_char_char_char_char_char_char_length\
    \ = suffix_char_char_char_char_char_char_char_char_char\n   |                \
    \                                                                            \
    \                                                                      ^ help:\
    \ add `;` here\n42 | }\n   | - unexpected tok"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = string;\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_index = 0;\n    let mut\
    \ longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n    let\
    \ mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 = 0;\n \
    \   let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7 =\
    \ 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjbc6zaz2.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjbc6zaz2.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_len = string.len();\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_palindrome_start = -1;\n    let\
    \ mut longest_postfix_palindrome_end = -1;\n    let mut longest_postfix_palindrome_len\
    \ = -1;\n    let mut longest_postfix_palindrome_postfix = String::new();\n   \
    \ let mut longest_postfix_palindrome_postfix_start = -1;\n    let mut longest_postfix_palindrome_postfix_end\
    \ = -1;\n    let mut longest_postfix_palindrome_postfix_len = -1;\n    let mut\
    \ longest_postfix_palindrome_postfix_palindrome = String::new();\n    let mut\
    \ longest_postfix_palindrome_postfix_palindrome_start = -1;\n    let mut longest_postfix_palindrome_postfix_palindrome_end\
    \ = -1;\n    let mut longest_postfix_palindrome_postfix_palindrome_len = -1;\n\
    \    let mut longest_postfix_palindrome_postfix_palindrome_palindrome = String::new();\n\
    \    let mut longest_postfix_palindrome_postfix_palindrome_postfix_start = -1;\n\
    \    let mut longest_postfix_palindrome_postfix_palindrome_postfix_end = -1;\n\
    \    let mut longest_postfix_palindrome_postfix_palindrome_postfix_len = -1;\n\
    \    let mut longest_postfix_palindrome_postfix_palindrome_postfix_palindrome\
    \ = String::new();\n    let mut longest_postfix_palindrome_postfix_palindrome_postfix_palindrome_start\
    \ = -1;\n    let mut longest_postfix_palindrome_postfix_palindrome_postfix_palindrome_end\
    \ = -1;\n    let mut longest_postfix_palindrome_postfix_palindrome_postfix_palindrome_len\
    \ = -1;\n    let mut longest_postfix_palindrome_postfix_palindrome_postfix_palindrome_palindrome\
    \ = String::new();\n    let mut longest_postfix_palindrome_postfix_palindrome_postfix_palindrome_postfix_start\
    \ = -1;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7opu4l0r.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n\n    while !string.is_empty() {\n        let mut index = string.len()\
    \ - 1;\n        let mut char = string[index];\n\n        while index >= 0 {\n\
    \            if char != string[index] {\n                break;\n            }\n\
    \n            index -= 1;\n        }\n\n        reversed_string.insert(0, char);\n\
    \        string = &string[index..];\n    }\n\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpatpnc1ka.rs:11:24\n\
    \   |\n11 |         let mut char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpatpnc1ka.rs:14:24\n   |\n14 |             if char != string[index]\
    \ {\n   |                        ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `insert` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpatpnc1ka.rs:21:25\n   |\n21 |         reversed_string.insert(0,\
    \ char);\n   |                         ^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpatpnc1ka.rs:22:18\n   |\n6  |     let mut string\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    22 |         string = &string[index..];\n   |                  ^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n22 |         string = (&string[index..]).to_string();\n   |           \
    \       +              "
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_len\
    \ = string.len();\n    let mut longest_postfix_idx = 0;\n    let mut longest_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_idx = 0;\n    let mut longest_postfix_postfix_len\
    \ = 0;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_postfix_idx\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_idx = 0;\n    let mut longest_postfix_postfix_postfix_len\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix = \"\";\n    let mut\
    \ longest_postfix_postfix_postfix_idx = 0;\n    let mut longest_postfix_postfix_len\
    \ = 0;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_idx\
    \ = 0;\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_idx = 0;\n    let mut longest_postfix_len\
    \ = 0;\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_idx =\
    \ 0;\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix = \"\"\
    ;\n    let mut longest_postfix_idx = 0;\n    let mut longest_postfix_len = 0;\n\
    \    let mut longest_postfix = \"\";\n    let mut longest_postfix_idx = 0;\n \
    \   let mut longest_postfix_len = 0;\n    let mut longest_postfix = \"\";\n  \
    \  let mut longest_postfix_idx = 0;\n    let mut longest_postfix_len = 0;\n  \
    \  let mut longest_postfix = \"\";\n    let mut longest_postfix_idx = 0;\n   \
    \ let mut longest_postfix_len = 0;\n    let mut longest_postfix = \"\";\n    let\
    \ mut longest_postfix_idx = 0;\n    let mut longest_postfix_len = 0;\n    let\
    \ mut longest_postfix = \"\";\n    let mut longest_postfix_idx = 0;\n    let mut\
    \ longest_postfix_len = 0;\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_idx\
    \ = 0;\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix = \"\
    \";\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5s9l2b0e.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = -1;\n    let mut longest_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_index = -1;\n    let mut\
    \ longest_postfix_postfix_length = -1;\n\n    for c in string.chars() {\n    \
    \    if longest_postfix_length == -1 || longest_postfix_length > c.len() {\n \
    \           longest_postfix_length = c.len();\n            longest_postfix_postfix\
    \ = String::new();\n            longest_postfix_postfix_index = -1;\n        \
    \    longest_postfix_postfix_length = -1;\n        }\n\n        if longest_postfix_length\
    \ == c.len() {\n            longest_postfix_postfix.push(c);\n            longest_postfix_postfix_index\
    \ += 1;\n        }\n\n        if longest_postfix_postfix_index == longest_postfix_length\
    \ {\n            longest_postfix_postfix.push(c);\n            longest_postfix_postfix_index\
    \ += 1;\n        }\n\n        if longest_postfix_postfix_index > longest_postfix_length\
    \ {\n            longest_postfix_length = longest_postfix_postfix.len();\n   \
    \         longest_postfix_postfix = String::new();\n            longest_postfix_postfix_index\
    \ = -1;\n            longest_postfix_postfix_length = -1;\n        }\n\n     \
    \   if longest_postfix_postfix_index == 0 {\n            longest_postfix_postfix.push(c);\n\
    \            longest_postfix_postfix_index += 1;\n        }\n    }\n\n    let\
    \ mut longest_postfix_postfix_length = longest_postfix_postfix.len();\n    let\
    \ mut longest_postfix_postfix_index = longest_postfix_postfix.len();\n    let\
    \ mut longest_postfix_postfix_postfix = String::new();\n    let mut longest_postfix_postfix_postfix_index\
    \ = longest_postfix_postfix.len();\n\n    for c in longest_postfix_postfix.chars()\
    \ {\n        if longest_postfix_postfix_length == -1 || longest_postfix_postfix_length\
    \ > c.len() {\n            longest_postfix_postfix_length = c.len();\n       \
    \     longest_postfix_postfix_postfix = String::new();\n            longest_postfix_postfix_postfix_index\
    \ = -1;\n            longest_postfix_postfix_postfix_length = -1;\n        }\n\
    \n        if longest_postfix_postfix_length == c.len() {\n            lon\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz6_03xxb.rs:69:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n50 |     for c in\
    \ longest_postfix_postfix.chars() {\n   |                                    \
    \          - unclosed delimiter\n...\n58 |         if longest_postfix_postfix_length\
    \ == c.len() {\n   |                                                      - this\
    \ delimiter might not be properly closed...\n59 |             lon\n60 | }\n  \
    \ | - ...as it matches this but it has different indentation\n...\n69 | }\n  \
    \ |   ^\n\nerror[E0425]: cannot find value `longest_postfix_postfix_postfix_length`\
    \ in this scope\n  --> /tmp/tmpz6_03xxb.rs:55:13\n   |\n55 |             longest_postfix_postfix_postfix_length\
    \ = -1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `longest_postfix_postfix_postfix_index`\n\
    \nerror[E0425]: cannot find value `lon` in this scope\n  --> /tmp/tmpz6_03xxb.rs:59:13\n\
    \   |\n59 |             lon\n   |             ^^^ not found in this scope\n\n\
    error[E0599]: no method named `len` found for type `char` in the current scope\n\
    \  --> /tmp/tmpz6_03xxb.rs:15:71\n   |\n15 |         if longest_postfix_length\
    \ == -1 || longest_postfix_length > c.len() {\n   |                          \
    \                                             ^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `len` found for type `char` in the current scope\n\
    \  --> /tmp/tmpz6_03xxb.rs:16:40\n   |\n16 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpz6_03xxb.rs:22:40\n   |\n22 |         if longest_postfix_length\
    \ == c.len() {\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n -->\
    \ /tmp/tmpz6_03xxb.rs:9:38\n  |\n9 |     let mut longest_postfix_length = -1;\n\
    \  |       "
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_len = string.len();\n    let mut longest_postfix = String::new();\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_post\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpik28oqat.rs:56:25\n   |\n\
    56 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    57 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpik28oqat.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_index = -1;\n\
    \    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start =\
    \ -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_index = -1;\n    let mut\
    \ longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl2fc4__y.rs:44:37\n   |\n\
    44 |     let mut longest_postfix_postfix_\n   |                              \
    \       ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpl2fc4__y.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_i\
    \ = 0;\n    let mut longest_postfix_length_reverse_j = 0;\n    let mut longest_postfix_length_reverse_j_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_j_reverse_index = 0;\n    let\
    \ mut longest_postfix_length_reverse_j_reverse_i = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j\
    \ = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j_reverse = 0;\n\
    \    let mut longest_postfix_length_reverse_j_reverse_j_reverse_index = 0;\n \
    \   let mut longest_postfix_length_reverse_j_reverse_j_reverse_i = 0;\n    let\
    \ mut longest_postfix_length_reverse_j_reverse_j_reverse_j = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j_reverse_i\
    \ = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j_reverse_j = 0;\n\
    \    let mut longest_postfix_length_reverse_j_reverse_j_reverse_i = 0;\n    let\
    \ mut longest_postfix_length_reverse_j_reverse_j_reverse_j = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j_reverse_i\
    \ = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j_reverse_j = 0;\n\
    \    let mut longest_postfix_length_reverse_j_reverse_j_reverse_i = 0;\n    let\
    \ mut longest_postfix_length_reverse_j_reverse_j_reverse_j = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j_reverse_i\
    \ = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j_reverse_j = 0;\n\
    \    let mut longest_postfix_length_reverse_j_reverse_j_reverse_i = 0;\n    let\
    \ mut longest_postfix_length_reverse_j_reverse_j_reverse_j = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j_reverse_i\
    \ = 0;\n    let mut longest_postfix_length_reverse_j_reverse_j_reverse_j = 0;\n\
    \    let mut longest_postfix_length_reverse_j_reverse_j_reverse_i = 0;\n\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp80ufbbnb.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_index = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length = 0;\n    let mut longest_postfix_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_index = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_p\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpda6wraly.rs:28:73\n   |\n\
    28 |     let mut longest_postfix_length_palindrome_length_palindrome_length_p\n\
    \   |                                                                        \
    \ ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpda6wraly.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_length2\
    \ = 0;\n    let mut longest_postfix_length3 = 0;\n    let mut longest_postfix_length4\
    \ = 0;\n    let mut longest_postfix_length5 = 0;\n    let mut longest_postfix_length6\
    \ = 0;\n    let mut longest_postfix_length7 = 0;\n    let mut longest_postfix_length8\
    \ = 0;\n    let mut longest_postfix_length9 = 0;\n    let mut longest_postfix_length10\
    \ = 0;\n    let mut longest_postfix_length11 = 0;\n    let mut longest_postfix_length12\
    \ = 0;\n    let mut longest_postfix_length13 = 0;\n    let mut longest_postfix_length14\
    \ = 0;\n    let mut longest_postfix_length15 = 0;\n    let mut longest_postfix_length16\
    \ = 0;\n    let mut longest_postfix_length17 = 0;\n    let mut longest_postfix_length18\
    \ = 0;\n    let mut longest_postfix_length19 = 0;\n    let mut longest_postfix_length20\
    \ = 0;\n    let mut longest_postfix_length21 = 0;\n    let mut longest_postfix_length22\
    \ = 0;\n    let mut longest_postfix_length23 = 0;\n    let mut longest_postfix_length24\
    \ = 0;\n    let mut longest_postfix_length25 = 0;\n    let mut longest_postfix_length26\
    \ = 0;\n    let mut longest_postfix_length27 = 0;\n    let mut longest_postfix_length28\
    \ = 0;\n    let mut longest_postfix_length29 = 0;\n    let mut longest_postfix_length30\
    \ = 0;\n    let mut longest_postfix_length31 = 0;\n    let mut longest_postfix_length32\
    \ = 0;\n    let mut longest_postfix_length33 = 0;\n    let mut longest_postfix_length34\
    \ = 0;\n    let mut longest_postfix_length35 = 0;\n    let mut longest_postfix_length36\
    \ = 0;\n    let mut longest_postfix_length37 = 0;\n    let mut longest_postfix_length38\
    \ = 0;\n    let mut longest_postfix_length39 = 0;\n    let mut longest_postfix_length40\
    \ = 0;\n    let mut longest_postfix_length41 = 0;\n    let mut longest_postfix_length42\
    \ = 0;\n    let mut longest_postfix_length43 = 0;\n    let mut longest_postfix_length44\
    \ = 0;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc2i63wks.rs:5:39\n  |\n5 |\
    \ fn make_palindrome(string: String) -> String {\n  |    ---------------     \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string\
    \ = \"\";\n\n    for index in 0..string.len() {\n        let char = string[index];\n\
    \        let is_palindrome = is_palindrome(&char);\n\n        if is_palindrome\
    \ {\n            let postfix_length = index - longest_postfix_index;\n       \
    \     reversed_string += &string[longest_postfix_index..index];\n            longest_postfix_length\
    \ = postfix_length;\n            longest_postfix_index = index;\n            longest_postfix_string\
    \ += &string[index..longest_postfix_index];\n        }\n    }\n\n    reversed_string\
    \ += &string[longest_postfix_index..];\n    longest_postfix_string += &string[longest_postfix_index..];\n\
    \n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmplzlv84dh.rs:13:29\n   |\n13 |         let is_palindrome = is_palindrome(&char);\n\
    \   |                             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplzlv84dh.rs:12:20\n\
    \   |\n12 |         let char = string[index];\n   |                    ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmplzlv84dh.rs:17:13\n   |\n17 |             reversed_string\
    \ += &string[longest_postfix_index..index];\n   |             ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmplzlv84dh.rs:20:13\n\
    \   |\n20 |             longest_postfix_string += &string[index..longest_postfix_index];\n\
    \   |             ----------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmplzlv84dh.rs:24:5\n\
    \   |\n24 |     reversed_string += &string[longest_postfix_index..];\n   |   \
    \  ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |     |\n   |     cannot\
    \ use `+=` on type `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&str`\n  --> /tmp/tmplzlv84dh.rs:25:5\n   |\n25 |     longest_postfix_string\
    \ += &string"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut palindrome =\
    \ string;\n    let mut reversed_string = string;\n    let mut reversed_palindrome\
    \ = string;\n    let mut prefix_len = 0;\n    let mut suffix_len = 0;\n    let\
    \ mut prefix_len2 = 0;\n    let mut suffix_len2 = 0;\n    let mut prefix_len3\
    \ = 0;\n    let mut suffix_len3 = 0;\n    let mut prefix_len4 = 0;\n    let mut\
    \ suffix_len4 = 0;\n    let mut prefix_len5 = 0;\n    let mut suffix_len5 = 0;\n\
    \    let mut prefix_len6 = 0;\n    let mut suffix_len6 = 0;\n    let mut prefix_len7\
    \ = 0;\n    let mut suffix_len7 = 0;\n    let mut prefix_len8 = 0;\n    let mut\
    \ suffix_len8 = 0;\n    let mut prefix_len9 = 0;\n    let mut suffix_len9 = 0;\n\
    \    let mut prefix_len10 = 0;\n    let mut suffix_len10 = 0;\n    let mut prefix_len11\
    \ = 0;\n    let mut suffix_len11 = 0;\n    let mut prefix_len12 = 0;\n    let\
    \ mut suffix_len12 = 0;\n    let mut prefix_len13 = 0;\n    let mut suffix_len13\
    \ = 0;\n    let mut prefix_len14 = 0;\n    let mut suffix_len14 = 0;\n    let\
    \ mut prefix_len15 = 0;\n    let mut suffix_len15 = 0;\n    let mut prefix_len16\
    \ = 0;\n    let mut suffix_len16 = 0;\n    let mut prefix_len17 = 0;\n    let\
    \ mut suffix_len17 = 0;\n    let mut prefix_len18 = 0;\n    let mut suffix_len18\
    \ = 0;\n    let mut prefix_len19 = 0;\n    let mut suffix_len19 = 0;\n    let\
    \ mut prefix_len20 = 0;\n    let mut suffix_len20 = 0;\n    let mut prefix_len21\
    \ = 0;\n    let mut suffix_len21 = 0;\n    let mut prefix_len22 = 0;\n    let\
    \ mut suffix_len22 = 0;\n    let mut prefix_len23 = 0;\n    let mut suffix_len23\
    \ = 0;\n    let mut prefix_len24 = 0;\n    let mut suffix_len24 = 0;\n    let\
    \ mut prefix_len25 = 0;\n    let mut suffix_len25 = 0;\n    let mut prefix_len26\
    \ = 0;\n    let mut suffix_len26 = 0;\n    let mut prefix_len27 = 0;\n    let\
    \ mut suffix_len27 = 0;\n    let mut prefix_len28 = 0;\n    let mut suffix_len28\
    \ = 0;\n    let mut prefix_len29 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpopy1y6j3.rs:67:11\n   |\n\
    67 |     let mu\n   |           ^ help: add `;` here\n68 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpopy1y6j3.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix = \"\";\n    for c in string.chars() {\n \
    \       if longest_postfix_length < c.len() {\n            longest_postfix_length\
    \ = c.len();\n            longest_postfix = c;\n        }\n    }\n    let mut\
    \ reversed_postfix = longest_postfix;\n    for c in reversed_postfix.chars() {\n\
    \        if longest_postfix_length < c.len() {\n            reversed_postfix =\
    \ reversed_postfix.chars().chain(c.chars()).collect();\n            break;\n \
    \       }\n    }\n    reversed_postfix.reverse();\n    reversed_string += &reversed_postfix;\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmptun0pw9j.rs:10:39\n   |\n10 |         if longest_postfix_length\
    \ < c.len() {\n   |                                       ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmptun0pw9j.rs:11:40\n   |\n11 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptun0pw9j.rs:12:31\n\
    \   |\n8  |     let mut longest_postfix = \"\";\n   |                        \
    \       -- expected due to this value\n...\n12 |             longest_postfix =\
    \ c;\n   |                               ^ expected `&str`, found `char`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmptun0pw9j.rs:17:39\n\
    \   |\n17 |         if longest_postfix_length < c.len() {\n   |              \
    \                         ^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmptun0pw9j.rs:18:65\n\
    \   |\n18 |             reversed_postfix = reversed_postfix.chars().chain(c.chars()).collect();\n\
    \   |                                                                 ^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `reverse` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmptun0pw9j.rs:22:22\n   |\n22 |   \
    \  reversed_postfix.reverse();\n   |                      ^^^^^^^ method not found\
    \ in `&str`\n\nerror[E0277]: a value of type `&str` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmptun0pw9j.rs:18:74\n     |\n18\
    \   |             reversed_postfix = reversed_postfix.chars().chain(c.chars()).collect();\n\
    \     |                                                                      \
    \    ^^^^^^^ value of type `&str` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `&str`\n\
    \     = help: the following oth"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reverse_string\
    \ = \"\";\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n  \
    \  let mut suffix_index = 0;\n    let mut prefix_index = 0;\n    while suffix_index\
    \ < palindrome.len() {\n        let mut suffix_char = match palindrome[suffix_index]\
    \ {\n            'a' => 1,\n            'b' => 2,\n            'c' => 3,\n   \
    \         'd' => 4,\n            'e' => 5,\n            'f' => 6,\n          \
    \  'g' => 7,\n            'h' => 8,\n            'i' => 9,\n            'j' =>\
    \ 10,\n            'k' => 11,\n            'l' => 12,\n            'm' => 13,\n\
    \            'n' => 14,\n            'o' => 15,\n            'p' => 16,\n    \
    \        'q' => 17,\n            'r' => 18,\n            's' => 19,\n        \
    \    't' => 20,\n            'u' => 21,\n            'v' => 22,\n            'w'\
    \ => 23,\n            'x' => 24,\n            'y' => 25,\n            'z' => 26,\n\
    \            _ => panic!(\"Invalid character in string: {}\", palindrome[suffix_index]),\n\
    \        };\n        reverse_string += &mut suffix_char.to_string();\n       \
    \ suffix_length += suffix_char;\n        suffix_index += 1;\n    }\n    while\
    \ prefix_index < palindrome.len() {\n        let mut prefix_char = match palindrome[prefix_index]\
    \ {\n            'a' => 1,\n            'b' => 2,\n            'c' => 3,\n   \
    \         'd' => 4,\n            'e' => 5,\n            'f' => 6,\n          \
    \  'g' => 7,\n            'h' => 8,\n            'i' => 9,\n            'j' =>\
    \ 10,\n            'k' => 11,\n            'l' => 12,\n            'm' => 13,\n\
    \            'n' => 14,\n            'o' => 15,\n            'p' => 16,\n    \
    \        'q' => 17,\n            'r' => 18,\n            's' => 19,\n        \
    \    't' => 20,\n            'u' => 21,\n            'v' => 22,\n            'w'\
    \ => 23,\n            'x' => 24,\n            'y' => 25,\n            'z' => 26,\n\
    \            _ => panic!(\"Invalid character in string: {}\", palindrome[prefix_index]),\n\
    \        };\n        palindrome = &palindrome[prefix_index..prefix_index + prefix_char];\n\
    \        prefix_length += prefix_char;\n        prefix_index += 1;\n    }\n  \
    \  palindrome += &mut reverse_string[..prefix_length];\n    palindrome\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjj0ggdo4.rs:13:37\n\
    \   |\n13 |         let mut suffix_char = match palindrome[suffix_index] {\n \
    \  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjj0ggdo4.rs:40:60\n   |\n40 |             _ => panic!(\"Invalid\
    \ character in string: {}\", palindrome[suffix_index]),\n   |                \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpjj0ggdo4.rs:42:9\n   |\n42 |         reverse_string\
    \ += &mut suffix_char.to_string();\n   |         --------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjj0ggdo4.rs:47:37\n\
    \   |\n47 |         let mut prefix_char = match palindrome[prefix_index] {\n \
    \  |                                     ^^^^^^^^"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = string;\n    let mut longest_postfix = String::new();\n    let mut longest_postfix_length\
    \ = String::new();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = longest_postfix.len();\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_length = longest_postfix.len();\n    let mut longest_postfix_length\
    \ = \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpjgj3jv2p.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut reverse_length\
    \ = 0;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome = String::new();\n    let\
    \ mut longest_postfix_length_palindrome_length = 0;\n    let mut longest_postfix_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome = String::new();\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length = 0;\n\
    \    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = String::new();\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprgjkbwpi.rs:26:143\n   |\n\
    26 |     let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\n\
    \   |                                                                        \
    \                                                                       ^ help:\
    \ add `;` here\n27 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmprgjkbwpi.rs:5:39\n  |\n5 | fn make_palindrome(string: String) ->\
    \ String {\n  |    ---------------                    ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n  \
    \  while suffix_length != palindrome.len() {\n        suffix_length = palindrome.len();\n\
    \        let mut suffix_start = suffix_length;\n        while suffix_start > 0\
    \ {\n            let mut suffix_end = suffix_start;\n            while suffix_end\
    \ < palindrome.len() {\n                if palindrome[suffix_end - 1] != palindrome[suffix_end]\
    \ {\n                    break;\n                }\n                suffix_end\
    \ += 1;\n            }\n            if suffix_end == palindrome.len() {\n    \
    \            suffix_length -= 1;\n            } else {\n                reversed_string\
    \ += &palindrome[suffix_end - 1];\n                suffix_length -= 1;\n     \
    \           prefix_length += 1;\n            }\n        }\n        palindrome\
    \ = &palindrome[prefix_length..];\n    }\n    reversed_string += &palindrome[suffix_length..];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy81o303u.rs:16:20\n\
    \   |\n16 |                 if palindrome[suffix_end - 1] != palindrome[suffix_end]\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy81o303u.rs:16:50\n   |\n16 |                 if palindrome[suffix_end\
    \ - 1] != palindrome[suffix_end] {\n   |                                     \
    \             ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy81o303u.rs:24:37\n   |\n24 |                 reversed_string +=\
    \ &palindrome[suffix_end - 1];\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeI"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mut longest_postfix_index45 = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_4godlq.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9_4godlq.rs:5:39\n\
    \  |\n5 | fn make_palindrome(string: String) -> String {\n  |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805901
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    for c in string.chars() {\n        if longest_postfix_length == 0\
    \ {\n            longest_postfix_length = c.len_utf8();\n        }\n        if\
    \ longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    for c in string.chars() {\n        if\
    \ longest_postfix_length == 0 {\n            longest_postfix_length = c.len_utf8();\n\
    \        }\n        if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6u_v4pyl.rs:72:5\n   |\n\
    5  |   fn make_palindrome(string: String) -> String {\n   |                  \
    \                       ------ expected `String` because of return type\n...\n\
    72 | /     for c in string.chars() {\n73 | |         if longest_postfix_length\
    \ == 0 {\n74 | |             longest_postfix_length = c.len_utf8();\n75 | |  \
    \       }\n...  |\n78 | |         }\n79 | |     }\n   | |_____^ expected struct\
    \ `String`, found `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_length\
    \ = 0;\n    for c in reversed_string.chars() {\n        if longest_postfix_length\
    \ == 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n    \
    \    if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut longest_postfix_string = String::with_capacity(longest_postfix_length\
    \ + 2);\n    for c in reversed_string.chars() {\n        if longest_postfix_length\
    \ == 0 {\n            longest_postfix_string.push(c);\n        } else {\n    \
    \        longest_postfix_string.push(c);\n            longest_postfix_string.push('-');\n\
    \        }\n    }\n    longest_postfix_string.push(reversed_string);\n    longest_postfix_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwyvnnc7j.rs:25:33\n   |\n\
    25 |     longest_postfix_string.push(reversed_string);\n   |                 \
    \                ^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_index = 0;\n    let mut\
    \ longest_postfix_length_suffix = 0;\n    let mut longest_postfix_length_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_palindrome = 0;\n    let mut\
    \ longest_postfix_length_suffix_palindrome_index = 0;\n    let mut longest_postfix_length_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_index = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix_palindrome = 0;\n    let mut longest_postfix_length_suffix_suffix_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_index = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix_index = 0;\n \
    \   let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_index =\
    \ 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindro\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxg1hf79l.rs:34:86\n   |\n\
    34 |     let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindro\n\
    \   |                                                                        \
    \              ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpxg1hf79l.rs:5:39\n  |\n5 | fn make_palindrome(string:\
    \ String) -> String {\n  |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = String::new();\n    let mut\
    \ longest_postfix_index = -1;\n    let mut longest_postfix = String::new();\n\
    \    for index in 0..string.len() {\n        let mut postfix = String::new();\n\
    \        postfix.push_str(&string[index..]);\n        if longest_postfix_index\
    \ == -1 || postfix.len() > longest_postfix.len() {\n            longest_postfix_index\
    \ = index;\n            longest_postfix = postfix;\n        }\n    }\n    let\
    \ mut postfix = String::new();\n    postfix.push_str(&string[longest_postfix_index..]);\n\
    \    reversed_string.push_str(&longest_postfix.reverse());\n    reversed_string.push_str(&postfix);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpa61d9zfl.rs:7:37\n\
    \  |\n7 |     let mut longest_postfix_index = -1;\n  |                       \
    \              ^^ the trait `Neg` is not implemented for `usize`\n  |\n  = help:\
    \ the following other types implement trait `Neg`:\n            &f32\n       \
    \     &f64\n            &i128\n            &i16\n            &i32\n          \
    \  &i64\n            &i8\n            &isize\n          and 8 others\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpa61d9zfl.rs:12:37\n\
    \   |\n12 |         if longest_postfix_index == -1 || postfix.len() > longest_postfix.len()\
    \ {\n   |                                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpa61d9zfl.rs:19:47\n   |\n\
    19 |     reversed_string.push_str(&longest_postfix.reverse());\n   |         \
    \                                      ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length_index = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl1usz76f.rs:29:53\n   |\n\
    29 |     let mut longest_postfix_length_palindrome_length\n   |              \
    \                                       ^ help: add `;` here\n30 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpl1usz76f.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index2\
    \ = 0;\n    let mut longest_postfix_string2 = \"\";\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_string3 = \"\";\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_string4 = \"\";\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_string5 = \"\";\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_string6 = \"\";\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_string7 = \"\";\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_string8 = \"\";\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_string9 = \"\";\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_string10 = \"\";\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_string11 = \"\";\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_string12 = \"\";\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_string13 = \"\";\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_string14 = \"\";\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_string15 = \"\";\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_string16 = \"\";\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_string17 = \"\";\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_string18 = \"\";\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_string19 = \"\";\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_string20 = \"\";\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_string21 = \"\";\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_string22 = \"\";\n    let mut longest_postfix_index23\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq3edrji0.rs:53:36\n   |\n\
    53 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpq3edrji0.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string.to_string();\n    let mut palindrome\
    \ = String::new();\n    let mut suffix_length = 0;\n    let mut prefix_length\
    \ = 0;\n    while suffix_length < string.len() {\n        let mut suffix_start\
    \ = suffix_length;\n        let mut suffix_end = suffix_length;\n        while\
    \ suffix_end < string.len() {\n            if string[suffix_end] != string[suffix_end\
    \ - 1] {\n                break;\n            }\n            suffix_end += 1;\n\
    \        }\n        if suffix_end == suffix_start {\n            palindrome.push_str(&string[suffix_start..suffix_end]);\n\
    \            suffix_length += 1;\n        } else {\n            suffix_length\
    \ = 0;\n        }\n    }\n    while prefix_length < string.len() {\n        let\
    \ mut prefix_start = prefix_length;\n        let mut prefix_end = prefix_length;\n\
    \        while prefix_end < string.len() {\n            if string[prefix_end]\
    \ != string[prefix_end - 1] {\n                break;\n            }\n       \
    \     prefix_end += 1;\n        }\n        if prefix_end == prefix_start {\n \
    \           palindrome.push_str(&string[prefix_start..prefix_end]);\n        \
    \    prefix_length += 1;\n        } else {\n            prefix_length = 0;\n \
    \       }\n    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1jbt7bu8.rs:14:16\n\
    \   |\n14 |             if string[suffix_end] != string[suffix_end - 1] {\n  \
    \ |                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1jbt7bu8.rs:14:38\n   |\n14 |             if string[suffix_end]\
    \ != string[suffix_end - 1] {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1jbt7bu8.rs:30:16\n   |\n30 |             if string[prefix_end]\
    \ != string[prefix_end - 1] {\n   |                ^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_suffix = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffix_index\
    \ = 0;\n    let mut longest_postfix_suffix_length = 0;\n    let mut longest_postfix_suffi\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_asbs1ax.rs:49:34\n   |\n\
    49 |     let mut longest_postfix_suffi\n   |                                 \
    \ ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp_asbs1ax.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n\
    \    while suffix_length < palindrome.len() {\n        let mut suffix_length =\
    \ palindrome.len();\n        let mut prefix_length = 0;\n        while prefix_length\
    \ < suffix_length {\n            let mut prefix_length = suffix_length;\n    \
    \        let mut suffix_length = palindrome.len();\n            let mut char =\
    \ palindrome[prefix_length..suffix_length];\n            while char != char.rev()\
    \ {\n                suffix_length -= 1;\n                prefix_length += 1;\n\
    \                char = char.next();\n            }\n            palindrome =\
    \ &palindrome[prefix_length..suffix_length];\n        }\n        reversed_string\
    \ += &palindrome[suffix_length..];\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpnbjrsmyj.rs:16:17\n   |\n16 |             let mut char =\
    \ palindrome[prefix_length..suffix_length];\n   |                 ^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n16 |             let mut char = &palindrome[prefix_length..suffix_length];\n\
    \   |                            +\n\nerror[E0599]: `str` is not an iterator\n\
    \  --> /tmp/tmpnbjrsmyj.rs:17:32\n   |\n17 |             while char != char.rev()\
    \ {\n   |                                ^^^ `str` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `str: Iterator`\n\
    \           which is required by `&mut str: Iterator`\n\nerror[E0599]: no method\
    \ named `next` found for type `str` in the current scope\n  --> /tmp/tmpnbjrsmyj.rs:20:29\n\
    \   |\n20 |                 char = char.next();\n   |                        \
    \     ^^^^ method not found in `str`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n  --> /tmp/tmpnbjrsmyj.rs:20:17\n\
    \   |\n20 |                 char = char.next();\n   |                 ^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: the left-hand-side of an assignment must have\
    \ a statically known size\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbjrsmyj.rs:22:26\n\
    \   |\n6  |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n22 |             palindrome = &palindrome[prefix_length..suffix_length];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n22 |             palindrome = (&palindrome[prefix_length..suffix_length]).to_string();\n\
    \   |                          + "
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_length_reverse = 0;\n    let mut longest_postfix_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_length_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse = 0;\n    let\
    \ mut longest_postfix_length_reverse_length_reverse_index = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_index = 0;\n\
    \    let mut longest_postfix_length_reverse_length_reverse_length_index = 0;\n\
    \    let mut longest_postfix_length_reverse_length_reverse_length_reverse = 0;\n\
    \    let mut longest_postfix_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_length_reverse_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_length_reverse_length\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7r5cehke.rs:36:50\n   |\n\
    36 |     let mut longest_postfix_length_reverse_length\n   |                 \
    \                                 ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7r5cehke.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix\
    \ = string.chars().take_while(|c| !c.is_ascii_lowercase()).count();\n    let mut\
    \ prefix_length = longest_postfix - 1;\n    while longest_postfix > 0 {\n    \
    \    reversed_string.insert(0, &string[prefix_length..prefix_length + longest_postfix]);\n\
    \        longest_postfix -= 1;\n        prefix_length -= 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzs2kp_1x.rs:10:35\n   |\n\
    10 |         reversed_string.insert(0, &string[prefix_length..prefix_length +\
    \ longest_postfix]);\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxqszn1k2.rs:53:36\n   |\n\
    53 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpxqszn1k2.rs:5:39\n  |\n5 | fn make_palindrome(string: String)\
    \ -> String {\n  |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976775
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string;\n    let mut longest_postfix_len\
    \ = string.len();\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_palindrome = String::new();\n    let mut\
    \ longest_postfix_palindrome_start = -1;\n    let mut longest_postfix_palindrome_end\
    \ = -1;\n\n    for pos in 0..string.len() {\n        let mut postfix_start = -1;\n\
    \        let mut postfix_end = -1;\n        let mut postfix_palindrome = String::new();\n\
    \        let mut postfix_palindrome_start = -1;\n        let mut postfix_palindrome_end\
    \ = -1;\n\n        for ch in string.chars() {\n            if pos == 0 {\n   \
    \             postfix_start = pos;\n                postfix_end = pos;\n     \
    \           postfix_palindrome = String::new();\n                postfix_palindrome_start\
    \ = pos;\n                postfix_palindrome_end = pos;\n            } else {\n\
    \                let mut postfix_len = longest_postfix_len;\n                if\
    \ pos == longest_postfix_end {\n                    postfix_len = pos - postfix_start;\n\
    \                }\n                if ch == reversed_string[pos - postfix_len]\
    \ {\n                    postfix_end = pos;\n                    postfix_palindrome\
    \ = String::from(&reversed_string[postfix_start - postfix_len..postfix_end]);\n\
    \                    postfix_palindrome_start = postfix_start;\n             \
    \       postfix_palindrome_end = postfix_end;\n                }\n           \
    \ }\n        }\n\n        if postfix_palindrome_start != -1 && postfix_palindrome_end\
    \ != -1 {\n            longest_postfix_len = postfix_palindrome_end - postfix_palindrome_start;\n\
    \            longest_postfix_start = postfix_palindrome_start;\n            longest_postfix_end\
    \ = postfix_palindrome_end;\n            longest_postfix_palindrome = postfix_palindrome;\n\
    \        }\n    }\n\n    if longest_postfix_palindrome_start != -1 && longest_postfix_palindrome_end\
    \ != -1 {\n        reversed_string = &reversed_string[longest_postfix_palindrome_start..longest_postfix_palindrome_end];\n\
    \    }\n\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpoua5swoi.rs:15:33\n\
    \   |\n15 |         let mut postfix_start = -1;\n   |                        \
    \         ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpoua5swoi.rs:16:31\n\
    \   |\n16 |         let mut postfix_end = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpoua5swoi.rs:18:44\n\
    \   |\n18 |         let mut postfix_palindrome_start = -1;\n   |             \
    \                               ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpoua5swoi.rs:19:42\n   |\n19 |         let mut postfix_palindrome_end\
    \ = -1;\n   |                                          ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n --> /tmp/tmpoua5swoi.rs:9:35\n  |\n9 |     let mut longest_postfix_end\
    \ = -1;\n  |                             "
  stdout: ''
  timestamp: 1659976776
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = \"\";\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_char:\
    \ char;\n    let mut longest_postfix_char_length = 0;\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length_index2 = 0;\n    let mut longest_postfix_char_length_index3\
    \ = 0;\n    let mut longest_postfix_char_length_index4 = 0;\n    let mut longest_postfix_char_length_index5\
    \ = 0;\n    let mut longest_postfix_char_length_index6 = 0;\n    let mut longest_postfix_char_length_index7\
    \ = 0;\n    let mut longest_postfix_char_length_index8 = 0;\n    let mut longest_postfix_char_length_index9\
    \ = 0;\n    let mut longest_postfix_char_length_index10 = 0;\n    let mut longest_postfix_char_length_index11\
    \ = 0;\n    let mut longest_postfix_char_length_index12 = 0;\n    let mut longest_postfix_char_length_index13\
    \ = 0;\n    let mut longest_postfix_char_length_index14 = 0;\n    let mut longest_postfix_char_length_index15\
    \ = 0;\n    let mut longest_postfix_char_length_index16 = 0;\n    let mut longest_postfix_char_length_index17\
    \ = 0;\n    let mut longest_postfix_char_length_index18 = 0;\n    let mut longest_postfix_char_length_index19\
    \ = 0;\n    let mut longest_postfix_char_length_index20 = 0;\n    let mut longest_postfix_char_length_index21\
    \ = 0;\n    let mut longest_postfix_char_length_index22 = 0;\n    let mut longest_postfix_char_length_index23\
    \ = 0;\n    let mut longest_postfix_char_length_index24 = 0;\n    let mut longest_postfix_char_length_index25\
    \ = 0;\n    let mut longest_postfix_char_length_index26 = 0;\n    let mut longest_postfix_char_length_index27\
    \ = 0;\n    let mut longest_postfix_char_length_index28 = 0;\n    let mut longest_postfix_char_length_index29\
    \ = 0;\n    let mut longest_postfix_char_length_index30 = 0;\n    let mut longest_postfix_char_length_index31\
    \ = 0;\n    let mut longest_postfix_char_length_index32 = 0;\n    let mut longest_postfix_char_length_index33\
    \ = 0;\n    let mut longest_postfix_char_length_index34 = 0;\n    let mut longest_postfix_char_length_index35\
    \ = 0;\n    let mut longest_postfix_char_length_index36\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoy73alqd.rs:46:48\n   |\n\
    46 |     let mut longest_postfix_char_length_index36\n   |                   \
    \                             ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpoy73alqd.rs:5:39\n  |\n\
    5 | fn make_palindrome(string: String) -> String {\n  |    ---------------   \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976776
