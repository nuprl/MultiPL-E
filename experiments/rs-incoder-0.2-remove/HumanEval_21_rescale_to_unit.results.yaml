language: rs
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_number = numbers.iter().min().unwrap();\n    let mut max_number = numbers.iter().max().unwrap();\n\
    \    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&numbers);\n\
    \    new_numbers.sort_unstable();\n    new_numbers.iter_mut().for_each(|n| {\n\
    \        *n = ((*n - min_number) / (max_number - min_number)) * 2.0 + 0.0;\n \
    \   });\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmphj8c63s5.rs:4:41\n\
    \  |\n4 |     let mut min_number = numbers.iter().min().unwrap();\n  |       \
    \                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n  |\n  = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n -->\
    \ /tmp/tmphj8c63s5.rs:5:41\n  |\n5 |     let mut max_number = numbers.iter().max().unwrap();\n\
    \  |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \ --> /tmp/tmphj8c63s5.rs:8:17\n  |\n8 |     new_numbers.sort_unstable();\n  |\
    \                 ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min_val)\
    \ / (max_val - min_val));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpzk1n6hz2.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for &n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for &n in numbers {\n        let\
    \ new_n = ((n - min_value) / (max_value - min_value)) * 2.0 + 0.0;\n        new_numbers.push_back(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphnvcldhu.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphnvcldhu.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror[E0599]: no method named `push_back`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmphnvcldhu.rs:17:21\n\
    \   |\n17 |         new_numbers.push_back(new_n);\n   |                     ^^^^^^^^^\
    \ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push(n / max_value - min_value / max_value);\n    }\n  \
    \  rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp_0o2gszy.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest = numbers[0];\n   \
    \ let mut largest = numbers[0];\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number;\n        }\n        if number >\
    \ largest {\n            largest = number;\n        }\n    }\n    for number in\
    \ numbers {\n        rescaled_numbers.push(number - smallest);\n        rescaled_numbers.push(number\
    \ - largest);\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpsgqbsgim.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        rescaled.push((n - smallest)\
    \ / (largest - smallest));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpm69o0t55.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut min_number = numbers.iter().min().unwrap();\n\
    \    let mut max_number = numbers.iter().max().unwrap();\n    new_numbers.extend_from_slice(&[min_number]);\n\
    \    new_numbers.extend_from_slice(&[max_number]);\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpvdj2vqtr.rs:5:41\n\
    \  |\n5 |     let mut min_number = numbers.iter().min().unwrap();\n  |       \
    \                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n  |\n  = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n -->\
    \ /tmp/tmpvdj2vqtr.rs:6:41\n  |\n6 |     let mut max_number = numbers.iter().max().unwrap();\n\
    \  |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvdj2vqtr.rs:9:5\n\
    \  |\n3 | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n  |           \
    \                               -------- expected `Vec<f64>` because of return\
    \ type\n...\n9 |     new_numbers\n  |     ^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \  |\n  = note: expected struct `Vec<f64>`\n             found struct `Vec<&f64>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ new_n = ((n - min_value) / (max_value - min_value)) * 2.0 + 0.0;\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp70uf91jt.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        rescaled.push((n - smallest)\
    \ / (largest - smallest));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpm69o0t55.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
