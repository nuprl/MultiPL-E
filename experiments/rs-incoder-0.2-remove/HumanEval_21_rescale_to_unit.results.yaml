language: rs
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_number = numbers.iter().min().unwrap();\n    let mut max_number = numbers.iter().max().unwrap();\n\
    \    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&numbers);\n\
    \    new_numbers.sort_unstable();\n    new_numbers.iter_mut().for_each(|n| {\n\
    \        *n = ((*n - min_number) / (max_number - min_number)) * 2.0 + 0.0;\n \
    \   });\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmphj8c63s5.rs:4:41\n\
    \  |\n4 |     let mut min_number = numbers.iter().min().unwrap();\n  |       \
    \                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n  |\n  = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n -->\
    \ /tmp/tmphj8c63s5.rs:5:41\n  |\n5 |     let mut max_number = numbers.iter().max().unwrap();\n\
    \  |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \ --> /tmp/tmphj8c63s5.rs:8:17\n  |\n8 |     new_numbers.sort_unstable();\n  |\
    \                 ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min_val)\
    \ / (max_val - min_val));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpzk1n6hz2.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for &n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for &n in numbers {\n        let\
    \ new_n = ((n - min_value) / (max_value - min_value)) * 2.0 + 0.0;\n        new_numbers.push_back(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphnvcldhu.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `f64`\n  |         |\n  |         expected `f64`, found reference\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphnvcldhu.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `f64`\n   |         |\n\
    \   |         expected `f64`, found reference\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror[E0599]: no method named `push_back`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmphnvcldhu.rs:17:21\n\
    \   |\n17 |         new_numbers.push_back(new_n);\n   |                     ^^^^^^^^^\
    \ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push(n / max_value - min_value / max_value);\n    }\n  \
    \  rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp_0o2gszy.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest = numbers[0];\n   \
    \ let mut largest = numbers[0];\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number;\n        }\n        if number >\
    \ largest {\n            largest = number;\n        }\n    }\n    for number in\
    \ numbers {\n        rescaled_numbers.push(number - smallest);\n        rescaled_numbers.push(number\
    \ - largest);\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpsgqbsgim.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        rescaled.push((n - smallest)\
    \ / (largest - smallest));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpm69o0t55.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut min_number = numbers.iter().min().unwrap();\n\
    \    let mut max_number = numbers.iter().max().unwrap();\n    new_numbers.extend_from_slice(&[min_number]);\n\
    \    new_numbers.extend_from_slice(&[max_number]);\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpvdj2vqtr.rs:5:41\n\
    \  |\n5 |     let mut min_number = numbers.iter().min().unwrap();\n  |       \
    \                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n  |\n  = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n -->\
    \ /tmp/tmpvdj2vqtr.rs:6:41\n  |\n6 |     let mut max_number = numbers.iter().max().unwrap();\n\
    \  |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvdj2vqtr.rs:9:5\n\
    \  |\n3 | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n  |           \
    \                               -------- expected `Vec<f64>` because of return\
    \ type\n...\n9 |     new_numbers\n  |     ^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \  |\n  = note: expected struct `Vec<f64>`\n             found struct `Vec<&f64>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ new_n = ((n - min_value) / (max_value - min_value)) * 2.0 + 0.0;\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp70uf91jt.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        rescaled.push((n - smallest)\
    \ / (largest - smallest));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpm69o0t55.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min;\n        }\n        if new_n > max {\n            new_n\
    \ -= max;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi5a9510r.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq5zzq852.rs:15:37\n   |\n\
    15 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for\
    \ number in numbers {\n        if number < min_number {\n            min_number\
    \ = number;\n        }\n        if number > max_number {\n            max_number\
    \ = number;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n  \
    \  for number in numbers {\n        rescaled_numbers.push(number - min_number)\
    \ / (max_number - min_number);\n    }\n    rescaled_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot divide `()` by `f64`\n  --> /tmp/tmp8udfgfjg.rs:16:52\n\
    \   |\n16 |         rescaled_numbers.push(number - min_number) / (max_number -\
    \ min_number);\n   |         ------------------------------------------ ^ -------------------------\
    \ f64\n   |         |\n   |         ()\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        rescaled.push((n - smallest)\
    \ / (largest - smallest));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpm69o0t55.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let new_n = ((n - min_val) /\
    \ (max_val - min_val)) * 2.0 + 0.0;\n        new_numbers.push(new_n);\n    }\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpny56ljb7.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpl51njd_l.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut rescaled_n = n;\n   \
    \     if rescaled_n < min_val {\n            rescaled_n = min_val;\n        }\n\
    \        if rescaled_n > max_val {\n            rescaled_n = max_val;\n      \
    \  }\n        rescaled_numbers.push(rescaled_n);\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpbj9q5aqw.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_number = numbers[0];\n \
    \   let mut max_number = numbers[0];\n    for number in numbers {\n        if\
    \ number < min_number {\n            min_number = number;\n        }\n       \
    \ if number > max_number {\n            max_number = number;\n        }\n    }\n\
    \    for number in numbers {\n        rescaled_numbers.push(number - min_number);\n\
    \    }\n    rescaled_numbers.push(max_number - min_number);\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp4gti7xqb.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpl51njd_l.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        rescaled.push((n - smallest)\
    \ / (largest - smallest));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpm69o0t55.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ new_n = ((n - min_value) / (max_value - min_value)).round() as f64;\n      \
    \  new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpbszzauk6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut min_number = numbers.iter().min().unwrap();\n\
    \    let mut max_number = numbers.iter().max().unwrap();\n    let mut min_number\
    \ = min_number - min_number % 0.1;\n    let mut max_number = max_number + max_number\
    \ % 0.1;\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n\
    \    new_numbers.push(max_number);\n    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n\
    \    new_numbers.push(min_number);\n    new_numbers.push(max_number);\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmph61322n2.rs:5:41\n\
    \     |\n5    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmph61322n2.rs:6:41\n\
    \     |\n6    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmph61322n2.rs:3:42\n  |\n3 | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n  |    ---------------                       ^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<f64>`\n          found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for\
    \ number in numbers {\n        if number < min_number {\n            min_number\
    \ = number;\n        }\n        if number > max_number {\n            max_number\
    \ = number;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n  \
    \  for number in numbers {\n        rescaled_numbers.push(number - min_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpb1fnsgcn.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n6   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for &n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for &n in numbers {\n   \
    \     rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbm5z6mqc.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbm5z6mqc.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push(n / max_val\
    \ * 1.0 + min_val / min_val * 0.0);\n    }\n    rescaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmprq4__8vc.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min_val)\
    \ / (max_val - min_val));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpzk1n6hz2.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ mut new_n = n;\n        if n == min_value {\n            new_n = 0;\n      \
    \  }\n        if n == max_value {\n            new_n = 1;\n        }\n       \
    \ new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7sbu1ir3.rs:18:21\n   |\n\
    16 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n17 |         if n == min_value {\n18 |             new_n = 0;\n\
    \   |                     ^\n   |                     |\n   |                \
    \     expected `f64`, found integer\n   |                     help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7sbu1ir3.rs:21:21\n\
    \   |\n16 |         let mut new_n = n;\n   |                         - expected\
    \ due to this value\n...\n21 |             new_n = 1;\n   |                  \
    \   ^\n   |                     |\n   |                     expected `f64`, found\
    \ integer\n   |                     help: use a float literal: `1.0`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers.iter().min().unwrap();\n\
    \    let mut largest_number = numbers.iter().max().unwrap();\n    let mut smallest_index\
    \ = 0;\n    let mut largest_index = 0;\n    for number in numbers {\n        if\
    \ number < smallest_number {\n            smallest_number = number;\n        \
    \    smallest_index = rescaled_numbers.len();\n        }\n        if number >\
    \ largest_number {\n            largest_number = number;\n            largest_index\
    \ = rescaled_numbers.len();\n        }\n        rescaled_numbers.push(number);\n\
    \    }\n    rescaled_numbers[smallest_index] = smallest_number as f64 / smallest_number;\n\
    \    rescaled_numbers[largest_index] = largest_number as f64 / largest_number;\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp81gcwd1t.rs:5:46\n\
    \     |\n5    |     let mut smallest_number = numbers.iter().min().unwrap();\n\
    \     |                                              ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmp81gcwd1t.rs:6:45\n     |\n6    |     let mut\
    \ largest_number = numbers.iter().max().unwrap();\n     |                    \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp81gcwd1t.rs:10:21\n   |\n10 |\
    \         if number < smallest_number {\n   |                     ^^^^^^^^^^^^^^^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |         if number < *smallest_number {\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp81gcwd1t.rs:11:31\n   |\n5  |\
    \     let mut smallest_number = numbers.iter().min().unwrap();\n   |         \
    \                      ----------------------------- expected due to this value\n\
    ...\n11 |             smallest_number = number;\n   |                        \
    \       ^^^^^^\n   |                               |\n   |                   \
    \            expected `&f64`, found `f64`\n   |               "
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_value = numbers[0];\n  \
    \  let mut max_value = numbers[0];\n    for number in numbers {\n        if number\
    \ < min_value {\n            min_value = number;\n        }\n        if number\
    \ > max_value {\n            max_value = number;\n        }\n    }\n    for number\
    \ in numbers {\n        rescaled_numbers.push(number * (max_value - min_value)\
    \ / (numbers.len() - 1));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n  --> /tmp/tmpsbw1yvox.rs:16:64\n\
    \   |\n16 |         rescaled_numbers.push(number * (max_value - min_value) / (numbers.len()\
    \ - 1));\n   |                                                               \
    \ ^ no implementation for `f64 / usize`\n   |\n   = help: the trait `Div<usize>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n\
    \             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n  \
    \         and 54 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (1.0_f64\
    \ - 1.0_f64));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp2yw7uo_z.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_number = numbers.iter().min().unwrap();\n\
    \    let mut max_number = numbers.iter().max().unwrap();\n    let mut min_rescaled_number\
    \ = min_number;\n    let mut max_rescaled_number = max_number;\n    for number\
    \ in numbers {\n        let rescaled_number = (number - min_number) / (max_number\
    \ - min_number);\n        rescaled_numbers.push(rescaled_number);\n        min_rescaled_number\
    \ = std::cmp::min(min_rescaled_number, rescaled_number);\n        max_rescaled_number\
    \ = std::cmp::max(max_rescaled_number, rescaled_number);\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxa04_zhl.rs:5:41\n\
    \     |\n5    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxa04_zhl.rs:6:41\n\
    \     |\n6    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxa04_zhl.rs:12:66\n   |\n12 |\
    \         min_rescaled_number = std::cmp::min(min_rescaled_number, rescaled_number);\n\
    \   |                                                                  ^^^^^^^^^^^^^^^\n\
    \   |                                                                  |\n   |\
    \                                                                  expected `&f64`,\
    \ found `f64`\n   |                                                          \
    \        help: consider borrowing here: `&rescaled_number`\n\nerror[E0277]: the\
    \ trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxa04_zhl.rs:12:31\n\
    \     |\n12   |         min_rescaled_number = std::cmp::min(min_rescaled_number,\
    \ rescaled_number);\n     |                           "
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    new_numbers.reserve(numbers.len());\n   \
    \ for n in numbers {\n        let mut new_n = n;\n        if new_n < 0 {\n   \
    \         new_n *= -1;\n        }\n        new_numbers.push(new_n);\n    }\n \
    \   new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp90lhhw_q.rs:8:20\n  |\n8 |\
    \         if new_n < 0 {\n  |                    ^\n  |                    |\n\
    \  |                    expected `f64`, found integer\n  |                   \
    \ help: use a float literal: `0.0`\n\nerror[E0277]: cannot multiply-assign `f64`\
    \ by `{integer}`\n --> /tmp/tmp90lhhw_q.rs:9:19\n  |\n9 |             new_n *=\
    \ -1;\n  |                   ^^ no implementation for `f64 *= {integer}`\n  |\n\
    \  = help: the trait `MulAssign<{integer}>` is not implemented for `f64`\n  =\
    \ help: the following other types implement trait `MulAssign<Rhs>`:\n        \
    \    <f32 as MulAssign<&f32>>\n            <f32 as MulAssign>\n            <f64\
    \ as MulAssign<&f64>>\n            <f64 as MulAssign>\n            <i128 as MulAssign<&i128>>\n\
    \            <i128 as MulAssign>\n            <i16 as MulAssign<&i16>>\n     \
    \       <i16 as MulAssign>\n          and 20 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpl51njd_l.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_number = numbers[0];\n \
    \   let mut max_number = numbers[0];\n    for number in numbers {\n        if\
    \ number < min_number {\n            min_number = number;\n        }\n       \
    \ if number > max_number {\n            max_number = number;\n        }\n    }\n\
    \    for number in numbers {\n        rescaled_numbers.push(number * (max_number\
    \ - min_number) / (numbers.len() - 1));\n    }\n    rescaled_numbers\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n  --> /tmp/tmpcnlmy4ha.rs:16:66\n\
    \   |\n16 |         rescaled_numbers.push(number * (max_number - min_number) /\
    \ (numbers.len() - 1));\n   |                                                \
    \                  ^ no implementation for `f64 / usize`\n   |\n   = help: the\
    \ trait `Div<usize>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let new_n = ((n - min_val) /\
    \ (max_val - min_val)) * 2.0 + 0.0;\n        new_numbers.push(new_n);\n    }\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpny56ljb7.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for &n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4nff4zat.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4nff4zat.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut min_number = numbers[0];\n    let\
    \ mut max_number = numbers[0];\n    for number in numbers {\n        if number\
    \ < min_number {\n            min_number = number;\n        }\n        if number\
    \ > max_number {\n            max_number = number;\n        }\n    }\n    for\
    \ number in numbers {\n        new_numbers.push(number - min_number);\n      \
    \  new_numbers.push(number - max_number);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpof4umf0l.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ new_n = ((n - min_value) / (max_value - min_value)) * 2.0 + 0.0;\n        new_numbers.push(new_n);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp70uf91jt.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push((number\
    \ - smallest_number) / (largest_number - smallest_number));\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwuw0j43p.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest = numbers[0];\n   \
    \ let mut largest = numbers[0];\n    for number in numbers {\n        if number\
    \ < smallest {\n            rescaled_numbers.push(0);\n            smallest =\
    \ number;\n        } else {\n            rescaled_numbers.push(1);\n         \
    \   largest = number;\n        }\n    }\n    rescaled_numbers.extend_from_slice(&[smallest,\
    \ largest]);\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5yxhwwqi.rs:16:42\n   |\n\
    16 |     rescaled_numbers.extend_from_slice(&[smallest, largest]);\n   |     \
    \                                     ^^^^^^^^ expected integer, found `f64`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5yxhwwqi.rs:17:5\n   |\n3  | fn\
    \ rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |                     \
    \                     -------- expected `Vec<f64>` because of return type\n...\n\
    17 |     rescaled_numbers\n   |     ^^^^^^^^^^^^^^^^ expected `f64`, found integer\n\
    \   |\n   = note: expected struct `Vec<f64>`\n              found struct `Vec<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_value = numbers[0];\n  \
    \  let mut max_value = numbers[0];\n    for number in numbers {\n        if number\
    \ < min_value {\n            min_value = number;\n        }\n        if number\
    \ > max_value {\n            max_value = number;\n        }\n    }\n    for number\
    \ in numbers {\n        rescaled_numbers.push(number - min_value) / (max_value\
    \ - min_value);\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot divide `()` by `f64`\n  --> /tmp/tmpkhdh92df.rs:16:51\n\
    \   |\n16 |         rescaled_numbers.push(number - min_value) / (max_value - min_value);\n\
    \   |         ----------------------------------------- ^ -----------------------\
    \ f64\n   |         |\n   |         ()\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (1.0 + 1.0e-6));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpo2p9ysqf.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq5zzq852.rs:15:37\n   |\n\
    15 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest = numbers[0];\n   \
    \ let mut largest = numbers[0];\n    for n in numbers {\n        if n < smallest\
    \ {\n            smallest = n;\n        }\n        if n > largest {\n        \
    \    largest = n;\n        }\n    }\n    for n in numbers {\n        rescaled_numbers.push((n\
    \ - smallest) / (largest - smallest));\n    }\n    rescaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp20pjmxm0.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n7   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_number = numbers[0];\n \
    \   let mut max_number = numbers[0];\n    for number in numbers {\n        if\
    \ number < min_number {\n            min_number = number;\n        }\n       \
    \ if number > max_number {\n            max_number = number;\n        }\n    }\n\
    \    for number in numbers {\n        rescaled_numbers.push(number - min_number);\n\
    \    }\n    rescaled_numbers.sort();\n    rescaled_numbers.reverse();\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpwphxzdo2.rs:18:22\n\
    \    |\n18  |     rescaled_numbers.sort();\n    |                      ^^^^ the\
    \ trait `Ord` is not implemented for `f64`\n    |\n    = help: the following other\
    \ types implement trait `Ord`:\n              i128\n              i16\n      \
    \        i32\n              i64\n              i8\n              isize\n     \
    \         u128\n              u16\n            and 4 others\nnote: required by\
    \ a bound in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push((number\
    \ - smallest_number) / (largest_number - smallest_number));\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwuw0j43p.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push(n / max - min);\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpck0chjr7.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ n == min_val {\n            new_n = 0;\n        }\n        if n == max_val {\n\
    \            new_n = 1;\n        }\n        new_numbers.push(new_n);\n    }\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkdbjfj8.rs:18:21\n   |\n\
    16 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n17 |         if n == min_val {\n18 |             new_n = 0;\n  \
    \ |                     ^\n   |                     |\n   |                  \
    \   expected `f64`, found integer\n   |                     help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzkdbjfj8.rs:21:21\n\
    \   |\n16 |         let mut new_n = n;\n   |                         - expected\
    \ due to this value\n...\n21 |             new_n = 1;\n   |                  \
    \   ^\n   |                     |\n   |                     expected `f64`, found\
    \ integer\n   |                     help: use a float literal: `1.0`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for number\
    \ in numbers {\n        if number < min_value {\n            min_value = number;\n\
    \        }\n        if number > max_value {\n            max_value = number;\n\
    \        }\n    }\n    let mut new_numbers = Vec::new();\n    for number in numbers\
    \ {\n        let new_number = (number - min_value) / (max_value - min_value);\n\
    \        new_numbers.push(new_number);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp06ehd0er.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n6   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for &n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4nff4zat.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4nff4zat.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers.iter().min().unwrap();\n    let mut max_value = numbers.iter().max().unwrap();\n\
    \    min_value = min_value / numbers.len();\n    max_value = max_value / numbers.len();\n\
    \    numbers.iter_mut().for_each(|n| {\n        *n = *n * max_value + min_value;\n\
    \    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp807kll_8.rs:4:40\n\
    \     |\n4    |     let mut min_value = numbers.iter().min().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp807kll_8.rs:5:40\n\
    \     |\n5    |     let mut max_value = numbers.iter().max().unwrap();\n     |\
    \                                        ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: cannot divide `&f64` by `usize`\n --> /tmp/tmp807kll_8.rs:6:27\n\
    \  |\n6 |     min_value = min_value / numbers.len();\n  |                    \
    \       ^ no implementation for `&f64 / usize`\n  |\n  = help: the trait `Div<usize>`\
    \ is not implemented for `&f64`\n  = help: the following other types implement\
    \ trait `Div<Rhs>`:\n            <&'a f32 as Div<f32>>\n            <&'a f64 as\
    \ Div<f64>>\n            <&'a i128 as Div<i128>>\n            <&'a i16 as Div<i16>>\n\
    \            <&'a i32 as Div<i32>>\n            <&'a i64 as Div<i64>>\n      \
    \      <&'a i8 as Div<i8>>\n            <&'a isize as Div<isize>>\n          and\
    \ 54 others\n\nerror[E0277]: cannot divide `&f64` by `usize`\n --> /tmp/tmp807kll_8.rs:7:27\n\
    \  |\n7 |     max_value = max_value / numbers.len();\n  |  "
  stdout: ''
  timestamp: 1659976414
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest = numbers[0];\n   \
    \ let mut largest = numbers[0];\n    for n in numbers {\n        if n < smallest\
    \ {\n            smallest = n;\n        }\n        if n > largest {\n        \
    \    largest = n;\n        }\n        rescaled_numbers.push(n - smallest + largest);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 97.8]`,\n right: `[0.0, 1.0]`', /tmp/tmpb6by_63p.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if n == min {\n \
    \           new_n = 0;\n        }\n        if n == max {\n            new_n =\
    \ 1;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_p8ftuk.rs:18:21\n   |\n\
    16 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n17 |         if n == min {\n18 |             new_n = 0;\n   |  \
    \                   ^\n   |                     |\n   |                     expected\
    \ `f64`, found integer\n   |                     help: use a float literal: `0.0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj_p8ftuk.rs:21:21\n   |\n16 |\
    \         let mut new_n = n;\n   |                         - expected due to this\
    \ value\n...\n21 |             new_n = 1;\n   |                     ^\n   |  \
    \                   |\n   |                     expected `f64`, found integer\n\
    \   |                     help: use a float literal: `1.0`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let new_n = ((n - min) / (max - min)) as f64;\n\
    \        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp9knyc3m5.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        new_numbers.push((n\
    \ - smallest) / (largest - smallest));\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpcrare8n7.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n7   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n        rescaled.push((n - smallest) / (largest - smallest));\n\
    \    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[NaN, 1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmp6o1fmcig.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for &n in numbers {\n        rescaled_numbers.push(n / max - min);\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxnc7tggo.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxnc7tggo.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut min_number = numbers.iter().min().unwrap();\n\
    \    let mut max_number = numbers.iter().max().unwrap();\n    let mut min_number\
    \ = min_number / max_number;\n    let mut max_number = max_number / min_number;\n\
    \    for number in numbers {\n        new_numbers.push((number - min_number) /\
    \ (max_number - min_number));\n    }\n    new_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp57c4anzk.rs:5:41\n\
    \     |\n5    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp57c4anzk.rs:6:41\n\
    \     |\n6    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        new_numbers.push((n\
    \ - smallest) / (largest - smallest));\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpcrare8n7.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n7   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_number = numbers[0];\n \
    \   let mut max_number = numbers[0];\n    for number in numbers {\n        if\
    \ number < min_number {\n            min_number = number;\n        }\n       \
    \ if number > max_number {\n            max_number = number;\n        }\n    }\n\
    \    for number in numbers {\n        rescaled_numbers.push(number * (max_number\
    \ - min_number) / (numbers.len() - 1));\n    }\n    rescaled_numbers\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n  --> /tmp/tmpcnlmy4ha.rs:16:66\n\
    \   |\n16 |         rescaled_numbers.push(number * (max_number - min_number) /\
    \ (numbers.len() - 1));\n   |                                                \
    \                  ^ no implementation for `f64 / usize`\n   |\n   = help: the\
    \ trait `Div<usize>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut min_number = numbers[0];\n    let\
    \ mut max_number = numbers[0];\n    for number in numbers {\n        if number\
    \ < min_number {\n            min_number = number;\n        }\n        if number\
    \ > max_number {\n            max_number = number;\n        }\n    }\n    for\
    \ number in numbers {\n        new_numbers.push(number - min_number);\n      \
    \  new_numbers.push(number - max_number);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpof4umf0l.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for &n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4nff4zat.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4nff4zat.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min;\n        }\n        if new_n > max {\n            new_n\
    \ -= max;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi5a9510r.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for number\
    \ in numbers {\n        if number < min_value {\n            min_value = number;\n\
    \        }\n        if number > max_value {\n            max_value = number;\n\
    \        }\n    }\n    let mut rescaled_numbers = Vec::new();\n    for number\
    \ in numbers {\n        rescaled_numbers.push(number - min_value) / (max_value\
    \ - min_value);\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot divide `()` by `f64`\n  --> /tmp/tmp3z2fqdzl.rs:16:51\n\
    \   |\n16 |         rescaled_numbers.push(number - min_value) / (max_value - min_value);\n\
    \   |         ----------------------------------------- ^ -----------------------\
    \ f64\n   |         |\n   |         ()\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let new_n = ((n - min) / (max - min)) as f64;\n\
    \        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp9knyc3m5.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number) / (largest_number - smallest_number);\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot divide `()` by `f64`\n  --> /tmp/tmpppnc2ukg.rs:16:57\n\
    \   |\n16 |         rescaled_numbers.push(number - smallest_number) / (largest_number\
    \ - smallest_number);\n   |         -----------------------------------------------\
    \ ^ ---------------------------------- f64\n   |         |\n   |         ()\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min_val)\
    \ / (max_val - min_val));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpzk1n6hz2.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n \
    \   let mut largest_number = numbers[0];\n    for number in numbers {\n      \
    \  if number < smallest_number {\n            smallest_number = number;\n    \
    \    }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        new_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpkce3p8f0.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvjrtwkqg.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvjrtwkqg.rs:15:37\n   |\n15 |     numbers.iter().for_each(|n|\
    \ n = n * scale);\n   |                              -      ^^^^^^^^^\n   |  \
    \                            |      |\n   |                              |   \
    \   expected `&f64`, found `f64`\n   |                              |      help:\
    \ consider borrowing here: `&(n * scale)`\n   |                              expected\
    \ due to this parameter type\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for &n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4nff4zat.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4nff4zat.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    new_numbers.push(smallest as f64);\n    new_numbers.push(largest\
    \ as f64);\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmpdzd3p1ss.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push(n / max_val\
    \ * 1.0);\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpxk9_0fo6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        let new_n = ((n - smallest)\
    \ / (largest - smallest)) * 2.0 - 1.0;\n        new_numbers.push(new_n);\n   \
    \ }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpbcq0kzu5.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n7   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_number = numbers[0];\n \
    \   let mut max_number = numbers[0];\n    for number in numbers {\n        if\
    \ number < min_number {\n            min_number = number;\n        }\n       \
    \ if number > max_number {\n            max_number = number;\n        }\n    }\n\
    \    for number in numbers {\n        rescaled_numbers.push(number * (max_number\
    \ - min_number) / (1.0 + min_number));\n    }\n    rescaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpodh7mrpp.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for\
    \ &n in numbers {\n        if n < min_number {\n            min_number = n;\n\
    \        }\n        if n > max_number {\n            max_number = n;\n       \
    \ }\n    }\n    let mut new_numbers = Vec::new();\n    for &n in numbers {\n \
    \       let new_number = (n - min_number) / (max_number - min_number);\n     \
    \   new_numbers.push(new_number);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgl19xaj4.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgl19xaj4.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> =\
    \ Vec::new();\n    for &n in numbers {\n        rescaled.push(n / max - min);\n\
    \    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwrrnuljl.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwrrnuljl.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push(n / max - min + min);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpz5y747ii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ n == min_val {\n            new_n = 0;\n        }\n        if n == max_val {\n\
    \            new_n = 1;\n        }\n        new_numbers.push(new_n);\n    }\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkdbjfj8.rs:18:21\n   |\n\
    16 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n17 |         if n == min_val {\n18 |             new_n = 0;\n  \
    \ |                     ^\n   |                     |\n   |                  \
    \   expected `f64`, found integer\n   |                     help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzkdbjfj8.rs:21:21\n\
    \   |\n16 |         let mut new_n = n;\n   |                         - expected\
    \ due to this value\n...\n21 |             new_n = 1;\n   |                  \
    \   ^\n   |                     |\n   |                     expected `f64`, found\
    \ integer\n   |                     help: use a float literal: `1.0`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (1.0f64\
    \ - 1.0f64));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpcqrj_eji.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_number {\n            min_number = n;\n \
    \       }\n        if n > max_number {\n            max_number = n;\n        }\n\
    \    }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n \
    \       rescaled_numbers.push((n - min_number) / (max_number - min_number));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp219p775b.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ n < min_val {\n            new_n = min_val;\n        }\n        if n > max_val\
    \ {\n            new_n = max_val;\n        }\n        rescaled_numbers.push(new_n);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp9whjl4tz.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_number = numbers[0];\n \
    \   let mut max_number = numbers[0];\n    for number in numbers {\n        if\
    \ number < min_number {\n            min_number = number;\n        }\n       \
    \ if number > max_number {\n            max_number = number;\n        }\n    }\n\
    \    for number in numbers {\n        rescaled_numbers.push(number * (max_number\
    \ - min_number) / (numbers.len() - 1));\n    }\n    rescaled_numbers\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `f64` by `usize`\n  --> /tmp/tmpcnlmy4ha.rs:16:66\n\
    \   |\n16 |         rescaled_numbers.push(number * (max_number - min_number) /\
    \ (numbers.len() - 1));\n   |                                                \
    \                  ^ no implementation for `f64 / usize`\n   |\n   = help: the\
    \ trait `Div<usize>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push((number\
    \ - smallest_number) / (largest_number - smallest_number));\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwuw0j43p.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let new_n = ((n - min_val) /\
    \ (max_val - min_val)) * 2.0 - 1.0;\n        new_numbers.push(new_n);\n    }\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp1zre5cry.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ n == min_val {\n            new_n = 0;\n        }\n        if n == max_val {\n\
    \            new_n = 1;\n        }\n        new_numbers.push(new_n);\n    }\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkdbjfj8.rs:18:21\n   |\n\
    16 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n17 |         if n == min_val {\n18 |             new_n = 0;\n  \
    \ |                     ^\n   |                     |\n   |                  \
    \   expected `f64`, found integer\n   |                     help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzkdbjfj8.rs:21:21\n\
    \   |\n16 |         let mut new_n = n;\n   |                         - expected\
    \ due to this value\n...\n21 |             new_n = 1;\n   |                  \
    \   ^\n   |                     |\n   |                     expected `f64`, found\
    \ integer\n   |                     help: use a float literal: `1.0`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest = numbers[0];\n   \
    \ let mut largest = numbers[0];\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number;\n        }\n        if number >\
    \ largest {\n            largest = number;\n        }\n    }\n    for number in\
    \ numbers {\n        rescaled_numbers.push(number - smallest);\n    }\n    rescaled_numbers.push(largest\
    \ - smallest);\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpjlldtmsz.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push((number\
    \ - smallest_number) / (largest_number - smallest_number));\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwuw0j43p.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled = Vec::new();\n\
    \    for &n in numbers {\n        rescaled.push((n - min) / (max - min));\n  \
    \  }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpifnqag6m.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpifnqag6m.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut min_number = numbers.iter().min().unwrap();\n\
    \    let mut max_number = numbers.iter().max().unwrap();\n    let mut min_number\
    \ = min_number as f64;\n    let mut max_number = max_number as f64;\n    let mut\
    \ min_number = min_number as f64;\n    let mut max_number = max_number as f64;\n\
    \    let mut min_number = min_number as f64;\n    let mut max_number = max_number\
    \ as f64;\n    let mut min_number = min_number as f64;\n    let mut max_number\
    \ = max_number as f64;\n    let mut min_number = min_number as f64;\n    let mut\
    \ max_number = max_number as f64;\n    let mut min_number = min_number as f64;\n\
    \    let mut max_number = max_number as f64;\n    let mut min_number = min_number\
    \ as f64;\n    let mut max_number = max_number as f64;\n    let mut min_number\
    \ = min_number as f64;\n    let mut max_number = max_number as f64;\n    let mut\
    \ min_number = min_number as f64;\n    let mut max_number = max_number as f64;\n\
    \    let mut min_number = min_number as f64;\n    let mut max_number = max_number\
    \ as f64;\n    let mut min_number = min_number as f64;\n    let mut max_number\
    \ = max_number as f64;\n    let mut min_number = min_number as f64;\n    let mut\
    \ max_number = max_number as f64;\n    let mut min_number = min_number as f64;\n\
    \    let mut max_number = max_number as f64;\n    let mut min_number = min_number\
    \ as f64;\n    let mut max_number = max_number as f64;\n    let mut min_number\
    \ = min_number as f64;\n    let mut max_number = max_number as f64;\n    let mut\
    \ min_number = min_number as f64;\n    let mut max_number = max_number as f64;\n\
    \    let mut min_number = min_number as f64;\n    let mut max_number = max_number\
    \ as f64;\n    let mut min_number = min_number as f64;\n    let mut max_number\
    \ = max_number as f64;\n    let mut min_number = min_number as f64;\n    let mut\
    \ max_number = max_number as f64;\n    let mut min_number = min_number as f64;\n\
    \    let mut max_number = max_number \n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaoc8myy4.rs:46:36\n   |\n\
    46 |     let mut max_number = max_number \n   |                              \
    \      ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpaoc8myy4.rs:5:41\n\
    \     |\n5    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpaoc8myy4.rs:6:41\n\
    \     |\n6    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpaoc8myy4.rs:3:42\n  |\n3 | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n  |    ---------------                       ^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<f64>`\n          found unit type `()`\n\nerror[E0606]: casting `&f64` as\
    \ `f64` is invalid\n --> /tmp/tmpaoc8myy4.rs:7:26\n  |\n7 |     let mut min_number\
    \ = min_number as f64;\n  |                          ----------^^^^^^^\n  |   "
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest = numbers[0];\n   \
    \ let mut largest = numbers[0];\n    for n in numbers {\n        if n < smallest\
    \ {\n            smallest = n;\n        }\n        if n > largest {\n        \
    \    largest = n;\n        }\n    }\n    for n in numbers {\n        rescaled_numbers.push((n\
    \ - smallest) / (largest - smallest));\n    }\n    rescaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp20pjmxm0.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n7   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_number = numbers.iter().min().unwrap();\n    let mut max_number = numbers.iter().max().unwrap();\n\
    \    let mut new_numbers = Vec::new();\n    new_numbers.extend_from_slice(&numbers);\n\
    \    new_numbers.sort_unstable();\n    new_numbers.iter_mut().for_each(|n| {\n\
    \        *n = ((n - min_number) / (max_number - min_number)) * 2.0 + 0.5;\n  \
    \  });\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmphu3koaug.rs:4:41\n\
    \     |\n4    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmphu3koaug.rs:5:41\n\
    \     |\n5    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmphu3koaug.rs:8:17\n\
    \     |\n8    |     new_numbers.sort_unstable();\n     |                 ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::sort_unstable`\n\nerror[E0369]: cannot\
    \ subtract `&f64` from `&mut f64`\n  --> /tmp/tmphu3koaug.rs:10:18\n   |\n10 |\
    \         *n = ((n - min_number) / (max_number - min_number)) * 2.0 + 0.5;\n \
    \  |                - ^ ---------- &f64\n   |   "
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest = numbers[0];\n   \
    \ let mut largest = numbers[0];\n    for n in numbers {\n        if n < smallest\
    \ {\n            smallest = n;\n        }\n        if n > largest {\n        \
    \    largest = n;\n        }\n    }\n    for n in numbers {\n        rescaled_numbers.push((n\
    \ - smallest) / (largest - smallest));\n    }\n    rescaled_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp20pjmxm0.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n7   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_number = numbers.iter().min().unwrap();\n\
    \    let mut max_number = numbers.iter().max().unwrap();\n    let mut min_rescaled_number\
    \ = min_number;\n    let mut max_rescaled_number = max_number;\n    let mut min_rescaled_index\
    \ = -1;\n    let mut max_rescaled_index = -1;\n    for i in numbers.iter() {\n\
    \        if i == min_number {\n            min_rescaled_index = i;\n         \
    \   min_rescaled_number = i;\n        } else if i == max_number {\n          \
    \  max_rescaled_index = i;\n            max_rescaled_number = i;\n        }\n\
    \    }\n    for i in numbers.iter() {\n        let rescaled_number = i as f64\
    \ / max_rescaled_number as f64;\n        rescaled_numbers.push(rescaled_number);\n\
    \    }\n    for i in 0..numbers.len() {\n        if i == min_rescaled_index {\n\
    \            rescaled_numbers[i] = 0.0;\n        } else {\n            rescaled_numbers[i]\
    \ = rescaled_numbers[min_rescaled_index];\n        }\n    }\n    for i in 0..numbers.len()\
    \ {\n        if i == max_rescaled_index {\n            rescaled_numbers[i] = 1.0;\n\
    \        } else {\n            rescaled_numbers[i] = rescaled_numbers[max_rescaled_index];\n\
    \        }\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp8u71961u.rs:5:41\n\
    \     |\n5    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp8u71961u.rs:6:41\n\
    \     |\n6    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8u71961u.rs:13:34\n   |\n9  |\
    \     let mut min_rescaled_index = -1;\n   |                                 \
    \ -- expected due to this value\n...\n13 |             min_rescaled_index = i;\n\
    \   |                                  ^ expected integer, found `&f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8u71961u.rs:16:34\n   |\n10 |     let mut max_rescaled_index\
    \ = -1;\n   |                                  -- expected due to this value\n\
    ...\n16 |             max_rescaled_index = i;\n   |                          \
    \        ^ expected integer, found `&f64`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n --> /tmp/tmp8u71961u.rs:9:34\n  |\n9 |     let mut min_rescaled_index\
    \ = -1;\n  |                            "
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let new_n = ((n - min) / (max - min)) as f64;\n\
    \        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp9knyc3m5.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers.iter().min().unwrap();\n\
    \    let mut largest_number = numbers.iter().max().unwrap();\n    rescaled_numbers.push(smallest_number);\n\
    \    rescaled_numbers.push(largest_number);\n    for number in numbers {\n   \
    \     rescaled_numbers.push(number * rescaled_numbers[1] / rescaled_numbers[0]);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpd_jn3l5d.rs:5:46\n\
    \     |\n5    |     let mut smallest_number = numbers.iter().min().unwrap();\n\
    \     |                                              ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmpd_jn3l5d.rs:6:45\n     |\n6    |     let mut\
    \ largest_number = numbers.iter().max().unwrap();\n     |                    \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd_jn3l5d.rs:10:31\n   |\n10 |\
    \         rescaled_numbers.push(number * rescaled_numbers[1] / rescaled_numbers[0]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                               |\n   |                               expected\
    \ `&f64`, found `f64`\n   |                               help: consider borrowing\
    \ here: `&(number * rescaled_numbers[1] / rescaled_numbers[0])`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd_jn3l5d.rs:12:5\n   |\n3  | fn rescale_to_unit(numbers:\
    \ Vec<f64>) -> Vec<f64> {\n   |                                          --------\
    \ expected `Vec<f64>` because of return type\n...\n12 |     rescaled_numbers\n\
    \   |     ^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for number\
    \ in numbers {\n        if number < min_value {\n            min_value = number;\n\
    \        }\n        if number > max_value {\n            max_value = number;\n\
    \        }\n    }\n    let mut rescaled_numbers = Vec::new();\n    for number\
    \ in numbers {\n        rescaled_numbers.push(number - min_value) / (max_value\
    \ - min_value);\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot divide `()` by `f64`\n  --> /tmp/tmp3z2fqdzl.rs:16:51\n\
    \   |\n16 |         rescaled_numbers.push(number - min_value) / (max_value - min_value);\n\
    \   |         ----------------------------------------- ^ -----------------------\
    \ f64\n   |         |\n   |         ()\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if n == min {\n \
    \           new_n = 0;\n        }\n        if n == max {\n            new_n =\
    \ 1;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_p8ftuk.rs:18:21\n   |\n\
    16 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n17 |         if n == min {\n18 |             new_n = 0;\n   |  \
    \                   ^\n   |                     |\n   |                     expected\
    \ `f64`, found integer\n   |                     help: use a float literal: `0.0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj_p8ftuk.rs:21:21\n   |\n16 |\
    \         let mut new_n = n;\n   |                         - expected due to this\
    \ value\n...\n21 |             new_n = 1;\n   |                     ^\n   |  \
    \                   |\n   |                     expected `f64`, found integer\n\
    \   |                     help: use a float literal: `1.0`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        new_numbers.push((n\
    \ - smallest) / (largest - smallest));\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpcrare8n7.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n7   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut min_number = numbers.iter().min().unwrap();\n\
    \    let mut max_number = numbers.iter().max().unwrap();\n    let mut min_rescaled_number\
    \ = min_number;\n    let mut max_rescaled_number = max_number;\n    let mut min_rescaled_number\
    \ = min_number;\n    let mut max_rescaled_number = max_number;\n    for number\
    \ in numbers {\n        rescaled_numbers.push(number - min_rescaled_number);\n\
    \        min_rescaled_number = number;\n        max_rescaled_number = number;\n\
    \    }\n    for number in numbers {\n        rescaled_numbers.push(number - max_rescaled_number);\n\
    \        min_rescaled_number = number;\n        max_rescaled_number = number;\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_882o81k.rs:5:41\n\
    \     |\n5    |     let mut min_number = numbers.iter().min().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_882o81k.rs:6:41\n\
    \     |\n6    |     let mut max_number = numbers.iter().max().unwrap();\n    \
    \ |                                         ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_882o81k.rs:13:31\n   |\n9  |\
    \     let mut min_rescaled_number = min_number;\n   |                        \
    \           ---------- expected due to this value\n...\n13 |         min_rescaled_number\
    \ = number;\n   |                               ^^^^^^\n   |                 \
    \              |\n   |                               expected `&f64`, found `f64`\n\
    \   |                               help: consider borrowing here: `&number`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_882o81k.rs:14:31\n   |\n10 |\
    \     let mut max_rescaled_number = max_number;\n   |                        \
    \           ---------- expected due to this value\n...\n14 |         max_rescaled_number\
    \ = number;\n   |                               ^^^^^^\n   |    "
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ new_value = ((n - min_value) / (max_value - min_value)) * 1.0;\n        new_numbers.push(new_value);\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpbbre6_wi.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push((number\
    \ - smallest_number) / (largest_number - smallest_number));\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpwuw0j43p.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min_val)\
    \ / (max_val - min_val));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpzk1n6hz2.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled: Vec<f64> = Vec::new();\n\
    \    for n in numbers {\n        rescaled.push((n - min) / (max - min));\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi7y22tii.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut rescaled_numbers\
    \ = Vec::new();\n    for n in numbers {\n        rescaled_numbers.push((n - min_val)\
    \ / (max_val - min_val));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpzk1n6hz2.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_number = numbers[0];\n    let mut max_number = numbers[0];\n    for\
    \ n in numbers {\n        if n < min_number {\n            min_number = n;\n \
    \       }\n        if n > max_number {\n            max_number = n;\n        }\n\
    \    }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n \
    \       rescaled_numbers.push((n - min_number) / (max_number - min_number));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp219p775b.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = Vec::new();\n    let mut smallest = numbers[0];\n    let mut\
    \ largest = numbers[0];\n    for n in numbers {\n        if n < smallest {\n \
    \           smallest = n;\n        }\n        if n > largest {\n            largest\
    \ = n;\n        }\n    }\n    for n in numbers {\n        rescaled.push((n - smallest)\
    \ / (largest - smallest));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpm69o0t55.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(smallest_number\
    \ + (number - smallest_number) / (largest_number - smallest_number) * (largest_number\
    \ - smallest_number));\n    }\n    rescaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpancm2otj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ new_n = ((n - min_value) / (max_value - min_value)).round() as f64;\n      \
    \  new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpbszzauk6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for &n in numbers\
    \ {\n        if n < min {\n            min = n;\n        }\n        if n > max\
    \ {\n            max = n;\n        }\n    }\n    let mut rescaled = Vec::new();\n\
    \    for &n in numbers {\n        rescaled.push((n - min) / (max - min));\n  \
    \  }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpifnqag6m.rs:6:9\n  |\n6 |\
    \     for &n in numbers {\n  |         ^^    ------- this expression has type\
    \ `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `n`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpifnqag6m.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    let mut min_number = numbers[0];\n    let\
    \ mut max_number = numbers[0];\n    for number in numbers {\n        if number\
    \ < min_number {\n            min_number = number;\n        }\n        if number\
    \ > max_number {\n            max_number = number;\n        }\n    }\n    for\
    \ number in numbers {\n        new_numbers.push((number - min_number) / (max_number\
    \ - min_number));\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpb_c1lenj.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n15  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n7   |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let mut new_n = n;\n        if\
    \ n == min_val {\n            new_n = 0;\n        }\n        if n == max_val {\n\
    \            new_n = 1;\n        }\n        new_numbers.push(new_n);\n    }\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkdbjfj8.rs:18:21\n   |\n\
    16 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n17 |         if n == min_val {\n18 |             new_n = 0;\n  \
    \ |                     ^\n   |                     |\n   |                  \
    \   expected `f64`, found integer\n   |                     help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzkdbjfj8.rs:21:21\n\
    \   |\n16 |         let mut new_n = n;\n   |                         - expected\
    \ due to this value\n...\n21 |             new_n = 1;\n   |                  \
    \   ^\n   |                     |\n   |                     expected `f64`, found\
    \ integer\n   |                     help: use a float literal: `1.0`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if n == min {\n \
    \           new_n = 0;\n        }\n        if n == max {\n            new_n =\
    \ 1;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_p8ftuk.rs:18:21\n   |\n\
    16 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n17 |         if n == min {\n18 |             new_n = 0;\n   |  \
    \                   ^\n   |                     |\n   |                     expected\
    \ `f64`, found integer\n   |                     help: use a float literal: `0.0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj_p8ftuk.rs:21:21\n   |\n16 |\
    \         let mut new_n = n;\n   |                         - expected due to this\
    \ value\n...\n21 |             new_n = 1;\n   |                     ^\n   |  \
    \                   |\n   |                     expected `f64`, found integer\n\
    \   |                     help: use a float literal: `1.0`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max - min);\n\
    \    for n in numbers {\n        n /= scale;\n    }\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `n` is assigned to, but never used\n  --> /tmp/tmpzzdtiee4.rs:15:9\n\
    \   |\n15 |     for n in numbers {\n   |         ^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_n` instead\n\nwarning: value assigned\
    \ to `n` is never read\n  --> /tmp/tmpzzdtiee4.rs:16:9\n   |\n16 |         n /=\
    \ scale;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpzzdtiee4.rs:14:9\n   |\n14 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpzzdtiee4.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `n`\n  --> /tmp/tmpzzdtiee4.rs:16:9\n   |\n15 |     for n in numbers {\n   |\
    \         -\n   |         |\n   |         first assignment to `n`\n   |      \
    \   help: consider making this binding mutable: `mut n`\n16 |         n /= scale;\n\
    \   |         ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]:\
    \ use of moved value: `numbers`\n  --> /tmp/tmpzzdtiee4.rs:18:5\n   |\n3  | fn\
    \ rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n   |                    -------\
    \ move occurs because `numbers` has type `Vec<f64>`, which does not implement\
    \ the `Copy` tr"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n        let\
    \ mut new_n = n;\n        if n == min_value {\n            new_n = 0;\n      \
    \  }\n        if n == max_value {\n            new_n = 1;\n        }\n       \
    \ new_numbers.push(new_n);\n    }\n    new_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7sbu1ir3.rs:18:21\n   |\n\
    16 |         let mut new_n = n;\n   |                         - expected due to\
    \ this value\n17 |         if n == min_value {\n18 |             new_n = 0;\n\
    \   |                     ^\n   |                     |\n   |                \
    \     expected `f64`, found integer\n   |                     help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7sbu1ir3.rs:21:21\n\
    \   |\n16 |         let mut new_n = n;\n   |                         - expected\
    \ due to this value\n...\n21 |             new_n = 1;\n   |                  \
    \   ^\n   |                     |\n   |                     expected `f64`, found\
    \ integer\n   |                     help: use a float literal: `1.0`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_val = numbers[0];\n    let mut max_val = numbers[0];\n    for n in numbers\
    \ {\n        if n < min_val {\n            min_val = n;\n        }\n        if\
    \ n > max_val {\n            max_val = n;\n        }\n    }\n    let mut new_numbers\
    \ = Vec::new();\n    for n in numbers {\n        let new_n = ((n - min_val) /\
    \ (max_val - min_val)) * 2.0 + 0.0;\n        new_numbers.push(new_n);\n    }\n\
    \    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpny56ljb7.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut scale = (max_value - min_value).recip();\n    for n in numbers\
    \ {\n        *n -= min_value;\n        *n *= scale;\n    }\n    numbers\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpwteek52p.rs:16:9\n\
    \   |\n16 |         *n -= min_value;\n   |         ^^\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpwteek52p.rs:17:9\n   |\n17 |         *n\
    \ *= scale;\n   |         ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut scale = 1.0 * max / min;\n\
    \    numbers.iter().for_each(|n| n = n * scale);\n    numbers\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq5zzq852.rs:15:37\n   |\n\
    15 |     numbers.iter().for_each(|n| n = n * scale);\n   |                   \
    \           -      ^^^^^^^^^\n   |                              |      |\n   |\
    \                              |      expected `&f64`, found `f64`\n   |     \
    \                         |      help: consider borrowing here: `&(n * scale)`\n\
    \   |                              expected due to this parameter type\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut rescaled_numbers = Vec::new();\n\
    \    for n in numbers {\n        rescaled_numbers.push((n - min) / (max - min));\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmptz1w3ezs.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut new_numbers = Vec::new();\n    new_numbers.reserve(numbers.len());\n   \
    \ for n in numbers {\n        let mut new_n = n;\n        if new_n > 1.0 {\n \
    \           new_n -= 1.0;\n        }\n        if new_n < 0.0 {\n            new_n\
    \ += 1.0;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 48.9]`,\n right: `[0.0, 1.0]`', /tmp/tmpvbgcsk53.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut scale = 1.0 * (max - min);\n\
    \    numbers.iter().for_each(|n| {\n        *n -= min;\n        *n /= scale;\n\
    \    });\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n\
    \  --> /tmp/tmpfk6xec9d.rs:16:9\n   |\n15 |     numbers.iter().for_each(|n| {\n\
    \   |                              - help: consider changing this to be a mutable\
    \ reference: `&mut f64`\n16 |         *n -= min;\n   |         ^^^^^^^^^ `n` is\
    \ a `&` reference, so the data it refers to cannot be written\n\nerror[E0594]:\
    \ cannot assign to `*n`, which is behind a `&` reference\n  --> /tmp/tmpfk6xec9d.rs:17:9\n\
    \   |\n15 |     numbers.iter().for_each(|n| {\n   |                          \
    \    - help: consider changing this to be a mutable reference: `&mut f64`\n16\
    \ |         *n -= min;\n17 |         *n /= scale;\n   |         ^^^^^^^^^^^ `n`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpfk6xec9d.rs:14:9\n   |\n14 |    \
    \ let mut scale = 1.0 * (max - min);\n   |         ----^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpfk6xec9d.rs:15:5\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     numbers.iter().for_each(|n| {\n    |     ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n    = note: borrow occurs due to deref coercion\
    \ to `[f64]`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content\
    \ to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers {\n\
    \    |              +\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0382, E0594.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest = numbers[0];\n   \
    \ let mut largest = numbers[0];\n    for number in numbers {\n        if number\
    \ < smallest {\n            rescaled_numbers.push(0.0);\n            smallest\
    \ = number;\n        } else {\n            rescaled_numbers.push(1.0);\n     \
    \       largest = number;\n        }\n    }\n    rescaled_numbers.extend_from_slice(&[smallest,\
    \ largest]);\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 1.0, 2.0, 49.9]`,\n right: `[0.0, 1.0]`', /tmp/tmp_cr10zen.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let mut smallest_number = numbers[0];\n\
    \    let mut largest_number = numbers[0];\n    for number in numbers {\n     \
    \   if number < smallest_number {\n            smallest_number = number;\n   \
    \     }\n        if number > largest_number {\n            largest_number = number;\n\
    \        }\n    }\n    for number in numbers {\n        rescaled_numbers.push(number\
    \ - smallest_number);\n        rescaled_numbers.push(number - largest_number);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpufoleq5w.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n7   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = numbers[0];\n    let mut max_value = numbers[0];\n    for n\
    \ in numbers {\n        if n < min_value {\n            min_value = n;\n     \
    \   }\n        if n > max_value {\n            max_value = n;\n        }\n   \
    \ }\n    let mut rescaled_numbers = Vec::new();\n    for n in numbers {\n    \
    \    rescaled_numbers.push((n - min_value) / (max_value - min_value));\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp0gr57kh6.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              -------\n    |              |\n    |              `numbers` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&numbers`\n...\n15  |     for\
    \ n in numbers {\n    |              ^^^^^^^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `numbers`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748875
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min = numbers[0];\n    let mut max = numbers[0];\n    for n in numbers {\n\
    \        if n < min {\n            min = n;\n        }\n        if n > max {\n\
    \            max = n;\n        }\n    }\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        let mut new_n = n;\n        if new_n < min {\n\
    \            new_n -= min;\n        }\n        if new_n > max {\n            new_n\
    \ -= max;\n        }\n        new_numbers.push(new_n);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpi5a9510r.rs:15:14\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for n in numbers {\n   \
    \ |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n15  |     for n in numbers {\n    |              ^^^^^^^ value used here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for n in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976414
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = numbers.clone();\n    rescaled.sort();\n    let mut smallest\
    \ = rescaled[0];\n    let mut largest = rescaled[0];\n    for &x in rescaled {\n\
    \        if x < smallest {\n            smallest = x;\n        }\n        if x\
    \ > largest {\n            largest = x;\n        }\n    }\n    let mut new_rescaled\
    \ = Vec::new();\n    for &x in rescaled {\n        let mut new_x = x;\n      \
    \  if smallest == largest {\n            new_x = 0.0;\n        }\n        new_rescaled.push(new_x);\n\
    \    }\n    new_rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmp67yttbaf.rs:5:14\n\
    \    |\n5   |     rescaled.sort();\n    |              ^^^^ the trait `Ord` is\
    \ not implemented for `f64`\n    |\n    = help: the following other types implement\
    \ trait `Ord`:\n              i128\n              i16\n              i32\n   \
    \           i64\n              i8\n              isize\n              u128\n \
    \             u16\n            and 4 others\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp67yttbaf.rs:8:9\n\
    \  |\n8 |     for &x in rescaled {\n  |         ^^    -------- this expression\
    \ has type `Option<f64>`\n  |         |\n  |         expected `f64`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `x`\n  |\n  =\
    \ note:   expected type `f64`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp67yttbaf.rs:17:9\n   |\n17 |     for &x in rescaled\
    \ {\n   |         ^^    -------- this expression has type `Option<f64>`\n   |\
    \         |\n   |         expected `f64`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `f64`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976414
