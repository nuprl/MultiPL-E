name: HumanEval_0_has_close_elements
language: rs
prompt: "/// Check if in given list of numbers, are any two numbers closer to each\
  \ other than\n/// given threshold.\nfn has_close_elements(numbers: Vec<f64>, threshold:\
  \ f64) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
  \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
  \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
  \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),\
  \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n\
  \    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
completions: ["    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        } else if n - min_number\
    \ < min_distance {\n            min_number = n;\n            min_distance = n\
    \ - min_number;\n        }\n    }\n    min_distance < threshold", "    numbers.iter().any(|x|\
    \ {\n        let mut min_dist = threshold;\n        let mut min_idx = -1;\n  \
    \      for (i, &x) in numbers.iter().enumerate() {\n            let dist = x -\
    \ i;\n            if dist < min_dist {\n                min_dist = dist;\n   \
    \             min_idx = i;\n            }\n        }\n        min_dist < threshold\n\
    \    })", "    let mut numbers_sorted = numbers.iter().cloned().collect::<Vec<_>>();\n\
    \    numbers_sorted.sort_unstable();\n    let mut min_distance = threshold;\n\
    \    let mut min_number = numbers_sorted.iter().cloned().collect::<Vec<_>>();\n\
    \    loop {\n        let mut min_number_iter = min_number.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \        let mut min_number_iter = min_number_iter.into_iter().cloned().collect::",
  "    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n    let\
    \ mut i = 0;\n    let mut j = 1;\n    while i < numbers_copy.len() - 1 && j <\
    \ numbers_copy.len() {\n        if numbers_copy[i] - numbers_copy[j] > threshold\
    \ {\n            return true;\n        }\n        if numbers_copy[i] - numbers_copy[j]\
    \ < -threshold {\n            return false;\n        }\n        i += 1;\n    \
    \    j += 1\n    }\n    false", "    let mut numbers_copy = numbers.clone();\n\
    \    numbers_copy.sort();\n    let mut i = 0;\n    let mut j = 1;\n    while i\
    \ < numbers_copy.len() && j < numbers_copy.len() {\n        if numbers_copy[i]\
    \ < numbers_copy[j] {\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n        if j == numbers_copy.len() {\n            return true;\n\
    \        }\n    }\n    false", "    let mut numbers_copy = numbers.clone();\n\
    \    numbers_copy.sort();\n    let mut min_distance = threshold;\n    let mut\
    \ min_element = numbers_copy[0];\n    for &n in numbers_copy {\n        let distance\
    \ = n - min_element;\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_element = n;\n        }\n    }\n    min_distance\
    \ < threshold", "    let mut min_distance = threshold;\n    let mut min_number\
    \ = numbers[0];\n    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold",
  "    let mut close = false;\n    for &n in numbers {\n        if n < threshold {\n\
    \            close = true;\n            break;\n        }\n    }\n    close",
  "    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n    let\
    \ mut min_distance = threshold;\n    let mut min_number = numbers_copy[0];\n \
    \   let mut min_number_index = numbers_copy.len() - 1;\n    let mut max_number\
    \ = numbers_copy[0];\n    let mut max_number_index = numbers_copy.len() - 1;\n\
    \    for i in 1..numbers_copy.len() {\n        let distance = numbers_copy[i]\
    \ - numbers_copy[i - 1];\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = numbers_copy[i];\n            min_number_index\
    \ = i;\n        }\n        if distance > max_distance {\n            max_distance\
    \ = distance;\n            max_number = numbers_copy[i];\n            max_number_index\
    \ = i;\n        }\n    }\n    min_number_index != max_number_index", "    let\
    \ mut min_distance = threshold;\n    let mut min_number = numbers[0];\n    for\
    \ &n in numbers {\n        let distance = n.abs() - min_number.abs();\n      \
    \  if distance < min_distance {\n            min_distance = distance;\n      \
    \      min_number = n;\n        }\n    }\n    min_distance < threshold", "   \
    \ numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n        let\
    \ mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate() {\n   \
    \         let dist = x - &numbers[i];\n            if dist < min_dist {\n    \
    \            min_dist = dist;\n                min_idx = i;\n            }\n \
    \       }\n        min_idx != -1\n    })", "    let mut numbers_sorted = numbers.iter().cloned().collect::<Vec<_>>();\n\
    \    numbers_sorted.sort_unstable();\n    let mut i = 0;\n    let mut j = 1;\n\
    \    while i < numbers_sorted.len() && j < numbers_sorted.len() {\n        if\
    \ numbers_sorted[i] < numbers_sorted[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n        if i == numbers_sorted.len() || j\
    \ == numbers_sorted.len() {\n            return false;\n        }\n    }\n   \
    \ numbers_sorted.len() >= 2 && numbers_sorted[i] == numbers_sorted[j] && numbers_sorted[i]\
    \ < threshold", "    let mut close = false;\n    for &n in numbers {\n       \
    \ if close.load(Ordering::Relaxed) {\n            break;\n        }\n        if\
    \ n < threshold {\n            close = true;\n        } else {\n            close\
    \ = false;\n            break;\n        }\n    }\n    close", "    let mut min_distance\
    \ = threshold;\n    let mut min_element = numbers[0];\n    for &n in numbers {\n\
    \        let distance = std::f64::abs(n - min_element);\n        if distance <\
    \ min_distance {\n            min_distance = distance;\n            min_element\
    \ = n;\n        }\n    }\n    min_distance < threshold", "    let mut numbers_sorted\
    \ = numbers.iter().cloned().sorted();\n    let mut min_distance = threshold;\n\
    \    let mut min_element = numbers_sorted.next().unwrap();\n    for element in\
    \ numbers_sorted {\n        if element - min_element > threshold {\n         \
    \   min_distance = element - min_element;\n            min_element = element;\n\
    \        }\n    }\n    min_distance < threshold", "    let mut min_dist = threshold;\n\
    \    for &n in numbers {\n        for &m in numbers {\n            if *n < m &&\
    \ *n - *m > min_dist {\n                min_dist = (*n - *m).abs();\n        \
    \    }\n        }\n    }\n    min_dist < threshold", "    numbers.iter().any(|x|\
    \ {\n        numbers.iter().any(|y| {\n            abs(x - y) < threshold\n  \
    \      })\n    })", "    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n\
    \    for &n in numbers_copy {\n        if n == threshold {\n            return\
    \ true;\n        }\n        if numbers.iter().any(|&n| n == n) {\n           \
    \ return true;\n        }\n    }\n    false", "    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < numbers.len() && j < numbers.len() {\n        if numbers[i]\
    \ - numbers[j] > threshold {\n            return true;\n        }\n        if\
    \ numbers[j] - numbers[i] > threshold {\n            return false;\n        }\n\
    \        i += 1;\n        j += 1;\n    }\n    false", "    let mut numbers_sorted\
    \ = numbers.iter().cloned().collect::<Vec<_>>();\n    numbers_sorted.sort_unstable();\n\
    \n    for &n in numbers_sorted {\n        if n == threshold {\n            return\
    \ true;\n        }\n        if n == numbers_sorted[numbers_sorted.len() - 1] {\n\
    \            return false;\n        }\n    }\n\n    false"]
stop_tokens:
- "\n}"
