language: rs
name: HumanEval_61_correct_bracketing
results:
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(stack.len());\n        } else\
    \ if c == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747903
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            open_brackets.push('(');\n        } else if bracket ==\
    \ ')' {\n            close_brackets.push(')');\n        } else {\n           \
    \ open_brackets.push(bracket);\n            close_brackets.push(bracket);\n  \
    \      }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw303mmw0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets {\n        if bracket == '(' {\n\
    \            open_brackets.push('(');\n            close_brackets.push(')');\n\
    \        } else if bracket == ')' {\n            if open_brackets.len() > 0 {\n\
    \                open_brackets.pop();\n                close_brackets.pop();\n\
    \            } else {\n                return false;\n            }\n        }\
    \ else {\n            return false;\n        }\n    }\n    if open_brackets.len()\
    \ != close_brackets.len() {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpgoikdo9u.rs:6:20\n\
    \    |\n6   |     for bracket in brackets {\n    |                    ^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\",\", \",\");\n\
    \    brackets.replace(\";\", \";\");\n    brackets.replace(\":\", \":\");\n  \
    \  brackets.replace(\"=\", \"=\");\n    brackets.replace(\"!\", \"!\");\n    brackets.replace(\"\
    ?\", \"?\");\n    brackets.replace(\",\", \",\");\n    brackets.replace(\";\"\
    , \";\");\n    brackets.replace(\":\", \":\");\n    brackets.replace(\"=\", \"\
    =\");\n    brackets.replace(\"!\", \"!\");\n    brackets.replace(\"?\", \"?\"\
    );\n    brackets.replace(\",\", \",\");\n    brackets.replace(\";\", \";\");\n\
    \    brackets.replace(\":\", \":\");\n    brackets.replace(\"=\", \"=\");\n  \
    \  brackets.replace(\"!\", \"!\");\n    brackets.replace(\"?\", \"?\");\n    brackets.replace(\"\
    ,\", \",\");\n    brackets.replace(\";\", \";\");\n    brackets.replace(\":\"\
    , \":\");\n    brackets.replace(\"=\", \"=\");\n    brackets.replace(\"!\", \"\
    !\");\n    brackets.replace(\"?\", \"?\");\n    brackets.replace(\",\", \",\"\
    );\n    brackets.replace(\";\", \";\");\n    brackets.replace(\":\", \":\");\n\
    \    brackets.replace(\"=\", \"=\");\n    brackets.replace(\"!\", \"!\");\n  \
    \  brackets.replace(\"?\", \"?\");\n    brackets.replace(\",\", \",\");\n    brackets.replace(\"\
    ;\", \";\");\n    brackets.replace(\":\", \":\");\n    brackets.replace(\"=\"\
    , \"=\");\n    brackets.replace(\"!\", \"!\");\n    brackets.replace(\"?\", \"\
    ?\");\n    brackets.replace(\",\", \",\");\n    brackets.replace(\";\", \";\"\
    );\n    brackets.replace(\":\", \":\");\n    brackets.replace(\"=\", \"=\");\n\
    \    brackets.replace(\"!\", \"!\");\n    brackets.replace(\"?\", \"?\");\n  \
    \  brackets.replace(\",\", \",\");\n    brackets.replace(\";\", \";\");\n    brackets.replace(\"\
    :\", \":\");\n    brackets.replace(\"=\", \"=\");\n    brackets.replace(\"!\"\
    , \"!\");\n    brackets.replace(\"?\", \"?\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpob7yigvo.rs:76:56\n\
    \   |\n76 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n77 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            stack.push(0);\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpteopfzr8.rs:17:19\n   |\n17 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^-----------\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_brackets_count = String::new();\n\
    \    let mut closing_brackets_count = String::new();\n    let mut opening_brackets_count_map\
    \ = HashMap::new();\n    let mut closing_brackets_count_map = HashMap::new();\n\
    \    let mut opening_brackets_count_map = HashMap::new();\n    let mut closing_brackets_count_map\
    \ = HashMap::new();\n    let mut opening_brackets_count_map = HashMap::new();\n\
    \    let mut closing_brackets_count_map = HashMap::new();\n    let mut opening_brackets_count_map\
    \ = HashMap::new();\n    let mut closing_brackets_count_map = HashMap::new();\n\
    \    let mut opening_brackets_count_map = HashMap::new();\n    let mut closing_brackets_count_map\
    \ = HashMap::new();\n    let mut opening_brackets_count_map = HashMap::new();\n\
    \    let mut closing_brackets_count_map = HashMap::new();\n    let mut opening_brackets_count_map\
    \ = HashMap::new();\n    let mut closing_brackets_count_map = HashMap::new();\n\
    \    let mut opening_brackets_count_map = HashMap::new();\n    let mut closing_brackets_count_map\
    \ = HashMap::new();\n    let mut opening_brackets_count_map = HashMap::new();\n\
    \    let mut closing_brackets_count_map = HashMap::new();\n    let mut opening_brackets_count_map\
    \ = HashMap::new();\n    let mut closing_brackets_count_map = HashMap::new();\n\
    \    let mut opening_brackets_count_map = HashMap::new();\n    let mut closing_brackets_count_map\
    \ = HashMap::new();\n    let mut opening_brackets_count_map = HashMap::new();\n\
    \    let mut closing_brackets_count_map = HashMap::new();\n    let mut opening_brackets_count_map\
    \ = HashMap::new();\n    let mut closing_brackets_count_map = HashMap::new();\n\
    \    let mut opening_brackets_count_map = HashMap::new();\n    let mut closing_brackets_count_map\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmptekfa9jj.rs:36:1\n\
    \   |\n36 | }\n   | ^ expected expression\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n --> /tmp/tmptekfa9jj.rs:8:42\n  |\n8 |  \
    \   let mut opening_brackets_count_map = HashMap::new();\n  |                \
    \                          ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n --> /tmp/tmptekfa9jj.rs:9:42\n\
    \  |\n9 |     let mut closing_brackets_count_map = HashMap::new();\n  |      \
    \                                    ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmptekfa9jj.rs:10:42\n\
    \   |\n10 |     let mut opening_brackets_count_map = HashMap::new();\n   |   \
    \                                       ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmptekfa9jj.rs:11:42\n   |\n11 |     let mut closing_brackets_count_map\
    \ = HashMap::new();\n   |                                          ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmptekfa9jj.rs:12:42\n   |\n12 |  \
    \   let mut opening_brackets_count_map = HashMap::new();\n   |               \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmptekfa9jj.rs:13:42\n\
    \   |\n13 |     let mut closing_brackets_count_map = HashMap::new();\n   |   \
    \                                       ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | us"
  stdout: ''
  timestamp: 1659747903
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            open_brackets.push('(');\n        } else if bracket ==\
    \ ')' {\n            close_brackets.push(')');\n        } else {\n           \
    \ open_brackets.push(bracket);\n            close_brackets.push(bracket);\n  \
    \      }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw303mmw0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets;\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\",\", \",\");\n\
    \    brackets.replace(\";\", \";\");\n    brackets.replace(\":\", \":\");\n  \
    \  brackets.replace(\"=\", \"=\");\n    brackets.replace(\"!\", \"!\");\n    brackets.replace(\"\
    ?\", \"?\");\n    brackets.replace(\",\", \",\");\n    brackets.replace(\";\"\
    , \";\");\n    brackets.replace(\":\", \":\");\n    brackets.replace(\"=\", \"\
    =\");\n    brackets.replace(\"!\", \"!\");\n    brackets.replace(\"?\", \"?\"\
    );\n    brackets.replace(\",\", \",\");\n    brackets.replace(\";\", \";\");\n\
    \    brackets.replace(\":\", \":\");\n    brackets.replace(\"=\", \"=\");\n  \
    \  brackets.replace(\"!\", \"!\");\n    brackets.replace(\"?\", \"?\");\n    brackets.replace(\"\
    ,\", \",\");\n    brackets.replace(\";\", \";\");\n    brackets.replace(\":\"\
    , \":\");\n    brackets.replace(\"=\", \"=\");\n    brackets.replace(\"!\", \"\
    !\");\n    brackets.replace(\"?\", \"?\");\n    brackets.replace(\",\", \",\"\
    );\n    brackets.replace(\";\", \";\");\n    brackets.replace(\":\", \":\");\n\
    \    brackets.replace(\"=\", \"=\");\n    brackets.replace(\"!\", \"!\");\n  \
    \  brackets.replace(\"?\", \"?\");\n    brackets.replace(\",\", \",\");\n    brackets.replace(\"\
    ;\", \";\");\n    brackets.replace(\":\", \":\");\n    brackets.replace(\"=\"\
    , \"=\");\n    brackets.replace(\"!\", \"!\");\n    brackets.replace(\"?\", \"\
    ?\");\n    brackets.replace(\",\", \",\");\n    brackets.replace(\";\", \";\"\
    );\n    brackets.replace(\":\", \":\");\n    brackets.replace(\"=\", \"=\");\n\
    \    brackets.replace(\"!\", \"!\");\n    brackets.replace(\"?\", \"?\");\n  \
    \  brackets.replace(\",\", \",\");\n    brackets.replace(\";\", \";\");\n    brackets.replace(\"\
    :\", \":\");\n    brackets.replace(\"=\", \"=\");\n    brackets.replace(\"!\"\
    , \"!\");\n    brackets.replace(\"?\", \"?\");\n\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxvr_fr5i.rs:3:44\n  |\n3 |\
    \ fn correct_bracketing(brackets: String) -> bool {\n  |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for bracket in brackets.chars().filter(|c|\
    \ !c.is_whitespace()) {\n        if bracket.chars().any(|c| c == '(') {\n    \
    \        opening_brackets.push(bracket);\n        } else {\n            closing_brackets.push(bracket);\n\
    \        }\n    }\n    opening_brackets.len() == closing_brackets.len()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n --> /tmp/tmpz8ftub6e.rs:7:20\n  |\n7 |         if bracket.chars().any(|c|\
    \ c == '(') {\n  |                    ^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    for bracket in brackets {\n        if bracket == '(' {\n\
    \            open_brackets.push('(');\n        } else if bracket == ')' {\n  \
    \          closed_brackets.push(')');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.len() == closed_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpjq57dhcw.rs:6:20\n\
    \    |\n6   |     for bracket in brackets {\n    |                    ^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for bracket in brackets.chars().filter(|c|\
    \ *c != '(' && c != ')') {\n        if *bracket == '(' {\n            opening_brackets.push(*bracket);\n\
    \        } else {\n            closing_brackets.push(*bracket);\n        }\n \
    \   }\n    opening_brackets.len() == closing_brackets.len()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp9ao_q30h.rs:6:63\n\
    \  |\n6 |     for bracket in brackets.chars().filter(|c| *c != '(' && c != ')')\
    \ {\n  |                                                               ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmp9ao_q30h.rs:7:12\n\
    \  |\n7 |         if *bracket == '(' {\n  |            ^^^^^^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n --> /tmp/tmp9ao_q30h.rs:8:35\n  |\n8 |\
    \             opening_brackets.push(*bracket);\n  |                          \
    \         ^^^^^^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  -->\
    \ /tmp/tmp9ao_q30h.rs:10:35\n   |\n10 |             closing_brackets.push(*bracket);\n\
    \   |                                   ^^^^^^^^\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for bracket in brackets.chars() {\n \
    \       if bracket == '(' {\n            opening_brackets.push('(');\n       \
    \ } else if bracket == ')' {\n            closing_brackets.push(')');\n      \
    \  } else {\n            opening_brackets.push(bracket);\n        }\n    }\n \
    \   opening_brackets.len() == closing_brackets.len()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsbsrvl15.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    for bracket in brackets {\n        if bracket == '(' {\n\
    \            open_brackets.push(')');\n        } else if bracket == ')' {\n  \
    \          closed_brackets.push('(');\n        } else {\n            open_brackets.push(bracket);\n\
    \            closed_brackets.push(bracket);\n        }\n    }\n    open_brackets\
    \ == closed_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp2rkdisiq.rs:6:20\n\
    \    |\n6   |     for bracket in brackets {\n    |                    ^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening = String::new();\n    let mut closing\
    \ = String::new();\n    for c in brackets {\n        if c == '(' {\n         \
    \   opening.push_str(&c);\n        } else if c == ')' {\n            closing.push_str(&c);\n\
    \        } else {\n            closing.push_str(&c);\n            opening.push_str(&c);\n\
    \        }\n    }\n    opening.len() == closing.len()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpa9twk0j6.rs:6:14\n\
    \    |\n6   |     for c in brackets {\n    |              ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the\
    \ trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n --> /tmp/tmpa9twk0j6.rs:6:9\n  |\n6 |     for c\
    \ in brackets {\n  |         ^ doesn't have a size known at compile-time\n  |\n\
    \  = help: the trait `Sized` is not implemented for `str`\n  = note: all local\
    \ variables must have a statically known size\n  = help: unsized locals are gated\
    \ as an unstable feature\n\nerror[E0277]: can't compare `str` with `char`\n -->\
    \ /tmp/tmpa9twk0j6.rs:7:14\n  |\n7 |         if c == '(' {\n  |              ^^\
    \ no implementation for `str == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `str`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n --> /tmp/tmpa9twk0j6.rs:6:14\n  |\n6 |\
    \     for c in brackets {\n  |              ^^^^^^^^ doesn't have a size known\
    \ at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n\
    \  = note: all local variables must have a statically known size\n  = help: unsized\
    \ locals are gated as an unstable feature\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpa9twk0j6.rs:6:5\n\
    \    |\n6   | /     for c in brackets {\n7   | |         if c == '(' {\n8   |\
    \ |             opening.push_str(&c);\n9   | |         } else if c == ')' {\n\
    ...   |\n14  | |         }\n15  | |     }\n    | |_____^ doesn't have a size known\
    \ at compile-time\n    |\n    = help: the trait `Sized` is not implemented for\
    \ `str`\nnote: required by `None`\n\nerror[E0277]: can't compare `str` with `char`\n\
    \ --> /tmp/tmpa9twk0j6.rs:9:21\n  |\n9 |         } else if c == ')' {\n  |   \
    \                  ^^ no implementation for `str == char`\n  |\n  = "
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\",\", \",\");\n\
    \    brackets.replace(\";\", \";\");\n    brackets.replace(\":\", \":\");\n  \
    \  brackets.replace(\"?\", \"?\");\n    brackets.replace(\"!\", \"!\");\n    brackets.replace(\"\
    ,\", \",\");\n    brackets.replace(\";\", \";\");\n    brackets.replace(\":\"\
    , \":\");\n    brackets.replace(\"?\", \"?\");\n    brackets.replace(\"!\", \"\
    !\");\n    brackets.replace(\",\", \",\");\n    brackets.replace(\";\", \";\"\
    );\n    brackets.replace(\":\", \":\");\n    brackets.replace(\"?\", \"?\");\n\
    \    brackets.replace(\"!\", \"!\");\n    brackets.replace(\",\", \",\");\n  \
    \  brackets.replace(\";\", \";\");\n    brackets.replace(\":\", \":\");\n    brackets.replace(\"\
    ?\", \"?\");\n    brackets.replace(\"!\", \"!\");\n    brackets.replace(\",\"\
    , \",\");\n    brackets.replace(\";\", \";\");\n    brackets.replace(\":\", \"\
    :\");\n    brackets.replace(\"?\", \"?\");\n    brackets.replace(\"!\", \"!\"\
    );\n    brackets.replace(\",\", \",\");\n    brackets.replace(\";\", \";\");\n\
    \    brackets.replace(\":\", \":\");\n    brackets.replace(\"?\", \"?\");\n  \
    \  brackets.replace(\"!\", \"!\");\n    brackets.replace(\",\", \",\");\n    brackets.replace(\"\
    ;\", \";\");\n    brackets.replace(\":\", \":\");\n    brackets.replace(\"?\"\
    , \"?\");\n    brackets.replace(\"!\", \"!\");\n    brackets.replace(\",\", \"\
    ,\");\n    brackets.replace(\";\", \";\");\n    brackets.replace(\":\", \":\"\
    );\n    brackets.replace(\"?\", \"?\");\n    brackets.replace(\"!\", \"!\");\n\
    \    brackets.replace(\",\", \",\");\n    brackets.replace(\";\", \";\");\n  \
    \  brackets.replace(\":\", \":\");\n    brackets.replace(\"?\", \"?\");\n    brackets.replace(\"\
    !\", \"!\");\n    brackets.replace(\",\", \",\");\n    brackets.replace(\";\"\
    , \";\");\n    brackets.replace(\":\", \":\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9g_h4m2f.rs:76:56\n\
    \   |\n76 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n77 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    for bracket in brackets.chars().filter(|c| c != '('\
    \ && c != ')') {\n        if open_brackets.is_empty() {\n            open_brackets.push(bracket);\n\
    \        } else {\n            close_brackets.push(bracket);\n        }\n    }\n\
    \n    open_brackets.len() == close_brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpb0qrt3r8.rs:7:50\n\
    \  |\n7 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n  |                                                  ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpb0qrt3r8.rs:7:62\n\
    \  |\n7 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n  |                                                              ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    let mut open_brackets_iter = brackets.char_indices();\n\
    \    let mut close_brackets_iter = brackets.char_indices();\n    let mut open_brackets_next\
    \ = open_brackets_iter.next();\n    let mut close_brackets_next = close_brackets_iter.next();\n\
    \    while let Some(open_bracket) = open_brackets_next {\n        open_brackets\
    \ += open_bracket;\n        open_brackets_next = open_brackets_iter.next();\n\
    \        while let Some(close_bracket) = close_brackets_next {\n            close_brackets\
    \ += close_bracket;\n            close_brackets_next = close_brackets_iter.next();\n\
    \            if open_brackets.chars().all(|c| c == close_bracket) {\n        \
    \        open_brackets.truncate(open_brackets.len() - 1);\n                close_brackets.truncate(close_brackets.len()\
    \ - 1);\n                return false;\n            }\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppv80ay2_.rs:11:26\n   |\n\
    11 |         open_brackets += open_bracket;\n   |                          ^^^^^^^^^^^^\
    \ expected `&str`, found tuple\n   |\n   = note: expected reference `&str`\n \
    \                 found tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppv80ay2_.rs:14:31\n   |\n14 |             close_brackets += close_bracket;\n\
    \   |                               ^^^^^^^^^^^^^ expected `&str`, found tuple\n\
    \   |\n   = note: expected reference `&str`\n                  found tuple `(usize,\
    \ char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppv80ay2_.rs:16:51\n\
    \   |\n16 |             if open_brackets.chars().all(|c| c == close_bracket) {\n\
    \   |                                                   ^^^^^^^^^^^^^ expected\
    \ `char`, found tuple\n   |\n   = note: expected type `char`\n             found\
    \ tuple `(usize, char)`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    for bracket in brackets {\n        if\
    \ bracket == '(' {\n            opening_brackets.push('(');\n        } else if\
    \ bracket == ')' {\n            closing_brackets.push(')');\n        } else {\n\
    \            opening_brackets.push(bracket);\n            closing_brackets.push(bracket);\n\
    \        }\n    }\n    opening_brackets.len() == closing_brackets.len()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpk38ysj11.rs:6:20\n\
    \    |\n6   |     for bracket in brackets {\n    |                    ^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747903
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            stack.push(bracket);\n        }\
    \ else if bracket == ')' {\n            if stack.len() == 0 {\n              \
    \  return false;\n            }\n            stack.pop();\n        } else {\n\
    \            return false;\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747903
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    while brackets.len()\
    \ > 0 {\n        let mut opening = brackets.chars().nth(1).unwrap();\n       \
    \ let mut closing = brackets.chars().nth(1).unwrap();\n        if opening != closing\
    \ {\n            return false;\n        }\n        brackets = brackets.to_string().replace(opening,\
    \ \"\");\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpapmhj2ek.rs:6:51

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747903
