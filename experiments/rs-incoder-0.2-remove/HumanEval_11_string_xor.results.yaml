language: rs
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push_str(&a[i..].iter().map(|c| match c {\n\
    \            0 => \"0\",\n            1 => \"1\",\n            _ => unreachable!(),\n\
    \        }).collect::<String>());\n    }\n    for i in 0..b.len() {\n        result.push_str(&b[i..].iter().map(|c|\
    \ match c {\n            0 => \"0\",\n            1 => \"1\",\n            _ =>\
    \ unreachable!(),\n        }).collect::<String>());\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmppyyjgby6.rs:6:33\n  |\n6 |         result.push_str(&a[i..].iter().map(|c|\
    \ match c {\n  |                                 ^^^^ method not found in `str`\n\
    \nerror[E0599]: no method named `iter` found for type `str` in the current scope\n\
    \  --> /tmp/tmppyyjgby6.rs:13:33\n   |\n13 |         result.push_str(&b[i..].iter().map(|c|\
    \ match c {\n   |                                 ^^^^ method not found in `str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:12\n\
    \  |\n6 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:20\n\
    \  |\n6 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars() {\n        result.push((c ^ b.chars().nth(0)).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpb8v6r7c9.rs:5:9\n  |\n5 |\
    \     for &c in a.chars() {\n  |         ^^    --------- this expression has type\
    \ `char`\n  |         |\n  |         expected `char`, found reference\n  |\n \
    \ = note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_f14r7ww.rs:6:29\n  |\n6 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u8`\n\nerror[E0277]:\
    \ no implementation for `usize ^ u8`\n --> /tmp/tmp_f14r7ww.rs:6:27\n  |\n6 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \            ^ no implementation for `usize ^ u8`\n  |\n  = help: the trait `BitXor<u8>`\
    \ is not implemented for `usize`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmp_f14r7ww.rs:6:23\n  |\n6 |         res.push_str(&a[i\
    \ ^ b.as_bytes()[i as usize]]);\n  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x| x == b[i]).collect::<String>());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmpph170nrx.rs:6:30\n  |\n6 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \ --> /tmp/tmpph170nrx.rs:6:54\n  |\n6 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                      \
    \                ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:23\n\
    \  |\n6 |         res.push_str(&a[i] ^ b[i]);\n  |                       ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:30\n  |\n6 |         res.push_str(&a[i]\
    \ ^ b[i]);\n  |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a\
    \ ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmptqwc3wee.rs:4:45\n\
    \  |\n4 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
