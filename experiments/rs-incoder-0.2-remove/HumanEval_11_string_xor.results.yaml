language: rs
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push_str(&a[i..].iter().map(|c| match c {\n\
    \            0 => \"0\",\n            1 => \"1\",\n            _ => unreachable!(),\n\
    \        }).collect::<String>());\n    }\n    for i in 0..b.len() {\n        result.push_str(&b[i..].iter().map(|c|\
    \ match c {\n            0 => \"0\",\n            1 => \"1\",\n            _ =>\
    \ unreachable!(),\n        }).collect::<String>());\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmppyyjgby6.rs:6:33\n  |\n6 |         result.push_str(&a[i..].iter().map(|c|\
    \ match c {\n  |                                 ^^^^ method not found in `str`\n\
    \nerror[E0599]: no method named `iter` found for type `str` in the current scope\n\
    \  --> /tmp/tmppyyjgby6.rs:13:33\n   |\n13 |         result.push_str(&b[i..].iter().map(|c|\
    \ match c {\n   |                                 ^^^^ method not found in `str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:12\n\
    \  |\n6 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:20\n\
    \  |\n6 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars() {\n        result.push((c ^ b.chars().nth(0)).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpb8v6r7c9.rs:5:9\n  |\n5 |\
    \     for &c in a.chars() {\n  |         ^^    --------- this expression has type\
    \ `char`\n  |         |\n  |         expected `char`, found reference\n  |\n \
    \ = note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_f14r7ww.rs:6:29\n  |\n6 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u8`\n\nerror[E0277]:\
    \ no implementation for `usize ^ u8`\n --> /tmp/tmp_f14r7ww.rs:6:27\n  |\n6 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i as usize]]);\n  |               \
    \            ^ no implementation for `usize ^ u8`\n  |\n  = help: the trait `BitXor<u8>`\
    \ is not implemented for `usize`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmp_f14r7ww.rs:6:23\n  |\n6 |         res.push_str(&a[i\
    \ ^ b.as_bytes()[i as usize]]);\n  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&x| x == b[i]).collect::<String>());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmpph170nrx.rs:6:30\n  |\n6 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \ --> /tmp/tmpph170nrx.rs:6:54\n  |\n6 |         res.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                      \
    \                ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:23\n\
    \  |\n6 |         res.push_str(&a[i] ^ b[i]);\n  |                       ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:30\n  |\n6 |         res.push_str(&a[i]\
    \ ^ b[i]);\n  |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a\
    \ ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmptqwc3wee.rs:4:45\n\
    \  |\n4 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i..].iter().filter(|&c| c == '1').collect::<String>());\n\
    \        res.push_str(&b[i..].iter().filter(|&c| c == '1').collect::<String>());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmps962q1b8.rs:6:30\n  |\n6 |         res.push_str(&a[i..].iter().filter(|&c|\
    \ c == '1').collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0599]: no method named `iter` found for type `str`\
    \ in the current scope\n --> /tmp/tmps962q1b8.rs:7:30\n  |\n7 |         res.push_str(&b[i..].iter().filter(|&c|\
    \ c == '1').collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in &a { res.push(c); }\n    for &c in &b { res.push(c); }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmp8tq_c4bz.rs:5:15\n\
    \  |\n5 |     for &c in &a { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmp8tq_c4bz.rs:6:15\n\
    \  |\n6 |     for &c in &b { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i ^ b.len()]);\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpeielpdmf.rs:6:23\n\
    \  |\n6 |         res.push_str(&a[i ^ b.len()]);\n  |                       ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn05btidu.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in a.chars().zip(b.chars()) {\n        res.push_str(c.0);\n        res.push_str(c.1);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoyfz_ls5.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a.chars()\n            .skip(i)\n   \
    \         .take(b.len())\n            .filter(|c| c.to_digit(16).is_some())\n\
    \            .collect::<Vec<_>>()\n            .join(\"\"));\n    }\n    for i\
    \ in 0..b.len() {\n        res.push_str(&b.chars()\n            .skip(i)\n   \
    \         .take(a.len())\n            .filter(|c| c.to_digit(16).is_some())\n\
    \            .collect::<Vec<_>>()\n            .join(\"\"));\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `join` exists for struct `Vec<char>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpn6rm7cig.rs:11:14\n   |\n11 |\
    \             .join(\"\"));\n   |              ^^^^ method cannot be called on\
    \ `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `[char]: Join<_>`\n\nerror[E0599]:\
    \ the method `join` exists for struct `Vec<char>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpn6rm7cig.rs:19:14\n   |\n19 |             .join(\"\"\
    ));\n   |              ^^^^ method cannot be called on `Vec<char>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `[char]: Join<_>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    String::from_utf8(a.chars().zip(b.chars()).filter(|(a,\
    \ b)| a != b).map(|(a, b)| a ^ b).collect())\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp3ji085ji.rs:4:87\n\
    \  |\n4 |     String::from_utf8(a.chars().zip(b.chars()).filter(|(a, b)| a !=\
    \ b).map(|(a, b)| a ^ b).collect())\n  |                                     \
    \                                                - ^ - char\n  |             \
    \                                                                        |\n \
    \ |                                                                          \
    \           char\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3ji085ji.rs:4:5\n\
    \  |\n3 | fn string_xor(a: String, b: String) -> String {\n  |               \
    \                         ------ expected `String` because of return type\n4 |\
    \     String::from_utf8(a.chars().zip(b.chars()).filter(|(a, b)| a != b).map(|(a,\
    \ b)| a ^ b).collect())\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Result`\n  |\n  = note: expected struct\
    \ `String`\n               found enum `Result<String, FromUtf8Error>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn05btidu.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).0 ^ (*c).1);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfh595gno.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a\
    \ ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmptqwc3wee.rs:4:45\n\
    \  |\n4 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in &a { res += &c ^ &b[c.to_digit(10).unwrap()]; }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpuh7rsaiv.rs:5:15\n\
    \  |\n5 |     for &c in &a { res += &c ^ &b[c.to_digit(10).unwrap()]; }\n  | \
    \              ^^ `&String` is not an iterator\n  |\n  = help: the trait `Iterator`\
    \ is not implemented for `&String`\n  = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn05btidu.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().cloned() {\n        result.push((c ^ b.chars().next().unwrap()).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmphv7lkjn1.rs:5:25\n     |\n5    |     for &c in a.chars().cloned()\
    \ {\n     |                         ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmphv7lkjn1.rs:5:15\n\
    \  |\n5 |     for &c in a.chars().cloned() {\n  |               ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmphv7lkjn1.rs:5:15\n  |\n5 |     for &c in a.chars().cloned() {\n\
    \  |               ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n\
    \  = note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().cloned() {\n        result.push((c ^ b[a.chars().index(c)]).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpk0cjxcsn.rs:5:25\n     |\n5    |     for &c in a.chars().cloned()\
    \ {\n     |                         ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmpk0cjxcsn.rs:5:15\n\
    \  |\n5 |     for &c in a.chars().cloned() {\n  |               ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmpk0cjxcsn.rs:5:15\n  |\n5 |     for &c in a.chars().cloned() {\n\
    \  |               ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n\
    \  = note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0599]: no method named `index` found for struct `Chars` in the current\
    \ scope\n --> /tmp/tmpk0cjxcsn.rs:6:38\n  |\n6 |         result.push((c ^ b[a.chars().index(c)]).to_string());\n\
    \  |                                      ^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i..].chars().filter(|c| b[i] == c).collect::<String>());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp48qqho8e.rs:6:49\n\
    \  |\n6 |         res.push_str(&a[i..].chars().filter(|c| b[i] == c).collect::<String>());\n\
    \  |                                                 ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().cloned() {\n        result.push((c ^ b.chars().nth(c.len() -\
    \ 1)).to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpgh08t_63.rs:5:25\n     |\n5    |     for &c in a.chars().cloned()\
    \ {\n     |                         ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmpgh08t_63.rs:5:15\n\
    \  |\n5 |     for &c in a.chars().cloned() {\n  |               ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmpgh08t_63.rs:5:15\n  |\n5 |     for &c in a.chars().cloned() {\n\
    \  |               ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n\
    \  = note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a\
    \ ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmptqwc3wee.rs:4:45\n\
    \  |\n4 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n --> /tmp/tmpvdp53gty.rs:6:23\n\
    \  |\n6 |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n \
    \ |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ no implementation for `usize ^ char`\n --> /tmp/tmpvdp53gty.rs:6:35\n  |\n6\
    \ |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n  |    \
    \                               ^ no implementation for `usize ^ char`\n  |\n\
    \  = help: the trait `BitXor<char>` is not implemented for `usize`\n  = help:\
    \ the following other types implement trait `BitXor<Rhs>`:\n            <&'a i128\
    \ as BitXor<i128>>\n            <&'a i16 as BitXor<i16>>\n            <&'a i32\
    \ as BitXor<i32>>\n            <&'a i64 as BitXor<i64>>\n            <&'a i8 as\
    \ BitXor<i8>>\n            <&'a isize as BitXor<isize>>\n            <&'a u128\
    \ as BitXor<u128>>\n            <&'a u16 as BitXor<u16>>\n          and 40 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeir0_v0d.rs:4:18\n\
    \  |\n4 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push_str(&a[i] ^ b[i]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp6jegxmus.rs:6:26\n\
    \  |\n6 |         result.push_str(&a[i] ^ b[i]);\n  |                        \
    \  ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp6jegxmus.rs:6:33\n\
    \  |\n6 |         result.push_str(&a[i] ^ b[i]);\n  |                        \
    \         ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n  = help: the following other\
    \ types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:12\n\
    \  |\n6 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:20\n\
    \  |\n6 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars() {\n        result.push((c ^ b[c.to_digit()]).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp499je7u7.rs:5:9\n  |\n5 |\
    \     for &c in a.chars() {\n  |         ^^    --------- this expression has type\
    \ `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `c`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:23\n\
    \  |\n6 |         res.push_str(&a[i] ^ b[i]);\n  |                       ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:30\n  |\n6 |         res.push_str(&a[i]\
    \ ^ b[i]);\n  |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result .push_char(a ^ b);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_char` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpue_7oeb6.rs:6:17\n  |\n6 |         result .push_char(a\
    \ ^ b);\n  |                 ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `push_str`\n\nerror[E0369]: no implementation for `char ^ char`\n\
    \ --> /tmp/tmpue_7oeb6.rs:6:29\n  |\n6 |         result .push_char(a ^ b);\n \
    \ |                           - ^ - char\n  |                           |\n  |\
    \                           char\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in &a { res.push(c); }\n    for &c in &b { res.push(c); }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmp8tq_c4bz.rs:5:15\n\
    \  |\n5 |     for &c in &a { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmp8tq_c4bz.rs:6:15\n\
    \  |\n6 |     for &c in &b { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).0 ^ (*c).1);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfh595gno.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().cloned() {\n        result.push(c);\n    }\n    for &c in b.chars().cloned()\
    \ {\n        result.push(c);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp3cu29k34.rs:5:25\n     |\n5    |     for &c in a.chars().cloned()\
    \ {\n     |                         ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmp3cu29k34.rs:5:15\n\
    \  |\n5 |     for &c in a.chars().cloned() {\n  |               ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmp3cu29k34.rs:5:15\n  |\n5 |     for &c in a.chars().cloned() {\n\
    \  |               ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n\
    \  = note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmp3cu29k34.rs:8:25\n     |\n8    |     for &c in b.chars().cloned()\
    \ {\n     |                         ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmp3cu29k34.rs:8:15\n\
    \  |\n8 |     for &c in b.chars().cloned() {\n  |               ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Ch"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i..].iter().map(|c| match c {\n   \
    \         0 => \"0\",\n            1 => \"1\",\n            _ => unreachable!(),\n\
    \        }).collect::<String>());\n        res.push_str(&b[i..].iter().map(|c|\
    \ match c {\n            0 => \"0\",\n            1 => \"1\",\n            _ =>\
    \ unreachable!(),\n        }).collect::<String>());\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmplt72y2ca.rs:6:30\n  |\n6 |         res.push_str(&a[i..].iter().map(|c|\
    \ match c {\n  |                              ^^^^ method not found in `str`\n\
    \nerror[E0599]: no method named `iter` found for type `str` in the current scope\n\
    \  --> /tmp/tmplt72y2ca.rs:11:30\n   |\n11 |         res.push_str(&b[i..].iter().map(|c|\
    \ match c {\n   |                              ^^^^ method not found in `str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push_str(&a.chars()[i].xor(&b.chars()[i]).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n --> /tmp/tmph52nkytg.rs:6:26\n\
    \  |\n6 |         result.push_str(&a.chars()[i].xor(&b.chars()[i]).to_string());\n\
    \  |                          ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `Chars<'_>`\n --> /tmp/tmph52nkytg.rs:6:44\n  |\n6 |       \
    \  result.push_str(&a.chars()[i].xor(&b.chars()[i]).to_string());\n  |       \
    \                                     ^^^^^^^^^^^^\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn05btidu.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push_str(&a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&char ^ char`\n --> /tmp/tmpxa6xae4j.rs:6:52\n\
    \  |\n6 |         result.push_str(&a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap());\n\
    \  |                         -------------------------- ^ -------------------------\
    \ char\n  |                         |\n  |                         &char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_owned()\n        .to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpjb3huhch.rs:4:69\n\
    \  |\n4 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in a.chars().cloned() {\n        res.push_str(&format!(\"{:02x}\", c ^ b.chars().nth(c.to_digit(16).unwrap()).unwrap()));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpcm7e4nkk.rs:5:25\n     |\n5    |     for &c in a.chars().cloned()\
    \ {\n     |                         ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmpcm7e4nkk.rs:5:15\n\
    \  |\n5 |     for &c in a.chars().cloned() {\n  |               ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmpcm7e4nkk.rs:5:15\n  |\n5 |     for &c in a.chars().cloned() {\n\
    \  |               ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n\
    \  = note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn05btidu.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgzr1xd81.rs:4:23\n  |\n4 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpgzr1xd81.rs:4:37\n  |\n4 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in a.chars() {\n        res.push_str(&c.to_string() ^ b.chars().next().unwrap().to_string());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcedmbmar.rs:5:9\n  |\n5 |\
    \     for &c in a.chars() {\n  |         ^^    --------- this expression has type\
    \ `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `c`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result .push_str(&format!(\"{:02x}\"\
    , c ^ c));\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp83hndw2j.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a\
    \ ^ b).collect()\n        .iter()\n        .map(|x| format!(\"{:02b}\", x))\n\
    \        .collect::<Vec<_>>()\n        .to_string()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpqnjyabf_.rs:4:45\n\
    \  |\n4 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i ^ b.as_bytes()[i]]);\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvcdhiilc.rs:6:29\n  |\n6 |\
    \         res.push_str(&a[i ^ b.as_bytes()[i]]);\n  |                        \
    \     ^^^^^^^^^^^^^^^ expected `usize`, found `u8`\n\nerror[E0277]: no implementation\
    \ for `usize ^ u8`\n --> /tmp/tmpvcdhiilc.rs:6:27\n  |\n6 |         res.push_str(&a[i\
    \ ^ b.as_bytes()[i]]);\n  |                           ^ no implementation for\
    \ `usize ^ u8`\n  |\n  = help: the trait `BitXor<u8>` is not implemented for `usize`\n\
    \  = help: the following other types implement trait `BitXor<Rhs>`:\n        \
    \    <&'a i128 as BitXor<i128>>\n            <&'a i16 as BitXor<i16>>\n      \
    \      <&'a i32 as BitXor<i32>>\n            <&'a i64 as BitXor<i64>>\n      \
    \      <&'a i8 as BitXor<i8>>\n            <&'a isize as BitXor<isize>>\n    \
    \        <&'a u128 as BitXor<u128>>\n            <&'a u16 as BitXor<u16>>\n  \
    \        and 40 others\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n --> /tmp/tmpvcdhiilc.rs:6:23\n  |\n6 |         res.push_str(&a[i ^\
    \ b.as_bytes()[i]]);\n  |                       ^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:12\n\
    \  |\n6 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:20\n\
    \  |\n6 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n --> /tmp/tmpvdp53gty.rs:6:23\n\
    \  |\n6 |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n \
    \ |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ no implementation for `usize ^ char`\n --> /tmp/tmpvdp53gty.rs:6:35\n  |\n6\
    \ |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n  |    \
    \                               ^ no implementation for `usize ^ char`\n  |\n\
    \  = help: the trait `BitXor<char>` is not implemented for `usize`\n  = help:\
    \ the following other types implement trait `BitXor<Rhs>`:\n            <&'a i128\
    \ as BitXor<i128>>\n            <&'a i16 as BitXor<i16>>\n            <&'a i32\
    \ as BitXor<i32>>\n            <&'a i64 as BitXor<i64>>\n            <&'a i8 as\
    \ BitXor<i8>>\n            <&'a isize as BitXor<isize>>\n            <&'a u128\
    \ as BitXor<u128>>\n            <&'a u16 as BitXor<u16>>\n          and 40 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in a.chars().zip(b.chars()) {\n        if *c != *c {\n            res.push_str(&format!(\"\
    {}\", *c));\n        } else {\n            res.push_str(&format!(\"{}\", *c));\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp97n42ox6.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_owned()\n        .to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpjb3huhch.rs:4:69\n\
    \  |\n4 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in a.chars().zip(b.chars()) {\n        res.push_str(&format!(\"{:02x}\", c ^\
    \ c));\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdwapxrz8.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:23\n\
    \  |\n6 |         res.push_str(&a[i] ^ b[i]);\n  |                       ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:30\n  |\n6 |         res.push_str(&a[i]\
    \ ^ b[i]);\n  |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push_str(&a[i..].iter().filter(|&x| x == b[i]).collect::<String>());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmp90k8o0e7.rs:6:33\n  |\n6 |         result.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                 ^^^^ method\
    \ not found in `str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \ --> /tmp/tmp90k8o0e7.rs:6:57\n  |\n6 |         result.push_str(&a[i..].iter().filter(|&x|\
    \ x == b[i]).collect::<String>());\n  |                                      \
    \                   ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeir0_v0d.rs:4:18\n\
    \  |\n4 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:23\n\
    \  |\n6 |         res.push_str(&a[i] ^ b[i]);\n  |                       ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:30\n  |\n6 |         res.push_str(&a[i]\
    \ ^ b[i]);\n  |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:12\n\
    \  |\n6 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:20\n\
    \  |\n6 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpp10rjl8u.rs:4:69\n\
    \  |\n4 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a\
    \ ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmptqwc3wee.rs:4:45\n\
    \  |\n4 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn05btidu.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgzr1xd81.rs:4:23\n  |\n4 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpgzr1xd81.rs:4:37\n  |\n4 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in &a { res.push(c); }\n    for &c in &b { res.push(c); }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmp8tq_c4bz.rs:5:15\n\
    \  |\n5 |     for &c in &a { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmp8tq_c4bz.rs:6:15\n\
    \  |\n6 |     for &c in &b { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn05btidu.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result .push((a ^ b) as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp8_80y251.rs:6:25\n\
    \  |\n6 |         result .push((a ^ b) as char);\n  |                       -\
    \ ^ - char\n  |                       |\n  |                       char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgzr1xd81.rs:4:23\n  |\n4 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpgzr1xd81.rs:4:37\n  |\n4 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:12\n\
    \  |\n6 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp25blsaph.rs:6:20\n\
    \  |\n6 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a\
    \ ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmptqwc3wee.rs:4:45\n\
    \  |\n4 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in a.chars().cloned() {\n        res.push_str(&format!(\"{:02x}\", c ^ b.chars().nth(c.to_digit(16).unwrap()).unwrap()));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpcm7e4nkk.rs:5:25\n     |\n5    |     for &c in a.chars().cloned()\
    \ {\n     |                         ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmpcm7e4nkk.rs:5:15\n\
    \  |\n5 |     for &c in a.chars().cloned() {\n  |               ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmpcm7e4nkk.rs:5:15\n  |\n5 |     for &c in a.chars().cloned() {\n\
    \  |               ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n\
    \  = note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in a.chars().zip(b.chars()).filter(|&(c1, _)| c1 != 0) {\n        res.push_str(&format!(\"\
    {:02x}\", c));\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnuuib8af.rs:5:64\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()).filter(|&(c1, _)| c1 != 0) {\n  |   \
    \                                                             ^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnuuib8af.rs:5:9\n\
    \  |\n5 |     for &c in a.chars().zip(b.chars()).filter(|&(c1, _)| c1 != 0) {\n\
    \  |         ^^    --------------------------------------------------- this expression\
    \ has type `Option<(char, char)>`\n  |         |\n  |         expected tuple,\
    \ found reference\n  |         help: you can probably remove the explicit borrow:\
    \ `c`\n  |\n  = note:  expected tuple `(char, char)`\n          found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        if a != b {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0a00a0\"`,\n right: `\"010010\"`', /tmp/tmplythu2iw.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).xor(*c).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn05btidu.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().chain(b.chars()) {\n        match c {\n            '1' => result.push(c),\n\
    \            '0' => result.push(c),\n            _ => result.push(c),\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n \
    \   assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7vqvngwz.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().chain(b.chars()) {\n  |         ^^    --------------------------\
    \ this expression has type `Option<char>`\n  |         |\n  |         expected\
    \ `char`, found reference\n  |         help: you can probably remove the explicit\
    \ borrow: `c`\n  |\n  = note:   expected type `char`\n          found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for &c\
    \ in a.chars() {\n        res.push_str(&format!(\"{:?}\", c ^ b.chars().nth(c.to_digit(10).unwrap())));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjv7ycj4b.rs:5:9\n  |\n5 |\
    \     for &c in a.chars() {\n  |         ^^    --------- this expression has type\
    \ `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `c`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() + b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc0f4h9tu.rs:4:20\n  |\n4 |\
    \     a.to_owned() + b.to_owned()\n  |                    ^^^^^^^^^^^^\n  |  \
    \                  |\n  |                    expected `&str`, found struct `String`\n\
    \  |                    help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgzr1xd81.rs:4:23\n  |\n4 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpgzr1xd81.rs:4:37\n  |\n4 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        if *c != *c {\n            result.push(*c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfskmhjnx.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a\
    \ ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmptqwc3wee.rs:4:45\n\
    \  |\n4 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_owned()\n        .to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpjb3huhch.rs:4:69\n\
    \  |\n4 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpu_4id7yq.rs:4:69\n\
    \  |\n4 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().cloned() {\n        result.push((c ^ b.chars().nth(c.as_bytes().unwrap())).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp5m5pepji.rs:5:25\n     |\n5    |     for &c in a.chars().cloned()\
    \ {\n     |                         ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmp5m5pepji.rs:5:15\n\
    \  |\n5 |     for &c in a.chars().cloned() {\n  |               ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |\n  = note:   expected type `char`\n  \
    \        found reference `&_`\n  = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \ --> /tmp/tmp5m5pepji.rs:5:15\n  |\n5 |     for &c in a.chars().cloned() {\n\
    \  |               ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n  |\n\
    \  = note:   expected type `char`\n          found reference `&_`\n  = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((c as u8) ^ c.to_digit(10));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4jd6f3sp.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4jd6f3sp.rs:6:21\n\
    \  |\n6 |         result.push((c as u8) ^ c.to_digit(10));\n  |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `u8`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a[i] ^ b[i]);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:23\n\
    \  |\n6 |         res.push_str(&a[i] ^ b[i]);\n  |                       ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmpma7ljonp.rs:6:30\n  |\n6 |         res.push_str(&a[i]\
    \ ^ b[i]);\n  |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push_str(&a[i] ^ b[i]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp6jegxmus.rs:6:26\n\
    \  |\n6 |         result.push_str(&a[i] ^ b[i]);\n  |                        \
    \  ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp6jegxmus.rs:6:33\n\
    \  |\n6 |         result.push_str(&a[i] ^ b[i]);\n  |                        \
    \         ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n  = help: the following other\
    \ types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp70gutzhi.rs:6:21\n\
    \  |\n6 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n --> /tmp/tmp70gutzhi.rs:6:28\n  |\n6 |         result.push(a[i]\
    \ ^ b[i]);\n  |                            ^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeir0_v0d.rs:4:18\n\
    \  |\n4 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        res.push_str(&a.chars()[i].xor(&b.chars()[i]).to_string());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n --> /tmp/tmptpvjchyo.rs:6:23\n\
    \  |\n6 |         res.push_str(&a.chars()[i].xor(&b.chars()[i]).to_string());\n\
    \  |                       ^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `Chars<'_>`\n --> /tmp/tmptpvjchyo.rs:6:41\n  |\n6 |         res.push_str(&a.chars()[i].xor(&b.chars()[i]).to_string());\n\
    \  |                                         ^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a\
    \ ^ b).collect()\n        .to_owned()\n        .to_string() + b.chars().to_owned()\n\
    \        .to_string() + a.chars().to_owned()\n        .to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpjxzipilb.rs:4:45\n\
    \  |\n4 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error[E0599]: the method `to_string` exists for struct `Chars<'_>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpjxzipilb.rs:7:10\n   |\n7  |      \
    \     .to_string() + a.chars().to_owned()\n   |            ^^^^^^^^^ method cannot\
    \ be called on `Chars<'_>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `Chars<'_>: std::fmt::Display`\n\
    \           which is required by `Chars<'_>: ToString`\n\nerror[E0599]: the method\
    \ `to_string` exists for struct `Chars<'_>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpjxzipilb.rs:8:10\n   |\n8  |           .to_string()\n   |     \
    \       ^^^^^^^^^ method cannot be called on `Chars<'_>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `Chars<'_>: std::fmt::Display`\n           which is required by `Chars<'_>:\
    \ ToString`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009032
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:5:15\n\
    \    |\n5   |     for &c in &a { result.push(c); }\n    |               ^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ `&String` is not an iterator\n   --> /tmp/tmpei9d8fju.rs:6:15\n    |\n6   |\
    \     for &c in &b { result.push(c); }\n    |               ^^ `&String` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\nnote: required by `into_iter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659746998
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ &c in a.chars().zip(b.chars()) {\n        result.push((*c).0 ^ (*c).1);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfh595gno.rs:5:9\n  |\n5 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009032
