name: HumanEval_145_order_by_points
language: rs
prompt: "/// Write a function which sorts the given list of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ list.\n/// For example:\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
  \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
  \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
  \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
  \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
  \ 23, 6, 6]);\n}\n"
completions: ["    let mut result = vec![];\n    let mut sum = 0;\n    for &i in nums\
    \ {\n        sum += i;\n        result.push(i);\n    }\n    result.sort_by_key(|&i|\
    \ {\n        sum - i\n    });\n    result", "    let mut nums_copy = nums.clone();\n\
    \    nums_copy.sort_by_key(|x| {\n        let mut sum = 0;\n        for &n in\
    \ &nums_copy {\n            sum += n % 10;\n        }\n        sum\n    });\n\
    \    nums_copy", "    nums.sort_by_key(|x| x.to_digits().iter().sum());\n    nums",
  "    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n  \
    \      let mut sum = 0;\n        for x in nums_sorted {\n            sum += x;\n\
    \        }\n        sum\n    });\n    nums_sorted", "    let mut nums_copy = nums.clone();\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        nums_sorted.swap(index, nums_sorted.iter().position(|&x| x + sum).unwrap());\n\
    \        index += 1;\n    }\n    nums_sorted", "    let mut nums_copy = nums.clone();\n\
    \    let mut sum = 0;\n    for i in nums_copy {\n        sum += i;\n    }\n  \
    \  nums_copy.sort_by_key(|x| {\n        sum - x;\n    });\n    nums_copy", " \
    \   let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n     \
    \   let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n  \
    \      }\n        sum\n    });\n    nums_copy", "    let mut nums_sorted = nums.clone();\n\
    \    nums_sorted.sort_by(|a, b| {\n        let mut a_digits = a.to_digits();\n\
    \        let mut b_digits = b.to_digits();\n        a_digits.iter().zip(b_digits.iter()).map(|(a,\
    \ b)| a + b).sum().unwrap()\n    });\n    nums_sorted", "    let mut nums_copy\
    \ = nums.clone();\n    nums_copy.sort_by_key(|x| {\n        let mut sum = 0;\n\
    \        for x in nums_copy {\n            sum += x;\n        }\n        sum\n\
    \    });\n    nums_copy", "    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for &n in &nums_sorted {\n            sum\
    \ += n % 10;\n        }\n        sum\n    });\n    nums_sorted", "    let mut\
    \ nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n        let\
    \ mut sum = 0;\n        for &n in &nums_sorted {\n            sum += n % 10;\n\
    \            n /= 10;\n        }\n        sum\n    });\n    nums_sorted", "  \
    \  let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n      \
    \  let mut sum = 0;\n        for x in nums_copy {\n            sum += *x;\n  \
    \      }\n        sum\n    });\n    nums_copy", "    nums.sort_by_key(|x| x.to_digits().sum());\n\
    \    nums", "    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n \
    \   for n in nums_sorted {\n        sum += n;\n    }\n    let mut nums_sorted_by_sum:\
    \ Vec<isize> = nums_sorted.clone();\n    let mut i = 0;\n    while i < nums_sorted_by_sum.len()\
    \ {\n        let mut j = i;\n        while j < nums_sorted_by_sum.len() && nums_sorted_by_sum[j]\
    \ == sum {\n            j += 1\n        }\n        if j > i {\n            nums_sorted_by_sum.swap(i,\
    \ j);\n            i += 1;\n        }\n    }\n    nums_sorted_by_sum", "    let\
    \ mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n        let\
    \ mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n        }\n\
    \        sum\n    });\n    nums_copy", "    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    for &i in nums_sorted {\n        sum += i;\n    }\n\
    \    nums_sorted.sort_by_key(|&i| {\n        sum - i;\n    });\n    nums_sorted",
  "    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x| {\n  \
    \      let mut sum = 0;\n        for &i in &nums {\n            sum += i;\n  \
    \      }\n        sum\n    });\n    sorted_nums", "    let mut sorted_nums = nums.clone();\n\
    \    sorted_nums.sort_by_key(|x| {\n        let mut sum = 0;\n        for &n in\
    \ &nums {\n            sum += n % 10;\n        }\n        sum\n    });\n    sorted_nums",
  "    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x| {\n  \
    \      let mut sum = 0;\n        for &n in &mut sorted_nums {\n            sum\
    \ += n % 10;\n            n /= 10;\n        }\n        sum\n    });\n    sorted_nums",
  "    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x| {\n  \
    \      let mut sum = 0;\n        for &i in &nums {\n            sum += i;\n  \
    \      }\n        sum\n    });\n    sorted_nums"]
stop_tokens:
- "\n}"
