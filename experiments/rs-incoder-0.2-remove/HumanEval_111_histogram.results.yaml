language: rs
name: HumanEval_111_histogram
results:
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ vec![];\n    while let Some(letter) = letters.pop() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).and_modify(|count| {\n             \
    \   *count += 1;\n            });\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    histogram.into_iter().map(|(_, count)| {\n      \
    \  let mut letter = String::new();\n        for _ in 0..count {\n            letter.push('\
    \ ');\n        }\n        letter\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpps8tp_70.rs:17:30\n   |\n\
    17 |             histogram.insert(letter, 1);\n   |                          \
    \    ^^^^^^\n   |                              |\n   |                       \
    \       expected `&char`, found `char`\n   |                              help:\
    \ consider borrowing here: `&letter`\n\nerror[E0277]: a value of type `HashMap<String,\
    \ isize>` cannot be built from an iterator over elements of type `String`\n  -->\
    \ /tmp/tmpps8tp_70.rs:26:8\n   |\n26 |     }).collect()\n   |        ^^^^^^^ value\
    \ of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \   |\n   = help: the trait `FromIterator<String>` is not implemented for `HashMap<String,\
    \ isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        if let Some(count) = histogram.get(&letter)\
    \ {\n            histogram.insert(letter, count + 1);\n        } else {\n    \
    \        histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9zqkf51b.rs:16:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n16 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.insert(letter,\
    \ histogram.entry(letter).or_insert(0));\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcbn2pcus.rs:10:34\n   |\n\
    10 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    let mut letter = String::new();\n    let mut count = 0;\n \
    \   for c in letters {\n        if histogram.contains_key(&c) {\n            histogram.entry(c).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(c, 1);\n        }\n  \
    \  }\n    for entry in histogram.iter() {\n        if entry.value == counts.len()\
    \ {\n            count = entry.key;\n        }\n    }\n    histogram.remove(&count);\n\
    \    histogram.insert(count, 1);\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpp03fkmvr.rs:15:13\n   |\n15 |             histogram.entry(c).or_insert(0)\
    \ += 1;\n   |             -------------------------------^^^^^\n   |         \
    \    |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c).or_insert(0)`\n\
    \   |\n15 |             *histogram.entry(c).or_insert(0) += 1;\n   |         \
    \    +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpp03fkmvr.rs:15:45\n\
    \   |\n15 |             histogram.entry(c).or_insert(0) += 1;\n   |          \
    \   ------------------------------- ^^\n   |             |\n   |             cannot\
    \ assign to this expression\n\nerror[E0609]: no field `value` on type `(&char,\
    \ &{integer})`\n  --> /tmp/tmpp03fkmvr.rs:21:18\n   |\n21 |         if entry.value\
    \ == counts.len() {\n   |                  ^^^^^\n\nerror[E0609]: no field `key`\
    \ on type `(&char, &{integer})`\n  --> /tmp/tmpp03fkmvr.rs:22:27\n   |\n22 | \
    \            count = entry.key;\n   |                           ^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp03fkmvr.rs:25:22\n   |\n25 |     histogram.remove(&count);\n\
    \   |                      ^^^^^^ expected `char`, found integer\n   |\n   = note:\
    \ expected reference `&char`\n              found reference `&{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp03fkmvr.rs:26:22\n   |\n26 |     histogram.insert(count,\
    \ 1);\n   |                      ^^^^^ expected `char`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp03fkmvr.rs:27:5\n   |\n7  | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n27 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E03"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp8_c9guyn.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749037
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp8_c9guyn.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749037
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort();\n\
    \    for letter in letters {\n        if let Some(count) = histogram.get(&letter)\
    \ {\n            histogram.insert(letter, count + 1);\n        } else {\n    \
    \        histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5n6k5en4.rs:18:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n18 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if histogram.contains_key(&c.to_string())\
    \ {\n            histogram.entry(c.to_string()).or_insert(0) += 1;\n        }\
    \ else {\n            histogram.insert(c.to_string(), 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpn5kyq6wi.rs:11:13\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             -------------------------------------------^^^^^\n \
    \  |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n11 |             *histogram.entry(c.to_string()).or_insert(0) += 1;\n \
    \  |             +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpn5kyq6wi.rs:11:57\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    letters.sort_unstable();\n    let mut letter_counts = HashMap::new();\n \
    \   for letter in letters {\n        letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    letter_counts\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp1hmufxi_.rs:12:9\n   |\n12 |         letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n12 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp1hmufxi_.rs:12:50\n\
    \   |\n12 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1hmufxi_.rs:14:5\n\
    \   |\n7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n14 |     letter_counts\n   |     ^^^^^^^^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0));\n    counts.sort_by_key(|&(_,\
    \ count)| {\n        count.cmp(&counts[counts.len() - 1])\n    });\n    histogram.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpgiydofod.rs:11:12\n   |\n11 |     counts.sort_by_key(|&(_,\
    \ count)| {\n   |            ^^^^^^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_,\
    \ char>>, [closure@/tmp/tmpgiydofod.rs:10:50: 10:85]>`\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Cloned<std::slice::Iter<'_, char>>, [closure@/tmp/tmpgiydofod.rs:10:50:\
    \ 10:85]>`\n  --> /tmp/tmpgiydofod.rs:12:20\n   |\n12 |         count.cmp(&counts[counts.len()\
    \ - 1])\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: a value\
    \ of type `HashMap<String, isize>` cannot be built from an iterator over elements\
    \ of type `(char, {integer})`\n    --> /tmp/tmpgiydofod.rs:14:27\n     |\n14 \
    \  |     histogram.into_iter().collect()\n     |                           ^^^^^^^\
    \ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=(char,\
    \ {integer})>`\n     |\n     = help: the trait `FromIterator<(char, {integer})>`\
    \ is not implemented for `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K,\
    \ V)>` is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letters_count\
    \ = letters.iter().cloned().count();\n    let mut max_letter = letters.iter().cloned().max();\n\
    \    let mut max_letter_count = letters_count.iter().cloned().max();\n    while\
    \ let Some(letter) = max_letter {\n        histogram.insert(letter, letters_count[letter]);\n\
    \        letters_count -= 1;\n        if letters_count == 0 {\n            break;\n\
    \        }\n        max_letter = letters.iter().cloned().max();\n        max_letter_count\
    \ = letters_count.iter().cloned().max();\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp1vh5jnb3.rs:12:46\n   |\n12 |     let mut max_letter_count\
    \ = letters_count.iter().cloned().max();\n   |                               \
    \               ^^^^ method not found in `usize`\n\nerror[E0608]: cannot index\
    \ into a value of type `usize`\n  --> /tmp/tmp1vh5jnb3.rs:14:34\n   |\n14 |  \
    \       histogram.insert(letter, letters_count[letter]);\n   |               \
    \                   ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmp1vh5jnb3.rs:20:42\n\
    \   |\n20 |         max_letter_count = letters_count.iter().cloned().max();\n\
    \   |                                          ^^^^ method not found in `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1vh5jnb3.rs:22:5\n   |\n7  | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n22 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, _>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letters_count\
    \ = letters.len();\n    let mut letter_count = 1;\n    for letter in letters {\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, letter_count);\n\
    \            letter_count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpk_jjr82m.rs:14:13\n   |\n14 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n14 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpk_jjr82m.rs:14:51\n\
    \   |\n14 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk_jjr82m.rs:16:30\n   |\n16 |             histogram.insert(letter,\
    \ letter_count);\n   |                              ^^^^^^\n   |             \
    \                 |\n   |                              expected `&char`, found\
    \ `char`\n   |                              help: consider borrowing here: `&letter`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk_jjr82m.rs:20:5\n   |\n7  | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n20 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letter_counts\
    \ = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0));\n    letter_counts.sort_by_key(|&(_,\
    \ count)| count.cmp(&letters.len()));\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpm0hcxb6o.rs:11:19\n   |\n11 |     letter_counts.sort_by_key(|&(_,\
    \ count)| count.cmp(&letters.len()));\n   |                   ^^^^^^^^^^^ method\
    \ not found in `Map<Cloned<std::slice::Iter<'_, char>>, [closure@/tmp/tmpm0hcxb6o.rs:10:57:\
    \ 10:92]>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm0hcxb6o.rs:12:5\n\
    \   |\n7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n12 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if histogram.contains_key(&c.to_string())\
    \ {\n            histogram.entry(c.to_string()).or_insert(0) += 1;\n        }\
    \ else {\n            histogram.insert(c.to_string(), 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpn5kyq6wi.rs:11:13\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             -------------------------------------------^^^^^\n \
    \  |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n11 |             *histogram.entry(c.to_string()).or_insert(0) += 1;\n \
    \  |             +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpn5kyq6wi.rs:11:57\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letter_counts\
    \ = vec![];\n    for letter in letters {\n        let letter_count = histogram.entry(letter).or_insert(0);\n\
    \        *letter_count += 1;\n        letter_counts.push(*letter_count);\n   \
    \ }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq3ah8fav.rs:16:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n16 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if let Some(count) = histogram.get(&c.to_string())\
    \ {\n            *count += 1;\n        } else {\n            histogram.insert(c.to_string(),\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*count`, which is behind a `&` reference\n\
    \  --> /tmp/tmpbdipyyke.rs:11:13\n   |\n10 |         if let Some(count) = histogram.get(&c.to_string())\
    \ {\n   |                     ----- help: consider changing this to be a mutable\
    \ reference: `&mut isize`\n11 |             *count += 1;\n   |             ^^^^^^^^^^^\
    \ `count` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if let Some(count) = histogram.get(&c.to_string())\
    \ {\n            *count += 1;\n        } else {\n            histogram.insert(c.to_string(),\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*count`, which is behind a `&` reference\n\
    \  --> /tmp/tmpbdipyyke.rs:11:13\n   |\n10 |         if let Some(count) = histogram.get(&c.to_string())\
    \ {\n   |                     ----- help: consider changing this to be a mutable\
    \ reference: `&mut isize`\n11 |             *count += 1;\n   |             ^^^^^^^^^^^\
    \ `count` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_by_key(|&x|\
    \ x.to_ascii_lowercase());\n    let mut letter_count = 1;\n    for letter in letters\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|x|\
    \ x.1 += letter_count);\n        } else {\n            histogram.insert(letter,\
    \ letter_count);\n        }\n        letter_count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&mut V`\n  --> /tmp/tmp2efee665.rs:14:50\n\
    \   |\n14 |             histogram.entry(&letter).and_modify(|x| x.1 += letter_count);\n\
    \   |                                                  ^ consider giving this\
    \ closure parameter the explicit type `&mut V`, where the type parameter `V` is\
    \ specified\n   |\n   = note: type must be known at this point\n\nerror[E0609]:\
    \ no field `1` on type `&mut _`\n  --> /tmp/tmp2efee665.rs:14:55\n   |\n14 | \
    \            histogram.entry(&letter).and_modify(|x| x.1 += letter_count);\n \
    \  |                                                       ^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0609.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if histogram.contains_key(&c.to_string())\
    \ {\n            histogram.entry(c.to_string()).or_insert(0) += 1;\n        }\
    \ else {\n            histogram.insert(c.to_string(), 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpn5kyq6wi.rs:11:13\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             -------------------------------------------^^^^^\n \
    \  |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n11 |             *histogram.entry(c.to_string()).or_insert(0) += 1;\n \
    \  |             +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpn5kyq6wi.rs:11:57\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|x|\
    \ x.inc(1));\n        } else {\n            histogram.insert(letter, 1);\n   \
    \     }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&mut V`\n  --> /tmp/tmpqi4vret9.rs:11:50\n\
    \   |\n11 |             histogram.entry(&letter).and_modify(|x| x.inc(1));\n \
    \  |                                                  ^ consider giving this closure\
    \ parameter the explicit type `&mut V`, where the type parameter `V` is specified\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        if let Some(count) = histogram.get(&letter)\
    \ {\n            histogram.insert(letter, count + 1);\n        } else {\n    \
    \        histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9zqkf51b.rs:16:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n16 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \    letters.sort_by_key(|c| c.to_ascii_lowercase());\n    for letter in letters\
    \ {\n        let count = histogram.entry(letter).or_insert(0);\n        *count\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \"a\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp7cs__vya.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letter_counts\
    \ = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0));\n    letter_counts.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    letter_counts.collect::<Vec<_>>()\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpd2y0xwa7.rs:11:19\n   |\n11 |     letter_counts.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                   ^^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_,\
    \ char>>, [closure@/tmp/tmpd2y0xwa7.rs:10:57: 10:92]>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd2y0xwa7.rs:12:5\n   |\n7  | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n12 |     letter_counts.collect::<Vec<_>>()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `HashMap<String, isize>`\n         \
    \     found struct `Vec<&mut {integer}>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.insert(letter,\
    \ histogram.entry(letter).or_insert(0));\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcbn2pcus.rs:10:34\n   |\n\
    10 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_by_key(|&x|\
    \ x.to_ascii_lowercase());\n    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0l4vtuj.rs:15:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n15 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_by_key(|&x|\
    \ x.to_string());\n    let mut count = 1;\n    for letter in letters {\n     \
    \   if histogram.contains_key(&letter) {\n            histogram.entry(letter).and_modify(|x|\
    \ {\n                *x += 1;\n            });\n        } else {\n           \
    \ histogram.insert(letter, count);\n            count += 1;\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpai5drkzz.rs:22:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n22 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        if let Some(count) = histogram.get(&letter) {\n            histogram.insert(letter,\
    \ count + 1);\n        } else {\n            histogram.insert(letter, 1);\n  \
    \      }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmph8nqp8uk.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut occurrences = HashMap::new();\n\
    \    for letter in letters {\n        if let Some(count) = occurrences.get(&letter)\
    \ {\n            occurrences.insert(letter, count + 1);\n        } else {\n  \
    \          occurrences.insert(letter, 1);\n        }\n    }\n    occurrences\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpumj2_bzw.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        if let Some(count) = histogram.get(&letter) {\n            histogram.insert(letter,\
    \ count + 1);\n        } else {\n            histogram.insert(letter, 1);\n  \
    \      }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmph8nqp8uk.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if let Some(count) = histogram.entry(c).or_insert(0)\
    \ {\n            *count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvt57qqeg.rs:10:16\n   |\n\
    10 |         if let Some(count) = histogram.entry(c).or_insert(0) {\n   |    \
    \            ^^^^^^^^^^^   ------------------------------- this expression has\
    \ type `&mut {integer}`\n   |                |\n   |                expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvt57qqeg.rs:14:5\n\
    \   |\n7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n14 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_unstable();\n\
    \    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoeokfac1.rs:15:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n15 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4hitye8v.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if histogram.contains_key(&c.to_string())\
    \ {\n            histogram.entry(c.to_string()).or_insert(0) += 1;\n        }\
    \ else {\n            histogram.insert(c.to_string(), 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpn5kyq6wi.rs:11:13\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             -------------------------------------------^^^^^\n \
    \  |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n11 |             *histogram.entry(c.to_string()).or_insert(0) += 1;\n \
    \  |             +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpn5kyq6wi.rs:11:57\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_unstable();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = letters_iter.next();\n\
    \    let mut count = 1;\n    while let Some(letter) = letters_iter.next() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n        count += 1;\n   \
    \ }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp2zii969_.rs:15:9\n   |\n15 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n15 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp2zii969_.rs:15:46\n\
    \   |\n15 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2zii969_.rs:18:5\n   |\n7  | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n18 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0067, E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letter_counts\
    \ = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0));\n    letter_counts.sort_by_key(|&(_,\
    \ count)| {\n        count.cmp(&histogram.get(&c).unwrap())\n    });\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpc798dgum.rs:12:35\n\
    \   |\n12 |         count.cmp(&histogram.get(&c).unwrap())\n   |             \
    \                      ^ not found in this scope\n\nerror[E0599]: no method named\
    \ `sort_by_key` found for struct `Map` in the current scope\n  --> /tmp/tmpc798dgum.rs:11:19\n\
    \   |\n11 |     letter_counts.sort_by_key(|&(_, count)| {\n   |              \
    \     ^^^^^^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_, char>>,\
    \ [closure@/tmp/tmpc798dgum.rs:10:57: 10:92]>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc798dgum.rs:14:5\n   |\n7  | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n14 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0));\n    counts.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    histogram.into_iter().map(|(_, v)| {\n        let mut\
    \ letter = String::new();\n        letters.iter().for_each(|c| {\n           \
    \ if c == v.0 {\n                letter += c.to_string();\n            }\n   \
    \     });\n        letter\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmp06xer7qv.rs:11:12\n   |\n11 |     counts.sort_by(|a, b|\
    \ b.1.cmp(&a.1));\n   |            ^^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_,\
    \ char>>, [closure@/tmp/tmp06xer7qv.rs:10:50: 10:85]>`\n\nerror[E0610]: `{integer}`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp06xer7qv.rs:15:23\n\
    \   |\n15 |             if c == v.0 {\n   |                       ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp06xer7qv.rs:16:27\n   |\n16 |              \
    \   letter += c.to_string();\n   |                           ^^^^^^^^^^^^^\n \
    \  |                           |\n   |                           expected `&str`,\
    \ found struct `String`\n   |                           help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0277]: a value of type `HashMap<String, isize>`\
    \ cannot be built from an iterator over elements of type `String`\n    --> /tmp/tmp06xer7qv.rs:20:8\n\
    \     |\n20   |     }).collect()\n     |        ^^^^^^^ value of type `HashMap<String,\
    \ isize>` cannot be built from `std::iter::Iterator<Item=String>`\n     |\n  \
    \   = help: the trait `FromIterator<String>` is not implemented for `HashMap<String,\
    \ isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented for `HashMap<K,\
    \ V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599, E0610.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_by_key(|&x|\
    \ x.to_ascii_lowercase());\n    for letter in letters {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprjd1dwrr.rs:18:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n18 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letters_count\
    \ = letters.len();\n    let mut letter_count = 1;\n    let mut letter_count_max\
    \ = 1;\n    let mut letter_count_min = 1;\n    let mut letter_count_sum = 0;\n\
    \    let mut letter_count_sum_max = 1;\n    let mut letter_count_sum_min = 1;\n\
    \    let mut letter_count_sum_sum = 0;\n    let mut letter_count_sum_sum_max =\
    \ 1;\n    let mut letter_count_sum_sum_min = 1;\n    let mut letter_count_sum_sum_sum\
    \ = 0;\n    let mut letter_count_sum_sum_sum_max = 1;\n    let mut letter_count_sum_sum_sum_min\
    \ = 1;\n    let mut letter_count_sum_sum_sum_sum = 0;\n    let mut letter_count_sum_sum_sum_sum_max\
    \ = 1;\n    let mut letter_count_sum_sum_sum_sum_min = 1;\n    let mut letter_count_sum_sum_sum_sum_sum\
    \ = 0;\n    let mut letter_count_sum_sum_sum_sum_max = 1;\n    let mut letter_count_sum_sum_sum_sum_min\
    \ = 1;\n    let mut letter_count_sum_sum_sum_sum_sum = 0;\n    let mut letter_count_sum_sum_sum_sum_sum_max\
    \ = 1;\n    let mut letter_count_sum_sum_sum_sum_sum_min = 1;\n    let mut letter_count_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_max = 1;\n    let mut\
    \ letter_count_sum_sum_sum_sum_sum_sum_min = 1;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_max = 1;\n    let mut\
    \ letter_count_sum_sum_sum_sum_sum_sum_min = 1;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_max = 1;\n    let mut\
    \ letter_count_sum_sum_sum_sum_sum_sum_sum_min = 1;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_sum_max = 1;\n    let\
    \ mut letter_count_sum_sum_sum_sum_sum_sum_sum_min = 1;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_sum_max = 1;\n    let\
    \ mut letter_count_sum_sum_sum_sum_sum_sum_sum_min = 1;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    let mut letter_count_sum_sum_sum_sum_sum_sum_sum_sum_max = 1;\n  \
    \  let mut letter_count_sum_sum_sum_\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdelxyejg.rs:49:38\n   |\n\
    49 |     let mut letter_count_sum_sum_sum_\n   |                             \
    \         ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpdelxyejg.rs:7:31\n  |\n7 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n  |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `HashMap<String, isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \    let mut counts = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0));\n\
    \    counts.sort_by(|a, b| b.1.cmp(&a.1));\n    histogram.into_iter().map(|(_,\
    \ count)| {\n        let mut letter = String::new();\n        let mut count =\
    \ count.unwrap();\n        count.iter().for_each(|&i| {\n            letter =\
    \ if i == 0 { letter } else { &letter + &\" \" };\n        });\n        (letter,\
    \ count)\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmplq0j0s3l.rs:11:12\n   |\n11 |     counts.sort_by(|a, b|\
    \ b.1.cmp(&a.1));\n   |            ^^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmplq0j0s3l.rs:10:50: 10:85]>`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `{integer}` in the current scope\n  --> /tmp/tmplq0j0s3l.rs:14:31\n\
    \   |\n14 |         let mut count = count.unwrap();\n   |                    \
    \           ^^^^^^ method not found in `{integer}`\n\nerror[E0369]: cannot add\
    \ `&&str` to `&String`\n  --> /tmp/tmplq0j0s3l.rs:16:58\n   |\n16 |          \
    \   letter = if i == 0 { letter } else { &letter + &\" \" };\n   |           \
    \                                       ------- ^ ---- &&str\n   |           \
    \                                       |       |\n   |                      \
    \                            |       `+` cannot be used to concatenate two `&str`\
    \ strings\n   |                                                  &String\n   |\n\
    \   = note: string concatenation requires an owned `String` on the left\nhelp:\
    \ remove the borrow to obtain an owned `String`\n   |\n16 -             letter\
    \ = if i == 0 { letter } else { &letter + &\" \" };\n16 +             letter =\
    \ if i == 0 { letter } else { letter + &\" \" };\n   | \n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        if let Some(count) = histogram.get(&letter)\
    \ {\n            histogram.insert(letter, count + 1);\n        } else {\n    \
    \        histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9zqkf51b.rs:16:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n16 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if let Some(count) = histogram.get(&c.to_string())\
    \ {\n            *count += 1;\n        } else {\n            histogram.insert(c.to_string(),\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*count`, which is behind a `&` reference\n\
    \  --> /tmp/tmpbdipyyke.rs:11:13\n   |\n10 |         if let Some(count) = histogram.get(&c.to_string())\
    \ {\n   |                     ----- help: consider changing this to be a mutable\
    \ reference: `&mut isize`\n11 |             *count += 1;\n   |             ^^^^^^^^^^^\
    \ `count` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp8_c9guyn.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749037
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if histogram.contains_key(&c.to_string())\
    \ {\n            histogram.entry(c.to_string()).or_insert(0) += 1;\n        }\
    \ else {\n            histogram.insert(c.to_string(), 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpn5kyq6wi.rs:11:13\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             -------------------------------------------^^^^^\n \
    \  |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n11 |             *histogram.entry(c.to_string()).or_insert(0) += 1;\n \
    \  |             +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmpn5kyq6wi.rs:11:57\n   |\n11 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    let mut letter = String::new();\n    let mut count = 0;\n \
    \   let mut i = 0;\n    while i < letters.len() {\n        letter = letters[i].to_string();\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|x|\
    \ *x += 1);\n        } else {\n            histogram.insert(letter, 1);\n    \
    \    }\n        counts.push(count);\n        i += 1;\n        count += 1;\n  \
    \  }\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new(), 0);\n    histogram.insert(String::new(),\
    \ 0);\n    histogram.insert(String::new\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9f07cr33.rs:63:21\n\
    \   |\n7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                                                 - closing delimiter possibly\
    \ meant for this\n...\n63 |     histogram.insert(String::new\n   |           \
    \          ^ unclosed delimiter\n64 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9f07cr33.rs:19:30\n   |\n19 |\
    \             histogram.insert(letter, 1);\n   |                             \
    \ ^^^^^^\n   |                              |\n   |                          \
    \    expected `&String`, found struct `String`\n   |                         \
    \     help: consider borrowing here: `&letter`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9f07cr33.rs:25:22\n   |\n25 |     histogram.insert(String::new(),\
    \ 0);\n   |                      ^^^^^^^^^^^^^\n   |                      |\n\
    \   |                      expected `&String`, found struct `String`\n   |   \
    \                   help: consider borrowing here: `&String::new()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9f07cr33.rs:26:22\n   |\n26 |     histogram.insert(String::new(),\
    \ 0);\n   |                      ^^^^^^^^^^^^^\n   |                      |\n\
    \   |                      expected `&String`, found struct `String`\n   |   \
    \                   help: consider borrowing here: `&String::new()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9f07cr33.rs:27:22\n   |\n27 |     histogram.insert(String::new(),\
    \ 0);\n   |                      ^^^^^^^^^^^^^\n   |                      |\n\
    \   |                      expected `&String`, found struct `String`\n   |   \
    \                   help: consider borrowing here: `&String::new()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9f07cr33.rs:28:22\n   |\n28 |     histogram.insert(String::new(),\
    \ 0);\n   |                      ^^^^^^^^^^^^^\n   |                      |\n\
    \   |                      expected `&String`, found struct `String`\n   |   \
    \                   help: consider borrowing here: `&String::new()`\n\nerror[E0308]:\
    \ mismatched types\n  --> "
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp97kbta7l.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp97kbta7l.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp97kbta7l.rs:12:5\n   |\n7  | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n12 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letters_count\
    \ = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0)).collect::<Vec<_>>();\n\
    \    letters_count.sort_by_key(|&(_, count)| {\n        count.cmp(&letters_count[letters_count.len()\
    \ - 1])\n    });\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeurskh29.rs:11:33\n   |\n\
    11 |     letters_count.sort_by_key(|&(_, count)| {\n   |                     \
    \            ^^^^^^^^^-\n   |                                 |        |\n   |\
    \                                 |        expected due to this\n   |        \
    \                         expected integer, found tuple\n   |\n   = note: expected\
    \ type `{integer}`\n             found tuple `(_, _)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeurskh29.rs:14:5\n   |\n7  | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n14 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letter_counts\
    \ = HashMap::new();\n\n    for letter in letters {\n        let count = letter_counts.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n\n    for (_, count) in letter_counts {\n      \
    \  histogram.insert(count.to_string(), count);\n    }\n\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"2\": 2, \"3\": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpqkq64d6d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut letters = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = letters.get(&letter) {\n            letters.insert(letter, count + 1);\n \
    \       } else {\n            letters.insert(letter, 1);\n        }\n    }\n \
    \   letters\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp09ro2p_y.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut count =\
    \ 1;\n    for letter in letters {\n        histogram.entry(letter).or_insert(count).clone()\
    \ += 1;\n        count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpetjxyu7r.rs:12:58\n\
    \   |\n12 |         histogram.entry(letter).or_insert(count).clone() += 1;\n \
    \  |         ------------------------------------------------ ^^\n   |       \
    \  |\n   |         cannot assign to this expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpetjxyu7r.rs:15:5\n   |\n7  | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n15 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_unstable();\n\
    \    for letter in letters {\n        if histogram.contains_key(&letter) {\n \
    \           histogram.entry(letter).or_insert(0) += 1;\n        } else {\n   \
    \         histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp6_2se8f8.rs:13:13\n   |\n13 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n13 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp6_2se8f8.rs:13:50\n\
    \   |\n13 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6_2se8f8.rs:18:5\n   |\n7  | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n18 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp97kbta7l.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp97kbta7l.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp97kbta7l.rs:12:5\n   |\n7  | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n12 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if let Some(count) = histogram.entry(c.to_string()).or_insert(0)\
    \ {\n            *count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm8dvmlou.rs:10:16\n   |\n\
    10 |         if let Some(count) = histogram.entry(c.to_string()).or_insert(0)\
    \ {\n   |                ^^^^^^^^^^^   -------------------------------------------\
    \ this expression has type `&mut {integer}`\n   |                |\n   |     \
    \           expected integer, found enum `Option`\n   |\n   = note: expected type\
    \ `{integer}`\n              found enum `Option<_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letters_count\
    \ = letters.len();\n    let mut letter_count = 1;\n    let mut letter = letters.first();\n\
    \    while let Some(letter) = letter {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n        letters_count -= 1;\n        if letters_count == 0 {\n      \
    \      histogram.insert(letter, letter_count);\n            letter_count = 1;\n\
    \            letter = letters.next();\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp2l_m_vfc.rs:14:9\n   |\n14 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n14 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp2l_m_vfc.rs:14:46\n\
    \   |\n14 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<char>` in the current scope\n \
    \ --> /tmp/tmp2l_m_vfc.rs:19:30\n   |\n19 |             letter = letters.next();\n\
    \   |                              ^^^^ method not found in `Vec<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2l_m_vfc.rs:22:5\n   |\n7  | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n22 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0067, E0308, E0368, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0));\n    counts.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    histogram.into_iter().map(|(_, count)| {\n        let\
    \ mut letter = String::new();\n        let mut count = 1;\n        for (key, value)\
    \ in &histogram {\n            if value == count {\n                letter +=\
    \ key;\n            }\n            count += 1;\n        }\n        (letter, count)\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmp9fxi77l3.rs:11:12\n   |\n11 |     counts.sort_by(|a, b|\
    \ b.1.cmp(&a.1));\n   |            ^^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_,\
    \ char>>, [closure@/tmp/tmp9fxi77l3.rs:10:50: 10:85]>`\n\nerror[E0277]: can't\
    \ compare `&{integer}` with `{integer}`\n  --> /tmp/tmp9fxi77l3.rs:16:22\n   |\n\
    16 |             if value == count {\n   |                      ^^ no implementation\
    \ for `&{integer} == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9fxi77l3.rs:17:27\n   |\n17 |                 letter += key;\n   | \
    \                          ^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letter_counts\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqxwn7gup.rs:50:27\n   |\n\
    50 |     let mut letter_counts_\n   |                           ^ help: add `;`\
    \ here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpqxwn7gup.rs:7:31\n  |\n7 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n  |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n  |\n  = note: expected struct `HashMap<String,\
    \ isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.insert(letter, histogram.entry(letter).or_insert(0));\n   \
    \ }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpai4j3ki8.rs:10:34\n   |\n\
    10 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_unstable();\n\
    \    for letter in letters {\n        if histogram.contains_key(&letter) {\n \
    \           histogram.entry(letter).or_insert(0) += 1;\n        } else {\n   \
    \         histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp6_2se8f8.rs:13:13\n   |\n13 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n13 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp6_2se8f8.rs:13:50\n\
    \   |\n13 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6_2se8f8.rs:18:5\n   |\n7  | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n18 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_by_key(|&x|\
    \ x.to_ascii_lowercase());\n    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0l4vtuj.rs:15:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n15 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut occurrences = HashMap::new();\n\
    \    for letter in letters {\n        if let Some(count) = occurrences.get(&letter)\
    \ {\n            occurrences.insert(letter, count + 1);\n        } else {\n  \
    \          occurrences.insert(letter, 1);\n        }\n    }\n    occurrences\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpumj2_bzw.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    let mut letter = String::new();\n    let mut letter_count =\
    \ 0;\n    for c in letters {\n        if histogram.contains_key(&c) {\n      \
    \      histogram.entry(c).or_insert(0) += 1;\n        } else {\n            histogram.insert(c,\
    \ 1);\n        }\n    }\n    for entry in histogram.iter() {\n        if entry.value\
    \ == letters.len() {\n            letter = entry.key.to_string();\n          \
    \  letter_count += 1;\n        }\n    }\n    histogram.insert(letter, letter_count);\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp8lpq0zzi.rs:15:13\n   |\n15 |             histogram.entry(c).or_insert(0)\
    \ += 1;\n   |             -------------------------------^^^^^\n   |         \
    \    |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c).or_insert(0)`\n\
    \   |\n15 |             *histogram.entry(c).or_insert(0) += 1;\n   |         \
    \    +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp8lpq0zzi.rs:15:45\n\
    \   |\n15 |             histogram.entry(c).or_insert(0) += 1;\n   |          \
    \   ------------------------------- ^^\n   |             |\n   |             cannot\
    \ assign to this expression\n\nerror[E0609]: no field `value` on type `(&char,\
    \ &{integer})`\n  --> /tmp/tmp8lpq0zzi.rs:21:18\n   |\n21 |         if entry.value\
    \ == letters.len() {\n   |                  ^^^^^\n\nerror[E0609]: no field `key`\
    \ on type `(&char, &{integer})`\n  --> /tmp/tmp8lpq0zzi.rs:22:28\n   |\n22 | \
    \            letter = entry.key.to_string();\n   |                           \
    \ ^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8lpq0zzi.rs:26:22\n   |\n\
    26 |     histogram.insert(letter, letter_count);\n   |                      ^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp8lpq0zzi.rs:27:5\n   |\n7  | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n27 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort();\n\
    \    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7axj2e27.rs:15:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n15 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.insert(letter, histogram.entry(letter).or_insert(0));\n   \
    \ }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpai4j3ki8.rs:10:34\n   |\n\
    10 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.insert(letter,\
    \ histogram.entry(letter).or_insert(0));\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcbn2pcus.rs:10:34\n   |\n\
    10 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    let mut letter = String::new();\n    let mut letter_count =\
    \ 0;\n    let mut letter_index = 0;\n    while let Some(letter) = letters.next()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|count|\
    \ {\n                *count += 1;\n            });\n        } else {\n       \
    \     histogram.insert(letter, 1);\n        }\n    }\n    for entry in histogram.iter()\
    \ {\n        let letter = entry.key();\n        let count = entry.value();\n \
    \       if count > letter_count {\n            letter = letters[letter_index];\n\
    \            letter_index = letter_index + 1;\n            letter_count = count;\n\
    \        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpbue26ob9.rs:14:38\n   |\n14 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbue26ob9.rs:20:30\n\
    \   |\n20 |             histogram.insert(letter, 1);\n   |                   \
    \           ^^^^^^\n   |                              |\n   |                \
    \              cyclic type of infinite size\n   |                            \
    \  help: consider borrowing here: `&letter`\n\nerror[E0599]: no method named `key`\
    \ found for tuple `(&&_, &{integer})` in the current scope\n  --> /tmp/tmpbue26ob9.rs:24:28\n\
    \   |\n24 |         let letter = entry.key();\n   |                          \
    \  ^^^ method not found in `(&&_, &{integer})`\n\nerror[E0599]: no method named\
    \ `value` found for tuple `(&&_, &{integer})` in the current scope\n  --> /tmp/tmpbue26ob9.rs:25:27\n\
    \   |\n25 |         let count = entry.value();\n   |                         \
    \  ^^^^^ method not found in `(&&_, &{integer})`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbue26ob9.rs:32:5\n   |\n7  | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n32 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&_,\
    \ {integer}>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut count =\
    \ 1;\n    for letter in letters {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(letter).and_modify(|x| {\n                *x\
    \ += 1;\n            });\n        } else {\n            histogram.insert(letter,\
    \ count);\n            count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmmcduhsy.rs:21:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n21 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        if let Some(count) = histogram.get(&letter) {\n            histogram.insert(letter,\
    \ count + 1);\n        } else {\n            histogram.insert(letter, 1);\n  \
    \      }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmph8nqp8uk.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if let Some(count) = histogram.entry(c.to_string()).or_insert(0)\
    \ {\n            *count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm8dvmlou.rs:10:16\n   |\n\
    10 |         if let Some(count) = histogram.entry(c.to_string()).or_insert(0)\
    \ {\n   |                ^^^^^^^^^^^   -------------------------------------------\
    \ this expression has type `&mut {integer}`\n   |                |\n   |     \
    \           expected integer, found enum `Option`\n   |\n   = note: expected type\
    \ `{integer}`\n              found enum `Option<_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4hitye8v.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        if let Some(count) = histogram.get(&letter) {\n            histogram.insert(letter,\
    \ count + 1);\n        } else {\n            histogram.insert(letter, 1);\n  \
    \      }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmph8nqp8uk.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    for letter in letters {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).and_modify(|count| {\n             \
    \   *count += 1;\n            });\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    for entry in histogram.iter() {\n        if let Some(count)\
    \ = entry.value {\n            counts.push((entry.key, count));\n        }\n \
    \   }\n    counts.sort_by(|a, b| b.1.cmp(&a.1));\n    histogram.into_iter().map(|entry|\
    \ entry.1).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp11hmydqk.rs:17:30\n   |\n\
    17 |             histogram.insert(letter, 1);\n   |                          \
    \    ^^^^^^\n   |                              |\n   |                       \
    \       expected `&char`, found `char`\n   |                              help:\
    \ consider borrowing here: `&letter`\n\nerror[E0609]: no field `value` on type\
    \ `(&&char, &{integer})`\n  --> /tmp/tmp11hmydqk.rs:21:36\n   |\n21 |        \
    \ if let Some(count) = entry.value {\n   |                                   \
    \ ^^^^^\n\nerror[E0609]: no field `key` on type `(&&char, &{integer})`\n  -->\
    \ /tmp/tmp11hmydqk.rs:22:32\n   |\n22 |             counts.push((entry.key, count));\n\
    \   |                                ^^^\n\nerror[E0609]: no field `1` on type\
    \ `&_`\n  --> /tmp/tmp11hmydqk.rs:25:29\n   |\n25 |     counts.sort_by(|a, b|\
    \ b.1.cmp(&a.1));\n   |                             ^\n\nerror[E0277]: a value\
    \ of type `HashMap<String, isize>` cannot be built from an iterator over elements\
    \ of type `{integer}`\n    --> /tmp/tmp11hmydqk.rs:26:48\n     |\n26   |     histogram.into_iter().map(|entry|\
    \ entry.1).collect()\n     |                                                ^^^^^^^\
    \ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item={integer}>`\n\
    \     |\n     = help: the trait `FromIterator<{integer}>` is not implemented for\
    \ `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented\
    \ for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0609.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    letters.sort_by_key(|&x|\
    \ x.to_ascii_lowercase());\n    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0l4vtuj.rs:15:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n15 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        if let Some(count) = histogram.get(&letter)\
    \ {\n            histogram.insert(letter, count + 1);\n        } else {\n    \
    \        histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9zqkf51b.rs:16:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n16 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if histogram.contains_key(&c.to_string())\
    \ {\n            histogram.entry(c.to_string()).and_modify(|e| e.value += 1);\n\
    \        } else {\n            histogram.insert(c.to_string(), 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&mut V`\n  --> /tmp/tmpfdu8zrhq.rs:11:56\n\
    \   |\n11 |             histogram.entry(c.to_string()).and_modify(|e| e.value\
    \ += 1);\n   |                                                        ^ consider\
    \ giving this closure parameter the explicit type `&mut V`, where the type parameter\
    \ `V` is specified\n   |\n   = note: type must be known at this point\n\nerror[E0609]:\
    \ no field `value` on type `&mut _`\n  --> /tmp/tmpfdu8zrhq.rs:11:61\n   |\n11\
    \ |             histogram.entry(c.to_string()).and_modify(|e| e.value += 1);\n\
    \   |                                                             ^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0609.\nFor more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram.into_iter().map(|(_, count)| {\n \
    \       let mut letter = String::new();\n        for (key, value) in histogram\
    \ {\n            if value == count {\n                letter += key;\n       \
    \     }\n        }\n        letter\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmkd8ccob.rs:19:27\n   |\n\
    19 |                 letter += key;\n   |                           ^^^ expected\
    \ `&str`, found `char`\n\nerror[E0277]: a value of type `HashMap<String, isize>`\
    \ cannot be built from an iterator over elements of type `String`\n    --> /tmp/tmpmkd8ccob.rs:23:8\n\
    \     |\n23   |     }).collect()\n     |        ^^^^^^^ value of type `HashMap<String,\
    \ isize>` cannot be built from `std::iter::Iterator<Item=String>`\n     |\n  \
    \   = help: the trait `FromIterator<String>` is not implemented for `HashMap<String,\
    \ isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented for `HashMap<K,\
    \ V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    for c in letters {\n        if histogram.contains_key(&c)\
    \ {\n            histogram.entry(c).and_modify(|e| *e += count);\n        } else\
    \ {\n            histogram.insert(c, count);\n        }\n        count += 1;\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 8, \" \": 12, \"b\": 8}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpu4ukmsw6.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0)).collect();\n\
    \    counts.sort_by_key(|&(_, count)| {\n        count.cmp(&counts.last())\n \
    \   });\n    histogram.iter().cloned().for_each(|(_, count)| {\n        *count\
    \ += 1;\n    });\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpc439pjel.rs:11:5\n\
    \   |\n10 |     let mut counts = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0)).collect();\n\
    \   |         ---------- consider giving `counts` a type\n11 |     counts.sort_by_key(|&(_,\
    \ count)| {\n   |     ^^^^^^ cannot infer type\n   |\n   = note: type must be\
    \ known at this point\n\nerror[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_,\
    \ char, {integer}> as Iterator>::Item == &_`\n    --> /tmp/tmpc439pjel.rs:14:22\n\
    \     |\n14   |     histogram.iter().cloned().for_each(|(_, count)| {\n     |\
    \                      ^^^^^^ expected reference, found tuple\n     |\n     =\
    \ note: expected reference `&_`\n                    found tuple `(&char, &{integer})`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `for_each` exists\
    \ for struct `Cloned<std::collections::hash_map::Iter<'_, char, {integer}>>`,\
    \ but its trait bounds were not satisfied\n    --> /tmp/tmpc439pjel.rs:14:31\n\
    \     |\n14   |       histogram.iter().cloned().for_each(|(_, count)| {\n    \
    \ |                                 ^^^^^^^^ method cannot be called on `Cloned<std::collections::hash_map::Iter<'_,\
    \ char, {integer}>>` due to unsatisfied trait bounds\n     |\n     = note: the\
    \ following trait bounds were not satisfied:\n             `<std::collections::hash_map::Iter<'_,\
    \ char, {integer}> as Iterator>::Item = &_`\n             which is required by\
    \ `Cloned<std::collections::hash_map::Iter<'_, char, {integer}>>: Iterator`\n\
    \             `Cloned<std::collections::hash_map::Iter<'_, char, {integer}>>:\
    \ Iterator`\n             which is required by `&mut Cloned<std::collections::hash_map::Iter<'_,\
    \ char, {integer}>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc439pjel.rs:17:5\n\
    \   |\n7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n17 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `Ha"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    letters.sort_unstable();\n    let mut counts = HashMap::new();\n    for letter\
    \ in letters {\n        if let Some(count) = counts.get(&letter) {\n         \
    \   counts.entry(letter).and_modify(|x| *x += 1);\n        } else {\n        \
    \    counts.insert(letter, 1);\n        }\n    }\n    counts\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp5gzzy0j.rs:18:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n18 |     counts\n   |     ^^^^^^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n  \
    \            found struct `HashMap<char, {integer}>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.insert(letter, histogram.entry(letter).or_insert(0));\n   \
    \ }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpai4j3ki8.rs:10:34\n   |\n\
    10 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if histogram.contains_key(&c.to_string())\
    \ {\n            histogram.insert(c.to_string(), histogram.get(&c.to_string())\
    \ + 1);\n        } else {\n            histogram.insert(c.to_string(), 1);\n \
    \       }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `Option<&_>`\n  --> /tmp/tmpzxw9gczg.rs:11:75\n\
    \   |\n11 |             histogram.insert(c.to_string(), histogram.get(&c.to_string())\
    \ + 1);\n   |                                             -----------------------------\
    \ ^ - {integer}\n   |                                             |\n   |    \
    \                                         Option<&_>\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letter_counts\
    \ = Vec::new();\n    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n        letter_counts.push((letter, *count));\n    }\n\
    \    histogram.sort_by_key(|&(_, count)| count.reverse());\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `HashMap`\
    \ in the current scope\n  --> /tmp/tmp5qf3bux5.rs:16:15\n   |\n16 |     histogram.sort_by_key(|&(_,\
    \ count)| count.reverse());\n   |               ^^^^^^^^^^^ method not found in\
    \ `HashMap<char, {integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5qf3bux5.rs:17:5\n\
    \   |\n7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n17 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut words = test.split_whitespace();\n    for word in words {\n     \
    \   let letter = word.chars().next().unwrap();\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpzvwbzgw5.rs:13:13\n   |\n13 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n13 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpzvwbzgw5.rs:13:50\n\
    \   |\n13 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzvwbzgw5.rs:18:5\n   |\n7  | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n18 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut words = test.split_whitespace();\n    for word in words {\n     \
    \   let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n  \
    \      let count = histogram.entry(letter).or_insert(0);\n        *count += 1;\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqb88b91z.rs:15:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n15 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    for letter in letters {\n        if let Some(count) = histogram.get(&letter)\
    \ {\n            histogram.insert(letter, count + 1);\n        } else {\n    \
    \        histogram.insert(letter, 1);\n        }\n    }\n    histogram.into_iter().map(|(_,\
    \ count)| {\n        let mut letter = String::new();\n        for (_, count) in\
    \ histogram.iter() {\n            letter += &*count as char;\n        }\n    \
    \    letter\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0b_0_nai.rs:21:23\n   |\n\
    21 |             letter += &*count as char;\n   |                       ^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0277]: a value of type `HashMap<String,\
    \ isize>` cannot be built from an iterator over elements of type `String`\n  \
    \  --> /tmp/tmp0b_0_nai.rs:24:8\n     |\n24   |     }).collect()\n     |     \
    \   ^^^^^^^ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented\
    \ for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\nerror[E0606]:\
    \ casting `&{integer}` as `char` is invalid\n  --> /tmp/tmp0b_0_nai.rs:21:23\n\
    \   |\n21 |             letter += &*count as char;\n   |                     \
    \  -------^^^^^^^^\n   |                       |\n   |                       cannot\
    \ cast `&{integer}` as `char`\n   |                       help: dereference the\
    \ expression: `*&*count`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut words = test.split_whitespace();\n    for word in words {\n     \
    \   let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n  \
    \      let count = histogram.entry(letter).or_insert(0);\n        *count += 1;\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqb88b91z.rs:15:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n15 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        if let Some(count) = histogram.get(&letter) {\n            histogram.insert(letter,\
    \ count + 1);\n        } else {\n            histogram.insert(letter, 1);\n  \
    \      }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmph8nqp8uk.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letter_counts\
    \ = Vec::new();\n    let mut letter_counts_len = Vec::new();\n    let mut letter_counts_len_max\
    \ = Vec::new();\n    let mut letter_counts_len_min = Vec::new();\n    let mut\
    \ letter_counts_len_avg = Vec::new();\n    let mut letter_counts_len_median =\
    \ Vec::new();\n    let mut letter_counts_len_mode = Vec::new();\n    let mut letter_counts_len_std\
    \ = Vec::new();\n    let mut letter_counts_len_sum = Vec::new();\n    let mut\
    \ letter_counts_len_min = Vec::new();\n    let mut letter_counts_len_max = Vec::new();\n\
    \    let mut letter_counts_len_avg = Vec::new();\n    let mut letter_counts_len_median\
    \ = Vec::new();\n    let mut letter_counts_len_mode = Vec::new();\n    let mut\
    \ letter_counts_len_std = Vec::new();\n    let mut letter_counts_len_sum = Vec::new();\n\
    \    let mut letter_counts_len_min = Vec::new();\n    let mut letter_counts_len_max\
    \ = Vec::new();\n    let mut letter_counts_len_avg = Vec::new();\n    let mut\
    \ letter_counts_len_median = Vec::new();\n    let mut letter_counts_len_mode =\
    \ Vec::new();\n    let mut letter_counts_len_std = Vec::new();\n    let mut letter_counts_len_sum\
    \ = Vec::new();\n    let mut letter_counts_len_min = Vec::new();\n    let mut\
    \ letter_counts_len_max = Vec::new();\n    let mut letter_counts_len_avg = Vec::new();\n\
    \    let mut letter_counts_len_median = Vec::new();\n    let mut letter_counts_len_mode\
    \ = Vec::new();\n    let mut letter_counts_len_std = Vec::new();\n    let mut\
    \ letter_counts_len_sum = Vec::new();\n    let mut letter_counts_len_min = Vec::new();\n\
    \    let mut letter_counts_len_max = Vec::new();\n    let mut letter_counts_len_avg\
    \ = Vec::new();\n    let mut letter_counts_len_median = Vec::new();\n    let mut\
    \ letter_counts_len_mode = Vec::new();\n    let mut letter_counts_len_std = Vec::new();\n\
    \    let mut letter_counts_len_sum = Vec::\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpzl_md3yq.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        if let Some(count) = histogram.entry(letter).or_insert(0) {\n       \
    \     *count += 1;\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprezamq83.rs:10:16\n   |\n\
    10 |         if let Some(count) = histogram.entry(letter).or_insert(0) {\n   |\
    \                ^^^^^^^^^^^   ------------------------------------ this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letters_count\
    \ = letters.len();\n    let mut letter_count = 1;\n    let mut letter_count_max\
    \ = 0;\n    let mut letter_count_min = 0;\n    let mut letter_count_sum = 0;\n\
    \    let mut letter_count_max = 0;\n    let mut letter_count_min = 0;\n    let\
    \ mut letter_count_sum = 0;\n    let mut letter_count_max = 0;\n    let mut letter_count_min\
    \ = 0;\n    let mut letter_count_sum = 0;\n    let mut letter_count_max = 0;\n\
    \    let mut letter_count_min = 0;\n    let mut letter_count_sum = 0;\n    let\
    \ mut letter_count_max = 0;\n    let mut letter_count_min = 0;\n    let mut letter_count_sum\
    \ = 0;\n    let mut letter_count_max = 0;\n    let mut letter_count_min = 0;\n\
    \    let mut letter_count_sum = 0;\n    let mut letter_count_max = 0;\n    let\
    \ mut letter_count_min = 0;\n    let mut letter_count_sum = 0;\n    let mut letter_count_max\
    \ = 0;\n    let mut letter_count_min = 0;\n    let mut letter_count_sum = 0;\n\
    \    let mut letter_count_max = 0;\n    let mut letter_count_min = 0;\n    let\
    \ mut letter_count_sum = 0;\n    let mut letter_count_max = 0;\n    let mut letter_count_min\
    \ = 0;\n    let mut letter_count_sum = 0;\n    let mut letter_count_max = 0;\n\
    \    let mut letter_count_min = 0;\n    let mut letter_count_sum = 0;\n    let\
    \ mut letter_count_max = 0;\n    let mut letter_count_min = 0;\n    let mut letter_count_sum\
    \ = 0;\n    let mut letter_count_max = 0;\n    let mut letter_count_min = 0;\n\
    \    let mut letter_count_sum = 0;\n    let mut letter_count_max = 0;\n    let\
    \ mut letter_count_min = 0;\n    let mut letter_count_sum = 0;\n    let mut letter_count_max\
    \ = 0;\n    let mut letter_count_min = 0;\n    let mut letter_count_sum = 0;\n\
    \    let mut letter_count_max = 0;\n    let mut letter_count_min = 0;\n    let\
    \ mut letter_count_sum = 0;\n    let mut letter_count_max = 0;\n    let mut letter_count_min\
    \ = 0;\n    let mut letter_count_sum = 0;\n    let mut letter_count_max = 0;\n\
    \    let mut letter_count_min = 0;\n    let mut letter_count_sum = 0;\n    let\
    \ mut letter_count_max = 0;\n    let mut letter_count_min = 0;\n    let mut letter_count_sum\
    \ = 0;\n    let mut letter_count_max = 0;\n    let mut \n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp0tr3pv1f.rs:71:1\n\
    \   |\n71 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    let mut letter = String::new();\n    let mut count = 0;\n \
    \   while let Some(letter) = letters.pop() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).and_modify(|x| *x += 1);\n        }\
    \ else {\n            histogram.insert(letter, 1);\n        }\n    }\n    for\
    \ entry in histogram.iter() {\n        if let Some(count) = entry.value {\n  \
    \          counts.push((entry.key, count));\n        }\n    }\n    counts.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    histogram.into_iter().collect()\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwlvyqbw_.rs:17:30\n   |\n\
    17 |             histogram.insert(letter, 1);\n   |                          \
    \    ^^^^^^\n   |                              |\n   |                       \
    \       expected `&char`, found `char`\n   |                              help:\
    \ consider borrowing here: `&letter`\n\nerror[E0609]: no field `value` on type\
    \ `(&&char, &{integer})`\n  --> /tmp/tmpwlvyqbw_.rs:21:36\n   |\n21 |        \
    \ if let Some(count) = entry.value {\n   |                                   \
    \ ^^^^^\n\nerror[E0609]: no field `key` on type `(&&char, &{integer})`\n  -->\
    \ /tmp/tmpwlvyqbw_.rs:22:32\n   |\n22 |             counts.push((entry.key, count));\n\
    \   |                                ^^^\n\nerror[E0609]: no field `1` on type\
    \ `&_`\n  --> /tmp/tmpwlvyqbw_.rs:25:29\n   |\n25 |     counts.sort_by(|a, b|\
    \ b.1.cmp(&a.1));\n   |                             ^\n\nerror[E0277]: a value\
    \ of type `HashMap<String, isize>` cannot be built from an iterator over elements\
    \ of type `(&char, {integer})`\n    --> /tmp/tmpwlvyqbw_.rs:26:27\n     |\n26\
    \   |     histogram.into_iter().collect()\n     |                           ^^^^^^^\
    \ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=(&char,\
    \ {integer})>`\n     |\n     = help: the trait `FromIterator<(&char, {integer})>`\
    \ is not implemented for `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K,\
    \ V)>` is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        if let Some(count) = histogram.entry(c.to_string()).or_insert(0)\
    \ {\n            *count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm8dvmlou.rs:10:16\n   |\n\
    10 |         if let Some(count) = histogram.entry(c.to_string()).or_insert(0)\
    \ {\n   |                ^^^^^^^^^^^   -------------------------------------------\
    \ this expression has type `&mut {integer}`\n   |                |\n   |     \
    \           expected integer, found enum `Option`\n   |\n   = note: expected type\
    \ `{integer}`\n              found enum `Option<_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letters_count\
    \ = letters.iter().cloned().count();\n    let mut letters_count_max = letters_count.clone();\n\
    \    let mut letters_count_min = letters_count.clone();\n    let mut letters_count_sum\
    \ = letters_count.clone();\n    let mut letters_count_product = letters_count.clone();\n\
    \    let mut letters_count_quotient = letters_count.clone();\n    let mut letters_count_quotient_max\
    \ = letters_count.clone();\n    let mut letters_count_quotient_min = letters_count.clone();\n\
    \    let mut letters_count_quotient_sum = letters_count.clone();\n    let mut\
    \ letters_count_quotient_product = letters_count.clone();\n    let mut letters_count_quotient_quotient\
    \ = letters_count.clone();\n    let mut letters_count_quotient_quotient_max =\
    \ letters_count.clone();\n    let mut letters_count_quotient_quotient_min = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_sum = letters_count.clone();\n  \
    \  let mut letters_count_quotient_quotient_product = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_max = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_min = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_sum = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_product = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_quotient = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_max = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_min = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_sum = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_product = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_quotient = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_max = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_min = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_quotient_sum = letters_count.clone();\n\
    \    let mut letters_count_quotient_quotient_\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmmbcrraz.rs:39:45\n   |\n\
    39 |     let mut letters_count_quotient_quotient_\n   |                      \
    \                       ^ help: add `;` here\n40 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpmmbcrraz.rs:7:31\n  |\n7 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n  |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `HashMap<String, isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut occurrences = HashMap::new();\n\
    \    let mut max_occurrences = isize::MAX;\n    let mut max_letter: Option<String>\
    \ = None;\n    for letter in letters {\n        if let Some(count) = occurrences.get(&letter)\
    \ {\n            occurrences.entry(letter).and_modify(|x| x.1 += count);\n   \
    \     } else {\n            occurrences.entry(letter).and_modify(|x| x.1 += 1);\n\
    \        }\n        if occurrences.get(&letter).1 > max_occurrences {\n      \
    \      max_occurrences = occurrences.get(&letter).1;\n            max_letter =\
    \ Some(letter);\n        }\n    }\n    occurrences\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&mut V`\n  --> /tmp/tmp6sw0pugr.rs:14:51\n\
    \   |\n14 |             occurrences.entry(letter).and_modify(|x| x.1 += count);\n\
    \   |                                                   ^ consider giving this\
    \ closure parameter the explicit type `&mut V`, where the type parameter `V` is\
    \ specified\n   |\n   = note: type must be known at this point\n\nerror[E0609]:\
    \ no field `1` on type `&mut _`\n  --> /tmp/tmp6sw0pugr.rs:14:56\n   |\n14 | \
    \            occurrences.entry(letter).and_modify(|x| x.1 += count);\n   |   \
    \                                                     ^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0609.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut words = test.split_whitespace();\n    for word in words {\n     \
    \   let letter = word.chars().map(|c| c.to_lowercase()).collect::<Vec<_>>();\n\
    \        histogram.insert(letter, histogram.entry(letter).or_insert(0));\n   \
    \ }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `ToLowercase: Eq` is not satisfied\n   -->\
    \ /tmp/tmp_31awas8.rs:12:19\n    |\n12  |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \    |                   ^^^^^^ the trait `Eq` is not implemented for `ToLowercase`\n\
    \    |\n    = help: the trait `Eq` is implemented for `Vec<T, A>`\n    = note:\
    \ required because of the requirements on the impl of `Eq` for `Vec<ToLowercase>`\n\
    note: required by a bound in `HashMap::<K, V, S>::insert`\n\nerror[E0277]: the\
    \ trait bound `ToLowercase: Hash` is not satisfied\n   --> /tmp/tmp_31awas8.rs:12:19\n\
    \    |\n12  |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \    |                   ^^^^^^ the trait `Hash` is not implemented for `ToLowercase`\n\
    \    |\n    = help: the trait `Hash` is implemented for `Vec<T, A>`\n    = note:\
    \ required because of the requirements on the impl of `Hash` for `Vec<ToLowercase>`\n\
    note: required by a bound in `HashMap::<K, V, S>::insert`\n\nerror[E0599]: the\
    \ method `entry` exists for struct `HashMap<Vec<ToLowercase>, _>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp_31awas8.rs:12:44\n    |\n12  |  \
    \         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n  \
    \  |                                              ^^^^^\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `Vec<ToLowercase>: Eq`\n\
    \            `Vec<ToLowercase>: Hash`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_31awas8.rs:14:5\n   |\n7  | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n14 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<Vec<ToLowercase>,\
    \ _>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ vec![];\n    letters.sort_by(|a, b| a.cmp(b));\n    for letter in letters {\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        counts.push(count);\n    }\n    histogram.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    histogram.reverse();\n    histogram.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `HashMap` in the\
    \ current scope\n  --> /tmp/tmpte4oqikb.rs:17:15\n   |\n17 |     histogram.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |               ^^^^^^^ method not found in `HashMap<char,\
    \ {integer}>`\n\nerror[E0599]: no method named `reverse` found for struct `HashMap`\
    \ in the current scope\n  --> /tmp/tmpte4oqikb.rs:18:15\n   |\n18 |     histogram.reverse();\n\
    \   |               ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0277]: a value of type `HashMap<String, isize>` cannot\
    \ be built from an iterator over elements of type `(char, {integer})`\n    -->\
    \ /tmp/tmpte4oqikb.rs:19:27\n     |\n19   |     histogram.into_iter().collect()\n\
    \     |                           ^^^^^^^ value of type `HashMap<String, isize>`\
    \ cannot be built from `std::iter::Iterator<Item=(char, {integer})>`\n     |\n\
    \     = help: the trait `FromIterator<(char, {integer})>` is not implemented for\
    \ `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented\
    \ for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0));\n    counts.sort_by_key(|&(_,\
    \ count)| {\n        count.cmp(&counts[counts.len() - 1])\n    });\n    histogram.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpgiydofod.rs:11:12\n   |\n11 |     counts.sort_by_key(|&(_,\
    \ count)| {\n   |            ^^^^^^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_,\
    \ char>>, [closure@/tmp/tmpgiydofod.rs:10:50: 10:85]>`\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Cloned<std::slice::Iter<'_, char>>, [closure@/tmp/tmpgiydofod.rs:10:50:\
    \ 10:85]>`\n  --> /tmp/tmpgiydofod.rs:12:20\n   |\n12 |         count.cmp(&counts[counts.len()\
    \ - 1])\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: a value\
    \ of type `HashMap<String, isize>` cannot be built from an iterator over elements\
    \ of type `(char, {integer})`\n    --> /tmp/tmpgiydofod.rs:14:27\n     |\n14 \
    \  |     histogram.into_iter().collect()\n     |                           ^^^^^^^\
    \ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=(char,\
    \ {integer})>`\n     |\n     = help: the trait `FromIterator<(char, {integer})>`\
    \ is not implemented for `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K,\
    \ V)>` is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n    for letter in letters {\n  \
    \      letter_counts.entry(letter).or_insert(0) += 1;\n    }\n    letter_counts\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpp9e1b23_.rs:11:9\n   |\n11 |         letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n11 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpp9e1b23_.rs:11:50\n\
    \   |\n11 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp9e1b23_.rs:13:5\n\
    \   |\n7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n13 |     letter_counts\n   |     ^^^^^^^^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp97kbta7l.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp97kbta7l.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp97kbta7l.rs:12:5\n   |\n7  | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n12 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp97kbta7l.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp97kbta7l.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp97kbta7l.rs:12:5\n   |\n7  | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n12 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut letter_counts\
    \ = letters.iter().cloned().map(|c| histogram.entry(c).or_default(0)).collect::<Vec<_>>();\n\
    \    letter_counts.sort_by_key(|&(_, count)| count.cmp(&letter_counts.last())).for_each(|(_,\
    \ count)| {\n        histogram.insert(*c, count);\n    });\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpgh3mj7uw.rs:12:27\n\
    \   |\n12 |         histogram.insert(*c, count);\n   |                       \
    \    ^ not found in this scope\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmpgh3mj7uw.rs:10:80\n     |\n10 \
    \  |     let mut letter_counts = letters.iter().cloned().map(|c| histogram.entry(c).or_default(0)).collect::<Vec<_>>();\n\
    \     |                                                                      \
    \          ^^^^^^^^^^ - supplied 1 argument\n     |                          \
    \                                                      |\n     |             \
    \                                                                   expected 0\
    \ arguments\n     |\nnote: associated function defined here\n\nerror[E0599]: `()`\
    \ is not an iterator\n  --> /tmp/tmpgh3mj7uw.rs:11:79\n   |\n11 |     letter_counts.sort_by_key(|&(_,\
    \ count)| count.cmp(&letter_counts.last())).for_each(|(_, count)| {\n   |    \
    \                                                                           ^^^^^^^^\
    \ `()` is not an iterator\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `(): Iterator`\n           which is required by `&mut\
    \ (): Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    letters.sort_by(|a, b| a.cmp(b));\n    for letter in letters\
    \ {\n        let count = histogram.entry(letter).or_insert(0);\n        *count\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhhmnvcr.rs:16:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n16 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp8_c9guyn.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749037
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().collect::<Vec<_>>();\n    let mut counts =\
    \ Vec::new();\n    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram.into_iter().map(|(_, count)| {\n \
    \       let mut letter = String::new();\n        for (key, value) in histogram\
    \ {\n            if *value == count {\n                letter += key;\n      \
    \      }\n        }\n        letter\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmph2c8b2fz.rs:18:16\n\
    \   |\n18 |             if *value == count {\n   |                ^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph2c8b2fz.rs:19:27\n   |\n19 |              \
    \   letter += key;\n   |                           ^^^ expected `&str`, found\
    \ `char`\n\nerror[E0277]: a value of type `HashMap<String, isize>` cannot be built\
    \ from an iterator over elements of type `String`\n    --> /tmp/tmph2c8b2fz.rs:23:8\n\
    \     |\n23   |     }).collect()\n     |        ^^^^^^^ value of type `HashMap<String,\
    \ isize>` cannot be built from `std::iter::Iterator<Item=String>`\n     |\n  \
    \   = help: the trait `FromIterator<String>` is not implemented for `HashMap<String,\
    \ isize>`\n     = help: the trait `FromIterator<(K, V)>` is implemented for `HashMap<K,\
    \ V, S>`\nnote: required by a bound in `collect`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut words = test.split_whitespace();\n    for word in words {\n     \
    \   let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n  \
    \      let count = histogram.entry(letter).or_insert(0);\n        *count += 1;\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqb88b91z.rs:15:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n15 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpfb7n8y9b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        if let Some(count)\
    \ = histogram.get(&letter) {\n            histogram.insert(letter, count + 1);\n\
    \        } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpvz54mhqd.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    let mut letters = test.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut max_count = -1;\n    let mut max_letter:\
    \ Option<String> = None;\n    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n        if *count > max_count {\n            max_count\
    \ = *count;\n            max_letter = Some(letter);\n        }\n    }\n    histogram.entry(max_letter).or_insert(0)\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsea94yu2.rs:21:21\n   |\n\
    21 |     histogram.entry(max_letter).or_insert(0)\n   |                     ^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsea94yu2.rs:21:5\n   |\n7  | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n21 |     histogram.entry(max_letter).or_insert(0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`,\
    \ found `&mut {integer}`\n   |\n   = note:         expected struct `HashMap<String,\
    \ isize>`\n           found mutable reference `&mut {integer}`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprc8m1lsy.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprc8m1lsy.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmwmp7nbj.rs:10:9\n   |\n10 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmwmp7nbj.rs:10:53\n\
    \   |\n10 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpdw77jv0b.rs:10:9\n   |\n10 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n10 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdw77jv0b.rs:10:46\n\
    \   |\n10 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659749036
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpa0afq_tz.rs:11:13\n   |\n11 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n11 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpa0afq_tz.rs:11:51\n\
    \   |\n11 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa0afq_tz.rs:13:30\n   |\n13 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&String`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpa0afq_tz.rs:16:5\n   |\n7  | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n16 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        if let Some(count) = histogram.get(&letter) {\n            *count +=\
    \ 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*count`, which is behind a `&` reference\n\
    \  --> /tmp/tmpujwl_9ec.rs:11:13\n   |\n10 |         if let Some(count) = histogram.get(&letter)\
    \ {\n   |                     ----- help: consider changing this to be a mutable\
    \ reference: `&mut isize`\n11 |             *count += 1;\n   |             ^^^^^^^^^^^\
    \ `count` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659976461
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()).collect::<Vec<_>>() {\n\
    \        histogram.insert(letter, histogram.entry(letter).or_insert(0));\n   \
    \ }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpai4j3ki8.rs:10:34\n   |\n\
    10 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n10 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976460
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\nfn histogram(test:\
    \ String) -> HashMap<String, isize> {\n    let mut histogram = HashMap::new();\n\
    \    for c in test.chars() {\n        let count = histogram.entry(c).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwv8kzdz.rs:13:5\n   |\n\
    7  | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n13 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749036
