name: HumanEval_112_reverse_delete
language: rs
prompt: "/// Task\n/// We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n/// then check if the result\
  \ string is palindrome.\n/// A string is called palindrome if it reads the same\
  \ backward as forward.\n/// You should return a tuple containing the result string\
  \ and True/False for the check.\n/// Example\nfn reverse_delete(s: String, c: String)\
  \ -> (String, bool) {\n"
tests: "}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
  abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
  abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
  dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
  a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"\
  vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
  mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
completions: ["    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    for ch in s.chars() {\n        if ch == c {\n            continue;\n    \
    \    }\n        result.push(ch);\n    }\n    if result != s {\n        is_palindrome\
    \ = false;\n    }\n    (result, is_palindrome)", "    let mut s = String::from(s);\n\
    \    let mut c = String::from(c);\n    let mut result = String::from(\"\");\n\
    \    let mut is_palindrome = true;\n    while !s.is_empty() {\n        if c.contains(&s[s.len()\
    \ - 1]) {\n            s.truncate(s.len() - 1);\n        } else {\n          \
    \  is_palindrome = false;\n            break;\n        }\n    }\n    if is_palindrome\
    \ {\n        result.push_str(&s);\n    }\n    (result, is_palindrome)", "    let\
    \ mut result = String::new();\n    let mut s = s.chars();\n    let mut c = c.chars();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < s.len() && j < c.len()\
    \ {\n        if s[i] == c[j] {\n            result.push(c[j]);\n            i\
    \ += 1;\n            j += 1;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    if i == s.len() {\n        result.push(c[j]);\n    }\n    if j ==\
    \ c.len() {\n        result.push(c[i]);\n    }\n    return (result, s.is_palindrome());",
  "    let mut result = String::new();\n    let mut is_palindrome = false;\n    let\
    \ mut i = s.len() - 1;\n    let mut j = s.len() - 1;\n    while i >= 0 && j >=\
    \ 0 {\n        if s[i] == c[j] {\n            result.append(s[i]);\n         \
    \   i -= 1;\n            j -= 1;\n        } else {\n            i -= 1;\n    \
    \    }\n    }\n    if i == -1 {\n        is_palindrome = true;\n    }\n    (result,\
    \ is_palindrome)", "    let mut s = s;\n    let mut c = c;\n    let mut result\
    \ = \"\";\n    let mut is_palindrome = true;\n    while !s.is_empty() {\n    \
    \    if c.contains(&s[0]) {\n            s = &s[1..];\n        } else {\n    \
    \        is_palindrome = false;\n            break;\n        }\n    }\n    if\
    \ is_palindrome {\n        result = &s[..];\n    }\n    (result, is_palindrome)",
  "    let mut s = String::from(s);\n    let mut c = String::from(c);\n    let mut\
    \ result = String::new();\n    let mut is_palindrome = true;\n    while !s.is_empty()\
    \ {\n        if c.contains(&s[0]) {\n            s = s.chars().filter(|&x| x !=\
    \ s[0]).collect::<String>();\n        } else {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    if is_palindrome {\n        result\
    \ = s.chars().collect::<String>();\n    }\n    (result, is_palindrome)", "   \
    \ let mut s = String::from(s);\n    let mut c = String::from(c);\n    let mut\
    \ result = String::from(s);\n    let mut is_palindrome = true;\n    while !s.is_empty()\
    \ {\n        if c.contains(&s[s.len() - 1]) {\n            s = s.chars().filter(|&x|\
    \ x != s[s.len() - 1]).collect();\n        } else {\n            is_palindrome\
    \ = false;\n            break;\n        }\n    }\n    if is_palindrome {\n   \
    \     return (result, true);\n    } else {\n        return (result, false);\n\
    \    }", "    let mut s = s;\n    let mut c = c;\n    let mut result = \"\";\n\
    \    let mut is_palindrome = true;\n    while s.len() > 0 {\n        if c.contains(&s[s.len()\
    \ - 1]) {\n            result = result + &s[s.len() - 1];\n            s.truncate(s.len()\
    \ - 1);\n        } else {\n            is_palindrome = false;\n            break;\n\
    \        }\n    }\n    if is_palindrome {\n        return (result, true);\n  \
    \  } else {\n        return (result, false);\n    }", "    let mut s = s;\n  \
    \  let mut c = c;\n    let mut result = \"\";\n    let mut flag = false;\n   \
    \ while !s.is_empty() {\n        if c.contains(&s[0]) {\n            s.remove_prefix(1);\n\
    \            c.remove_prefix(1);\n        } else {\n            result += s[0];\n\
    \            s.remove_prefix(1);\n        }\n    }\n    if s == result {\n   \
    \     flag = true;\n    }\n    (result, flag)", "    let mut s = s;\n    let mut\
    \ c = c;\n    let mut result = \"\";\n    let mut flag = false;\n    while !s.is_empty()\
    \ {\n        if c.contains(&s[0]) {\n            s.remove_prefix(1);\n       \
    \     c.remove_prefix(1);\n        } else {\n            result += s[0];\n   \
    \         s.remove_prefix(1);\n        }\n    }\n    if result == c {\n      \
    \  flag = true;\n    }\n    (result, flag)", "    let mut s = String::from(s);\n\
    \    let mut c = String::from(c);\n    let mut result = String::from(\"\");\n\
    \    let mut is_palindrome = true;\n    while !s.is_empty() {\n        if c.contains(&s[0])\
    \ {\n            s.remove_prefix(1);\n        } else {\n            is_palindrome\
    \ = false;\n            break;\n        }\n    }\n    if is_palindrome {\n   \
    \     result.push_str(&s);\n    }\n    (result, is_palindrome)", "    let mut\
    \ s = s;\n    let mut c = c;\n    let mut result = \"\";\n    let mut is_palindrome\
    \ = true;\n    while s.len() > 0 {\n        if c.contains(&s[0]) {\n         \
    \   s.remove_prefix(1);\n        } else {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    if s.len() == 0 {\n        is_palindrome\
    \ = false;\n    }\n    return (result, is_palindrome);", "    let mut result =\
    \ String::new();\n    let mut is_palindrome = false;\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if c == c {\n            result.append(c);\n        } else {\n  \
    \          is_palindrome = false;\n            break;\n        }\n    }\n    if\
    \ is_palindrome {\n        return (result, true);\n    }\n    let mut reversed_s\
    \ = String::new();\n    for (i, c) in s.chars().enumerate() {\n        reversed_s.append(c);\n\
    \    }\n    let mut reversed_c = String::new();\n    for (i, c) in c.chars().enumerate()\
    \ {\n        reversed_c.append(c);\n    }\n    let mut is_palindrome = false;\n\
    \    for (i, c) in reversed_s.chars().enumerate() {\n        if c == reversed_c\
    \ {\n            is_palindrome = true;\n            break;\n        }\n    }\n\
    \    if is_palindrome {\n        return (result, true);\n    }\n    let mut reversed_result\
    \ = String::new();\n    for (i, c) in result.chars().enumerate() {\n        reversed_result.append(c);\n\
    \    }\n    let mut is_palindrome = false;\n    for (i, c) in reversed_result.chars().enumerate()\
    \ {\n        if c == reversed_s {\n            is_palindrome = true;\n       \
    \     break;\n        }\n    }\n    if is_palindrome {\n        return (result,\
    \ true);\n    }\n    let mut reversed_c = String::new();\n    for (i, c) in c.chars().enumerate()\
    \ {\n        reversed_c.append(c);\n    }\n    let mut is_palindrome = false;\n\
    \    for (i, c) in reversed_s.chars().enumerate() {\n        if c == reversed_c\
    \ {\n            is_palindrome = true;\n            break;\n        }\n    }\n\
    \    if is_palindrome {\n        return (result, true);\n    }\n    let mut reversed_result\
    \ = String::new();\n    for (i, c) in result.chars().enumerate() {\n        reversed_result.append(c);\n\
    \    }\n    let mut is_palindrome = false;\n    for (i, c) in reversed_result.chars().enumerate()\
    \ {\n        if c == reversed_c {\n            is_palindrome = true;\n       \
    \     break;\n        }\n    }\n    if is_palindrome {\n        return (result,\
    \ true);\n    }\n    let mut reversed_s = String::new();\n    for (i, c) in s.chars().enumerate()\
    \ {\n        reversed_s.append(c);\n    }\n    let mut is_palindrome = false;\n\
    \    for (i, c) in reversed_s.chars().enumerate() {\n        if c == reversed_c\
    \ {\n            is_palindrome = true;\n            break;\n        }\n    }\n\
    \    if is_palindrome {\n", "    let mut s = s;\n    let mut c = c;\n    let mut\
    \ result = \"\";\n    let mut flag = false;\n    while !s.is_empty() {\n     \
    \   if c.contains(&s[0]) {\n            result += &s[0];\n            s.truncate(1);\n\
    \        } else {\n            result += &s[0];\n            s.truncate(1);\n\
    \            flag = true;\n        }\n    }\n    if flag {\n        return (result,\
    \ true);\n    } else {\n        return (result, false);\n    }", "    let mut\
    \ s = s;\n    let mut c = c;\n    let mut result = \"\";\n    let mut is_palindrome\
    \ = true;\n    while !s.is_empty() {\n        if s.chars().any(|c| c == c.chars().nth(s.len()\
    \ - 1)) {\n            s += c;\n        } else {\n            is_palindrome =\
    \ false;\n        }\n    }\n    while !c.is_empty() {\n        if c.chars().any(|c|\
    \ c == c.chars().nth(s.len() - 1)) {\n            c += s;\n        } else {\n\
    \            is_palindrome = false;\n        }\n    }\n    (s, is_palindrome)",
  "    let mut result = String::new();\n    let mut is_palindrome = true;\n    for\
    \ (i, c) in s.chars().enumerate() {\n        if c == c {\n            result.append(c);\n\
    \        } else {\n            is_palindrome = false;\n            break;\n  \
    \      }\n    }\n    (result, is_palindrome)", "    let mut s = String::from(s);\n\
    \    let mut c = String::from(c);\n    let mut result = String::from(\"\");\n\
    \    let mut is_palindrome = true;\n    while !s.is_empty() {\n        if c.contains(&s[s.len()\
    \ - 1]) {\n            s = s.chars().filter(|&x| x != s[s.len() - 1]).collect();\n\
    \        } else {\n            is_palindrome = false;\n            break;\n  \
    \      }\n    }\n    if is_palindrome {\n        result = s.chars().collect();\n\
    \    }\n    (result, is_palindrome)", "    let mut s = s;\n    let mut c = c;\n\
    \    let mut result = \"\";\n    let mut is_palindrome = true;\n    while s.len()\
    \ > 0 {\n        if s.chars().any(|c| c == c.chars().nth(s.len() - 1)) {\n   \
    \         result += &s.chars().nth(s.len() - 1);\n            s = &s[s.len() -\
    \ 1];\n        } else {\n            is_palindrome = false;\n            break;\n\
    \        }\n    }\n    if is_palindrome {\n        return (result, true);\n  \
    \  } else {\n        return (result, false);\n    }", "    let mut s = String::from(s);\n\
    \    let mut c = String::from(c);\n    let mut result = String::from(\"\");\n\
    \    let mut is_palindrome = true;\n    while !s.is_empty() {\n        if c.contains(&s[s.len()\
    \ - 1]) {\n            s = s.chars().filter(|&x| x != s[s.len() - 1]).collect::<String>();\n\
    \        } else {\n            is_palindrome = false;\n            break;\n  \
    \      }\n    }\n    if is_palindrome {\n        result = s.chars().collect::<String>();\n\
    \    }\n    (result, is_palindrome)", "    let mut s = s;\n    let mut c = c;\n\
    \    let mut result = \"\";\n    let mut is_palindrome = true;\n\n    while !s.is_empty()\
    \ {\n        if c.contains(&s[0]) {\n            s = s.chars().filter(|&x| x !=\
    \ s[0]).collect::<String>();\n        } else {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n\n    if is_palindrome {\n        result\
    \ = s.chars().collect::<String>();\n    }\n\n    (result, is_palindrome)"]
stop_tokens:
- "\n}"
