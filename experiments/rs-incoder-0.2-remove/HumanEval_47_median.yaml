name: HumanEval_47_median
language: rs
prompt: "/// Return median of elements in the list l.\nfn median(l: Vec<isize>) ->\
  \ f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "   \
    \ let mut s = l.len();\n    l.sort();\n    l.iter().fold(0.0, |a, b| {\n     \
    \   if b - a > 1 {\n            a + (b - a - 1) / 2.0\n        } else {\n    \
    \        a\n        }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\n    \
    \              |a, b| if b < a { b } else { a })", "    l.iter().fold(0.0, |a,\
    \ b| {\n        b.cmp(&a).unwrap().partial_cmp(&b).unwrap().unwrap()\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\n                  |a,\
    \ b| if b < a { b } else { a })", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    let mut mid = l.len() / 2;\n    let mut low = mid;\n    let\
    \ mut high = mid;\n    while low < high {\n        if l[low] > l[high] {\n   \
    \         high = mid;\n        } else {\n            low = mid + 1;\n        }\n\
    \        mid = (low + high) / 2;\n    }\n    l[mid]", "    l.iter().fold(0.0,\
    \ |a, b| {\n        if a > b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(b).unwrap().sqrt()\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.cmp(&a).unwrap().partial_cmp(&b).unwrap().unwrap()\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(0.0, |a, b| {\n        if *a < *b {\n            a\n\
    \        } else {\n            b\n        }\n    })", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0,\
    \ |a, b| {\n        if a > b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match b {\n  \
    \          None => a,\n            Some(x) => if x < a { a } else { x },\n   \
    \     }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.cmp(&a).unwrap().partial_cmp(&b).unwrap().unwrap()\n\
    \    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "   \
    \ let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        match\
    \ b {\n            0 => a,\n            _ => a + 1.0,\n        }\n    }) / l.len()",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        if a > b {\n    \
    \        a\n        } else {\n            b\n        }\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    let len = l.len();\n    l.len() / 2.0", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.cmp(&a).unwrap().partial_cmp(&b).unwrap().unwrap()\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(f64::NEG_INFINITY,\n                  |acc, x| if acc.is_nan()\
    \ || x < acc {\n                      acc\n                  } else {\n      \
    \                x\n                  })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        a.checked_add(f64::from(b)).unwrap()\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if b < a { b\
    \ } else { a }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.cmp(&a).unwrap().partial_cmp(&b).unwrap().unwrap()\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY,\n                  |a, b| if b\
    \ < a { b } else { a })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(0.0, |a, b| {\n        b.cmp(&a).unwrap().partial_cmp(&b).unwrap().unwrap()\n\
    \    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "   \
    \ let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\n                  |a,\
    \ b| if b < a { b } else { a })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.cmp(&a).unwrap().partial_cmp(&b).unwrap().unwrap()\n   \
    \ })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a > b {\n  \
    \          a\n        } else {\n            b\n        }\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2",
  "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l =\
    \ l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   l.iter().fold(0.0, |a, b| {\n        b.cmp(&a).unwrap().floor() as f64\n \
    \   })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut s = l.iter().fold(0, |a, b| a + b);\n    l.iter().fold(s.floor(), |a, b|\
    \ {\n        if b < a { a } else { b }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    let mid = l.len() / 2;\n    l.swap(0, mid);\n    l[mid]",
  "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l =\
    \ l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b|\
    \ {\n        b.cmp(&a).unwrap().partial_cmp(&b).unwrap().unwrap()\n    })", " \
    \   let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l =\
    \ l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.cmp(&a).unwrap().partial_cmp(&b).unwrap().unwrap()\n\
    \    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "   \
    \ let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        if a > b {\n    \
    \        a\n        } else {\n            b\n        }\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n    l.len()\
    \ / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut s = l.len();\n    if s == 0 {\n        return\
    \ 0.0;\n    }\n    let mut mid = s >> 1;\n    let mut low = l[mid..];\n    let\
    \ mut high = l[..mid];\n    let mut midval: f64;\n    let mut lowval: f64;\n \
    \   let mut highval: f64;\n    while low != high {\n        midval = low.iter().fold(0.0,\
    \ |x, y| x + y) / mid;\n        lowval = low.iter().fold(0.0, |x, y| x + y) /\
    \ low;\n        highval = high.iter().fold(0.0, |x, y| x + y) / high;\n      \
    \  if midval < lowval {\n            low = low.iter().skip(mid).collect();\n \
    \       } else {\n            high = high.iter().skip(mid).collect();\n      \
    \  }\n    }\n    midval", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut s = l.iter().cloned().collect::<Vec<_>>();\n\
    \    s.sort();\n    s.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        a.checked_add(b).unwrap()\
    \ / 2.0\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut s = l.len();\n    l.sort();\n \
    \   if s % 2 == 0 {\n        l.len() / 2\n    } else {\n        l.len() / 2 -\
    \ 1\n    }", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", " \
    \   let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l =\
    \ l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        if *a > *b {\n            a\n        } else {\n            b\n  \
    \      }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\n                  |acc,\
    \ x| if x < acc { x } else { acc })", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        if b < a { b } else\
    \ { a }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    let len = l.len();\n    l.iter().skip(len / 2).fold(l.iter().next().unwrap(),\
    \ |a, b| a + b) / 2.0", "    l.iter().fold(0.0, |a, b| {\n        if a > b {\n\
    \            a\n        } else {\n            b\n        }\n    })", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2"]
stop_tokens:
- "\n}"
