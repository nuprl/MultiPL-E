language: rs
name: HumanEval_58_common
results:
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if !l2.contains(&i) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdunrf10n.rs:9:5\n  |\n2 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(*l2.pop());\n        } else if l2.len() == 0 {\n          \
    \  result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(*l1.pop());\n   \
    \                 i += 1;\n                } else {\n                    result.push(*l2.pop());\n\
    \                    i += 1;\n                }\n            }\n            while\
    \ l1.len() > 0 {\n                result.push(*l1.pop());\n                i +=\
    \ 1;\n            }\n            while l2.len() > 0 {\n                result.push(*l2.pop());\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n --> /tmp/tmpo2csj7jl.rs:8:25\n\
    \  |\n8 |             result.push(*l2.pop());\n  |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpo2csj7jl.rs:10:25\n\
    \   |\n10 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpo2csj7jl.rs:17:33\n   |\n17 |                     result.push(*l1.pop());\n\
    \   |                                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpo2csj7jl.rs:20:33\n   |\n20 |        \
    \             result.push(*l2.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpo2csj7jl.rs:25:29\n\
    \   |\n25 |                 result.push(*l1.pop());\n   |                    \
    \         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmpo2csj7jl.rs:29:29\n   |\n29 |                 result.push(*l2.pop());\n\
    \   |                             ^^^^^^^^^\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747550
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i]\
    \ == l2[i] {\n            result.push(l1[i]);\n            i += 1;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpndg4vi4u.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned().chain(l2.iter().cloned()) {\n        if result.iter().any(|&x|\
    \ x == i) {\n            continue;\n        }\n        result.push(i);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpfhmg0_ng.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[i] < l2[i] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n            while l1.len() >\
    \ 0 {\n                result.push(l1.pop());\n            }\n            while\
    \ l2.len() > 0 {\n                result.push(l2.pop());\n            }\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkz4rek1x.rs:31:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n31 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while\
    \ let Some(i) = l1_iter.next() {\n        if let Some(j) = l2_iter.next() {\n\
    \            if i == j {\n                continue;\n            }\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5icro07g.rs:14:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n14 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1.clone();\n \
    \   l.retain(l2);\n    l\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `Vec<isize>`\n\
    \ --> /tmp/tmpbrqwy4sw.rs:4:14\n  |\n4 |     l.retain(l2);\n  |              ^^\
    \ expected an `FnMut<(&isize,)>` closure, found `Vec<isize>`\n  |\n  = help: the\
    \ trait `for<'r> FnMut<(&'r isize,)>` is not implemented for `Vec<isize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    let mut l4 = l2.clone();\n    l4.sort();\n    l3.iter().zip(l4.iter()).filter(|&(i,\
    \ j)| i == j).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n --> /tmp/tmpsbq7iymr.rs:7:55\n  |\n\
    7 |     l3.iter().zip(l4.iter()).filter(|&(i, j)| i == j).collect()\n  |     \
    \                                                  ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n  |\n  =\
    \ help: the trait `FromIterator<(&isize, &isize)>` is not implemented for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(*l2.pop());\n        } else if l2.len() == 0 {\n          \
    \  result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if *l1.front() == *l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(*l1.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n --> /tmp/tmpkyjvklop.rs:8:25\n\
    \  |\n8 |             result.push(*l2.pop());\n  |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:10:25\n\
    \   |\n10 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:24\n   |\n15 |          \
    \       if *l1.front() == *l2.front() {\n   |                        ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:39\n\
    \   |\n15 |                 if *l1.front() == *l2.front() {\n   |            \
    \                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:22:25\n\
    \   |\n22 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if !l2.contains(&i) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdunrf10n.rs:9:5\n  |\n2 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.last().unwrap() == l2.last().unwrap() {\n         \
    \               l1.pop();\n                        l2.pop();\n               \
    \     } else {\n                        break;\n                    }\n      \
    \          }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzty5u0t8.rs:30:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(*l2.pop());\n        } else if l2.len() == 0 {\n          \
    \  result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if *l1.front() == *l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(*l1.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n --> /tmp/tmpkyjvklop.rs:8:25\n\
    \  |\n8 |             result.push(*l2.pop());\n  |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:10:25\n\
    \   |\n10 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:24\n   |\n15 |          \
    \       if *l1.front() == *l2.front() {\n   |                        ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:39\n\
    \   |\n15 |                 if *l1.front() == *l2.front() {\n   |            \
    \                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:22:25\n\
    \   |\n22 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.last() == l2.last() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkxfc_ay7.rs:30:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
