language: rs
name: HumanEval_58_common
results:
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if !l2.contains(&i) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdunrf10n.rs:9:5\n  |\n2 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(*l2.pop());\n        } else if l2.len() == 0 {\n          \
    \  result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(*l1.pop());\n   \
    \                 i += 1;\n                } else {\n                    result.push(*l2.pop());\n\
    \                    i += 1;\n                }\n            }\n            while\
    \ l1.len() > 0 {\n                result.push(*l1.pop());\n                i +=\
    \ 1;\n            }\n            while l2.len() > 0 {\n                result.push(*l2.pop());\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n --> /tmp/tmpo2csj7jl.rs:8:25\n\
    \  |\n8 |             result.push(*l2.pop());\n  |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpo2csj7jl.rs:10:25\n\
    \   |\n10 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpo2csj7jl.rs:17:33\n   |\n17 |                     result.push(*l1.pop());\n\
    \   |                                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpo2csj7jl.rs:20:33\n   |\n20 |        \
    \             result.push(*l2.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpo2csj7jl.rs:25:29\n\
    \   |\n25 |                 result.push(*l1.pop());\n   |                    \
    \         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmpo2csj7jl.rs:29:29\n   |\n29 |                 result.push(*l2.pop());\n\
    \   |                             ^^^^^^^^^\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747550
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i]\
    \ == l2[i] {\n            result.push(l1[i]);\n            i += 1;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpndg4vi4u.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned().chain(l2.iter().cloned()) {\n        if result.iter().any(|&x|\
    \ x == i) {\n            continue;\n        }\n        result.push(i);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpfhmg0_ng.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[i] < l2[i] {\n                    result.push(l1.pop());\n    \
    \            } else {\n                    result.push(l2.pop());\n          \
    \      }\n                i += 1;\n            }\n            while l1.len() >\
    \ 0 {\n                result.push(l1.pop());\n            }\n            while\
    \ l2.len() > 0 {\n                result.push(l2.pop());\n            }\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkz4rek1x.rs:31:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n31 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while\
    \ let Some(i) = l1_iter.next() {\n        if let Some(j) = l2_iter.next() {\n\
    \            if i == j {\n                continue;\n            }\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5icro07g.rs:14:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n14 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1.clone();\n \
    \   l.retain(l2);\n    l\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `Vec<isize>`\n\
    \ --> /tmp/tmpbrqwy4sw.rs:4:14\n  |\n4 |     l.retain(l2);\n  |              ^^\
    \ expected an `FnMut<(&isize,)>` closure, found `Vec<isize>`\n  |\n  = help: the\
    \ trait `for<'r> FnMut<(&'r isize,)>` is not implemented for `Vec<isize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    let mut l4 = l2.clone();\n    l4.sort();\n    l3.iter().zip(l4.iter()).filter(|&(i,\
    \ j)| i == j).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n --> /tmp/tmpsbq7iymr.rs:7:55\n  |\n\
    7 |     l3.iter().zip(l4.iter()).filter(|&(i, j)| i == j).collect()\n  |     \
    \                                                  ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n  |\n  =\
    \ help: the trait `FromIterator<(&isize, &isize)>` is not implemented for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(*l2.pop());\n        } else if l2.len() == 0 {\n          \
    \  result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if *l1.front() == *l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(*l1.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n --> /tmp/tmpkyjvklop.rs:8:25\n\
    \  |\n8 |             result.push(*l2.pop());\n  |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:10:25\n\
    \   |\n10 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:24\n   |\n15 |          \
    \       if *l1.front() == *l2.front() {\n   |                        ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:39\n\
    \   |\n15 |                 if *l1.front() == *l2.front() {\n   |            \
    \                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:22:25\n\
    \   |\n22 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if !l2.contains(&i) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdunrf10n.rs:9:5\n  |\n2 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.last().unwrap() == l2.last().unwrap() {\n         \
    \               l1.pop();\n                        l2.pop();\n               \
    \     } else {\n                        break;\n                    }\n      \
    \          }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzty5u0t8.rs:30:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(*l2.pop());\n        } else if l2.len() == 0 {\n          \
    \  result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if *l1.front() == *l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(*l1.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n --> /tmp/tmpkyjvklop.rs:8:25\n\
    \  |\n8 |             result.push(*l2.pop());\n  |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:10:25\n\
    \   |\n10 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:24\n   |\n15 |          \
    \       if *l1.front() == *l2.front() {\n   |                        ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:39\n\
    \   |\n15 |                 if *l1.front() == *l2.front() {\n   |            \
    \                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:22:25\n\
    \   |\n22 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.last() == l2.last() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkxfc_ay7.rs:30:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpf19sq5up.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpf19sq5up.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     res\n  |     ^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2[0]);\n            l2.pop();\n        } else if l2.len()\
    \ == 0 {\n            result.push(l1[0]);\n            l1.pop();\n        } else\
    \ {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n      \
    \      let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n            while\
    \ l1.len() > 0 && l2.len() > 0 {\n                if l1[0] < l2[0] {\n       \
    \             result.push(l1[0]);\n                    l1.pop();\n           \
    \     } else {\n                    result.push(l2[0]);\n                    l2.pop();\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for el1 in l1 {\n        for el2 in l2 {\n            if el1 == el2 {\n \
    \               l3.push(el1);\n                break;\n            }\n       \
    \ }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l2`\n   --> /tmp/tmp94j8ix83.rs:5:20\n\
    \    |\n2   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                           -- move occurs because `l2` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n5   |         for el2 in l2\
    \ {\n    |                    ^^ `l2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l2`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n5\
    \   |         for el2 in &l2 {\n    |                    +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    l1.sort_unstable();\n    l2.sort_unstable();\n    while l1.len() > 0 || l2.len()\
    \ > 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n           \
    \ l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \ --> /tmp/tmp1xh0k1i6.rs:4:5\n  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n  |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n3 |     let mut l3 = Vec::new();\n4 |     l1.sort_unstable();\n  |\
    \     ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `l2` as mutable, as it is not declared as mutable\n --> /tmp/tmp1xh0k1i6.rs:5:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                      -- help: consider changing this to be mutable: `mut l2`\n\
    ...\n5 |     l2.sort_unstable();\n  |     ^^^^^^^^^^^^^^^^^^ cannot borrow as\
    \ mutable\n\nerror[E0596]: cannot borrow `l2` as mutable, as it is not declared\
    \ as mutable\n --> /tmp/tmp1xh0k1i6.rs:9:13\n  |\n2 | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n  |                           -- help: consider\
    \ changing this to be mutable: `mut l2`\n...\n9 |             l2.pop();\n  | \
    \            ^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `l1` as mutable, as it is not declared as mutable\n  --> /tmp/tmp1xh0k1i6.rs:12:13\n\
    \   |\n2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \         -- help: consider changing this to be mutable: `mut l1`\n...\n12 | \
    \            l1.pop();\n   |             ^^^^^^^^ cannot borrow as mutable\n\n\
    error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp1xh0k1i6.rs:16:17\n   |\n2  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n16 |                 l1.pop();\n   |                 ^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `l2` as mutable, as\
    \ it is not declared as mutable\n  --> /tmp/tmp1xh0k1i6.rs:19:17\n   |\n2  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \            -- help: consider changing this to be mutable: `mut l2`\n...\n19\
    \ |                 l2.pop();\n   |                 ^^^^^^^^ cann"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1[l1.len() - 1] == l2[l2.len() - 1] {\n             \
    \           l1.pop();\n                        l2.pop();\n                   \
    \ } else {\n                        break;\n                    }\n          \
    \      }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2vpexmai.rs:30:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.retain(l2.clone());\n    l3\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `Vec<isize>`\n\
    \    --> /tmp/tmpzmjnxq0_.rs:5:15\n     |\n5    |     l3.retain(l2.clone());\n\
    \     |        ------ ^^^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found\
    \ `Vec<isize>`\n     |        |\n     |        required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `for<'r> FnMut<(&'r isize,)>` is\
    \ not implemented for `Vec<isize>`\nnote: required by a bound in `Vec::<T, A>::retain`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbxvw1cc.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort_unstable();\n    l3.dedup();\n    l3.sort_unstable();\n    l3.dedup();\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpcitft7bm.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbxvw1cc.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1.clone();\n \
    \   l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l.sort_unstable();\n\
    \    l = l.iter().cloned().collect();\n    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l.sort_unstable();\n\
    \    l = l.iter().cloned().collect();\n    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l.sort_unstable();\n\
    \    l = l.iter().cloned().collect();\n    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l.sort_unstable();\n\
    \    l = l.iter().cloned().collect();\n    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l.sort_unstable();\n\
    \    l = l.iter().cloned().collect();\n    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l.sort_unstable();\n\
    \    l = l.iter().cloned().collect();\n    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l.sort_unstable();\n\
    \    l = l.iter().cloned().collect();\n    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l.sort_unstable();\n\
    \    l = l.iter().cloned().collect();\n    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l.sort_unstable();\n\
    \    l = l.iter().cloned().collect();\n    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l = l.iter().cloned().collect();\n\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptv1u_x8t.rs:2:46\n  |\n2 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------   \
    \                                 ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit\
    \ type `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if !l2.contains(&i) {\n          \
    \  result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpbf8ucvmj.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n\
    \    l3.dedup();\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpbkp1v8pm.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i]\
    \ == l2[i] {\n            result.push(l1[i]);\n            i += 1;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpndg4vi4u.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1.clone();\n \
    \   l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l = l2.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 5, 7, 9, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmppzvrm3or.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop().unwrap());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop().unwrap());\n        } else {\n            let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            while l1.len() != 0 || l2.len() != 0 {\n                if l1.len()\
    \ == 0 {\n                    result.push(l2.pop().unwrap());\n              \
    \  } else if l2.len() == 0 {\n                    result.push(l1.pop().unwrap());\n\
    \                } else {\n                    if l1.iter().next().unwrap() ==\
    \ l2.iter().next().unwrap() {\n                        l1.pop();\n           \
    \             l2.pop();\n                    } else {\n                      \
    \  break;\n                    }\n                }\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for el1 in l1 {\n        for el2 in l2 {\n            if el1 == el2 {\n \
    \               l3.push(el1);\n                break;\n            }\n       \
    \ }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l2`\n   --> /tmp/tmp94j8ix83.rs:5:20\n\
    \    |\n2   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                           -- move occurs because `l2` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n5   |         for el2 in l2\
    \ {\n    |                    ^^ `l2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l2`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n5\
    \   |         for el2 in &l2 {\n    |                    +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i]\
    \ == l2[i] {\n            result.push(l1[i]);\n            i += 1;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpndg4vi4u.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2[0]);\n            l2.remove(0);\n        } else if l2.len()\
    \ == 0 {\n            result.push(l1[0]);\n            l1.remove(0);\n       \
    \ } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1[0] < l2[0] {\n                    result.push(l1[0]);\n       \
    \             l1.remove(0);\n                } else {\n                    result.push(l2[0]);\n\
    \                    l2.remove(0);\n                }\n                i += 1;\n\
    \            }\n            while l1.len() > 0 {\n                result.push(l1[0]);\n\
    \                l1.remove(0);\n                i += 1;\n            }\n     \
    \       while l2.len() > 0 {\n                result.push(l2[0]);\n          \
    \      l2.remove(0);\n                i += 1;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned().chain(l2.iter().cloned()) {\n        if result.contains(&i)\
    \ {\n            continue;\n        }\n        result.push(i);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpjbavsavu.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbxvw1cc.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp2uviulpd.rs:20:27\n   |\n20 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2uviulpd.rs:20:41\n\
    \   |\n20 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2uviulpd.rs:30:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            if l1.len() == 0 {\n                result.push(l2.pop());\n    \
    \        } else if l2.len() == 0 {\n                result.push(l1.pop());\n \
    \           } else {\n                break;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpqk6xxxz4.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpqk6xxxz4.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqk6xxxz4.rs:31:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n31 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop().unwrap());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop().unwrap());\n        } else {\n            let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            while l1.len() != 0 || l2.len() != 0 {\n                if l1.len()\
    \ == 0 {\n                    result.push(l2.pop().unwrap());\n              \
    \  } else if l2.len() == 0 {\n                    result.push(l1.pop().unwrap());\n\
    \                } else {\n                    if l1.last().unwrap() == l2.last().unwrap()\
    \ {\n                        l1.pop();\n                        l2.pop();\n  \
    \                  } else {\n                        break;\n                \
    \    }\n                }\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(*l2.pop());\n        } else if l2.len() == 0 {\n          \
    \  result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if *l1.front() == *l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(*l1.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n --> /tmp/tmpkyjvklop.rs:8:25\n\
    \  |\n8 |             result.push(*l2.pop());\n  |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:10:25\n\
    \   |\n10 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:24\n   |\n15 |          \
    \       if *l1.front() == *l2.front() {\n   |                        ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:39\n\
    \   |\n15 |                 if *l1.front() == *l2.front() {\n   |            \
    \                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:22:25\n\
    \   |\n22 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if !l2.contains(&i) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdunrf10n.rs:9:5\n  |\n2 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1.clone();\n \
    \   l.sort_unstable();\n    let mut r = l2.clone();\n    r.sort_unstable();\n\
    \    let mut res = vec![];\n    while l.len() > 0 || r.len() > 0 {\n        if\
    \ l.len() == 0 {\n            res.push(0);\n            break;\n        }\n  \
    \      if r.len() == 0 {\n            res.push(0);\n            break;\n     \
    \   }\n        if l[0] < r[0] {\n            res.push(l[0]);\n            l.remove(0);\n\
    \        } else {\n            res.push(r[0]);\n            r.remove(0);\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3, 4, 5, 5, 5, 7, 9, 34, 121, 653, 0]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmpg1ue9yo_.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.last().unwrap() == l2.last().unwrap() {\n         \
    \               l1.pop();\n                        l2.pop();\n               \
    \     } else {\n                        break;\n                    }\n      \
    \          }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzty5u0t8.rs:30:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.retain(l2.clone());\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `Vec<isize>`\n\
    \    --> /tmp/tmpm62jyqks.rs:4:15\n     |\n4    |     l3.retain(l2.clone());\n\
    \     |        ------ ^^^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found\
    \ `Vec<isize>`\n     |        |\n     |        required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `for<'r> FnMut<(&'r isize,)>` is\
    \ not implemented for `Vec<isize>`\nnote: required by a bound in `Vec::<T, A>::retain`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 && l1.front()\
    \ == l2.front() {\n                i += 1;\n                l1.pop();\n      \
    \          l2.pop();\n            }\n            result.push(i);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpyhpnxijg.rs:15:54\n   |\n15 |             while\
    \ l1.len() > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |           \
    \                                           ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpyhpnxijg.rs:15:68\n   |\n15 |             while l1.len()\
    \ > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |                    \
    \                                                ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyhpnxijg.rs:20:25\n   |\n20 |\
    \             result.push(i);\n   |                         ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    20 |             result.push(Some(i));\n   |                         +++++ +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyhpnxijg.rs:23:5\n   |\n2  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n23 |     result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while\
    \ l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any()\
    \ {\n            if l1_iter.peek() == l2_iter.peek() {\n                result.push(l1_iter.next());\n\
    \                result.push(l2_iter.next());\n            } else {\n        \
    \        result.push(l1_iter.peek());\n                result.push(l2_iter.peek());\n\
    \            }\n        } else if l1_iter.any() {\n            result.push(l1_iter.next());\n\
    \        } else {\n            result.push(l2_iter.next());\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpw7ghg2i7.rs:6:19\n     |\n6    |     while l1_iter.any() || l2_iter.any()\
    \ {\n     |                   ^^^- supplied 0 arguments\n     |              \
    \     |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 0\
    \ arguments were supplied\n    --> /tmp/tmpw7ghg2i7.rs:6:36\n     |\n6    |  \
    \   while l1_iter.any() || l2_iter.any() {\n     |                           \
    \         ^^^- supplied 0 arguments\n     |                                  \
    \  |\n     |                                    expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpw7ghg2i7.rs:7:20\n \
    \    |\n7    |         if l1_iter.any() && l2_iter.any() {\n     |           \
    \         ^^^- supplied 0 arguments\n     |                    |\n     |     \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpw7ghg2i7.rs:7:37\n     |\n7    |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmpw7ghg2i7.rs:8:24\n  |\n8 |             if\
    \ l1_iter.peek() == l2_iter.peek() {\n  |                        ^^^^ method not\
    \ found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named `peek`\
    \ found for struct `std::slice::Iter` in the current scope\n --> /tmp/tmpw7ghg2i7.rs:8:42\n\
    \  |\n8 |             if l1_iter.peek() == l2_iter.peek() {\n  |             \
    \                             ^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror[E0599]: no method named `peek` found for str"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(*l2.pop());\n        } else if l2.len() == 0 {\n        \
    \    result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(*l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(*l1.pop());\n                } else\
    \ {\n                    if l1.len() == l2.len() {\n                        if\
    \ l1.len() == 1 {\n                            result.push(*l1.pop());\n     \
    \                   } else {\n                            l1.pop();\n        \
    \                    l2.pop();\n                        }\n                  \
    \  } else {\n                        l1.pop();\n                        l2.pop();\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n --> /tmp/tmp2d_gqz_n.rs:8:25\n\
    \  |\n8 |             result.push(*l2.pop());\n  |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp2d_gqz_n.rs:10:25\n\
    \   |\n10 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmp2d_gqz_n.rs:16:33\n   |\n16 |                     result.push(*l2.pop());\n\
    \   |                                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp2d_gqz_n.rs:18:33\n   |\n18 |        \
    \             result.push(*l1.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmp2d_gqz_n.rs:22:41\n\
    \   |\n22 | ...                   result.push(*l1.pop());\n   |              \
    \                     ^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp2uviulpd.rs:20:27\n   |\n20 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2uviulpd.rs:20:41\n\
    \   |\n20 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2uviulpd.rs:30:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l = l1.clone();\n \
    \   l.sort_unstable();\n    l = l.iter().cloned().collect();\n    l = l2.iter().cloned().collect();\n\
    \    l.sort_unstable();\n    l\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 5, 7, 9, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmppzvrm3or.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.retain(l2.clone());\n    l3\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `Vec<isize>`\n\
    \    --> /tmp/tmpzmjnxq0_.rs:5:15\n     |\n5    |     l3.retain(l2.clone());\n\
    \     |        ------ ^^^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found\
    \ `Vec<isize>`\n     |        |\n     |        required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `for<'r> FnMut<(&'r isize,)>` is\
    \ not implemented for `Vec<isize>`\nnote: required by a bound in `Vec::<T, A>::retain`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n\
    \    let mut l1_next = l1.iter().cloned();\n    let mut l2_next = l2.iter().cloned();\n\
    \    while l1_iter.next() && l2_iter.next() {\n        if l1_next.next() == l2_next.next()\
    \ {\n            result.push(l1_next.clone());\n            l1_next = l1.iter().cloned();\n\
    \            l2_next = l2.iter().cloned();\n        } else {\n            if l1_next.next()\
    \ < l2_next.next() {\n                l1_next = l1.iter().cloned();\n        \
    \    } else {\n                l2_next = l2.iter().cloned();\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqatrztb1.rs:8:11\n  |\n8 |\
    \     while l1_iter.next() && l2_iter.next() {\n  |           ^^^^^^^^^^^^^^ expected\
    \ `bool`, found enum `Option`\n  |\n  = note: expected type `bool`\n         \
    \    found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpqatrztb1.rs:8:29\n\
    \  |\n8 |     while l1_iter.next() && l2_iter.next() {\n  |                  \
    \           ^^^^^^^^^^^^^^ expected `bool`, found enum `Option`\n  |\n  = note:\
    \ expected type `bool`\n             found enum `Option<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqatrztb1.rs:21:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n21 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found struct `Cloned`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n              found struct `Vec<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.len() == l2.len() {\n                        let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n                        let mut\
    \ l2 = l2.iter().cloned().collect::<Vec<_>>();\n                        while\
    \ l1.len() != 0 || l2.len() != 0 {\n                            if l1.len() ==\
    \ 0 {\n                                result.push(l2.pop());\n              \
    \              } else if l2.len() == 0 {\n                                result.push(l1.pop());\n\
    \                            } else {\n                                if l1.len()\
    \ == l2.len() {\n                                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkxwp_lpn.rs:40:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n40 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbxvw1cc.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop().unwrap());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop().unwrap());\n        } else {\n            let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop().unwrap());\n\
    \                } else if l2.len() == 0 {\n                    result.push(l1.pop().unwrap());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     if l1.len() == i {\n                            result.push(l1.pop().unwrap());\n\
    \                        } else {\n                            result.push(l2.pop().unwrap());\n\
    \                        }\n                    } else {\n                   \
    \     if l1.len() < l2.len() {\n                            result.push(l1.pop().unwrap());\n\
    \                        } else {\n                            result.push(l2.pop().unwrap());\n\
    \                        }\n                    }\n                }\n       \
    \         i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 && l1.front()\
    \ == l2.front() {\n                l1.pop();\n                l2.pop();\n    \
    \            i += 1;\n            }\n            result.push(i);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpp8jtm8cv.rs:15:54\n   |\n15 |             while\
    \ l1.len() > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |           \
    \                                           ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpp8jtm8cv.rs:15:68\n   |\n15 |             while l1.len()\
    \ > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |                    \
    \                                                ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp8jtm8cv.rs:20:25\n   |\n20 |\
    \             result.push(i);\n   |                         ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    20 |             result.push(Some(i));\n   |                         +++++ +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp8jtm8cv.rs:23:5\n   |\n2  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n23 |     result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned().chain(l2.iter().cloned()) {\n        if result.iter().any(|&x|\
    \ x == i) {\n            continue;\n        }\n        result.push(i);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpfhmg0_ng.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut\
    \ l1_next = l1_iter.next();\n    let mut l2_next = l2_iter.next();\n    while\
    \ l1_next != l2_next {\n        if l1_next.unwrap() == l2_next.unwrap() {\n  \
    \          result.push(l1_next.unwrap());\n            l1_next = l1_iter.next();\n\
    \            l2_next = l2_iter.next();\n        } else {\n            if l1_next.unwrap()\
    \ < l2_next.unwrap() {\n                l1_next = l1_iter.next();\n          \
    \  } else {\n                l2_next = l2_iter.next();\n            }\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdu26dus5.rs:21:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n21 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0 {\n      \
    \          if l1.len() == 0 {\n                    result.push(l2.pop());\n  \
    \              } else if l2.len() == 0 {\n                    result.push(l1.pop());\n\
    \                } else {\n                    if l1.peek() == l2.peek() {\n \
    \                       i += 1;\n                    } else {\n              \
    \          break;\n                    }\n                }\n            }\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `peek` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpebecflkv.rs:21:27\n   |\n21 |                 \
    \    if l1.peek() == l2.peek() {\n   |                           ^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `peek` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpebecflkv.rs:21:40\n   |\n21\
    \ |                     if l1.peek() == l2.peek() {\n   |                    \
    \                    ^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpebecflkv.rs:30:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    for el in l1 {\n        if l4.contains(&el)\
    \ {\n            continue;\n        }\n        for el2 in l2 {\n            if\
    \ el == el2 {\n                l3.push(el);\n                l4.push(el2);\n \
    \               break;\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l2`\n   --> /tmp/tmpmul4yoa1.rs:9:20\n\
    \    |\n2   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                           -- move occurs because `l2` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n9   |         for el2 in l2\
    \ {\n    |                    ^^ `l2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l2`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n9\
    \   |         for el2 in &l2 {\n    |                    +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpf19sq5up.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpf19sq5up.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     res\n  |     ^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if !l2.contains(&i) {\n          \
    \  result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpbf8ucvmj.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbxvw1cc.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 && l1.front()\
    \ == l2.front() {\n                i += 1;\n                l1.pop();\n      \
    \          l2.pop();\n            }\n            result.push(i);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmppu24su88.rs:15:56\n   |\n15 |             while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |         \
    \                                               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmppu24su88.rs:15:70\n   |\n15 |             while l1.len()\
    \ != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |                  \
    \                                                    ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppu24su88.rs:20:25\n\
    \   |\n20 |             result.push(i);\n   |                         ^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |             result.push(Some(i));\n   |                         +++++\
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppu24su88.rs:23:5\n   |\n\
    2  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for el1 in l1 {\n        for el2 in l2 {\n            if el1 == el2 {\n \
    \               l3.push(el1);\n                break;\n            }\n       \
    \ }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l2`\n   --> /tmp/tmp94j8ix83.rs:5:20\n\
    \    |\n2   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                           -- move occurs because `l2` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n5   |         for el2 in l2\
    \ {\n    |                    ^^ `l2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l2`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n5\
    \   |         for el2 in &l2 {\n    |                    +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&i| i == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv_sl5jnm.rs:9:5\n  |\n2 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbxvw1cc.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpo5rgbly5.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp2uviulpd.rs:20:27\n   |\n20 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2uviulpd.rs:20:41\n\
    \   |\n20 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2uviulpd.rs:30:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.extend(l2.iter().cloned());\n    l3.sort();\n    l3\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3, 4, 5, 5, 5, 7, 9, 34, 121, 653, 653]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmp7g21im8t.rs:12:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned().chain(l2.iter().cloned()) {\n        if result.iter().any(|&x|\
    \ x == i) {\n            continue;\n        }\n        result.push(i);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpfhmg0_ng.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.retain(l2.clone());\n    l3\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize,)>` closure, found `Vec<isize>`\n\
    \    --> /tmp/tmpzmjnxq0_.rs:5:15\n     |\n5    |     l3.retain(l2.clone());\n\
    \     |        ------ ^^^^^^^^^^ expected an `FnMut<(&isize,)>` closure, found\
    \ `Vec<isize>`\n     |        |\n     |        required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `for<'r> FnMut<(&'r isize,)>` is\
    \ not implemented for `Vec<isize>`\nnote: required by a bound in `Vec::<T, A>::retain`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop().unwrap());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop().unwrap());\n        } else {\n            let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop().unwrap());\n\
    \                } else if l2.len() == 0 {\n                    result.push(l1.pop().unwrap());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     if l1.len() == 1 {\n                            result.push(l1.pop().unwrap());\n\
    \                        } else {\n                            result.push(l1.pop().unwrap());\n\
    \                            result.push(l2.pop().unwrap());\n               \
    \         }\n                    } else {\n                        if l1.len()\
    \ > l2.len() {\n                            result.push(l1.pop().unwrap());\n\
    \                        } else {\n                            result.push(l2.pop().unwrap());\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbxvw1cc.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&i| i == i) {\n\
    \            l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpwd6_aq2b.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp2uviulpd.rs:20:27\n   |\n20 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2uviulpd.rs:20:41\n\
    \   |\n20 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2uviulpd.rs:30:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop().unwrap());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop().unwrap());\n        } else {\n            let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0\
    \ && l1.iter().next().unwrap() == l2.iter().next().unwrap() {\n              \
    \  i += 1;\n                l1.pop();\n                l2.pop();\n           \
    \ }\n            result.push(i);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    for i in l1.iter() {\n        if !l2.contains(&i) {\n            res.push(i);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9yn198x9.rs:9:5\n  |\n2 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n9 |     res\n  |     ^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for &i in l1 {\n        if l2.iter().any(|&j| i == j) {\n            l3.push(i);\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzpk0dops.rs:4:9\n  |\n4 |\
    \     for &i in l1 {\n  |         ^^    -- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if !l2.contains(&i) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdunrf10n.rs:9:5\n  |\n2 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |             \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if !l2.contains(&i) {\n          \
    \  result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpbf8ucvmj.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    l1.sort_unstable();\n    l2.sort_unstable();\n    for i in l1.iter().zip(l2.iter()).filter(|&(a,\
    \ b)| *a < *b).map(|&(a, b)| a).cloned() {\n        l3.push(i);\n    }\n    l3.sort_unstable();\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkwkbgjk6.rs:6:70\n  |\n6 |\
    \     for i in l1.iter().zip(l2.iter()).filter(|&(a, b)| *a < *b).map(|&(a, b)|\
    \ a).cloned() {\n  |                                                         \
    \             ^^^^^^-\n  |                                                   \
    \                   |     |\n  |                                             \
    \                         |     expected due to this\n  |                    \
    \                                                  expected tuple, found reference\n\
    \  |\n  = note:  expected tuple `(&isize, &isize)`\n          found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop().unwrap());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop().unwrap());\n        } else {\n            let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop().unwrap());\n\
    \                } else if l2.len() == 0 {\n                    result.push(l1.pop().unwrap());\n\
    \                } else {\n                    if l1.last() == l2.first() {\n\
    \                        l1.pop();\n                        l2.pop();\n      \
    \              } else {\n                        break;\n                    }\n\
    \                }\n                i += 1;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp2uviulpd.rs:20:27\n   |\n20 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2uviulpd.rs:20:41\n\
    \   |\n20 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2uviulpd.rs:30:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if !l2.contains(&i) {\n          \
    \  result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpbf8ucvmj.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop().unwrap());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop().unwrap());\n        } else {\n            let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop().unwrap());\n\
    \                } else if l2.len() == 0 {\n                    result.push(l1.pop().unwrap());\n\
    \                } else {\n                    if l1.last().unwrap() == l2.last().unwrap()\
    \ {\n                        result.push(l1.pop().unwrap());\n               \
    \         l1.pop();\n                        l2.pop();\n                    }\
    \ else {\n                        i += 1;\n                    }\n           \
    \     }\n            }\n            if i == 0 {\n                result.push(l1.pop().unwrap());\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop().unwrap());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop().unwrap());\n        } else {\n            let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            while l1.len() != 0 || l2.len() != 0 {\n                if l1.len()\
    \ == 0 {\n                    result.push(l2.pop().unwrap());\n              \
    \  } else if l2.len() == 0 {\n                    result.push(l1.pop().unwrap());\n\
    \                } else {\n                    if l1.last().unwrap() == l2.last().unwrap()\
    \ {\n                        l1.pop();\n                        l2.pop();\n  \
    \                  } else {\n                        break;\n                \
    \    }\n                }\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    let mut l4 = l2.clone();\n    l4.sort();\n    l3.iter().zip(l4.iter()).filter(|&(a,\
    \ b)| *a == *b).cloned().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpqovexjmh.rs:7:37: 7:55]>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpqovexjmh.rs:7:57\n     |\n7    |\
    \     l3.iter().zip(l4.iter()).filter(|&(a, b)| *a == *b).cloned().collect()\n\
    \     |                                                         ^^^^^^ expected\
    \ reference, found tuple\n     |\n     = note: expected reference `&_`\n     \
    \               found tuple `(&isize, &isize)`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpqovexjmh.rs:7:37: 7:55]>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpqovexjmh.rs:7:66\n  \
    \ |\n7  |        l3.iter().zip(l4.iter()).filter(|&(a, b)| *a == *b).cloned().collect()\n\
    \   |                                                                     ^^^^^^^\
    \ method cannot be called on `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpqovexjmh.rs:7:37: 7:55]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmpqovexjmh.rs:7:37: 7:55]> as Iterator>::Item = &_`\n       \
    \    which is required by `Cloned<Filter<Zip<std::slice::Iter<'_, isize>, std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpqovexjmh.rs:7:37: 7:55]>>: Iterator`\n           `Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpqovexjmh.rs:7:37: 7:55]>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Filter<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmpqovexjmh.rs:7:37: 7:55]>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            if l1.len() == 0 {\n                result.push(l2.pop());\n    \
    \        } else if l2.len() == 0 {\n                result.push(l1.pop());\n \
    \           } else {\n                break;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpqk6xxxz4.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpqk6xxxz4.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqk6xxxz4.rs:31:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n31 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbxvw1cc.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if !l2.contains(&i) {\n          \
    \  result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpbf8ucvmj.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n\
    \    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpwbxvw1cc.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n\
    \    let mut l1_next = l1_iter.next();\n    let mut l2_next = l2_iter.next();\n\
    \    while l1_next != l2_next {\n        if l1_next.unwrap() == l2_next.unwrap()\
    \ {\n            result.push(l1_next.unwrap());\n            l1_next = l1_iter.next();\n\
    \            l2_next = l2_iter.next();\n        } else {\n            if l1_next.unwrap()\
    \ < l2_next.unwrap() {\n                l1_next = l1_iter.next();\n          \
    \  } else {\n                l2_next = l2_iter.next();\n            }\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpqlit8lxx.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if !l2.contains(&i) {\n          \
    \  result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpbf8ucvmj.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if !l2.contains(&i) {\n          \
    \  result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpbf8ucvmj.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned().chain(l2.iter().cloned()) {\n        if result.iter().any(|&x|\
    \ x == i) {\n            continue;\n        }\n        result.push(i);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpfhmg0_ng.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if l1.front() == l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(l1.pop());\n            result.push(l2.pop());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:23\n   |\n15 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp49c6t5jq.rs:15:37\n   |\n15\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp49c6t5jq.rs:26:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n26 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n\
    \    let mut l1_end = l1.iter().count();\n    let mut l2_end = l2.iter().count();\n\
    \    while l1_iter.next() && l2_iter.next() {\n        if l1_iter.unwrap() ==\
    \ l2_iter.unwrap() {\n            result.push(l1_iter.unwrap());\n           \
    \ l1_iter.next();\n            l2_iter.next();\n        } else if l1_iter.unwrap()\
    \ < l2_iter.unwrap() {\n            result.push(l1_iter.unwrap());\n         \
    \   l1_iter.next();\n        } else {\n            result.push(l2_iter.unwrap());\n\
    \            l2_iter.next();\n        }\n    }\n    while l1_iter.next() {\n \
    \       result.push(l1_iter.unwrap());\n        l1_iter.next();\n    }\n    while\
    \ l2_iter.next() {\n        result.push(l2_iter.unwrap());\n        l2_iter.next();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_7dczyj6.rs:8:11\n  |\n8 |\
    \     while l1_iter.next() && l2_iter.next() {\n  |           ^^^^^^^^^^^^^^ expected\
    \ `bool`, found enum `Option`\n  |\n  = note: expected type `bool`\n         \
    \    found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_7dczyj6.rs:8:29\n\
    \  |\n8 |     while l1_iter.next() && l2_iter.next() {\n  |                  \
    \           ^^^^^^^^^^^^^^ expected `bool`, found enum `Option`\n  |\n  = note:\
    \ expected type `bool`\n             found enum `Option<isize>`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `Cloned` in the current scope\n -->\
    \ /tmp/tmp_7dczyj6.rs:9:20\n  |\n9 |         if l1_iter.unwrap() == l2_iter.unwrap()\
    \ {\n  |                    ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `unwrap` found for struct `Cloned`\
    \ in the current scope\n --> /tmp/tmp_7dczyj6.rs:9:40\n  |\n9 |         if l1_iter.unwrap()\
    \ == l2_iter.unwrap() {\n  |                                        ^^^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `Cloned` in the current scope\n  --> /tmp/tmp_7dczyj6.rs:10:33\n\
    \   |\n10 |             result.push(l1_iter.unwrap());\n   |                 \
    \                ^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0599]: no method named `unwrap` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmp_7dczyj6.rs:13:27\n   |\n13 |         } else if l1_iter.unwrap()\
    \ < l2_iter.unwrap() {\n   |                           ^^^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named `unwrap`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmp_7dczyj6.rs:13:46\n\
    \   |\n13 |         } else if l1_iter.unwrap() < l2_iter.unwrap() {\n   |    \
    \                                          ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `unwrap` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmp_7dczyj6.rs:14:33"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if !l2.contains(&i) {\n          \
    \  result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 34, 2]`,\n right: `[1, 5, 653]`', /tmp/tmpbf8ucvmj.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp2uviulpd.rs:20:27\n   |\n20 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2uviulpd.rs:20:41\n\
    \   |\n20 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2uviulpd.rs:30:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   l3.push(i);\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdatac2zp.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     l3\n  |     ^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned().chain(l2.iter().cloned()) {\n        if result.iter().any(|&x|\
    \ x == i) {\n            continue;\n        }\n        result.push(i);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmpfhmg0_ng.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(l2.pop());\n        } else if l2.len() == 0 {\n           \
    \ result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1.front() == l2.front() {\n                    l1.pop();\n      \
    \              l2.pop();\n                } else {\n                    i += 1;\n\
    \                }\n            }\n            if l1.len() == 0 {\n          \
    \      result.push(l2.pop());\n            } else if l2.len() == 0 {\n       \
    \         result.push(l1.pop());\n            } else {\n                i += 1;\n\
    \            }\n            if i == 0 {\n                result.push(l1.pop());\n\
    \                result.push(l2.pop());\n            }\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpwr1ou6uf.rs:16:23\n   |\n16 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpwr1ou6uf.rs:16:37\n   |\n16\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwr1ou6uf.rs:36:5\n   |\n2  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n36 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpu44s85m1.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h_3a72u.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     result\n  |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\n  = note: expected struct `Vec<isize>`\n             found struct\
    \ `Vec<&isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i]\
    \ == l2[i] {\n            result.push(l1[i]);\n            i += 1;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpndg4vi4u.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      result.push(*l2.pop());\n        } else if l2.len() == 0 {\n          \
    \  result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() > 0 && l2.len() > 0 {\n                if *l1.front() == *l2.front()\
    \ {\n                    l1.pop();\n                    l2.pop();\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            result.push(*l1.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n --> /tmp/tmpkyjvklop.rs:8:25\n\
    \  |\n8 |             result.push(*l2.pop());\n  |                         ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:10:25\n\
    \   |\n10 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0599]: no method named `front` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:24\n   |\n15 |          \
    \       if *l1.front() == *l2.front() {\n   |                        ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpkyjvklop.rs:15:39\n\
    \   |\n15 |                 if *l1.front() == *l2.front() {\n   |            \
    \                           ^^^^^ method not found in `Vec<isize>`\n\nerror[E0614]:\
    \ type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpkyjvklop.rs:22:25\n\
    \   |\n22 |             result.push(*l1.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747551
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop().unwrap());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop().unwrap());\n        } else {\n            let\
    \ mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop().unwrap());\n\
    \                } else if l2.len() == 0 {\n                    result.push(l1.pop().unwrap());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     result.push(l1.pop().unwrap());\n                    } else\
    \ {\n                        if l1.len() < l2.len() {\n                      \
    \      result.push(l1.pop().unwrap());\n                        } else {\n   \
    \                         result.push(l2.pop().unwrap());\n                  \
    \      }\n                    }\n                }\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976095
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    for i in l1.iter() {\n        if l2.iter().any(|&x| x == i) {\n         \
    \   res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpf19sq5up.rs:5:36\n  |\n5 |\
    \         if l2.iter().any(|&x| x == i) {\n  |                               \
    \     ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the\
    \ borrow\n  |\n5 |         if l2.iter().any(|&x| x == *i) {\n  |             \
    \                       +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpf19sq5up.rs:9:5\n\
    \  |\n2 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |     \
    \                                         ---------- expected `Vec<isize>` because\
    \ of return type\n...\n9 |     res\n  |     ^^^ expected `isize`, found `&isize`\n\
    \  |\n  = note: expected struct `Vec<isize>`\n             found struct `Vec<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for x in l1 {\n        if l2.iter().any(|&y| x == y) {\n            result.push(x);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpvd25n_q5.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976090
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\nfn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n\
    \    let mut l4 = Vec::new();\n    let mut l5 = Vec::new();\n    let mut l6 =\
    \ Vec::new();\n    let mut l7 = Vec::new();\n    let mut l8 = Vec::new();\n  \
    \  let mut l9 = Vec::new();\n    let mut l10 = Vec::new();\n    let mut l11 =\
    \ Vec::new();\n    let mut l12 = Vec::new();\n    let mut l13 = Vec::new();\n\
    \    let mut l14 = Vec::new();\n    let mut l15 = Vec::new();\n    let mut l16\
    \ = Vec::new();\n    let mut l17 = Vec::new();\n    let mut l18 = Vec::new();\n\
    \    let mut l19 = Vec::new();\n    let mut l20 = Vec::new();\n    let mut l21\
    \ = Vec::new();\n    let mut l22 = Vec::new();\n    let mut l23 = Vec::new();\n\
    \    let mut l24 = Vec::new();\n    let mut l25 = Vec::new();\n    let mut l26\
    \ = Vec::new();\n    let mut l27 = Vec::new();\n    let mut l28 = Vec::new();\n\
    \    let mut l29 = Vec::new();\n    let mut l30 = Vec::new();\n    let mut l31\
    \ = Vec::new();\n    let mut l32 = Vec::new();\n    let mut l33 = Vec::new();\n\
    \    let mut l34 = Vec::new();\n    let mut l35 = Vec::new();\n    let mut l36\
    \ = Vec::new();\n    let mut l37 = Vec::new();\n    let mut l38 = Vec::new();\n\
    \    let mut l39 = Vec::new();\n    let mut l40 = Vec::new();\n    let mut l41\
    \ = Vec::new();\n    let mut l42 = Vec::new();\n    let mut l43 = Vec::new();\n\
    \    let mut l44 = Vec::new();\n    let mut l45 = Vec::new();\n    let mut l46\
    \ = Vec::new();\n    let mut l47 = Vec::new();\n    let mut l48 = Vec::new();\n\
    \    let mut l49 = Vec::new();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpxp5nuzlj.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976090
