name: HumanEval_18_how_many_times
language: rs
prompt: "/// Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\nfn how_many_times(string: String, substring: String)\
  \ -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
  \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
  ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
  ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
  ), String::from(\"john\")), 1);\n}\n"
completions: ["    let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len()\
    \ {\n        if string.starts_with(substring, pos) {\n            count += 1;\n\
    \        }\n        pos += 1;\n    }\n    count", '    string.chars().filter(|c|
    c == substring).count()', '    string.chars().filter(|c| c == substring).count()',
  "    let mut counter = 0;\n    let mut string_iter = string.char_indices();\n  \
    \  let mut substring_iter = substring.char_indices();\n    let mut substring_end\
    \ = substring_iter.end();\n    while let Some(substring_pos) = substring_iter.next()\
    \ {\n        if substring_pos == substring_end {\n            break;\n       \
    \ }\n        let mut substring_start = substring_pos;\n        while let Some(string_pos)\
    \ = string_iter.next() {\n            if string_pos == string_end {\n        \
    \        break;\n            }\n            if string_pos > substring_end {\n\
    \                break;\n            }\n            if string_pos < substring_start\
    \ {\n                continue;\n            }\n            if string_iter\n  \
    \              .next()\n                .unwrap()\n                .unwrap()\n\
    \                == substring_iter\n                    .next()\n            \
    \        .unwrap()\n                    .unwrap()\n            {\n           \
    \     counter += 1;\n            }\n        }\n    }\n    counter", '    string.chars().filter(|c|
    c == substring).count()', "    let mut counter = 0;\n    let mut pos = 0;\n  \
    \  while pos < string.len() {\n        let mut found = false;\n        for c in\
    \ string.chars() {\n            if c == substring.as_bytes()[pos] {\n        \
    \        found = true;\n                break;\n            }\n        }\n   \
    \     if found {\n            counter += 1;\n        }\n        pos += 1;\n  \
    \  }\n    counter", '    string.chars().filter(|c| c == substring).count() + 1',
  '    string.chars().filter(|c| c == substring).count() + 1', "    let mut count\
    \ = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n        let mut\
    \ end_pos = string.find(substring, pos);\n        if end_pos == String::npos {\n\
    \            break;\n        }\n        pos = end_pos + 1;\n        count += 1;\n\
    \    }\n    count", "    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    loop {\n        if\
    \ let Some((start, end)) = string_iter.next() {\n            if let Some((start,\
    \ end)) = substring_iter.next() {\n                if start < end {\n        \
    \            count += 1;\n                }\n            }\n        }\n      \
    \  if !string_iter.next().is_some() {\n            break;\n        }\n    }\n\
    \    count", '    string.chars().filter(|c| c == substring).count() + 1', '    string.chars().filter(|c|
    c == substring).count() + 1', '    string.chars().filter(|c| c == substring).count()',
  '    string.chars().filter(|c| c == substring).count() + 1', "    let mut count\
    \ = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n        let mut\
    \ i = pos;\n        while i < string.len() && string[i] == substring {\n     \
    \       i += 1;\n        }\n        if i == string.len() {\n            break;\n\
    \        }\n        count += 1;\n        pos = i + 1;\n    }\n    count", "  \
    \  let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut end = string.len();\n        if end > pos {\n            end\
    \ = pos;\n        }\n        if string.contains(&substring, start, end) {\n  \
    \          count += 1;\n        }\n        pos = end;\n    }\n    count", "  \
    \  let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = false;\n        for c in string.chars() {\n         \
    \   if pos == 0 {\n                found = true;\n                break;\n   \
    \         }\n            if c == substring.chars()[pos - 1] {\n              \
    \  found = true;\n                break;\n            }\n        }\n        if\
    \ found {\n            counter += 1;\n        }\n        pos += 1;\n    }\n  \
    \  counter", '    string.chars().filter(|c| c == substring).count() + 1', "  \
    \  let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.chars().any(|c| c == substring[pos]) {\n            count +=\
    \ 1;\n            pos += 1;\n        }\n        pos += 1;\n    }\n    count",
  '    string.chars().filter(|c| c == substring).count()']
stop_tokens:
- "\n}"
