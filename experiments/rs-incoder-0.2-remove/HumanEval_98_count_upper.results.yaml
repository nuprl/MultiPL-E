language: rs
name: HumanEval_98_count_upper
results:
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmi9vfagh.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmp1ge0d8ga.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n  |                     \
    \                                    ^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp1ge0d8ga.rs:4:5\n  |\n3 | fn count_upper(s: String)\
    \ -> isize {\n  |                              ----- expected `isize` because\
    \ of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_even()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count().try_into().unwrap()\n  | \
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmi9vfagh.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmp1ge0d8ga.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n  |                     \
    \                                    ^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp1ge0d8ga.rs:4:5\n  |\n3 | fn count_upper(s: String)\
    \ -> isize {\n  |                              ----- expected `isize` because\
    \ of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_even()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count().try_into().unwrap()\n  | \
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n --> /tmp/tmpv_7n8o7u.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n  |             \
    \                                            ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpv_7n8o7u.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmi9vfagh.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmp1ge0d8ga.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n  |                     \
    \                                    ^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp1ge0d8ga.rs:4:5\n  |\n3 | fn count_upper(s: String)\
    \ -> isize {\n  |                              ----- expected `isize` because\
    \ of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_even()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count().try_into().unwrap()\n  | \
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n --> /tmp/tmpv_7n8o7u.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n  |             \
    \                                            ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpv_7n8o7u.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmi9vfagh.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmp1ge0d8ga.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n  |                     \
    \                                    ^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp1ge0d8ga.rs:4:5\n  |\n3 | fn count_upper(s: String)\
    \ -> isize {\n  |                              ----- expected `isize` because\
    \ of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_even()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count().try_into().unwrap()\n  | \
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmi9vfagh.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmp1ge0d8ga.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n  |                     \
    \                                    ^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp1ge0d8ga.rs:4:5\n  |\n3 | fn count_upper(s: String)\
    \ -> isize {\n  |                              ----- expected `isize` because\
    \ of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_even()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count().try_into().unwrap()\n  | \
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmp1ge0d8ga.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n  |                     \
    \                                    ^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp1ge0d8ga.rs:4:5\n  |\n3 | fn count_upper(s: String)\
    \ -> isize {\n  |                              ----- expected `isize` because\
    \ of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_even()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count().try_into().unwrap()\n  | \
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmp1ge0d8ga.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n  |                     \
    \                                    ^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp1ge0d8ga.rs:4:5\n  |\n3 | fn count_upper(s: String)\
    \ -> isize {\n  |                              ----- expected `isize` because\
    \ of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_even()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count().try_into().unwrap()\n  | \
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmp59ux941s.rs:4:57\n\
    \  |\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |                                                       - ^ - {integer}\n \
    \ |                                                       |\n  |             \
    \                                          &char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp59ux941s.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize {\n\
    \  |                              ----- expected `isize` because of return type\n\
    4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n  |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmp1ge0d8ga.rs:4:57\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count()\n  |                     \
    \                                    ^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp1ge0d8ga.rs:4:5\n  |\n3 | fn count_upper(s: String)\
    \ -> isize {\n  |                              ----- expected `isize` because\
    \ of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_even()).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_even()).count().try_into().unwrap()\n  | \
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009083
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7zjojbt4.rs:4:5\n  |\n3 |\
    \ fn count_upper(s: String) -> isize {\n  |                              -----\
    \ expected `isize` because of return type\n4 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n  |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:31\n  |\n4 |\
    \     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                               ^^^\n  |                               |\n\
    \  |                               expected `&char`, found `char`\n  |       \
    \                        help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoo8c7t_q.rs:4:43\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n  |                  \
    \                         ^^^\n  |                                           |\n\
    \  |                                           expected `&char`, found `char`\n\
    \  |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n --> /tmp/tmpoo8c7t_q.rs:4:61\n\
    \  |\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \  |                                                           - ^ - {integer}\n\
    \  |                                                           |\n  |        \
    \                                                   &char\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpoo8c7t_q.rs:4:5\n  |\n3 | fn count_upper(s: String) -> isize\
    \ {\n  |                              ----- expected `isize` because of return\
    \ type\n4 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \ |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747139
