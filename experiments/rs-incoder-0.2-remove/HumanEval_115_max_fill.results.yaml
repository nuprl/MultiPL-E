language: rs
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_well = Vec::new();\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        let mut well = Vec::new();\n        for\
    \ col in row.iter() {\n            if col == 1 {\n                well.push(col);\n\
    \                cnt += 1;\n            } else {\n                if cnt > max_cnt\
    \ {\n                    max_cnt = cnt;\n                    max_well = well;\n\
    \                }\n                well.push(col);\n                cnt = 0;\n\
    \            }\n        }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n\
    \            max_well = well;\n        }\n    }\n    max_cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp0a3_23iw.rs:24:20\n\
    \   |\n24 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n    for row in 0..grid.len()\
    \ {\n        for col in 0..grid[row].len() {\n            if grid[row][col] ==\
    \ 1 {\n                cnt += 1;\n                max_cnt = std::cmp::max(max_cnt,\
    \ cnt);\n                max_grid[row][col] = 0;\n            }\n        }\n \
    \   }\n    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n\
    \            if grid[row][col] == 0 {\n                grid[row][col] = 1;\n \
    \               cnt -= 1;\n                max_cnt = std::cmp::max(max_cnt, cnt);\n\
    \                max_grid[row][col] = 1;\n            }\n        }\n    }\n  \
    \  max_cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpt9vf2ckr.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpt9vf2ckr.rs:32:17\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n32 |                 grid[row][col]\
    \ = 1;\n   |                 ^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_well = Vec::new();\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        let mut well = Vec::new();\n        for\
    \ col in row.iter() {\n            if col == 1 {\n                well.push(1);\n\
    \            } else {\n                well.push(0);\n            }\n        \
    \    cnt += well[well.len() - 1];\n        }\n        if cnt > max_cnt {\n   \
    \         max_cnt = cnt;\n            max_well = well;\n        }\n    }\n   \
    \ for row in grid.iter() {\n        let mut cnt = 0;\n        let mut well = Vec::new();\n\
    \        for col in row.iter() {\n            if col == 1 {\n                well.push(1);\n\
    \            } else {\n                well.push(0);\n            }\n        \
    \    cnt += well[well.len() - 1];\n        }\n        if cnt > max_cnt {\n   \
    \         max_cnt = cnt;\n            max_well = well;\n        }\n    }\n   \
    \ return max_cnt;\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpu8pss5x8.rs:24:20\n\
    \   |\n24 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpu8pss5x8.rs:40:20\n   |\n40 |             if col\
    \ == 1 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_grid = Vec::new();\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        let mut max_cnt = 0;\n        let mut max_row\
    \ = Vec::new();\n        for col in row.iter() {\n            if *col == 1 {\n\
    \                cnt += 1;\n                if cnt > max_cnt {\n             \
    \       max_cnt = cnt;\n                    max_row = col;\n                }\n\
    \            }\n        }\n        cnt += 1;\n        if cnt > max_cnt {\n   \
    \         max_cnt = cnt;\n            max_row = row;\n        }\n        max_grid.push(max_row);\n\
    \    }\n    for row in max_grid.iter() {\n        for col in row.iter() {\n  \
    \          if *col == 0 {\n                *col = 1;\n                cnt += 1;\n\
    \                if cnt > max_cnt {\n                    max_cnt = cnt;\n    \
    \                max_row = row;\n                }\n            }\n        }\n\
    \    }\n    return max_cnt;\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_row` in this scope\n  --> /tmp/tmpa9b21m5q.rs:47:21\n\
    \   |\n47 |                     max_row = row;\n   |                     ^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa9b21m5q.rs:29:31\n\
    \   |\n29 |                     max_row = col;\n   |                         \
    \      ^^^ expected struct `Vec`, found `&isize`\n   |\n   = note: expected struct\
    \ `Vec<_>`\n           found reference `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa9b21m5q.rs:36:23\n   |\n36 |             max_row = row;\n   |\
    \                       ^^^- help: try using a conversion method: `.to_vec()`\n\
    \   |                       |\n   |                       expected struct `Vec`,\
    \ found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<_>`\n           found\
    \ reference `&Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut ans = isize::MAX;\n\
    \    let mut buckets = Vec::new();\n    for row in grid.iter() {\n        let\
    \ mut bucket = Vec::new();\n        for cell in row.iter() {\n            bucket.push(cell\
    \ as isize);\n        }\n        buckets.push(bucket);\n    }\n    for bucket\
    \ in buckets.iter() {\n        if bucket.len() > 0 {\n            ans = bucket.iter().fold(ans,\
    \ |acc, cell| {\n                if acc < cell {\n                    acc += cell;\n\
    \                }\n                acc\n            });\n        }\n    }\n \
    \   ans\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdf68os7_.rs:29:26\n   |\n\
    29 |                 if acc < cell {\n   |                          ^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    29 |                 if acc < *cell {\n   |                          +\n\nerror[E0606]:\
    \ casting `&isize` as `isize` is invalid\n  --> /tmp/tmpdf68os7_.rs:22:25\n  \
    \ |\n22 |             bucket.push(cell as isize);\n   |                      \
    \   ----^^^^^^^^^\n   |                         |\n   |                      \
    \   cannot cast `&isize` as `isize`\n   |                         help: dereference\
    \ the expression: `*cell`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n    for row in 0..grid.len()\
    \ {\n        for col in 0..grid[row].len() {\n            let mut cnt = 0;\n \
    \           for row in 0..grid.len() {\n                for col in 0..grid[row].len()\
    \ {\n                    if grid[row][col] == 1 {\n                        cnt\
    \ += 1;\n                    }\n                }\n            }\n           \
    \ if cnt > max_cnt {\n                max_cnt = cnt;\n                max_grid\
    \ = grid.clone();\n            }\n        }\n    }\n    for row in 0..grid.len()\
    \ {\n        for col in 0..grid[row].len() {\n            if grid[row][col] ==\
    \ 1 {\n                grid[row][col] = 0;\n                cnt += 1;\n      \
    \      }\n        }\n    }\n    for row in 0..grid.len() {\n        for col in\
    \ 0..grid[row].len() {\n            if grid[row][col] == 1 {\n               \
    \ grid[row][col] = 1;\n                cnt += 1;\n            }\n        }\n \
    \   }\n    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n\
    \            if grid[row][col] == 1 {\n                grid[row][col] = 0;\n \
    \               cnt += 1;\n            }\n        }\n    }\n    for row in 0..grid.len()\
    \ {\n        for col in 0..grid[row].len() {\n            if grid[row][col] ==\
    \ 1 {\n                grid[row][col] = 1;\n                cnt += 1;\n      \
    \      }\n        }\n    }\n    for row in 0..grid.len() {\n        for col in\
    \ 0..grid[row].len() {\n            if grid[row][col] == 1 {\n               \
    \ grid[row][col] = 0;\n                cnt += 1;\n            }\n        }\n \
    \   }\n    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n\
    \            if grid[row][col] == 1 {\n                grid[row][col] = 1;\n \
    \               cnt += 1;\n            }\n        }\n    }\n    for row in 0..grid.len()\
    \ {\n        for col in 0..grid[row].len() {\n            if grid[row][col] ==\
    \ 1 {\n                grid[row][col] = 0;\n                cnt += 1;\n      \
    \      }\n        }\n    }\n    for row in 0..grid.len() {\n        for col in\
    \ 0..grid[row].len() {\n            if grid[row][col] == 1 {\n               \
    \ grid[row][col] = 1;\n                cnt += 1;\n            }\n        }\n \
    \   }\n    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n\
    \            if grid[row][col] == 1 {\n                grid[row][col] = 0;\n \
    \               cnt += 1;\n            }\n        }\n    }\n    for row in 0..grid.len(\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp2c0h2qhq.rs:109:1\n    |\n\
    109 | }\n    | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  \
    \ --> /tmp/tmp2c0h2qhq.rs:108:27\n    |\n16  | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n    |                                         \
    \                     - closing delimiter possibly meant for this\n...\n108 |\
    \     for row in 0..grid.len(\n    |                           ^ unclosed delimiter\n\
    109 | }\n    | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    for\
    \ row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > capacity {\n            cnt -= 1;\n        }\n     \
    \   if cnt > 0 {\n            cnt -= 1;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwc8wd1m3.rs:21:20\n\
    \   |\n21 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_well = Vec::new();\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 1 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_well = row;\n \
    \       }\n    }\n    for row in grid.iter() {\n        let mut cnt = 0;\n   \
    \     for col in row.iter() {\n            if col == 0 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = row;\n        }\n    }\n    if max_cnt > capacity\
    \ {\n        max_cnt = capacity;\n        max_well = Vec::new();\n    }\n    cnt\
    \ = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n        for col\
    \ in row.iter() {\n            if col == 1 {\n                cnt += 1;\n    \
    \        }\n        }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n\
    \            max_well = row;\n        }\n    }\n    if max_cnt > capacity {\n\
    \        max_cnt = capacity;\n        max_well = Vec::new();\n    }\n    cnt =\
    \ 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n        for col\
    \ in row.iter() {\n            if col == 0 {\n                cnt += 1;\n    \
    \        }\n        }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n\
    \            max_well = row;\n        }\n    }\n    if max_cnt > capacity {\n\
    \        max_cnt = capacity;\n        max_well = Vec::new();\n    }\n    cnt =\
    \ 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n        for col\
    \ in row.iter() {\n            if col == 1 {\n                cnt += 1;\n    \
    \        }\n        }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n\
    \            max_well = row;\n        }\n    }\n    if max_cnt > capacity {\n\
    \        max_cnt = capacity;\n        max_well = Vec::new();\n    }\n    cnt =\
    \ 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n        for col\
    \ in row.iter() {\n            if col == 0 {\n                cnt += 1;\n    \
    \        }\n        }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n\
    \            max_well = row;\n        }\n    }\n    if max_cnt > capacity {\n\
    \        max_cnt = capacity;\n        max_well = Vec::new();\n    }\n    cnt =\
    \ 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n        for col\
    \ in row.iter() {\n            if col == 1 {\n\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9sv2b03t.rs:131:3\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n117 |     for row in grid.iter() {\n    |                  \
    \          - unclosed delimiter\n118 |         let mut cnt = 0;\n119 |       \
    \  for col in row.iter() {\n    |                               - unclosed delimiter\n\
    120 |             if col == 1 {\n    |                         - this delimiter\
    \ might not be properly closed...\n121 | \n122 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n131 | }\n    |   ^\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmp9sv2b03t.rs:23:20\n   |\n23\
    \ |             if col == 1 {\n   |                    ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9sv2b03t.rs:29:24\n\
    \   |\n29 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp9sv2b03t.rs:35:20\n\
    \   |\n35 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9sv2b03t.rs:41:24\n\
    \   |\n41 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp9sv2b03t.rs:52:20\n\
    \   "
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    for\
    \ row in grid.iter() {\n        let mut cnt2 = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt2 += 1;\n            }\n  \
    \      }\n        if cnt2 > capacity {\n            cnt += 1;\n        }\n   \
    \ }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpngk2ve5r.rs:21:20\n\
    \   |\n21 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_well = Vec::new();\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        let mut well = Vec::new();\n        for\
    \ col in row.iter() {\n            if col == 1 {\n                well.push(1);\n\
    \                cnt += 1;\n            } else {\n                well.push(0);\n\
    \            }\n        }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n\
    \            max_well = well;\n        }\n    }\n    for row in grid.iter() {\n\
    \        let mut cnt = 0;\n        let mut well = Vec::new();\n        for col\
    \ in row.iter() {\n            if col == 1 {\n                well.push(1);\n\
    \                cnt += 1;\n            } else {\n                well.push(0);\n\
    \            }\n        }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n\
    \            max_well = well;\n        }\n    }\n    return max_cnt;\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp80d0pv3s.rs:24:20\n\
    \   |\n24 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmp80d0pv3s.rs:40:20\n   |\n40 |             if col\
    \ == 1 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut ans = isize::MAX;\n\
    \    let mut buckets = vec![0; capacity];\n    for row in grid.iter() {\n    \
    \    let mut cur_capacity = isize::MAX;\n        for cell in row.iter() {\n  \
    \          if cell == 1 {\n                cur_capacity += 1;\n            }\n\
    \        }\n        buckets[cur_capacity] += 1;\n        if cur_capacity > ans\
    \ {\n            ans = cur_capacity;\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu5tjq4c8.rs:18:31\n   |\n\
    18 |     let mut buckets = vec![0; capacity];\n   |                          \
    \     ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n18\
    \ |     let mut buckets = vec![0; capacity.try_into().unwrap()];\n   |       \
    \                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpu5tjq4c8.rs:22:21\n   |\n22 |     \
    \        if cell == 1 {\n   |                     ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpu5tjq4c8.rs:26:9\n   |\n26 |         buckets[cur_capacity] += 1;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_grid: Vec<Vec<isize>> = vec![];\n    for row\
    \ in grid.iter() {\n        let mut cnt = 0;\n        let mut max_cnt = 0;\n \
    \       let mut max_grid: Vec<Vec<isize>> = vec![];\n        for row in row.iter()\
    \ {\n            if *row == 1 {\n                cnt += 1;\n                if\
    \ cnt > max_cnt {\n                    max_cnt = cnt;\n                    max_grid\
    \ = row;\n                }\n            }\n        }\n        cnt += 1;\n   \
    \     if cnt > max_cnt {\n            max_cnt = cnt;\n            max_grid = row;\n\
    \        }\n    }\n    if max_cnt == 0 {\n        return 0;\n    }\n    for row\
    \ in max_grid.iter() {\n        for col in row.iter() {\n            if *col ==\
    \ 0 {\n                *col = 1;\n                cnt += 1;\n                if\
    \ cnt > max_cnt {\n                    max_cnt = cnt;\n                    max_grid\
    \ = row;\n                }\n            }\n        }\n    }\n    if max_cnt ==\
    \ 0 {\n        return 0;\n    }\n    for row in max_grid.iter() {\n        for\
    \ col in row.iter() {\n            if *col == 0 {\n                *col = 0;\n\
    \                cnt += 1;\n                if cnt > max_cnt {\n             \
    \       max_cnt = cnt;\n                    max_grid = row;\n                }\n\
    \            }\n        }\n    }\n    if max_cnt == 0 {\n        return 0;\n \
    \   }\n    for row in max_grid.iter() {\n        for col in row.iter() {\n   \
    \         if *col == 0 {\n                *col = 1;\n                cnt += 1;\n\
    \                if cnt > max_cnt {\n                    max_cnt = cnt;\n    \
    \                max_grid = row;\n                }\n            }\n        }\n\
    \    }\n    if max_cnt == 0 {\n        return 0;\n    }\n    for row in max_grid.iter()\
    \ {\n        for col in row.iter() {\n            if *col == 0 {\n           \
    \     *col = 0;\n                cnt += 1;\n                if cnt > max_cnt {\n\
    \                    max_cnt = cnt;\n                    max_grid = row;\n   \
    \             }\n            }\n        }\n    }\n    if max_cnt == 0 {\n    \
    \    return 0;\n    }\n    for row in max_grid.iter() {\n        for col in row.iter()\
    \ {\n            if *col == 0 {\n                *col = 1;\n                cnt\
    \ += 1;\n                if cnt > max_cnt {\n                    max_cnt = cnt;\n\
    \                    max_grid = row;\n                }\n            }\n     \
    \   }\n    }\n    if max_cnt == 0 {\n        return 0;\n    }\n    for row in\
    \ max_grid.iter() {\n        for col in row.iter() {\n            if *col == 0\
    \ {\n                *col = 0;\n\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmprqah7oo8.rs:131:3\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n117 |     for row in max_grid.iter() {\n    |              \
    \                  - unclosed delimiter\n118 |         for col in row.iter() {\n\
    \    |                               - unclosed delimiter\n119 |             if\
    \ *col == 0 {\n    |                          - this delimiter might not be properly\
    \ closed...\n...\n122 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n131 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprqah7oo8.rs:29:32\n   |\n29 |                     max_grid = row;\n\
    \   |                                ^^^ expected struct `Vec`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n           found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprqah7oo8.rs:36:24\n\
    \   |\n36 |             max_grid = row;\n   |                        ^^^ expected\
    \ struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \           found reference `&Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprqah7oo8.rs:49:32\n   |\n49 |                     max_grid = row;\n\
    \   |                                ^^^ expected struct `Vec`, found `&Vec<isize>`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n           found reference\
    \ `&Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprqah7oo8.rs:64:32\n\
    \   |\n64 |                     max_grid = row;\n   |                        \
    \        ^^^ expected struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected\
    \ struct `Vec<Vec<isize>>`\n           found reference `&Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprqah7oo8.rs:79:32\n   |\n79 |              \
    \       max_grid = row;\n   |                                ^^^ expected struct\
    \ `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \           found reference `&Vec<isize>`\n\nerr"
  stdout: ''
  timestamp: 1659747150
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut ans = isize::MAX;\n\
    \    let mut buckets = vec![Vec::new(); grid.len()];\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            buckets[i][j] = capacity\
    \ - grid[i][j];\n        }\n    }\n    for i in 0..grid.len() {\n        for j\
    \ in 0..grid[i].len() {\n            if buckets[i][j] <= 0 {\n               \
    \ ans = ans.min(buckets[i][j]);\n                buckets[i][j] = 0;\n        \
    \    }\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpr03tbhhg.rs:21:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_well = Vec::new();\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        let mut well = Vec::new();\n        for\
    \ col in row.iter() {\n            if *col == 1 {\n                well.push(col);\n\
    \                cnt += 1;\n            }\n        }\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n            max_well = well;\n        }\n   \
    \ }\n    for col in max_well.iter() {\n        if *col == 0 {\n            cnt\
    \ += 1;\n        }\n    }\n    if cnt > capacity {\n        cnt\n    } else {\n\
    \        0\n    }\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpon06paco.rs:35:17\n\
    \   |\n35 |         if *col == 0 {\n   |                 ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_grid = vec![vec![]; grid.len()];\n    for\
    \ i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 0 {\n                cnt += 1;\n                max_cnt += 1;\n         \
    \       max_grid[i][j] = cnt;\n            }\n        }\n    }\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            if max_grid[i][j] > max_cnt\
    \ {\n                max_cnt = max_grid[i][j];\n            }\n        }\n   \
    \ }\n    return max_cnt;\n}\n\nfn main() {\n    let candidate = max_fill;\n  \
    \  assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjnqgv3k4.rs:25:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut min_bucket = grid[0].len();\n    for i in 1..grid.len() {\n        for j\
    \ in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n                cnt\
    \ += 1;\n                if min_bucket > j {\n                    min_bucket =\
    \ j;\n                }\n            }\n        }\n    }\n    cnt += min_bucket\
    \ - capacity;\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk4dcp0s5.rs:29:25\n   |\n\
    29 |     cnt += min_bucket - capacity;\n   |                         ^^^^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from\
    \ `usize`\n  --> /tmp/tmpk4dcp0s5.rs:29:23\n   |\n29 |     cnt += min_bucket -\
    \ capacity;\n   |                       ^ no implementation for `usize - isize`\n\
    \   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk4dcp0s5.rs:30:5\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |                         \
    \                               ----- expected `isize` because of return type\n\
    ...\n30 |     cnt\n   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n30 |     cnt.try_into().unwrap()\n   |\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_well = Vec::new();\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        let mut well = Vec::new();\n        for\
    \ col in row.iter() {\n            if col == 1 {\n                well.push(col);\n\
    \            } else {\n                cnt += 1;\n            }\n        }\n \
    \       if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well =\
    \ well;\n        }\n    }\n    for row in grid.iter() {\n        let mut cnt =\
    \ 0;\n        let mut well = Vec::new();\n        for col in row.iter() {\n  \
    \          if col == 1 {\n                well.push(col);\n            } else\
    \ {\n                cnt += 1;\n            }\n        }\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n            max_well = well;\n        }\n   \
    \ }\n    for row in grid.iter() {\n        let mut cnt = 0;\n        let mut well\
    \ = Vec::new();\n        for col in row.iter() {\n            if col == 1 {\n\
    \                well.push(col);\n            } else {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = well;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        let mut well = Vec::new();\n        for\
    \ col in row.iter() {\n            if col == 1 {\n                well.push(col);\n\
    \            } else {\n                cnt += 1;\n            }\n        }\n \
    \       if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well =\
    \ well;\n        }\n    }\n    for row in grid.iter() {\n        let mut cnt =\
    \ 0;\n        let mut well = Vec::new();\n        for col in row.iter() {\n  \
    \          if col == 1 {\n                well.push(col);\n            } else\
    \ {\n                cnt += 1;\n            }\n        }\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n            max_well = well;\n        }\n   \
    \ }\n    for row in grid.iter() {\n        let mut cnt = 0;\n        let mut well\
    \ = Vec::new();\n        for col in row.iter() {\n            if col == 1 {\n\
    \                well.push(col);\n            } else {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = well;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        let mut well = Vec::new();\n        for\
    \ col in row.iter() {\n            if col == 1 {\n                well.push(col);\n\
    \            } else {\n                cnt += 1;\n            }\n        }\n\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgavu93zq.rs:130:3\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n110 |     for row in grid.iter() {\n    |                  \
    \          - this delimiter might not be properly closed...\n...\n121 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n130 | }\n\
    \    |   ^\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpgavu93zq.rs:24:20\n\
    \   |\n24 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpgavu93zq.rs:39:20\n   |\n39 |             if col\
    \ == 1 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpgavu93zq.rs:54:20\n\
    \   |\n54 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpgavu93zq.rs:69:20\n   |\n69 |             if col\
    \ == 1 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpgavu93zq.rs:84:20\n\
    \   |\n84 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpgavu93zq.rs:99:20\n   |\n99 |             if col\
    \ == 1 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: t"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    for\
    \ row in grid.iter() {\n        let mut cnt2 = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt2 += 1;\n            }\n  \
    \      }\n        if cnt2 > capacity {\n            cnt += 1;\n        }\n   \
    \ }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpngk2ve5r.rs:21:20\n\
    \   |\n21 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n    for row in 0..grid.len()\
    \ {\n        for col in 0..grid[row].len() {\n            let mut cnt = 0;\n \
    \           for r in 0..row.len() {\n                for c in 0..grid[r].len()\
    \ {\n                    if grid[r][c] == 1 {\n                        cnt +=\
    \ 1;\n                    }\n                }\n            }\n            if\
    \ cnt > max_cnt {\n                max_cnt = cnt;\n                max_grid =\
    \ grid.clone();\n            }\n            if cnt > capacity {\n            \
    \    grid[row][col] = 0;\n            }\n        }\n    }\n    for row in 0..grid.len()\
    \ {\n        for col in 0..grid[row].len() {\n            if grid[row][col] ==\
    \ 1 {\n                cnt += 1;\n            }\n        }\n    }\n    if cnt\
    \ > max_cnt {\n        max_cnt = cnt;\n        max_grid = grid.clone();\n    }\n\
    \    if cnt > capacity {\n        cnt = 0;\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpgbcv10l2.rs:23:29\n   |\n23 |             for r in 0..row.len()\
    \ {\n   |                             ^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747150
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut cnt = 0;\n    let\
    \ mut max_capacity = 0;\n    let mut max_capacity_row = -1;\n    let mut max_capacity_col\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let mut max_capacity_row_end = -1;\n    let mut max_capacity_col_end\
    \ = -1;\n    let mut max_capacity_row_start = -1;\n    let mut max_capacity_col_start\
    \ = -1;\n    let \n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp5zfxa7hq.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747149
