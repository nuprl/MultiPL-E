language: rs
name: HumanEval_40_triples_sum_to_zero
results:
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l.iter() {\n     \
    \   for j in l.iter() {\n            for k in l.iter() {\n                if i\
    \ + j + k == 0 {\n                    triples_sum_to_zero = true;\n          \
    \          break;\n                }\n            }\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwhq4i8fn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsu_41yn_.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut triples_sum_to_zero = false;\n\
    \    for i in l {\n        if triples.iter().any(|&x| x == i) {\n            triples.push(i);\n\
    \        } else {\n            triples_sum_to_zero = true;\n        }\n    }\n\
    \    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4iroxafw.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzyuiktan.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqewjr1c_.rs:9:24\n  |\n9 |\
    \     sum == 0 || sum == l.len() - 3\n  |                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     sum == 0 || sum == (l.len()\
    \ - 3).try_into().unwrap()\n  |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcl1xmon2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    let mut\
    \ i = 0;\n    while i < l.len() {\n        sum += l[i];\n        if sum == 0 {\n\
    \            triples_sum_to_zero = true;\n            break;\n        }\n    \
    \    i += 1;\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyhhjlphj.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut triples_sum_to_zero_counter\
    \ = 0;\n    let mut triples_sum_to_zero_counter2 = 0;\n    let mut triples_sum_to_zero_counter3\
    \ = 0;\n    for x in l {\n        if triples_sum_to_zero_counter == 0 {\n    \
    \        triples_sum_to_zero_counter = x;\n        }\n        if triples_sum_to_zero_counter2\
    \ == 0 {\n            triples_sum_to_zero_counter2 = x;\n        }\n        if\
    \ triples_sum_to_zero_counter3 == 0 {\n            triples_sum_to_zero_counter3\
    \ = x;\n        }\n        triples_sum_to_zero_counter += x;\n        triples_sum_to_zero_counter2\
    \ += x;\n        triples_sum_to_zero_counter3 += x;\n    }\n    if triples_sum_to_zero_counter\
    \ == triples_sum_to_zero_counter2 &&\n        triples_sum_to_zero_counter == triples_sum_to_zero_counter3\
    \ {\n        triples_sum_to_zero = true;\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdu6wtrye.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    for i in l {\n        for j in l {\n \
    \           for k in l {\n                triples.push((i, j, k));\n         \
    \   }\n        }\n    }\n    triples.iter().all(|triple| triple.iter().all(|i|\
    \ triple[0] == i && triple[1] == j && triple[2] == k))\n}\n\nfn main() {\n   \
    \ let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpumdl0bd6.rs:13:86\n\
    \   |\n13 |     triples.iter().all(|triple| triple.iter().all(|i| triple[0] ==\
    \ i && triple[1] == j && triple[2] == k))\n   |                              \
    \                                                        ^ help: a local variable\
    \ with a similar name exists: `i`\n\nerror[E0425]: cannot find value `k` in this\
    \ scope\n   --> /tmp/tmpumdl0bd6.rs:13:104\n    |\n13  |     triples.iter().all(|triple|\
    \ triple.iter().all(|i| triple[0] == i && triple[1] == j && triple[2] == k))\n\
    \    |                                                                       \
    \                                 ^ help: a tuple variant with a similar name\
    \ exists: `Ok`\n\nerror[E0599]: no method named `iter` found for reference `&(isize,\
    \ isize, isize)` in the current scope\n  --> /tmp/tmpumdl0bd6.rs:13:40\n   |\n\
    13 |     triples.iter().all(|triple| triple.iter().all(|i| triple[0] == i && triple[1]\
    \ == j && triple[2] == k))\n   |                                        ^^^^ method\
    \ not found in `&(isize, isize, isize)`\n\nerror[E0608]: cannot index into a value\
    \ of type `&(isize, isize, isize)`\n  --> /tmp/tmpumdl0bd6.rs:13:55\n   |\n13\
    \ |     triples.iter().all(|triple| triple.iter().all(|i| triple[0] == i && triple[1]\
    \ == j && triple[2] == k))\n   |                                             \
    \          ^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `&(isize,\
    \ isize, isize)`\n  --> /tmp/tmpumdl0bd6.rs:13:73\n   |\n13 |     triples.iter().all(|triple|\
    \ triple.iter().all(|i| triple[0] == i && triple[1] == j && triple[2] == k))\n\
    \   |                                                                        \
    \ ^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `&(isize, isize,\
    \ isize)`\n  --> /tmp/tmpumdl0bd6.rs:13:91\n   |\n13 |     triples.iter().all(|triple|\
    \ triple.iter().all(|i| triple[0] == i && triple[1] == j && triple[2] == k))\n\
    \   |                                                                        \
    \                   ^^^^^^^^^\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors "
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3 || sum == 6\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwm29h09z.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut triples_sum_to_zero_count\
    \ = 0;\n    let mut triples_sum_to_zero_sum = 0;\n    for &i in l {\n        if\
    \ triples_sum_to_zero_count == 3 {\n            triples_sum_to_zero = true;\n\
    \            break;\n        }\n        if triples_sum_to_zero_sum == 0 {\n  \
    \          triples_sum_to_zero_sum += i;\n        } else {\n            triples_sum_to_zero_sum\
    \ += i;\n            triples_sum_to_zero_count += 1;\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjamq_qfj.rs:8:9\n  |\n8 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcl1xmon2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut triple = false;\n    for x in l {\n   \
    \     sum += x;\n        if sum == 0 {\n            triple = true;\n        }\n\
    \    }\n    triple\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpafqb09fn.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3 || sum == 6\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxii0ws_9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx8jzwjnl.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    let mut triples_sum_to_zero = false;\n\
    \    for i in l {\n        if triples.contains(&i) {\n            triples.push(i);\n\
    \        } else {\n            triples.push(i);\n            triples_sum_to_zero\
    \ = true;\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqpoi7vkk.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsu_41yn_.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = true;\n    let mut triples_sum_to_zero_count\
    \ = 0;\n    for x in l {\n        if triples_sum_to_zero_count == 3 {\n      \
    \      triples_sum_to_zero = false;\n            break;\n        }\n        if\
    \ x != 0 {\n            triples_sum_to_zero_count += 1;\n        }\n    }\n  \
    \  triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeo_au029.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        if triples.iter().any(|&x|\
    \ x == i) {\n            return false;\n        }\n        triples.push(i);\n\
    \    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpptyuzpyp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut triples_sum_to_zero = false;\n\
    \    for &i in l {\n        if triples.iter().any(|&j| i + j == 0)\n         \
    \   || triples.iter().any(|&j| i + j == i + j)\n            || triples.iter().any(|&j|\
    \ i + j == i + j + i) {\n            triples.push(i);\n        } else {\n    \
    \        triples_sum_to_zero = true;\n            break;\n        }\n    }\n \
    \   triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp11u_zxyy.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                if i + j + k == 0 {\n             \
    \       triples.push((i, j, k));\n                }\n            }\n        }\n\
    \    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpav49sk_0.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples = Vec::new();\n6   | \
    \    for i in l {\n    |              - `l` moved due to this implicit call to\
    \ `.into_iter()`\n7   |         for j in l {\n    |                  ^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmpav49sk_0.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 0
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in 0..l.len() {\n   \
    \     for j in (i + 1)..l.len() {\n            for k in (j + 1)..l.len() {\n \
    \               if l[i] + l[j] + l[k] == 0 {\n                    triples_sum_to_zero\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    for x in l {\n        if triples.contains(&x)\
    \ {\n            return false;\n        }\n        triples.push(x);\n    }\n \
    \   triples.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe_5youy4.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        if triples.iter().any(|&x|\
    \ x == i) {\n            return false;\n        }\n        triples.push(i);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfrk97pdd.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for i\
    \ in l {\n        sum += i;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdw82esfy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut triples_sum_to_zero = false;\n\
    \    for i in l {\n        if triples.iter().any(|&x| x == i) {\n            triples.push(i);\n\
    \        } else {\n            triples_sum_to_zero = true;\n        }\n    }\n\
    \    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4iroxafw.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpdo5_b760.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 3 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut triple_sum = 0;\n \
    \   let mut triple_count = 0;\n    for x in l {\n        if triple_count > 3 {\n\
    \            break;\n        }\n        if triple_sum == x {\n            triple_sum\
    \ += x;\n            triple_count += 1;\n        } else {\n            triple_sum\
    \ += x;\n            triple_count = 1;\n        }\n    }\n    if triple_count\
    \ == 3 {\n        triples_sum_to_zero = true;\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphdg12bd5.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptdw8or85.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut sum = 0;\n    for &i in l\
    \ {\n        if i == 0 {\n            triples.push(0);\n        } else {\n   \
    \         triples.push(i);\n            sum += i;\n        }\n    }\n    if triples.len()\
    \ == 3 {\n        if triples.iter().all(|&i| i == 0) {\n            true\n   \
    \     } else {\n            false\n        }\n    } else {\n        false\n  \
    \  }\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp58b2b5ss.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx8jzwjnl.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    for i in l {\n        for j in l {\n \
    \           for k in l {\n                triples.push((i, j, k));\n         \
    \   }\n        }\n    }\n    triples.iter().all(|triple| triple.iter().all(|i|\
    \ triple[0] != i && triple[1] != i && triple[2] != i))\n}\n\nfn main() {\n   \
    \ let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&(isize, isize,\
    \ isize)` in the current scope\n  --> /tmp/tmpolyygnj0.rs:13:40\n   |\n13 |  \
    \   triples.iter().all(|triple| triple.iter().all(|i| triple[0] != i && triple[1]\
    \ != i && triple[2] != i))\n   |                                        ^^^^ method\
    \ not found in `&(isize, isize, isize)`\n\nerror[E0608]: cannot index into a value\
    \ of type `&(isize, isize, isize)`\n  --> /tmp/tmpolyygnj0.rs:13:55\n   |\n13\
    \ |     triples.iter().all(|triple| triple.iter().all(|i| triple[0] != i && triple[1]\
    \ != i && triple[2] != i))\n   |                                             \
    \          ^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `&(isize,\
    \ isize, isize)`\n  --> /tmp/tmpolyygnj0.rs:13:73\n   |\n13 |     triples.iter().all(|triple|\
    \ triple.iter().all(|i| triple[0] != i && triple[1] != i && triple[2] != i))\n\
    \   |                                                                        \
    \ ^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `&(isize, isize,\
    \ isize)`\n  --> /tmp/tmpolyygnj0.rs:13:91\n   |\n13 |     triples.iter().all(|triple|\
    \ triple.iter().all(|i| triple[0] != i && triple[1] != i && triple[2] != i))\n\
    \   |                                                                        \
    \                   ^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut triples_sum_to_zero_counter\
    \ = 0;\n    let mut triples_sum_to_zero_counter2 = 0;\n    let mut triples_sum_to_zero_counter3\
    \ = 0;\n    for i in l {\n        if triples_sum_to_zero_counter == 0 {\n    \
    \        triples_sum_to_zero_counter = i;\n        }\n        if triples_sum_to_zero_counter2\
    \ == 0 {\n            triples_sum_to_zero_counter2 = i;\n        }\n        if\
    \ triples_sum_to_zero_counter3 == 0 {\n            triples_sum_to_zero_counter3\
    \ = i;\n        }\n        triples_sum_to_zero_counter += i;\n        triples_sum_to_zero_counter2\
    \ += i;\n        triples_sum_to_zero_counter3 += i;\n    }\n    if triples_sum_to_zero_counter\
    \ == triples_sum_to_zero_counter2 && triples_sum_to_zero_counter == triples_sum_to_zero_counter3\
    \ {\n        triples_sum_to_zero = true;\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp511vr9eu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                if i + j + k == 0 {\n             \
    \       triples.push((i, j, k));\n                }\n            }\n        }\n\
    \    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpav49sk_0.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples = Vec::new();\n6   | \
    \    for i in l {\n    |              - `l` moved due to this implicit call to\
    \ `.into_iter()`\n7   |         for j in l {\n    |                  ^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmpav49sk_0.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsu_41yn_.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzyuiktan.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for x\
    \ in l {\n        sum += x;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp2blkg77.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    for x in l {\n        for y in\
    \ triples.iter().rev() {\n            let z = x + y;\n            if z == 0 {\n\
    \                triples.push((x, y, z));\n                break;\n          \
    \  }\n        }\n    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `&({integer}, {integer}, {integer})` to `isize`\n\
    \ --> /tmp/tmperqzl9i_.rs:8:23\n  |\n8 |             let z = x + y;\n  |     \
    \                  ^ no implementation for `isize + &({integer}, {integer}, {integer})`\n\
    \  |\n  = help: the trait `Add<&({integer}, {integer}, {integer})>` is not implemented\
    \ for `isize`\n  = help: the following other types implement trait `Add<Rhs>`:\n\
    \            <&'a f32 as Add<f32>>\n            <&'a f64 as Add<f64>>\n      \
    \      <&'a i128 as Add<i128>>\n            <&'a i16 as Add<i16>>\n          \
    \  <&'a i32 as Add<i32>>\n            <&'a i64 as Add<i64>>\n            <&'a\
    \ i8 as Add<i8>>\n            <&'a isize as Add<isize>>\n          and 48 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmperqzl9i_.rs:10:34\n   |\n10 |\
    \                 triples.push((x, y, z));\n   |                             \
    \     ^ expected integer, found reference\n   |\n   = note:   expected type `{integer}`\n\
    \           found reference `&(isize, {integer}, {integer})`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    let mut sum = 0;\n    for &i\
    \ in l {\n        sum += i;\n        triples.push((sum, sum, sum));\n    }\n \
    \   triples.iter().all(|&(i, j, k)| i == 0 || j == 0 || k == 0)\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp137m8sd0.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsu_41yn_.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        if triples.contains(&(i\
    \ + i + i)) {\n            return true;\n        }\n        triples.push(i);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfy431rou.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l.iter() {\n     \
    \   for j in l.iter() {\n            for k in l.iter() {\n                if i\
    \ + j + k == 0 {\n                    triples_sum_to_zero = true;\n          \
    \          break;\n                }\n            }\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwhq4i8fn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && l.iter().all(|&i| i == 0)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpnpcxih3w.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 3 && l.iter().all(|&i| i == 0)\n    |                 ^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l`\n    = note: borrow occurs due to deref\
    \ coercion to `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut triples_sum_to_zero = false;\n    for &i\
    \ in l {\n        sum += i;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3_fgxxcx.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpddrmxc2e.rs:9:24\n  |\n9 |\
    \     sum == 0 || sum == l.len() - 3\n  |                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     sum == 0 || sum == (l.len()\
    \ - 3).try_into().unwrap()\n  |                        +           +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = true;\n    let mut sum = 0;\n    for i\
    \ in l {\n        if i == 0 {\n            triples_sum_to_zero = false;\n    \
    \        break;\n        }\n        sum += i;\n    }\n    triples_sum_to_zero\
    \ && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n  \
    \  assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphzwjopu5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for x\
    \ in l {\n        sum += x;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpip5pbg6k.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3 || sum == 6\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxii0ws_9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut triples_sum_to_zero = false;\n\
    \    for i in l {\n        if triples.is_empty() {\n            triples.push(i);\n\
    \        } else {\n            let mut triple = triples.last().unwrap();\n   \
    \         if triple + i == 0 {\n                triples.push(i);\n           \
    \ } else {\n                triples.pop();\n                triples.push(i);\n\
    \            }\n        }\n    }\n    triples_sum_to_zero = triples.len() == 3;\n\
    \    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw9vawcmp.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx8jzwjnl.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l.iter() {\n     \
    \   for j in l.iter() {\n            for k in l.iter() {\n                if i\
    \ + j + k == 0 {\n                    triples_sum_to_zero = true;\n          \
    \          break;\n                }\n            }\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwhq4i8fn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpdo5_b760.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 3 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                triples.push((i, j, k));\n        \
    \    }\n        }\n    }\n    triples.iter().filter(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().\n}\n\nfn main() {\n \
    \   let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected token: `)`\n  --> /tmp/tmp_qd2fn59.rs:14:1\n   |\n14\
    \ | }\n   | ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp_qd2fn59.rs:13:1242\n\
    \   |\n4  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \                                   - closing delimiter possibly meant for this\n\
    ...\n13 |     triples.iter().filter(|&(_, _, _)| triples.iter().any(|&(_, _, _)|\
    \ triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(...\n   |                                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                             "
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut i = 0;\n    while i < l.len() {\n     \
    \   sum += l[i];\n        if sum == 0 {\n            return true;\n        }\n\
    \        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn6rfzqgj.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    let mut triples_sum_to_zero =\
    \ false;\n    for i in l.iter() {\n        for triplet in triples {\n        \
    \    if triplet[0] + triplet[1] + triplet[2] <= i {\n                triples_sum_to_zero\
    \ = true;\n                break;\n            }\n        }\n        if triples_sum_to_zero\
    \ {\n            break;\n        }\n        triples.push((i, 0, 0));\n    }\n\
    \    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `({integer}, {integer},\
    \ {integer})`\n --> /tmp/tmpcro3hg29.rs:9:16\n  |\n9 |             if triplet[0]\
    \ + triplet[1] + triplet[2] <= i {\n  |                ^^^^^^^^^^ help: to access\
    \ tuple elements, use: `triplet.0`\n\nerror[E0608]: cannot index into a value\
    \ of type `({integer}, {integer}, {integer})`\n --> /tmp/tmpcro3hg29.rs:9:29\n\
    \  |\n9 |             if triplet[0] + triplet[1] + triplet[2] <= i {\n  |    \
    \                         ^^^^^^^^^^ help: to access tuple elements, use: `triplet.1`\n\
    \nerror[E0608]: cannot index into a value of type `({integer}, {integer}, {integer})`\n\
    \ --> /tmp/tmpcro3hg29.rs:9:42\n  |\n9 |             if triplet[0] + triplet[1]\
    \ + triplet[2] <= i {\n  |                                          ^^^^^^^^^^\
    \ help: to access tuple elements, use: `triplet.2`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcro3hg29.rs:17:23\n   |\n17 |         triples.push((i,\
    \ 0, 0));\n   |                       ^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n17 |         triples.push((*i,\
    \ 0, 0));\n   |                       +\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx8jzwjnl.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut found = false;\n    for x in l {\n    \
    \    sum += x;\n        if sum == 0 {\n            found = true;\n           \
    \ break;\n        }\n    }\n    found\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9yertsnt.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    let mut sum = 0;\n    for x in\
    \ l {\n        sum += x;\n        triples.push((sum - x, sum, 0));\n    }\n  \
    \  let mut triples_sum_to_zero = false;\n    for triple in triples {\n       \
    \ if triple[0] == triple[1] && triple[1] == triple[2] {\n            triples_sum_to_zero\
    \ = true;\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `(isize, isize, {integer})`\n\
    \  --> /tmp/tmp7rkbhrfw.rs:13:12\n   |\n13 |         if triple[0] == triple[1]\
    \ && triple[1] == triple[2] {\n   |            ^^^^^^^^^ help: to access tuple\
    \ elements, use: `triple.0`\n\nerror[E0608]: cannot index into a value of type\
    \ `(isize, isize, {integer})`\n  --> /tmp/tmp7rkbhrfw.rs:13:25\n   |\n13 |   \
    \      if triple[0] == triple[1] && triple[1] == triple[2] {\n   |           \
    \              ^^^^^^^^^ help: to access tuple elements, use: `triple.1`\n\nerror[E0608]:\
    \ cannot index into a value of type `(isize, isize, {integer})`\n  --> /tmp/tmp7rkbhrfw.rs:13:38\n\
    \   |\n13 |         if triple[0] == triple[1] && triple[1] == triple[2] {\n  \
    \ |                                      ^^^^^^^^^ help: to access tuple elements,\
    \ use: `triple.1`\n\nerror[E0608]: cannot index into a value of type `(isize,\
    \ isize, {integer})`\n  --> /tmp/tmp7rkbhrfw.rs:13:51\n   |\n13 |         if triple[0]\
    \ == triple[1] && triple[1] == triple[2] {\n   |                             \
    \                      ^^^^^^^^^ help: to access tuple elements, use: `triple.2`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    for i in l {\n        if triples.contains(&i)\
    \ {\n            triples.push(i);\n        }\n    }\n    triples.len() == 3\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9ndilat8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut found = false;\n    for &i in l {\n   \
    \     if i == 0 {\n            found = true;\n        } else {\n            sum\
    \ += i;\n        }\n    }\n    found && sum == 0\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0krmjlzh.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    for x in l {\n        for y in\
    \ triples.iter().rev() {\n            let mut z = x + y;\n            if z ==\
    \ 0 {\n                triples.push((x, y, z));\n                break;\n    \
    \        }\n        }\n    }\n    triples.len() == 3\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `&({integer}, {integer}, {integer})` to `isize`\n\
    \ --> /tmp/tmpbgiglguj.rs:8:27\n  |\n8 |             let mut z = x + y;\n  | \
    \                          ^ no implementation for `isize + &({integer}, {integer},\
    \ {integer})`\n  |\n  = help: the trait `Add<&({integer}, {integer}, {integer})>`\
    \ is not implemented for `isize`\n  = help: the following other types implement\
    \ trait `Add<Rhs>`:\n            <&'a f32 as Add<f32>>\n            <&'a f64 as\
    \ Add<f64>>\n            <&'a i128 as Add<i128>>\n            <&'a i16 as Add<i16>>\n\
    \            <&'a i32 as Add<i32>>\n            <&'a i64 as Add<i64>>\n      \
    \      <&'a i8 as Add<i8>>\n            <&'a isize as Add<isize>>\n          and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbgiglguj.rs:10:34\n\
    \   |\n10 |                 triples.push((x, y, z));\n   |                   \
    \               ^ expected integer, found reference\n   |\n   = note:   expected\
    \ type `{integer}`\n           found reference `&(isize, {integer}, {integer})`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcl1xmon2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for x\
    \ in l {\n        sum += x;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpip5pbg6k.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    for i in l {\n        for j in l {\n \
    \           for k in l {\n                triples.push((i, j, k));\n         \
    \   }\n        }\n    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphd2wwm_7.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples = vec![];\n6   |     for\
    \ i in l {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    7   |         for j in l {\n    |                  ^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n    |    \
    \          +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphd2wwm_7.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l.iter() {\n     \
    \   for j in l.iter() {\n            for k in l.iter() {\n                if i\
    \ + j + k == 0 {\n                    triples_sum_to_zero = true;\n          \
    \          break;\n                }\n            }\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwhq4i8fn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut sum = 0;\n    for &i in l\
    \ {\n        sum += i;\n        triples.push((i, sum, sum != 0));\n    }\n   \
    \ triples.iter().all(|&(_, _, v)| v)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7blci9u_.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmm574xmc.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut triples_sum_to_zero_counter\
    \ = 0;\n    let mut triples_sum_to_zero_counter2 = 0;\n    for x in l {\n    \
    \    if triples_sum_to_zero_counter == 0 {\n            triples_sum_to_zero_counter\
    \ = x;\n        }\n        if triples_sum_to_zero_counter2 == 0 {\n          \
    \  triples_sum_to_zero_counter2 = x;\n        }\n        if triples_sum_to_zero_counter\
    \ == triples_sum_to_zero_counter2 {\n            triples_sum_to_zero_counter2\
    \ += x;\n        }\n        if triples_sum_to_zero_counter2 == 3 {\n         \
    \   triples_sum_to_zero = true;\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoqixlnk4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for i\
    \ in l {\n        sum += i;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdw82esfy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut triples_sum_to_zero = false;\n    for i\
    \ in l {\n        sum += i;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptjrbfpwt.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = 0;\n    while i < l.len() && j < l.len() && k < l.len() {\n        sum +=\
    \ l[i];\n        i += 1;\n        sum += l[j];\n        j += 1;\n        sum +=\
    \ l[k];\n        k += 1;\n    }\n    sum == 0 && i == l.len() && j == l.len()\
    \ && k == l.len()\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxyca8xgs.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                triples.push((i, j, k));\n        \
    \    }\n        }\n    }\n    let mut triples_set = HashSet::new();\n    for triple\
    \ in triples {\n        triples_set.insert(triple);\n    }\n    triples_set.len()\
    \ == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmppq1ys_fp.rs:13:27\n   |\n13 |     let mut triples_set = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    let mut sum = 0;\n    for &i\
    \ in l {\n        triples.push((i, i, i));\n        sum += i;\n    }\n    for\
    \ triple in triples {\n        if triple[0] + triple[1] + triple[2] != sum {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphih9g7k1.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0608]: cannot index into\
    \ a value of type `({integer}, {integer}, {integer})`\n  --> /tmp/tmphih9g7k1.rs:12:12\n\
    \   |\n12 |         if triple[0] + triple[1] + triple[2] != sum {\n   |      \
    \      ^^^^^^^^^ help: to access tuple elements, use: `triple.0`\n\nerror[E0608]:\
    \ cannot index into a value of type `({integer}, {integer}, {integer})`\n  -->\
    \ /tmp/tmphih9g7k1.rs:12:24\n   |\n12 |         if triple[0] + triple[1] + triple[2]\
    \ != sum {\n   |                        ^^^^^^^^^ help: to access tuple elements,\
    \ use: `triple.1`\n\nerror[E0608]: cannot index into a value of type `({integer},\
    \ {integer}, {integer})`\n  --> /tmp/tmphih9g7k1.rs:12:36\n   |\n12 |        \
    \ if triple[0] + triple[1] + triple[2] != sum {\n   |                        \
    \            ^^^^^^^^^ help: to access tuple elements, use: `triple.2`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut triples_sum_to_zero_counter\
    \ = 0;\n    for i in l {\n        if triples_sum_to_zero_counter > 3 {\n     \
    \       break;\n        }\n        for j in l {\n            if triples_sum_to_zero_counter\
    \ > 3 {\n                break;\n            }\n            for k in l {\n   \
    \             if triples_sum_to_zero_counter > 3 {\n                    break;\n\
    \                }\n                if i + j + k == 0 {\n                    triples_sum_to_zero\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n        triples_sum_to_zero_counter += 1;\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmp49tcumyh.rs:11:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n7   |     for i in l {\n    |             \
    \ - `l` moved due to this implicit call to `.into_iter()`\n...\n11  |        \
    \ for j in l {\n    |                  ^ value used here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `l`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n7   |     for i in &l {\n    |              +\n\n\
    error[E0382]: use of moved value: `l`\n  --> /tmp/tmp49tcumyh.rs:15:22\n   |\n\
    4  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |                   \
    \     - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n11 |         for j in l {\n   |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n...\n15 |             for\
    \ k in l {\n   |                      ^ value used here after move\n   |\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n   |\n11 |         for j in &l {\n   |                \
    \  +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpddrmxc2e.rs:9:24\n  |\n9 |\
    \     sum == 0 || sum == l.len() - 3\n  |                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     sum == 0 || sum == (l.len()\
    \ - 3).try_into().unwrap()\n  |                        +           +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqewjr1c_.rs:9:24\n  |\n9 |\
    \     sum == 0 || sum == l.len() - 3\n  |                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     sum == 0 || sum == (l.len()\
    \ - 3).try_into().unwrap()\n  |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzyuiktan.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    for &i in l {\n        for &j\
    \ in &triples {\n            for &k in &triples {\n                if i + j +\
    \ k == 0 {\n                    triples.push((i, j, k));\n                }\n\
    \            }\n        }\n    }\n    triples.len() == 3\n}\n\nfn main() {\n \
    \   let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsi0qlijc.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0277]: cannot add `({integer},\
    \ {integer}, {integer})` to `{integer}`\n --> /tmp/tmpsi0qlijc.rs:9:22\n  |\n\
    9 |                 if i + j + k == 0 {\n  |                      ^ no implementation\
    \ for `{integer} + ({integer}, {integer}, {integer})`\n  |\n  = help: the trait\
    \ `Add<({integer}, {integer}, {integer})>` is not implemented for `{integer}`\n\
    \  = help: the following other types implement trait `Add<Rhs>`:\n           \
    \ <&'a f32 as Add<f32>>\n            <&'a f64 as Add<f64>>\n            <&'a i128\
    \ as Add<i128>>\n            <&'a i16 as Add<i16>>\n            <&'a i32 as Add<i32>>\n\
    \            <&'a i64 as Add<i64>>\n            <&'a i8 as Add<i8>>\n        \
    \    <&'a isize as Add<isize>>\n          and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsi0qlijc.rs:10:38\n   |\n10 |                     triples.push((i,\
    \ j, k));\n   |                                      ^ expected integer, found\
    \ tuple\n   |\n   = note: expected type `{integer}`\n             found tuple\
    \ `({integer}, {integer}, {integer})`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsi0qlijc.rs:10:41\n   |\n10 |                     triples.push((i, j,\
    \ k));\n   |                                         ^ expected integer, found\
    \ tuple\n   |\n   = note: expected type `{integer}`\n             found tuple\
    \ `({integer}, {integer}, {integer})`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzyuiktan.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptdw8or85.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                triples.push((i, j, k));\n        \
    \    }\n        }\n    }\n    triples.iter().filter(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().\n}\n\nfn main() {\n \
    \   let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected token: `)`\n  --> /tmp/tmp_qd2fn59.rs:14:1\n   |\n14\
    \ | }\n   | ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp_qd2fn59.rs:13:1242\n\
    \   |\n4  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \                                   - closing delimiter possibly meant for this\n\
    ...\n13 |     triples.iter().filter(|&(_, _, _)| triples.iter().any(|&(_, _, _)|\
    \ triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(...\n   |                                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                             "
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzyuiktan.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut triples_sum_to_zero_count\
    \ = 0;\n    let mut triples_sum_to_zero_sum = 0;\n    for x in l {\n        if\
    \ triples_sum_to_zero_count == 3 {\n            triples_sum_to_zero = true;\n\
    \            break;\n        }\n        if triples_sum_to_zero_sum == 0 {\n  \
    \          triples_sum_to_zero_sum += x;\n            triples_sum_to_zero_count\
    \ += 1;\n        } else {\n            triples_sum_to_zero_sum += x;\n       \
    \     triples_sum_to_zero_count += 1;\n            if triples_sum_to_zero_sum\
    \ == x {\n                triples_sum_to_zero_count += 1;\n            }\n   \
    \     }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv67o4kfn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpddrmxc2e.rs:9:24\n  |\n9 |\
    \     sum == 0 || sum == l.len() - 3\n  |                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     sum == 0 || sum == (l.len()\
    \ - 3).try_into().unwrap()\n  |                        +           +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for x\
    \ in l {\n        sum += x;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpip5pbg6k.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsu_41yn_.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                triples.push((i, j, k));\n        \
    \    }\n        }\n    }\n    triples.iter().all(|triple| triple.iter().all(|i|\
    \ i == 0 || i == 1 || i == 2))\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&(isize, isize,\
    \ isize)` in the current scope\n  --> /tmp/tmpurcz9bu1.rs:13:40\n   |\n13 |  \
    \   triples.iter().all(|triple| triple.iter().all(|i| i == 0 || i == 1 || i ==\
    \ 2))\n   |                                        ^^^^ method not found in `&(isize,\
    \ isize, isize)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for &i in l {\n        triples.push((i,\
    \ i, i));\n    }\n    triples.sort();\n    let mut triples_sum_to_zero = false;\n\
    \    for triple in triples {\n        if triple[0] + triple[1] + triple[2] !=\
    \ 0 {\n            triples_sum_to_zero = true;\n            break;\n        }\n\
    \    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpezbqzhw4.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0608]: cannot index into\
    \ a value of type `(_, _, _)`\n  --> /tmp/tmpezbqzhw4.rs:12:12\n   |\n12 |   \
    \      if triple[0] + triple[1] + triple[2] != 0 {\n   |            ^^^^^^^^^\
    \ help: to access tuple elements, use: `triple.0`\n\nerror[E0608]: cannot index\
    \ into a value of type `(_, _, _)`\n  --> /tmp/tmpezbqzhw4.rs:12:24\n   |\n12\
    \ |         if triple[0] + triple[1] + triple[2] != 0 {\n   |                \
    \        ^^^^^^^^^ help: to access tuple elements, use: `triple.1`\n\nerror[E0608]:\
    \ cannot index into a value of type `(_, _, _)`\n  --> /tmp/tmpezbqzhw4.rs:12:36\n\
    \   |\n12 |         if triple[0] + triple[1] + triple[2] != 0 {\n   |        \
    \                            ^^^^^^^^^ help: to access tuple elements, use: `triple.2`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut sum = 0;\n    for &i in l\
    \ {\n        if i == 0 {\n            triples.push(0);\n            sum += i;\n\
    \        } else {\n            triples.push(i);\n            sum += i;\n     \
    \   }\n    }\n    if sum == 0 {\n        return true;\n    }\n    let mut triples_sum_to_zero\
    \ = false;\n    for i in triples.iter() {\n        if triples.iter().any(|&j|\
    \ j == i) {\n            triples_sum_to_zero = true;\n            break;\n   \
    \     }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9p65lj9g.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0277]: can't compare\
    \ `{integer}` with `&{integer}`\n  --> /tmp/tmp9p65lj9g.rs:21:38\n   |\n21 | \
    \        if triples.iter().any(|&j| j == i) {\n   |                          \
    \            ^^ no implementation for `{integer} == &{integer}`\n   |\n   = help:\
    \ the trait `PartialEq<&{integer}>` is not implemented for `{integer}`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx8jzwjnl.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 0
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in 0..l.len() {\n   \
    \     for j in (i + 1)..l.len() {\n            for k in (j + 1)..l.len() {\n \
    \               if l[i] + l[j] + l[k] == 0 {\n                    triples_sum_to_zero\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzyuiktan.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                if i + j + k == 0 {\n             \
    \       triples.push((i, j, k));\n                }\n            }\n        }\n\
    \    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpav49sk_0.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples = Vec::new();\n6   | \
    \    for i in l {\n    |              - `l` moved due to this implicit call to\
    \ `.into_iter()`\n7   |         for j in l {\n    |                  ^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmpav49sk_0.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpdo5_b760.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 3 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for x\
    \ in l {\n        sum += x;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpip5pbg6k.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    for x in l {\n        for y in\
    \ l {\n            for z in l {\n                if x + y + z == 0 {\n       \
    \             triples.push((x, y, z));\n                }\n            }\n   \
    \     }\n    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmp2vp1u003.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples = vec![(0, 0, 0)];\n6\
    \   |     for x in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for y in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmp2vp1u003.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for y in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for z in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for y in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmm574xmc.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut triples_sum_to_zero = false;\n    for x\
    \ in l {\n        if x == 0 {\n            triples_sum_to_zero = true;\n     \
    \       break;\n        }\n        sum += x;\n    }\n    if sum == 0 {\n     \
    \   triples_sum_to_zero = false;\n    }\n    triples_sum_to_zero\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpecskkzz8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    for x in l {\n        for y in\
    \ l {\n            for z in l {\n                let triple = (x, y, z);\n   \
    \             if triples.iter().any(|&(_, x, _)| x == triple[0] && y == triple[1]\
    \ && z == triple[2]) {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `(isize, isize, isize)`\n\
    \  --> /tmp/tmp8s6e3u9s.rs:10:57\n   |\n10 |                 if triples.iter().any(|&(_,\
    \ x, _)| x == triple[0] && y == triple[1] && z == triple[2]) {\n   |         \
    \                                                ^^^^^^^^^ help: to access tuple\
    \ elements, use: `triple.0`\n\nerror[E0608]: cannot index into a value of type\
    \ `(isize, isize, isize)`\n  --> /tmp/tmp8s6e3u9s.rs:10:75\n   |\n10 |       \
    \          if triples.iter().any(|&(_, x, _)| x == triple[0] && y == triple[1]\
    \ && z == triple[2]) {\n   |                                                 \
    \                          ^^^^^^^^^ help: to access tuple elements, use: `triple.1`\n\
    \nerror[E0608]: cannot index into a value of type `(isize, isize, isize)`\n  -->\
    \ /tmp/tmp8s6e3u9s.rs:10:93\n   |\n10 |                 if triples.iter().any(|&(_,\
    \ x, _)| x == triple[0] && y == triple[1] && z == triple[2]) {\n   |         \
    \                                                                            \
    \        ^^^^^^^^^ help: to access tuple elements, use: `triple.2`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0608`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut triples_sum_to_zero = false;\n\
    \    for x in l {\n        if triples.iter().any(|&y| x == y) {\n            triples.push(x);\n\
    \        } else {\n            triples_sum_to_zero = true;\n            break;\n\
    \        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp17918ar1.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for i\
    \ in l {\n        sum += i;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdw82esfy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut triples_sum_to_zero = false;\n\
    \    for &i in l {\n        if triples.len() == 3 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n        if i == triples[0] + triples[1]\
    \ + triples[2] {\n            triples.push(i);\n        } else {\n           \
    \ triples.pop();\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzh_bos5h.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcl1xmon2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    let mut sum = 0;\n    for x in l {\n \
    \       sum += x;\n        triples.push((sum, x, 0));\n    }\n    let mut triples_sum_to_zero\
    \ = false;\n    for triple in triples {\n        if triple[0] > 0 && triple[1]\
    \ > 0 && triple[2] > 0 {\n            triples_sum_to_zero = true;\n          \
    \  break;\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `(isize, isize, {integer})`\n\
    \  --> /tmp/tmpf35cek99.rs:13:12\n   |\n13 |         if triple[0] > 0 && triple[1]\
    \ > 0 && triple[2] > 0 {\n   |            ^^^^^^^^^ help: to access tuple elements,\
    \ use: `triple.0`\n\nerror[E0608]: cannot index into a value of type `(isize,\
    \ isize, {integer})`\n  --> /tmp/tmpf35cek99.rs:13:29\n   |\n13 |         if triple[0]\
    \ > 0 && triple[1] > 0 && triple[2] > 0 {\n   |                             ^^^^^^^^^\
    \ help: to access tuple elements, use: `triple.1`\n\nerror[E0608]: cannot index\
    \ into a value of type `(isize, isize, {integer})`\n  --> /tmp/tmpf35cek99.rs:13:46\n\
    \   |\n13 |         if triple[0] > 0 && triple[1] > 0 && triple[2] > 0 {\n   |\
    \                                              ^^^^^^^^^ help: to access tuple\
    \ elements, use: `triple.2`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcl1xmon2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    for i in l {\n        if triples.contains(&(i\
    \ + i + i)) {\n            return true;\n        }\n        triples.push(i);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_142i6om.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for x\
    \ in l {\n        sum += x;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpip5pbg6k.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l.iter() {\n     \
    \   for j in l.iter() {\n            for k in l.iter() {\n                if i\
    \ + j + k == 0 {\n                    triples_sum_to_zero = true;\n          \
    \      }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkk2qfwfp.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx8jzwjnl.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                if i + j + k == 0 {\n             \
    \       triples.push((i, j, k));\n                }\n            }\n        }\n\
    \    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpav49sk_0.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples = Vec::new();\n6   | \
    \    for i in l {\n    |              - `l` moved due to this implicit call to\
    \ `.into_iter()`\n7   |         for j in l {\n    |                  ^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmpav49sk_0.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut triple = false;\n    for x in l {\n   \
    \     if x == 0 {\n            sum += x;\n        } else {\n            if sum\
    \ == x {\n                triple = true;\n            }\n            sum = 0;\n\
    \        }\n    }\n    triple\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbxx3osqt.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzyuiktan.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpiz6owh6i.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        if triples.contains(&i)\
    \ {\n            triples.push(i);\n        }\n    }\n    triples.len() == 3\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpprpa66o4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                triples.push((i, j, k));\n        \
    \    }\n        }\n    }\n    triples.iter().all(|&(_, _, _)| {\n        triples.iter().all(|&(_,\
    \ _, _)| {\n            triples.iter().all(|&(_, _, _)| {\n                triples.iter().all(|&(_,\
    \ _, _)| {\n                    triples.iter().all(|&(_, _, _)| {\n          \
    \              triples.iter().all(|&(_, _, _)| {\n                           \
    \ triples.iter().all(|&(_, _, _)| {\n                                triples.iter().all(|&(_,\
    \ _, _)| {\n                                    triples.iter().all(|&(_, _, _)|\
    \ {\n                                        triples.iter().all(|&(_, _, _)| {\n\
    \                                            triples.iter().all(|&(_, _, _)| {\n\
    \                                                triples.iter().all(|&(_, _, _)|\
    \ {\n                                                    triples.iter().all(|&(_,\
    \ _, _)| {\n                                                        triples.iter().all(|&(_,\
    \ _, _)| {\n                                                            triples.iter().all(|&(_,\
    \ _, _)| {\n                                                                triples.iter().all(|&(_,\
    \ _, _)| {\n                                                                 \
    \   triples.iter().all(|&(_, _, _)| {\n                                      \
    \                                  triples.iter().all(|&(_, _, _)| {\n       \
    \                                                                     triples.iter().all(|&(_,\
    \ _, _)| {\n                                                                 \
    \               triples.iter().all(|&(_, _, _)| {\n                          \
    \                                                          triples.iter().all(|&(_,\
    \ _, _)| {\n                                                                 \
    \                       triples.iter().all(|&(_, _, _)| {\n                  \
    \                                                                          triples.iter().all(|&(_,\
    \ _, _)| {\n                                                                 \
    \                               triples.iter().all(|&(_, _, _)| {\n          \
    \                                                                            \
    \              triples.iter().all(|&(_, _, _)| {\n                           \
    \                                                                            \
    \ triples.iter().all(|&(_, _, _)| {\n                                        \
    \                                                                    triples.iter().all(|&(_,\
    \ _, _)| {\n                                                                 \
    \                                               triples.iter().all(|&(_, _, _)|\
    \ {\n                                                                        \
    \                                            triples.iter().all(|&(_, _, _)| {\n\
    \                                                                            \
    \                                            triples.iter().all(|&(_, _, _)| {\n\
    \                                                                            \
    \                                                triples.iter().all(|&\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuhc2l769.rs:57:3\n\
    \   |\n4  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \                                   - unclosed delimiter\n...\n13 |     triples.iter().all(|&(_,\
    \ _, _)| {\n   |                       -             - unclosed delimiter\n  \
    \ |                       |\n   |                       unclosed delimiter\n14\
    \ |         triples.iter().all(|&(_, _, _)| {\n   |                          \
    \ -             - unclosed delimiter\n   |                           |\n   | \
    \                          unclosed delimiter\n15 |             triples.iter().all(|&(_,\
    \ _, _)| {\n   |                               -             - unclosed delimiter\n\
    \   |                               |\n   |                               unclosed\
    \ delimiter\n16 |                 triples.iter().all(|&(_, _, _)| {\n   |    \
    \                               -             - unclosed delimiter\n   |     \
    \                              |\n   |                                   unclosed\
    \ delimiter\n17 |                     triples.iter().all(|&(_, _, _)| {\n   |\
    \                                       -             - unclosed delimiter\n \
    \  |                                       |\n   |                           \
    \            unclosed delimiter\n18 |                         triples.iter().all(|&(_,\
    \ _, _)| {\n   |                                           -             - unclosed\
    \ delimiter\n   |                                           |\n   |          \
    \                                 unclosed delimiter\n19 |                   \
    \          triples.iter().all(|&(_, _, _)| {\n   |                           \
    \                    -             - unclosed delimiter\n   |                \
    \                               |\n   |                                      \
    \         unclosed delimiter\n20 |                                 triples.iter().all(|&(_,\
    \ _, _)| {\n   |                                                   -         \
    \    - unclosed delimiter\n   |                                              \
    \     |\n   |                 "
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l.iter() {\n     \
    \   for j in l.iter() {\n            for k in l.iter() {\n                if i\
    \ + j + k == 0 {\n                    triples_sum_to_zero = true;\n          \
    \          break;\n                }\n            }\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwhq4i8fn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = 0;\n    while i < l.len() && j < l.len() && k < l.len() {\n        sum +=\
    \ l[i];\n        i += 1;\n        sum += l[j];\n        j += 1;\n        sum +=\
    \ l[k];\n        k += 1;\n    }\n    sum == 0 && k == l.len() - 1\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_jxuj9tv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp52lmdbm0.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              -\n    |              |\n    |              `l` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&l`\n...\n9   |     sum == 0 &&\
    \ l.len() == 3\n    |                 ^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `l`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l.iter() {\n     \
    \   if l.iter().any(|j| i + j == 0 || i + j == l.len() - 1) {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu6qui7om.rs:7:52\n  |\n7 |\
    \         if l.iter().any(|j| i + j == 0 || i + j == l.len() - 1) {\n  |     \
    \                                               ^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n7 |         if l.iter().any(|j| i +\
    \ j == 0 || i + j == (l.len() - 1).try_into().unwrap()) {\n  |               \
    \                                     +           +++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzyuiktan.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc_gq8g5q.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for i\
    \ in l {\n        sum += i;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdw82esfy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptdw8or85.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqewjr1c_.rs:9:24\n  |\n9 |\
    \     sum == 0 || sum == l.len() - 3\n  |                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     sum == 0 || sum == (l.len()\
    \ - 3).try_into().unwrap()\n  |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    let mut triples_sum_to_zero = false;\n\
    \    for &i in l {\n        if triples.is_empty() {\n            triples.push(i);\n\
    \        } else {\n            let mut triple = triples.last().unwrap();\n   \
    \         if triple + i == 0 {\n                triples.push(i);\n           \
    \ } else {\n                triples_sum_to_zero = true;\n            }\n     \
    \   }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpryf9lux8.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                triples.push((i, j, k));\n        \
    \    }\n        }\n    }\n    triples.iter().filter(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().\n}\n\nfn main() {\n \
    \   let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected token: `)`\n  --> /tmp/tmp_qd2fn59.rs:14:1\n   |\n14\
    \ | }\n   | ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp_qd2fn59.rs:13:1242\n\
    \   |\n4  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \                                   - closing delimiter possibly meant for this\n\
    ...\n13 |     triples.iter().filter(|&(_, _, _)| triples.iter().any(|&(_, _, _)|\
    \ triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_, _, _)| triples.iter().any(|&(_,\
    \ _, _)| triples.iter().any(|&(...\n   |                                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                             "
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzyuiktan.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 || sum == 3 || sum == 6\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkyx44wc6.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc_gq8g5q.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    let mut sum = 0;\n    for x in l {\n \
    \       sum += x;\n        triples.push((x, sum, sum - x));\n    }\n    triples.iter().all(|&(_,\
    \ x, _)| x == 0)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm7jih1vw.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for x\
    \ in l {\n        sum += x;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp2blkg77.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpddrmxc2e.rs:9:24\n  |\n9 |\
    \     sum == 0 || sum == l.len() - 3\n  |                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     sum == 0 || sum == (l.len()\
    \ - 3).try_into().unwrap()\n  |                        +           +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && l.iter().all(|&x| x == 0)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpxelj2h90.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 3 && l.iter().all(|&x| x == 0)\n    |                 ^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l`\n    = note: borrow occurs due to deref\
    \ coercion to `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for x in l {\n        sum += x;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpddrmxc2e.rs:9:24\n  |\n9 |\
    \     sum == 0 || sum == l.len() - 3\n  |                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     sum == 0 || sum == (l.len()\
    \ - 3).try_into().unwrap()\n  |                        +           +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    for i in l {\n        if triples.contains(&(i\
    \ + i + i)) {\n            return true;\n        }\n        triples.push(i);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_142i6om.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut i = 0;\n    while i < l.len() {\n     \
    \   sum += l[i];\n        i += 1;\n    }\n    sum == 0 && l.len() == 3\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_6hi714r.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                if i + j + k == 0 {\n             \
    \       triples.push((i, j, k));\n                }\n            }\n        }\n\
    \    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpav49sk_0.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples = Vec::new();\n6   | \
    \    for i in l {\n    |              - `l` moved due to this implicit call to\
    \ `.into_iter()`\n7   |         for j in l {\n    |                  ^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmpav49sk_0.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = 0;\n    while i < l.len() && j < l.len() && k < l.len() {\n        sum +=\
    \ l[i];\n        i += 1;\n        sum += l[j];\n        j += 1;\n        sum +=\
    \ l[k];\n        k += 1;\n    }\n    sum == 0 && i != l.len() && j != l.len()\
    \ && k != l.len()\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp57w3zktc.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for &i\
    \ in l {\n        sum += i;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_xz4atoj.rs:7:9\n  |\n7 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == l.len() - 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqewjr1c_.rs:9:24\n  |\n9 |\
    \     sum == 0 || sum == l.len() - 3\n  |                        ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n9 |     sum == 0 || sum == (l.len()\
    \ - 3).try_into().unwrap()\n  |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && l.iter().all(|&x| x == 0)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpxelj2h90.rs:9:17\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut sum = 0;\n6   |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n9   |     sum == 3 && l.iter().all(|&x| x == 0)\n    |                 ^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l`\n    = note: borrow occurs due to deref\
    \ coercion to `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = true;\n    let mut sum = 0;\n    for i\
    \ in l {\n        sum += i;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = false;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsr76797m.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = true;\n    for i in l.iter() {\n      \
    \  for j in l.iter() {\n            for k in l.iter() {\n                if i\
    \ + j + k == 0 {\n                    triples_sum_to_zero = false;\n         \
    \           break;\n                }\n            }\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppqjksyi7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc_gq8g5q.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for i in l {\n        sum += i;\n    }\n    sum\
    \ == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp37c1t_xo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut sum = 0;\n    for &i in l {\n        sum += i;\n    }\n    sum\
    \ == 0 || sum == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsu_41yn_.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `isize`\n  |\
    \         |\n  |         expected `isize`, found reference\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749110
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut sum = 0;\n    for i\
    \ in l {\n        sum += i;\n        if sum == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n    }\n    triples_sum_to_zero\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdw82esfy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![(0, 0, 0)];\n    for &i in l {\n        for &j\
    \ in triples {\n            for &k in triples {\n                if i + j + k\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n        triples.push((i, 0, 0));\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1gu3jdf8.rs:6:9\n  |\n6 |\
    \     for &i in l {\n  |         ^^    - this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp1gu3jdf8.rs:7:13\n  |\n7 |         for &j in triples {\n  |    \
    \         ^^    ------- this expression has type `Option<({integer}, {integer},\
    \ {integer})>`\n  |             |\n  |             expected tuple, found reference\n\
    \  |             help: you can probably remove the explicit borrow: `j`\n  |\n\
    \  = note:  expected tuple `({integer}, {integer}, {integer})`\n          found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1gu3jdf8.rs:8:17\n\
    \  |\n8 |             for &k in triples {\n  |                 ^^    ------- this\
    \ expression has type `Option<({integer}, {integer}, {integer})>`\n  |       \
    \          |\n  |                 expected tuple, found reference\n  |       \
    \          help: you can probably remove the explicit borrow: `k`\n  |\n  = note:\
    \  expected tuple `({integer}, {integer}, {integer})`\n          found reference\
    \ `&_`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    let mut triples_sum_to_zero_count\
    \ = 0;\n    let mut triples_sum_to_zero_sum = 0;\n    for x in l {\n        if\
    \ triples_sum_to_zero_count == 3 {\n            triples_sum_to_zero = true;\n\
    \            break;\n        }\n        if triples_sum_to_zero_sum == x {\n  \
    \          triples_sum_to_zero_count++;\n        } else {\n            triples_sum_to_zero_sum\
    \ += x;\n            triples_sum_to_zero_count = 1;\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpo9xtybww.rs:14:38\n\
    \   |\n14 |             triples_sum_to_zero_count++;\n   |                   \
    \                   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n14 |             { let tmp = triples_sum_to_zero_count; triples_sum_to_zero_count\
    \ += 1; tmp };\n   |             +++++++++++                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    14 -             triples_sum_to_zero_count++;\n14 +             triples_sum_to_zero_count\
    \ += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = Vec::new();\n    for i in l {\n        for j in l {\n\
    \            for k in l {\n                if i + j + k == 0 {\n             \
    \       triples.push((i, j, k));\n                }\n            }\n        }\n\
    \    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpav49sk_0.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples = Vec::new();\n6   | \
    \    for i in l {\n    |              - `l` moved due to this implicit call to\
    \ `.into_iter()`\n7   |         for j in l {\n    |                  ^ value used\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmpav49sk_0.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples = vec![];\n    for i in l {\n        for j in l {\n \
    \           for k in l {\n                if i + j + k == 0 {\n              \
    \      triples.push((i, j, k));\n                }\n            }\n        }\n\
    \    }\n    triples.len() == 3\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpwx2snx8n.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples = vec![];\n6   |     for\
    \ i in l {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    7   |         for j in l {\n    |                  ^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n    |    \
    \          +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmpwx2snx8n.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l {\n        for j\
    \ in l {\n            for k in l {\n                if i + j + k == 0 {\n    \
    \                triples_sum_to_zero = true;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    triples_sum_to_zero\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphg03pk_s.rs:7:18\n\
    \    |\n4   | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n5   |     let mut triples_sum_to_zero = false;\n\
    6   |     for i in l {\n    |              - `l` moved due to this implicit call\
    \ to `.into_iter()`\n7   |         for j in l {\n    |                  ^ value\
    \ used here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n6   |     for i in &l {\n\
    \    |              +\n\nerror[E0382]: use of moved value: `l`\n --> /tmp/tmphg03pk_s.rs:8:22\n\
    \  |\n4 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n  |               \
    \         - move occurs because `l` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n7 |         for j in l {\n  |                  - `l`\
    \ moved due to this implicit call to `.into_iter()`\n8 |             for k in\
    \ l {\n  |                      ^ value used here after move\n  |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n  |\n7 |         for j in &l {\n  |                  +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976511
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\nfn triples_sum_to_zero(l: Vec<isize>) -> bool\
    \ {\n    let mut triples_sum_to_zero = false;\n    for i in l.iter() {\n     \
    \   for j in l.iter() {\n            for k in l.iter() {\n                if i\
    \ + j + k == 0 {\n                    triples_sum_to_zero = true;\n          \
    \          break;\n                }\n            }\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwhq4i8fn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749111
