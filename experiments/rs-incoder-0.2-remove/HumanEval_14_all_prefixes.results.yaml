language: rs
name: HumanEval_14_all_prefixes
results:
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut s = string.chars();\n    let mut c = s.next();\n\
    \    while !c.is_none() {\n        if c.unwrap() == '.' {\n            prefixes.push(c.unwrap());\n\
    \        }\n        c = s.next();\n    }\n    prefixes\n}\n\nfn main() {\n   \
    \ let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpas7aajny.rs:12:5\n   |\n\
    2  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n12 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefix\
    \ = vec![];\n    let mut len = string.len();\n    while len > 0 {\n        prefix.push(&string[..len]);\n\
    \        len -= 1;\n    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwk83c5a7.rs:9:5\n  |\n2 |\
    \ fn all_prefixes(string: String) -> Vec<String> {\n  |                      \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    9 |     prefix\n  |     ^^^^^^ expected struct `String`, found `&str`\n  |\n \
    \ = note: expected struct `Vec<String>`\n             found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut string = string.to_string();\n    let mut i = 0;\n\
    \    while i < string.len() {\n        let mut j = i;\n        while j < string.len()\
    \ && string[j] == string[j + 1] {\n            j += 1; // skip duplicates\n  \
    \      }\n        prefixes.push(&string[i..j]);\n        i = j;\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpn4j5yekt.rs:8:35\n\
    \  |\n8 |         while j < string.len() && string[j] == string[j + 1] {\n  |\
    \                                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmpn4j5yekt.rs:8:48\n\
    \  |\n8 |         while j < string.len() && string[j] == string[j + 1] {\n  |\
    \                                                ^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn4j5yekt.rs:14:5\n\
    \   |\n2  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n14 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut current_prefix = \"\";\n    for c in string.chars()\
    \ {\n        if c == c.to_ascii_lowercase() {\n            current_prefix += c.to_ascii_lowercase();\n\
    \        } else {\n            prefixes.push(current_prefix);\n            current_prefix\
    \ = \"\";\n        }\n    }\n    prefixes.push(current_prefix);\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n --> /tmp/tmp7_vripx5.rs:7:13\n  |\n7 |             current_prefix +=\
    \ c.to_ascii_lowercase();\n  |             --------------^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |             |\n  |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7_vripx5.rs:14:5\n   |\n2  | fn all_prefixes(string:\
    \ String) -> Vec<String> {\n   |                                    -----------\
    \ expected `Vec<String>` because of return type\n...\n14 |     prefixes\n   |\
    \     ^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefix\
    \ = vec![];\n    let mut current = \"\";\n    for c in string.chars() {\n    \
    \    if c.is_ascii_alphanumeric() {\n            prefix.push(current);\n     \
    \       current = c.to_string();\n        } else {\n            current = current\
    \ + c.to_string();\n        }\n    }\n    prefix.push(current);\n    prefix\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgrzec7uy.rs:8:23\n  |\n8 |\
    \             current = c.to_string();\n  |                       ^^^^^^^^^^^^^\n\
    \  |                       |\n  |                       expected `&str`, found\
    \ struct `String`\n  |                       help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0369]: cannot add `String` to `&str`\n  --> /tmp/tmpgrzec7uy.rs:10:31\n\
    \   |\n10 |             current = current + c.to_string();\n   |             \
    \          ------- ^ ------------- String\n   |                       |      \
    \ |\n   |                       |       `+` cannot be used to concatenate a `&str`\
    \ with a `String`\n   |                       &str\n   |\nhelp: `to_owned()` can\
    \ be used to create an owned `String` from a string reference. String concatenation\
    \ appends the string on the right to the string on the left and may require reallocation.\
    \ This requires ownership of the string on the left\n   |\n10 |             current\
    \ = current.to_owned() + &c.to_string();\n   |                       ~~~~~~~~~~~~~~~~~~\
    \   ~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgrzec7uy.rs:14:5\n\
    \   |\n2  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n14 |     prefix\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut prefix = String::new();\n    let mut suffix = String::new();\n\
    \    let mut i = 1;\n    while i < string.len() {\n        prefix = prefix.to_owned()\
    \ + &string[i..i];\n        suffix = suffix.to_owned() + &string[i..i];\n    \
    \    if prefixes.contains(&prefix) {\n            i += 1;\n        } else {\n\
    \            prefixes.push(prefix);\n        }\n    }\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `prefix`\n  --> /tmp/tmply8n1rbw.rs:8:18\n\
    \   |\n4  |     let mut prefix = String::new();\n   |         ---------- move\
    \ occurs because `prefix` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n8  |         prefix = prefix.to_owned() + &string[i..i];\n   | \
    \        ------   ^^^^^^ value borrowed here after move\n   |         |\n   |\
    \         this reinitialization might get skipped\n...\n13 |             prefixes.push(prefix);\n\
    \   |                           ------ value moved here, in previous iteration\
    \ of loop\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefix\
    \ = vec![];\n    let mut string = string.to_string();\n    loop {\n        prefix.push(string);\n\
    \        if string.len() == 0 {\n            break;\n        }\n        string\
    \ = string.chars().next().unwrap();\n    }\n    prefix\n}\n\nfn main() {\n   \
    \ let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfvvuqbg6.rs:10:18\n   |\n\
    10 |         string = string.chars().next().unwrap();\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  |\n\
    \   |                  expected struct `String`, found `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 101
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefix\
    \ = vec![];\n    let mut current_len = string.len();\n    while current_len >\
    \ 0 {\n        prefix.push(string.chars().take(current_len).collect::<String>());\n\
    \        current_len -= 1;\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"asdfgh\", \"asdfg\", \"asdf\", \"asd\", \"as\", \"a\"]`,\n right: `[\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmptx45v7nn.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 101
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut s = string.to_string();\n    let mut i = 0;\n   \
    \ while i < s.len() {\n        prefixes.push(s.chars().take(i).collect::<String>());\n\
    \        i += 1;\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"a\", \"as\", \"asd\", \"asdf\", \"asdfg\"]`,\n right: `[\"a\", \"\
    as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmp9qdoa49s.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefix\
    \ = vec![];\n    let mut len = string.len();\n    while len > 0 {\n        prefix.push(&string[..len]);\n\
    \        len -= 1;\n    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwk83c5a7.rs:9:5\n  |\n2 |\
    \ fn all_prefixes(string: String) -> Vec<String> {\n  |                      \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    9 |     prefix\n  |     ^^^^^^ expected struct `String`, found `&str`\n  |\n \
    \ = note: expected struct `Vec<String>`\n             found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: -1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut string = string.to_string();\n    while !string.is_empty()\
    \ {\n        prefixes.push(string.clone());\n        string = string.chars().next().unwrap().to_string();\n\
    \    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659805269
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut current_prefix = \"\";\n    for c in string.chars()\
    \ {\n        if c.is_ascii_alphanumeric() {\n            current_prefix.push(c);\n\
    \        } else {\n            prefixes.push(current_prefix);\n            current_prefix\
    \ = \"\";\n        }\n    }\n    prefixes.push(current_prefix);\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n --> /tmp/tmpaa5a534g.rs:7:28\n  |\n7 |             current_prefix.push(c);\n\
    \  |                            ^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaa5a534g.rs:14:5\n   |\n2  | fn all_prefixes(string:\
    \ String) -> Vec<String> {\n   |                                    -----------\
    \ expected `Vec<String>` because of return type\n...\n14 |     prefixes\n   |\
    \     ^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut current_prefix = \"\";\n    for c in string.chars()\
    \ {\n        if c.is_ascii_alphanumeric() {\n            current_prefix.push(c);\n\
    \        } else {\n            prefixes.push(current_prefix);\n            current_prefix\
    \ = \"\";\n        }\n    }\n    prefixes.push(current_prefix);\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n --> /tmp/tmpaa5a534g.rs:7:28\n  |\n7 |             current_prefix.push(c);\n\
    \  |                            ^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaa5a534g.rs:14:5\n   |\n2  | fn all_prefixes(string:\
    \ String) -> Vec<String> {\n   |                                    -----------\
    \ expected `Vec<String>` because of return type\n...\n14 |     prefixes\n   |\
    \     ^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 101
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut string = string.to_string();\n    while string.len()\
    \ > 0 {\n        prefixes.push(string.chars().take_while(|c| !c.is_ascii_lowercase()).collect::<String>());\n\
    \        string = string.chars().take_while(|c| !c.is_ascii_lowercase()).collect::<String>();\n\
    \    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\"]`,\n right: `[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"\
    ]`', /tmp/tmpfgd5i225.rs:15:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut prefix = String::new();\n    let mut suffix = String::new();\n\
    \    let mut i = 1;\n    while i < string.len() {\n        prefix = prefix.to_owned()\
    \ + &string[i..i];\n        suffix = suffix.to_owned() + &string[i..i];\n    \
    \    i += 1;\n        prefixes.push(prefix);\n    }\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `prefix`\n  --> /tmp/tmps3x6lder.rs:8:18\n\
    \   |\n4  |     let mut prefix = String::new();\n   |         ---------- move\
    \ occurs because `prefix` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n8  |         prefix = prefix.to_owned() + &string[i..i];\n   | \
    \                 ^^^^^^ value borrowed here after move\n...\n11 |         prefixes.push(prefix);\n\
    \   |                       ------ value moved here, in previous iteration of\
    \ loop\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefix\
    \ = Vec::new();\n    let mut current_prefix = String::new();\n    let mut current_len\
    \ = String::new();\n    let mut current_len = string.len();\n    let mut current_len\
    \ = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut\
    \ current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n\
    \    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos\
    \ = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut\
    \ current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n\
    \    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos\
    \ = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut\
    \ current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n\
    \    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos\
    \ = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut\
    \ current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n\
    \    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos\
    \ = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut\
    \ current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n\
    \    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos\
    \ = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut\
    \ current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n\
    \    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos\
    \ = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut\
    \ current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n\
    \    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos\
    \ = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut\
    \ current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n\
    \    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut current_pos\
    \ = 0;\n    let mut current_pos = 0;\n    let mut current_pos = 0;\n    let mut\
    \ current_pos = \n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp9q1om7zn.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefix\
    \ = vec![];\n    let mut prefix_len = 0;\n    for c in string.chars() {\n    \
    \    if prefix_len > 0 {\n            prefix.push(&string[prefix_len..prefix_len\
    \ + c.len_utf8()]);\n        }\n        prefix_len += c.len_utf8();\n    }\n \
    \   prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfjau2evy.rs:11:5\n   |\n\
    2  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n11 |     prefix\n   |     ^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 101
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut current = String::from(\"\");\n    for c in string.chars()\
    \ {\n        if c.is_ascii_alphanumeric() {\n            current.push_str(&c.to_string());\n\
    \        } else {\n            prefixes.push(current);\n            current =\
    \ String::from(\"\");\n        }\n    }\n    prefixes.push(current);\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\"]`,\n right: `[]`', /tmp/tmp_wm2db_m.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 101
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut current_prefix = String::new();\n    let mut current_len\
    \ = string.len();\n    while current_len > 0 {\n        current_prefix.push_str(&string[..current_len]);\n\
    \        current_len -= 1;\n        if current_len == 0 {\n            prefixes.push(current_prefix);\n\
    \            current_prefix = String::new();\n        }\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"asdfghasdfgasdfasdasa\"]`,\n right: `[\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"]`', /tmp/tmpbob0j8fe.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805264
- exit_code: 1
  program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes\
    \ = Vec::new();\n    let mut prefix_len = 0;\n    let mut current_len = string.len();\n\
    \    while current_len > 0 {\n        prefixes.push(&string[prefix_len..current_len]);\n\
    \        prefix_len += 1;\n        current_len -= 1;\n    }\n    prefixes\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8ycz7gyg.rs:11:5\n   |\n\
    2  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n11 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805264
