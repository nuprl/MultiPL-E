language: rs
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_count = word.chars().filter(|c| vowels.contains(&c.to_string())).count();\n\
    \    let mut vowels_index = 0;\n    let mut vowels_index2 = 0;\n    let mut vowels_index3\
    \ = 0;\n    let mut vowels_index4 = 0;\n    let mut vowels_index5 = 0;\n    let\
    \ mut vowels_index6 = 0;\n    let mut vowels_index7 = 0;\n    let mut vowels_index8\
    \ = 0;\n    let mut vowels_index9 = 0;\n    let mut vowels_index10 = 0;\n    let\
    \ mut vowels_index11 = 0;\n    let mut vowels_index12 = 0;\n    let mut vowels_index13\
    \ = 0;\n    let mut vowels_index14 = 0;\n    let mut vowels_index15 = 0;\n   \
    \ let mut vowels_index16 = 0;\n    let mut vowels_index17 = 0;\n    let mut vowels_index18\
    \ = 0;\n    let mut vowels_index19 = 0;\n    let mut vowels_index20 = 0;\n   \
    \ let mut vowels_index21 = 0;\n    let mut vowels_index22 = 0;\n    let mut vowels_index23\
    \ = 0;\n    let mut vowels_index24 = 0;\n    let mut vowels_index25 = 0;\n   \
    \ let mut vowels_index26 = 0;\n    let mut vowels_index27 = 0;\n    let mut vowels_index28\
    \ = 0;\n    let mut vowels_index29 = 0;\n    let mut vowels_index30 = 0;\n   \
    \ let mut vowels_index31 = 0;\n    let mut vowels_index32 = 0;\n    let mut vowels_index33\
    \ = 0;\n    let mut vowels_index34 = 0;\n    let mut vowels_index35 = 0;\n   \
    \ let mut vowels_index36 = 0;\n    let mut vowels_index37 = 0;\n    let mut vowels_index38\
    \ = 0;\n    let mut vowels_index39 = 0;\n    let mut vowels_index40 = 0;\n   \
    \ let mut vowels_index41 = 0;\n    let mut vowels_index42 = 0;\n    let mut vowels_index43\
    \ = 0;\n    let mut vowels_index44 = 0;\n    let mut vowels_index45 = 0;\n   \
    \ let mut vowels_index46 = 0;\n    let mut vowels_index47 = 0;\n    let mut vowels_index48\
    \ = 0;\n    let mut vowels_index49 = 0;\n    let mut vowels_index50 = 0;\n   \
    \ let mut vowels_index51 = 0;\n    let mut vowels_index52 = 0;\n    let \n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpp6j5ms_g.rs:63:1\n  \
    \ |\n63 | }\n   | ^ expected pattern\n\nerror[E0308]: mismatched types\n --> /tmp/tmpp6j5ms_g.rs:9:68\n\
    \  |\n9 |     let mut vowels_count = word.chars().filter(|c| vowels.contains(&c.to_string())).count();\n\
    \  |                                                                    ^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n  |\n  = note: expected reference `&&str`\n\
    \             found reference `&String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count_min\
    \ = vec![0];\n    let mut vowels_index_count_max = vec![0];\n    let mut vowels_index_count_min_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count = vec![0];\n    let\
    \ mut vowels_index_count_min_max_count_min = vec![0];\n    let mut vowels_index_count_min_max_count_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max = vec![0];\n\
    \    let mut vowels_index_count_min_max_count_min_max_count = vec![0];\n    let\
    \ mut vowels_index_count_min_max_count_min_max_count_min = vec![0];\n    let mut\
    \ vowels_index_count_min_max_count_min_max_count_max = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min_max_count\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min_max_count_min\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min_max_count_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_min\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max\
    \ = vec![0];\n    let mut vowels_index_\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpy4jhhr55.rs:35:26\n   |\n\
    35 |     let mut vowels_index_\n   |                          ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpy4jhhr55.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) -> String\
    \ {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_end = vec![0];\n    let mut vowels_count_start = vec![0];\n\
    \    let mut vowels_count_start_index = vec![0];\n    let mut vowels_count_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp72fjn74h.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_set = HashSet::new();\n    vowels.iter().for_each(|v|\
    \ vowels_set.insert(v));\n    let mut vowels_count = vowels_set.len();\n    let\
    \ mut vowels_index = 0;\n    let mut vowels_index = word.len() - 1;\n    let mut\
    \ vowels_index = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n\
    \    let mut vowels_index = word.len() - 1;\n    let mut vowels_index = word.len()\
    \ - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index =\
    \ word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_index\
    \ = word.len() - 1;\n    let mut vowels_index = word.len() - 1;\n    let mut vowels_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0okgwf8v.rs:53:20\n   |\n\
    53 |     let mut vowels_\n   |                    ^ help: add `;` here\n54 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n --> /tmp/tmp0okgwf8v.rs:9:26\n  |\n9 |     let mut vowels_set\
    \ = HashSet::new();\n  |                          ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0308]: mismatched types\n --> /tmp/tmp0okgwf8v.rs:7:39\n  |\n7\
    \ | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count_max\
    \ = vec![0];\n    let mut vowels_index_count_min = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index_max = vec![0];\n    let mut vowels_index_count_min_index_max\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min = vec![0];\n    let\
    \ mut vowels_index_count_min_index_min = vec![0];\n    let mut vowels_index_count_max_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index = vec![0];\n\
    \    let mut vowels_index_count_max_index_min_index_max = vec![0];\n    let mut\
    \ vowels_index_count_min_index_min_index_max = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index = vec![0];\n\
    \    let mut vowels_index_count_max_index_min_index_min_index_max = vec![0];\n\
    \    let mut vowels_index_count_min_index_min_index_min_index_max = vec![0];\n\
    \    let mut vowels_index_count_max_index_min_index_min_index_min_index = vec![0];\n\
    \    let mut vowels_index_count_min_index_min_index_min_index_min_index = vec![0];\n\
    \    let mut vowels_index_count_max_index_min_index_min_index_min_index_max =\
    \ vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index_min_index_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpamy7_8xa.rs:38:72\n   |\n\
    38 |     let mut vowels_index_count_max_index_min_index_min_index_min_index_\n\
    \   |                                                                        ^\
    \ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpamy7_8xa.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String)\
    \ -> String {\n  |    -----------------                  ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let vowels_count = vowels.len();\n\
    \    let vowels_count = vowels.len();\n    let \n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpgprzuxu3.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n  \
    \  vowels.iter().for_each(|v| vowels_set.insert(v));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c| vowels_set.insert(c));\n\
    \    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ vowels_set.insert(c));\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n\
    \    word.chars().for_each(|c| vowels_set.insert(c));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c| vowels_set.insert(c));\n\
    \    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ vowels_set.insert(c));\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n\
    \    word.chars().for_each(|c| vowels_set.insert(c));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c| vowels_set.insert(c));\n\
    \    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ vowels_set.insert(c));\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n\
    \    word.chars().for_each(|c| vowels_set.insert(c));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c| vowels_set.insert(c));\n\
    \    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ vowels_set.insert(c));\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n\
    \    word.chars().for_each(|c| vowels_set.insert(c));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp7y14p3de.rs:9:25\n\
    \  |\n9 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n  |       \
    \                  ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmp7y14p3de.rs:9:41\n\
    \  |\n9 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n  |       \
    \                                  ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp7y14p3de.rs:11:25\n\
    \   |\n11 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp7y14p3de.rs:11:41\n\
    \   |\n11 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp7y14p3de.rs:13:25\n\
    \   |\n13 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp7y14p3de.rs:13:41\n\
    \   |\n13 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp7y14p3de.rs:15:25\n\
    \   |\n15 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \      "
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpt91q2f21.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n\
    \    let mut vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid_iter = vowels_mid.iter();\n    let mut vowels_mid_end\
    \ = vowels_mid_iter.next();\n    let mut vowels_mid_start = vowels_mid_iter.next();\n\
    \    let mut vowels_mid_mid_iter = vowels_mid_mid.iter();\n    let mut vowels_mid_mid_end\
    \ = vowels_mid_mid_iter.next();\n    let mut vowels_mid_mid_start = vowels_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_start\
    \ = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_start = vowels_mid_mid_mid_iter.next();\n    let mut\
    \ vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end\
    \ = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_start = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_start\
    \ = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \    let mut vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let\
    \ mut vowels_mid_mid_mid_start = vowels_mid_mid_mid_iter.next();\n    let mut\
    \ vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n    let mut vowels_mid_mid_mid_end\
    \ = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_start = vowels_mid_mid_mid_iter.next();\n\
    \    let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n    let mut\
    \ vowels_mid_mid_mid_end = vowels_mid_mid_mid_iter.next();\n    let mut vowels_mid_mid_mid_start\
    \ = vowels_mid_mid_mid_iter.next();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowels_mid_mid` in this scope\n  --> /tmp/tmp98zeiy76.rs:16:35\n\
    \   |\n16 |     let mut vowels_mid_mid_iter = vowels_mid_mid.iter();\n   |   \
    \                                ^^^^^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `vowels_mid_end`\n\nerror[E0425]: cannot find value `vowels_mid_mid_mid`\
    \ in this scope\n  --> /tmp/tmp98zeiy76.rs:19:39\n   |\n19 |     let mut vowels_mid_mid_mid_iter\
    \ = vowels_mid_mid_mid.iter();\n   |                                       ^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `vowels_mid_mid_end`\n\n\
    error[E0425]: cannot find value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmp98zeiy76.rs:22:39\n\
    \   |\n22 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmp98zeiy76.rs:25:39\n\
    \   |\n25 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmp98zeiy76.rs:28:39\n\
    \   |\n28 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmp98zeiy76.rs:31:39\n\
    \   |\n31 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `vowels_mid_mid_end`\n\nerror[E0425]: cannot find\
    \ value `vowels_mid_mid_mid` in this scope\n  --> /tmp/tmp98zeiy76.rs:34:39\n\
    \   |\n34 |     let mut vowels_mid_mid_mid_iter = vowels_mid_mid_mid.iter();\n\
    \   |                                       ^"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    let mut\
    \ vowel_pos = word.rfind('a', -1);\n    if vowel_pos == -1 {\n        return \"\
    \";\n    }\n    let mut vowel_len = word.len();\n    let mut vowel_end = word.rfind('a',\
    \ vowel_pos);\n    while vowel_end != -1 {\n        if vowel_end < vowel_pos {\n\
    \            vowel_len -= vowel_end - vowel_pos + 1;\n        } else {\n     \
    \       vowel_len = vowel_end - vowel_pos + 1;\n        }\n        vowel_end =\
    \ word.rfind('a', vowel_pos + 1);\n    }\n    let mut vowel_start = word.rfind('a',\
    \ vowel_len);\n    while vowel_start != -1 {\n        if vowel_start > vowel_pos\
    \ {\n            vowel_start -= vowel_pos - vowel_len + 1;\n        } else {\n\
    \            vowel_len = vowel_pos - vowel_start + 1;\n        }\n        vowel_start\
    \ = word.rfind('a', vowel_len);\n    }\n    let mut vowel_len = word.len();\n\
    \    let mut vowel_end = word.rfind('a', vowel_pos);\n    while vowel_end != -1\
    \ {\n        if vowel_end < vowel_pos {\n            vowel_len -= vowel_end -\
    \ vowel_pos + 1;\n        } else {\n            vowel_len = vowel_end - vowel_pos\
    \ + 1;\n        }\n        vowel_end = word.rfind('a', vowel_pos + 1);\n    }\n\
    \    let mut vowel_start = word.rfind('a', vowel_len);\n    while vowel_start\
    \ != -1 {\n        if vowel_start > vowel_pos {\n            vowel_start -= vowel_pos\
    \ - vowel_len + 1;\n        } else {\n            vowel_len = vowel_pos - vowel_start\
    \ + 1;\n        }\n        vowel_start = word.rfind('a', vowel_len);\n    }\n\
    \    word.chars().nth(vowel_start + 1).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpg_sa3sxa.rs:9:30\n     |\n9    |     let mut vowel_pos = word.rfind('a',\
    \ -1);\n     |                              ^^^^^ ---  -- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg_sa3sxa.rs:10:21\n   |\n10 |     if vowel_pos\
    \ == -1 {\n   |                     ^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n10 |     if vowel_pos == Some(-1)\
    \ {\n   |                     +++++  +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg_sa3sxa.rs:11:16\n   |\n7  | fn get_closest_vowel(word: String) ->\
    \ String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n11 |         return \"\";\n   |               \
    \ ^^- help: try using a conversion method: `.to_string()`\n   |              \
    \  |\n   |                expected struct `String`, found `&str`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpg_sa3sxa.rs:14:30\n\
    \     |\n14   |     let mut vowel_end = word.rfind('a', vowel_pos);\n     |  \
    \                            ^^^^^ ---  --------- supplied 2 arguments\n     |\
    \                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg_sa3sxa.rs:15:24\n   |\n15 |     while vowel_end\
    \ != -1 {\n   |                        ^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n15 |     while vowel_end !=\
    \ Some(-1) {\n   |                        +++++  +\n\nerror[E0369]: cannot subtract\
    \ `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpg_sa3sxa.rs:17:36\n   |\n\
    17 |             vowel_len -"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_set = HashSet::new();\n    vowels.iter().for_each(|v|\
    \ vowels_set.insert(v));\n    let mut vowels_found = HashSet::new();\n    let\
    \ mut vowels_found2 = HashSet::new();\n    let mut vowels_found3 = HashSet::new();\n\
    \    let mut vowels_found4 = HashSet::new();\n    let mut vowels_found5 = HashSet::new();\n\
    \    let mut vowels_found6 = HashSet::new();\n    let mut vowels_found7 = HashSet::new();\n\
    \    let mut vowels_found8 = HashSet::new();\n    let mut vowels_found9 = HashSet::new();\n\
    \    let mut vowels_found10 = HashSet::new();\n    let mut vowels_found11 = HashSet::new();\n\
    \    let mut vowels_found12 = HashSet::new();\n    let mut vowels_found13 = HashSet::new();\n\
    \    let mut vowels_found14 = HashSet::new();\n    let mut vowels_found15 = HashSet::new();\n\
    \    let mut vowels_found16 = HashSet::new();\n    let mut vowels_found17 = HashSet::new();\n\
    \    let mut vowels_found18 = HashSet::new();\n    let mut vowels_found19 = HashSet::new();\n\
    \    let mut vowels_found20 = HashSet::new();\n    let mut vowels_found21 = HashSet::new();\n\
    \    let mut vowels_found22 = HashSet::new();\n    let mut vowels_found23 = HashSet::new();\n\
    \    let mut vowels_found24 = HashSet::new();\n    let mut vowels_found25 = HashSet::new();\n\
    \    let mut vowels_found26 = HashSet::new();\n    let mut vowels_found27 = HashSet::new();\n\
    \    let mut vowels_found28 = HashSet::new();\n    let mut vowels_found29 = HashSet::new();\n\
    \    let mut vowels_found30 = HashSet::new();\n    let mut vowels_found31 = HashSet::new();\n\
    \    let mut vowels_found32 = HashSet::new();\n    let mut vowels_found33 = HashSet::new();\n\
    \    let mut vowels_found34 = HashSet\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplw92f52u.rs:44:37\n   |\n\
    44 |     let mut vowels_found34 = HashSet\n   |                              \
    \       ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n --> /tmp/tmplw92f52u.rs:9:26\n\
    \  |\n9 |     let mut vowels_set = HashSet::new();\n  |                      \
    \    ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmplw92f52u.rs:11:28\n   |\n11\
    \ |     let mut vowels_found = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmplw92f52u.rs:12:29\n   |\n12\
    \ |     let mut vowels_found2 = HashSet::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmplw92f52u.rs:13:29\n   |\n13\
    \ |     let mut vowels_found3 = HashSet::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmplw92f52u.rs:14:29\n   |\n14\
    \ |     let mut vowels_found4 = HashSet::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmplw92f52u.rs:15:29\n   |\n15\
    \ |     let mut vowels_found5 = HashSet::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to r"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index2 = vec![0];\n    let mut vowels_count2 = vec![0];\n\
    \    let mut vowels_index3 = vec![0];\n    let mut vowels_count3 = vec![0];\n\
    \    let mut vowels_index4 = vec![0];\n    let mut vowels_count4 = vec![0];\n\
    \    let mut vowels_index5 = vec![0];\n    let mut vowels_count5 = vec![0];\n\
    \    let mut vowels_index6 = vec![0];\n    let mut vowels_count6 = vec![0];\n\
    \    let mut vowels_index7 = vec![0];\n    let mut vowels_count7 = vec![0];\n\
    \    let mut vowels_index8 = vec![0];\n    let mut vowels_count8 = vec![0];\n\
    \    let mut vowels_index9 = vec![0];\n    let mut vowels_count9 = vec![0];\n\
    \    let mut vowels_index10 = vec![0];\n    let mut vowels_count10 = vec![0];\n\
    \    let mut vowels_index11 = vec![0];\n    let mut vowels_count11 = vec![0];\n\
    \    let mut vowels_index12 = vec![0];\n    let mut vowels_count12 = vec![0];\n\
    \    let mut vowels_index13 = vec![0];\n    let mut vowels_count13 = vec![0];\n\
    \    let mut vowels_index14 = vec![0];\n    let mut vowels_count14 = vec![0];\n\
    \    let mut vowels_index15 = vec![0];\n    let mut vowels_count15 = vec![0];\n\
    \    let mut vowels_index16 = vec![0];\n    let mut vowels_count16 = vec![0];\n\
    \    let mut vowels_index17 = vec![0];\n    let mut vowels_count17 = vec![0];\n\
    \    let mut vowels_index18 = vec![0];\n    let mut vowels_count18 = vec![0];\n\
    \    let mut vowels_index19 = vec![0];\n    let mut vowels_count19 = vec![0];\n\
    \    let mut vowels_index20 = vec![0];\n    let mut vowels_count20 = vec![0];\n\
    \    let mut vowels_index21 = vec![0];\n    let mut vowels_count21 = vec![0];\n\
    \    let mut vowels_index22 = vec![0];\n    let mut vowels_count22 = vec![0];\n\
    \    let mut vowels_index23 = vec![0];\n    let \n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpv3a97jg1.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count_max\
    \ = vec![0];\n    let mut vowels_index_count_min = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7y5opkg6.rs:47:47\n   |\n\
    47 |     let mut vowels_index_count_min_index = vec\n   |                    \
    \                           ^ help: add `;` here\n48 | }\n   | - unexpected token\n\
    \nerror[E0423]: expected value, found macro `vec`\n  --> /tmp/tmp7y5opkg6.rs:47:44\n\
    \   |\n47 |     let mut vowels_index_count_min_index = vec\n   |             \
    \                               ^^^ not a value\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp7y5opkg6.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) ->\
    \ String {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0423.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_set = HashSet::new();\n    vowels.iter().for_each(|v|\
    \ vowels_set.insert(v));\n    vowels_set.insert(\"\");\n    let mut vowels_index\
    \ = HashMap::new();\n    vowels.iter().for_each(|v| vowels_index.insert(v, 0));\n\
    \    vowels_index.insert(\"\", 0);\n    let mut vowels_index = HashMap::new();\n\
    \    vowels.iter().for_each(|v| vowels_index.insert(v, 0));\n    vowels_index.insert(\"\
    \", 0);\n    let mut vowels_index = HashMap::new();\n    vowels.iter().for_each(|v|\
    \ vowels_index.insert(v, 0));\n    vowels_index.insert(\"\", 0);\n    let mut\
    \ vowels_index = HashMap::new();\n    vowels.iter().for_each(|v| vowels_index.insert(v,\
    \ 0));\n    vowels_index.insert(\"\", 0);\n    let mut vowels_index = HashMap::new();\n\
    \    vowels.iter().for_each(|v| vowels_index.insert(v, 0));\n    vowels_index.insert(\"\
    \", 0);\n    let mut vowels_index = HashMap::new();\n    vowels.iter().for_each(|v|\
    \ vowels_index.insert(v, 0));\n    vowels_index.insert(\"\", 0);\n    let mut\
    \ vowels_index = HashMap::new();\n    vowels.iter().for_each(|v| vowels_index.insert(v,\
    \ 0));\n    vowels_index.insert(\"\", 0);\n    let mut vowels_index = HashMap::new();\n\
    \    vowels.iter().for_each(|v| vowels_index.insert(v, 0));\n    vowels_index.insert(\"\
    \", 0);\n    let mut vowels_index = HashMap::new();\n    vowels.iter().for_each(|v|\
    \ vowels_index.insert(v, 0));\n    vowels_index.insert(\"\", 0);\n    let mut\
    \ vowels_index = HashMap::new();\n    vowels.iter().for_each(|v| vowels_index.insert(v,\
    \ 0));\n    vowels_index.insert(\"\", 0);\n    let mut vowels_index = HashMap::new();\n\
    \    vowels.iter().for_each(|v| vowels_index.insert(v, 0));\n    vowels_index.insert(\"\
    \", 0);\n    let mut vowels_index = HashMap::new();\n    vowels.iter().for_each(|v|\
    \ vowels_index.insert(v, 0));\n    vowels_index.insert(\"\", 0);\n    let mut\
    \ vowels_index = HashMap::new();\n    vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpbt8wasi1.rs:9:26\n  |\n9 |     let mut vowels_set = HashSet::new();\n\
    \  |                          ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpbt8wasi1.rs:12:28\n\
    \   |\n12 |     let mut vowels_index = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpbt8wasi1.rs:15:28\n\
    \   |\n15 |     let mut vowels_index = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpbt8wasi1.rs:18:28\n\
    \   |\n18 |     let mut vowels_index = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpbt8wasi1.rs:21:28\n\
    \   |\n21 |     let mut vowels_index = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpbt8wasi1.rs:24:28\n\
    \   |\n24 |     let mut vowels_index = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpbt8wasi1.rs:27:28\n\
    \   |\n27 |     let mut vowels_index = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider im"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index2 = vec![0];\n    let mut vowels_index3 = vec![0];\n\
    \    let mut vowels_index4 = vec![0];\n    let mut vowels_index5 = vec![0];\n\
    \    let mut vowels_index6 = vec![0];\n    let mut vowels_index7 = vec![0];\n\
    \    let mut vowels_index8 = vec![0];\n    let mut vowels_index9 = vec![0];\n\
    \    let mut vowels_index10 = vec![0];\n    let mut vowels_index11 = vec![0];\n\
    \    let mut vowels_index12 = vec![0];\n    let mut vowels_index13 = vec![0];\n\
    \    let mut vowels_index14 = vec![0];\n    let mut vowels_index15 = vec![0];\n\
    \    let mut vowels_index16 = vec![0];\n    let mut vowels_index17 = vec![0];\n\
    \    let mut vowels_index18 = vec![0];\n    let mut vowels_index19 = vec![0];\n\
    \    let mut vowels_index20 = vec![0];\n    let mut vowels_index21 = vec![0];\n\
    \    let mut vowels_index22 = vec![0];\n    let mut vowels_index23 = vec![0];\n\
    \    let mut vowels_index24 = vec![0];\n    let mut vowels_index25 = vec![0];\n\
    \    let mut vowels_index26 = vec![0];\n    let mut vowels_index27 = vec![0];\n\
    \    let mut vowels_index28 = vec![0];\n    let mut vowels_index29 = vec![0];\n\
    \    let mut vowels_index30 = vec![0];\n    let mut vowels_index31 = vec![0];\n\
    \    let mut vowels_index32 = vec![0];\n    let mut vowels_index33 = vec![0];\n\
    \    let mut vowels_index34 = vec![0];\n    let mut vowels_index35 = vec![0];\n\
    \    let mut vowels_index36 = vec![0];\n    let mut vowels_index37 = vec![0];\n\
    \    let mut vowels_index38 = vec![0];\n    let mut vowels_index39 = vec![0];\n\
    \    let mut vowels_index40 = vec![0];\n    let mut vowels_index41 = vec![0];\n\
    \    let mut vowels_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps80nlfnp.rs:51:20\n   |\n\
    51 |     let mut vowels_\n   |                    ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmps80nlfnp.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = -1;\n\
    \    let mut vowels_count_end = -1;\n    let mut vowels_count_start = -1;\n  \
    \  let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_index\
    \ = -1;\n    let mut vowels_count_start_index = -1;\n    let mut vowels_count_end_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcg8v225u.rs:58:30\n   |\n\
    58 |     let mut vowels_count_end_\n   |                              ^ help:\
    \ add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpcg8v225u.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) ->\
    \ String {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec!\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmpgg62jy70.rs:58:1\n\
    \   |\n57 |     let mut vowels_index = vec!\n   |                            \
    \    - expected one of `(`, `[`, or `{`\n58 | }\n   | ^ unexpected token\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_idx = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).count();\n\
    \    \n    if vowels_idx < word.len() {\n        let mut vowels_idx = word.chars().enumerate().filter(|&(_,\
    \ c)| vowels.contains(c)).count();\n        let mut vowels_idx = vowels_idx -\
    \ 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx\
    \ = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let\
    \ mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx -\
    \ 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx\
    \ = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let\
    \ mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx -\
    \ 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx\
    \ = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let\
    \ mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx -\
    \ 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx\
    \ = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let\
    \ mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx -\
    \ 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx\
    \ = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let\
    \ mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx -\
    \ 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx\
    \ = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let\
    \ mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx -\
    \ 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx\
    \ = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let\
    \ mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx -\
    \ 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let mut vowels_idx\
    \ = vowels_idx - 1;\n        let mut vowels_idx = vowels_idx - 1;\n        let\
    \ mut \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdgawwafr.rs:70:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n11 |     if vowels_idx\
    \ < word.len() {\n   |                                - this delimiter might not\
    \ be properly closed...\n...\n53 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n70 | }\n   |   ^\n\nerror: expected identifier,\
    \ found `}`\n  --> /tmp/tmpdgawwafr.rs:53:1\n   |\n53 | }\n   | ^ expected identifier\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpdgawwafr.rs:9:84\n  |\n9 |    \
    \ let mut vowels_idx = word.chars().enumerate().filter(|&(_, c)| vowels.contains(c)).count();\n\
    \  |                                                                         \
    \           ^ expected `&&str`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdgawwafr.rs:12:88\n   |\n12 |         let mut vowels_idx = word.chars().enumerate().filter(|&(_,\
    \ c)| vowels.contains(c)).count();\n   |                                     \
    \                                                   ^ expected `&&str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdgawwafr.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = -1;\n\
    \    let mut vowels_count_max = vowels.len();\n    let mut vowels_count_min =\
    \ vowels.len();\n    let mut vowels_count_index = 0;\n    let mut vowels_count_max\
    \ = 0;\n    let mut vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_max = 0;\n    let mut vowels_count_min = 0;\n    let\
    \ mut vowels_count_index = 0;\n    let mut vowels_count_max = 0;\n    let mut\
    \ vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n    let mut vowels_count_max\
    \ = 0;\n    let mut vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_max = 0;\n    let mut vowels_count_min = 0;\n    let\
    \ mut vowels_count_index = 0;\n    let mut vowels_count_max = 0;\n    let mut\
    \ vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n    let mut vowels_count_max\
    \ = 0;\n    let mut vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_max = 0;\n    let mut vowels_count_min = 0;\n    let\
    \ mut vowels_count_index = 0;\n    let mut vowels_count_max = 0;\n    let mut\
    \ vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n    let mut vowels_count_max\
    \ = 0;\n    let mut vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_max = 0;\n    let mut vowels_count_min = 0;\n    let\
    \ mut vowels_count_index = 0;\n    let mut vowels_count_max = 0;\n    let mut\
    \ vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n    let mut vowels_count_max\
    \ = 0;\n    let mut vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_max = 0;\n    let mut vowels_count_min = 0;\n    let\
    \ mut vowels_count_index = 0;\n    let mut vowels_count_max = 0;\n    let mut\
    \ vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n    let mut vowels_count_max\
    \ = 0;\n    let mut vowels_count_min = 0;\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_max = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpizbidurp.rs:64:1\n  \
    \ |\n64 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let vowels_count = vowels.len();\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ - 1;\n    let vowels_count = vowels_count - 1;\n    let vowels_count = vowels_count\
    \ \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8l05hnwf.rs:58:36\n   |\n\
    58 |     let vowels_count = vowels_count \n   |                              \
    \      ^ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp8l05hnwf.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    let mut\
    \ vowel_pos = word.rfind(&vowels);\n    if vowel_pos == word.len() {\n       \
    \ return \"\";\n    }\n    let mut vowel_pos = word.rfind(&vowels, vowel_pos +\
    \ 1);\n    if vowel_pos == word.len() {\n        return \"\";\n    }\n    let\
    \ mut vowel_pos = word.rfind(&vowels, vowel_pos + 1);\n    if vowel_pos == word.len()\
    \ {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind(&vowels,\
    \ vowel_pos + 1);\n    if vowel_pos == word.len() {\n        return \"\";\n  \
    \  }\n    let mut vowel_pos = word.rfind(&vowels, vowel_pos + 1);\n    if vowel_pos\
    \ == word.len() {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind(&vowels,\
    \ vowel_pos + 1);\n    if vowel_pos == word.len() {\n        return \"\";\n  \
    \  }\n    let mut vowel_pos = word.rfind(&vowels, vowel_pos + 1);\n    if vowel_pos\
    \ == word.len() {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind(&vowels,\
    \ vowel_pos + 1);\n    if vowel_pos == word.len() {\n        return \"\";\n  \
    \  }\n    let mut vowel_pos = word.rfind(&vowels, vowel_pos + 1);\n    if vowel_pos\
    \ == word.len() {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind(&vowels,\
    \ vowel_pos + 1);\n    if vowel_pos == word.len() {\n        return \"\";\n  \
    \  }\n    let mut vowel_pos = word.rfind(&vowels, vowel_pos + 1);\n    if vowel_pos\
    \ == word.len() {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind(&vowels,\
    \ vowel_pos + 1);\n    if vowel_pos == word.len() {\n        return \"\";\n  \
    \  }\n    let mut vowel_pos = word.rfind(&vowels, vowel_pos + 1);\n    if vowel_pos\
    \ == word.len() {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind(&vowels,\
    \ vowel_pos + 1);\n    if vowel_pos == word.len() {\n        return \"\";\n  \
    \  }\n    let mut vowel_pos = word.rfind(&vowels, vowel_pos + 1);\n    if vowel_pos\
    \ == word.len() {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind(&vowels,\
    \ vowel_pos + 1);\n    if vowel_pos == word.len() {\n        return \"\";\n  \
    \  }\n    let mut vowel_pos = word.r\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyk30velj.rs:73:31\n   |\n\
    73 |     let mut vowel_pos = word.r\n   |                               ^ help:\
    \ add `;` here\n74 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyk30velj.rs:10:21\n   |\n10 |     if vowel_pos == word.len() {\n\
    \   |                     ^^^^^^^^^^ expected enum `Option`, found `usize`\n \
    \  |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n10 |     if vowel_pos == Some(word.len())\
    \ {\n   |                     +++++          +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyk30velj.rs:11:16\n   |\n7  | fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n11 |         return \"\";\n   |               \
    \ ^^- help: try using a conversion method: `.to_string()`\n   |              \
    \  |\n   |                expected struct `String`, found `&str`\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpyk30velj.rs:13:55\n\
    \   |\n13 |     let mut vowel_pos = word.rfind(&vowels, vowel_pos + 1);\n   |\
    \                                             --------- ^ - {integer}\n   |  \
    \                                           |\n   |                          \
    \                   Option<usize>\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmpyk30velj.rs:13:30\n     |\n13\
    \   |     let mut vowel_pos = word.rfind(&vowels, vowel_pos + 1);\n     |    \
    \                          ^^^^^ -------  ------------- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyk30velj.rs:14:21\n   |\n14 |     if vowel_pos\
    \ == word.len() {\n   |                     ^^^^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_index2 = 0;\n    let mut vowels_count_index3 = 0;\n\
    \    let mut vowels_count_index4 = 0;\n    let mut vowels_count_index5 = 0;\n\
    \    let mut vowels_count_index6 = 0;\n    let mut vowels_count_index7 = 0;\n\
    \    let mut vowels_count_index8 = 0;\n    let mut vowels_count_index9 = 0;\n\
    \    let mut vowels_count_index10 = 0;\n    let mut vowels_count_index11 = 0;\n\
    \    let mut vowels_count_index12 = 0;\n    let mut vowels_count_index13 = 0;\n\
    \    let mut vowels_count_index14 = 0;\n    let mut vowels_count_index15 = 0;\n\
    \    let mut vowels_count_index16 = 0;\n    let mut vowels_count_index17 = 0;\n\
    \    let mut vowels_count_index18 = 0;\n    let mut vowels_count_index19 = 0;\n\
    \    let mut vowels_count_index20 = 0;\n    let mut vowels_count_index21 = 0;\n\
    \    let mut vowels_count_index22 = 0;\n    let mut vowels_count_index23 = 0;\n\
    \    let mut vowels_count_index24 = 0;\n    let mut vowels_count_index25 = 0;\n\
    \    let mut vowels_count_index26 = 0;\n    let mut vowels_count_index27 = 0;\n\
    \    let mut vowels_count_index28 = 0;\n    let mut vowels_count_index29 = 0;\n\
    \    let mut vowels_count_index30 = 0;\n    let mut vowels_count_index31 = 0;\n\
    \    let mut vowels_count_index32 = 0;\n    let mut vowels_count_index33 = 0;\n\
    \    let mut vowels_count_index34 = 0;\n    let mut vowels_count_index35 = 0;\n\
    \    let mut vowels_count_index36 = 0;\n    let mut vowels_count_index37 = 0;\n\
    \    let mut vowels_count_index38 = 0;\n    let mut vowels_count_index39 = 0;\n\
    \    let mut vowels_count_index40 = 0;\n    let mut vowels_count_index41 = 0;\n\
    \    let mut vowels_count_index42 = 0;\n    let mut vowels_count_index43 = 0;\n\
    \    let mut vowels_count_index44 = 0;\n    let mut vowels_count_index45 = 0;\n\
    \    let mut vowels_count_index46 = 0;\n    let mut vowels_count_index47 = 0;\n\
    \    let mut vowels_count_index48 = 0;\n    let mut vowels_count_index49 = 0;\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxmvutlve.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut vowel_found = false;\n    let mut vowel_found2 = false;\n    let\
    \ mut vowel_found3 = false;\n    let mut vowel_found4 = false;\n    let mut vowel_found5\
    \ = false;\n    let mut vowel_found6 = false;\n    let mut vowel_found7 = false;\n\
    \    let mut vowel_found8 = false;\n    let mut vowel_found9 = false;\n    let\
    \ mut vowel_found10 = false;\n    let mut vowel_found11 = false;\n    let mut\
    \ vowel_found12 = false;\n    let mut vowel_found13 = false;\n    let mut vowel_found14\
    \ = false;\n    let mut vowel_found15 = false;\n    let mut vowel_found16 = false;\n\
    \    let mut vowel_found17 = false;\n    let mut vowel_found18 = false;\n    let\
    \ mut vowel_found19 = false;\n    let mut vowel_found20 = false;\n    let mut\
    \ vowel_found21 = false;\n    let mut vowel_found22 = false;\n    let mut vowel_found23\
    \ = false;\n    let mut vowel_found24 = false;\n    let mut vowel_found25 = false;\n\
    \    let mut vowel_found26 = false;\n    let mut vowel_found27 = false;\n    let\
    \ mut vowel_found28 = false;\n    let mut vowel_found29 = false;\n    let mut\
    \ vowel_found30 = false;\n    let mut vowel_found31 = false;\n    let mut vowel_found32\
    \ = false;\n    let mut vowel_found33 = false;\n    let mut vowel_found34 = false;\n\
    \    let mut vowel_found35 = false;\n    let mut vowel_found36 = false;\n    let\
    \ mut vowel_found37 = false;\n    let mut vowel_found38 = false;\n    let mut\
    \ vowel_found39 = false;\n    let mut vowel_found40 = false;\n    let mut vowel_found41\
    \ = false;\n    let mut vowel_found42 = false;\n    let mut vowel_found43 = false;\n\
    \    let mut vowel_found44 = false;\n    let mut vowel_found45 = false;\n    let\
    \ mut vowel_found46 = false;\n    let mut vowel_found47 = false;\n    let mut\
    \ vowel_found48 = false;\n    let mut vowel_found49 = false;\n    let mut vowel_found50\
    \ = false;\n    let mut vowel_found51 = false;\n    let mut vowel_found52 = false;\n\
    \    let mut vowel_found53 = false;\n    let mut vowel_found54 = false;\n    let\
    \ mu\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdbzoiwvy.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdbzoiwvy.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_max = 0;\n    let mut vowels_count_min = 0;\n    let\
    \ mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index = 0;\n \
    \   let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count =\
    \ 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let mut vowels_count_max_index = 0;\n    let mut vowels_count_min_index\
    \ = 0;\n    let mut vowels_count_max_count = 0;\n    let mut vowels_count_min_count\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n \
    \   assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n  \
    \  assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpmct5bsh0.rs:62:1\n  \
    \ |\n62 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count_max\
    \ = vec![0];\n    let mut vowels_index_count_min = vec![0];\n    let mut vowels_index_count_min_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index = vec![0];\n    let\
    \ mut vowels_index_count_min_max_index_max = vec![0];\n    let mut vowels_index_count_min_max_index_min\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max = vec![0];\n\
    \    let mut vowels_index_count_min_max_index_min_max_index = vec![0];\n    let\
    \ mut vowels_index_count_min_max_index_min_max_index_max = vec![0];\n    let mut\
    \ vowels_index_count_min_max_index_min_max_index_min = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index_min_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index_min_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index_min_max_index_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index_min_max_index_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index_min_max_index_min_max\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index_min_max_index_min_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index_min_max_index_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp274krsmj.rs:34:102\n   |\n\
    34 |     let mut vowels_index_count_min_max_index_min_max_index_min_max_index_min_max_index_min_max_index_\n\
    \   |                                                                        \
    \                              ^ help: add `;` here\n35 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp274krsmj.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n \
    \   let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.cloned();\n    let mut vowels_iter = vowels_iter.cloned();\n\
    \    let mut vowels_iter = vowels_iter.\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpje4cc_wt.rs:47:1\n   |\n47\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpje4cc_wt.rs:46:39\n\
    \   |\n46 |     let mut vowels_iter = vowels_iter.\n   |                     \
    \                  ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ the trait bound `str: Clone` is not satisfied\n    --> /tmp/tmpje4cc_wt.rs:11:39\n\
    \     |\n11   |     let mut vowels_iter = vowels_iter.cloned();\n     |      \
    \                                 ^^^^^^ the trait `Clone` is not implemented\
    \ for `str`\n     |\n     = help: the trait `Clone` is implemented for `String`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: `Cloned<Cloned<std::slice::Iter<'_,\
    \ &str>>>` is not an iterator\n  --> /tmp/tmpje4cc_wt.rs:12:39\n   |\n12 |   \
    \    let mut vowels_iter = vowels_iter.cloned();\n   |                       \
    \                  ^^^^^^ `Cloned<Cloned<std::slice::Iter<'_, &str>>>` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Cloned<Cloned<std::slice::Iter<'_, &str>>>: Iterator`\n         \
    \  which is required by `&mut Cloned<Cloned<std::slice::Iter<'_, &str>>>: Iterator`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpje4cc_wt.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_max = 0;\n    let mut vowels_count_min = 0;\n    let\
    \ mut vowels_count_max2 = 0;\n    let mut vowels_count_min2 = 0;\n    let mut\
    \ vowels_count_max3 = 0;\n    let mut vowels_count_min3 = 0;\n    let mut vowels_count_max4\
    \ = 0;\n    let mut vowels_count_min4 = 0;\n    let mut vowels_count_max5 = 0;\n\
    \    let mut vowels_count_min5 = 0;\n    let mut vowels_count_max6 = 0;\n    let\
    \ mut vowels_count_min6 = 0;\n    let mut vowels_count_max7 = 0;\n    let mut\
    \ vowels_count_min7 = 0;\n    let mut vowels_count_max8 = 0;\n    let mut vowels_count_min8\
    \ = 0;\n    let mut vowels_count_max9 = 0;\n    let mut vowels_count_min9 = 0;\n\
    \    let mut vowels_count_max10 = 0;\n    let mut vowels_count_min10 = 0;\n  \
    \  let mut vowels_count_max11 = 0;\n    let mut vowels_count_min11 = 0;\n    let\
    \ mut vowels_count_max12 = 0;\n    let mut vowels_count_min12 = 0;\n    let mut\
    \ vowels_count_max13 = 0;\n    let mut vowels_count_min13 = 0;\n    let mut vowels_count_max14\
    \ = 0;\n    let mut vowels_count_min14 = 0;\n    let mut vowels_count_max15 =\
    \ 0;\n    let mut vowels_count_min15 = 0;\n    let mut vowels_count_max16 = 0;\n\
    \    let mut vowels_count_min16 = 0;\n    let mut vowels_count_max17 = 0;\n  \
    \  let mut vowels_count_min17 = 0;\n    let mut vowels_count_max18 = 0;\n    let\
    \ mut vowels_count_min18 = 0;\n    let mut vowels_count_max19 = 0;\n    let mut\
    \ vowels_count_min19 = 0;\n    let mut vowels_count_max20 = 0;\n    let mut vowels_count_min20\
    \ = 0;\n    let mut vowels_count_max21 = 0;\n    let mut vowels_count_min21 =\
    \ 0;\n    let mut vowels_count_max22 = 0;\n    let mut vowels_count_min22 = 0;\n\
    \    let mut vowels_count_max23 = 0;\n    let mut vowels_count_min23 = 0;\n  \
    \  let mut vowels_count_max24 = 0;\n    let mut vowels_count_min24 = 0;\n    let\
    \ mut vowels_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4zv0b3zv.rs:59:20\n   |\n\
    59 |     let mut vowels_\n   |                    ^ help: add `;` here\n60 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4zv0b3zv.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let vowels_len =\
    \ vowels.len();\n    let mut vowel_pos = word.rfind('a', vowels_len);\n    let\
    \ mut vowel_pos_end = word.rfind('A', vowels_len);\n    if vowel_pos == vowel_pos_end\
    \ {\n        return \"\".to_string();\n    }\n    let mut vowel_pos_start = vowel_pos\
    \ + 1;\n    let mut vowel_pos_end = vowel_pos_start;\n    let mut vowel_pos_start_end\
    \ = vowel_pos_start;\n    while vowel_pos_start < vowel_pos_end {\n        if\
    \ vowels[vowel_pos_start] == vowels[vowel_pos_end] {\n            vowel_pos_start_end\
    \ = vowel_pos_start;\n            break;\n        }\n        vowel_pos_start +=\
    \ 1;\n        vowel_pos_end -= 1;\n    }\n    if vowel_pos_start == vowel_pos_end\
    \ {\n        return \"\".to_string();\n    }\n    let mut vowel_pos_start_end\
    \ = vowel_pos_start;\n    while vowel_pos_start_end < vowel_pos_end {\n      \
    \  if vowels[vowel_pos_start_end] == vowels[vowel_pos_end] {\n            vowel_pos_start_end\
    \ = vowel_pos_start_end;\n            break;\n        }\n        vowel_pos_start_end\
    \ += 1;\n        vowel_pos_end -= 1;\n    }\n    if vowel_pos_start_end == vowel_pos_end\
    \ {\n        return \"\".to_string();\n    }\n    let mut vowel_pos_start_end\
    \ = vowel_pos_start;\n    while vowel_pos_start_end < vowel_pos_end {\n      \
    \  if vowels[vowel_pos_start_end] == vowels[vowel_pos_end] {\n            vowel_pos_start_end\
    \ = vowel_pos_start_end;\n            break;\n        }\n        vowel_pos_start_end\
    \ += 1;\n        vowel_pos_end -= 1;\n    }\n    if vowel_pos_start_end == vowel_pos_end\
    \ {\n        return \"\".to_string();\n    }\n    let mut vowel_pos_start_end\
    \ = vowel_pos_start;\n    while vowel_pos_start_end < vowel_pos_end {\n      \
    \  if vowels[vowel_pos_start_end] == vowels[vowel_pos_end] {\n            vowel_pos_start_end\
    \ = vowel_pos_start_end;\n            break;\n        }\n        vowel_pos_start_end\
    \ += 1;\n        vowel_pos_end -= 1;\n    }\n    if vowel_pos_start_end == vowel_pos_end\
    \ {\n        return \"\".to_string();\n    }\n    let mut vowel_pos_start_end\
    \ = vowel_pos_start;\n    while vowel_pos_start_end < vowel_pos_end {\n      \
    \  if vowels[\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8pew1tui.rs:85:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n66 |     while vowel_pos_start_end\
    \ < vowel_pos_end {\n   |                                               - this\
    \ delimiter might not be properly closed...\n67 |         if vowels[\n68 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n85 | }\n\
    \   |   ^\n\nerror: expected expression, found `]`\n  --> /tmp/tmp8pew1tui.rs:68:1\n\
    \   |\n68 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp8pew1tui.rs:67:18\n   |\n7  | fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                              - closing\
    \ delimiter possibly meant for this\n...\n67 |         if vowels[\n   |      \
    \            ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp8pew1tui.rs:10:30\n     |\n10   |     let mut vowel_pos = word.rfind('a',\
    \ vowels_len);\n     |                              ^^^^^ ---  ---------- supplied\
    \ 2 arguments\n     |                              |\n     |                 \
    \             expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp8pew1tui.rs:11:34\n     |\n11   |     let mut vowel_pos_end =\
    \ word.rfind('A', vowels_len);\n     |                                  ^^^^^\
    \ ---  ---------- supplied 2 arguments\n     |                               \
    \   |\n     |                                  expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror[E0369]: cannot add `{integer}` to\
    \ `Option<usize>`\n  --> /tmp/tmp8pew1tui.rs:15:41\n   |\n15 |     let mut vowel_pos_start\
    \ = vowel_pos + 1;\n   |                               --------- ^ - {integer}\n\
    \   |                               |\n   |                               Option<usize>\n\
    \nerror[E0308]: mismatched "
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp91fpm9_h.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp91fpm9_h.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowel_found = false;\n    let mut vowel_start = -1;\n\
    \    let mut vowel_end = -1;\n    for &vowel in vowels.iter() {\n        if word.contains(vowel)\
    \ {\n            vowel_found = true;\n            vowel_start = word.rfind(vowel);\n\
    \            vowel_end = word.rfind(&vowel);\n            break;\n        }\n\
    \    }\n    if !vowel_found {\n        return \"\";\n    }\n    let mut vowel_found\
    \ = false;\n    let mut vowel_start = -1;\n    let mut vowel_end = -1;\n    for\
    \ &vowel in vowels.iter() {\n        if word.contains(&vowel) {\n            vowel_found\
    \ = true;\n            vowel_start = word.rfind(&vowel);\n            vowel_end\
    \ = word.rfind(vowel);\n            break;\n        }\n    }\n    if !vowel_found\
    \ {\n        return \"\";\n    }\n    let mut vowel_found = false;\n    let mut\
    \ vowel_start = -1;\n    let mut vowel_end = -1;\n    for &vowel in vowels.iter()\
    \ {\n        if word.contains(&vowel) {\n            vowel_found = true;\n   \
    \         vowel_start = word.rfind(&vowel);\n            vowel_end = word.rfind(vowel);\n\
    \            break;\n        }\n    }\n    if !vowel_found {\n        return \"\
    \";\n    }\n    let mut vowel_found = false;\n    let mut vowel_start = -1;\n\
    \    let mut vowel_end = -1;\n    for &vowel in vowels.iter() {\n        if word.contains(&vowel)\
    \ {\n            vowel_found = true;\n            vowel_start = word.rfind(&vowel);\n\
    \            vowel_end = word.rfind(vowel);\n            break;\n        }\n \
    \   }\n    if !vowel_found {\n        return \"\";\n    }\n    let mut vowel_found\
    \ = false;\n    let mut vowel_start = -1;\n    let mut vowel_end = -1;\n    for\
    \ &vowel in vowels.iter() {\n        if word.contains(&vowel) {\n            vowel_found\
    \ = true;\n            vowel_start = word.rfind(&vowel);\n            vowel_end\
    \ = word.rfind(vowel);\n            break;\n        }\n    }\n    if !vowel_found\
    \ {\n        return \"\";\n    }\n    let mut vowel_found = false;\n    let mut\
    \ vowel_start = -1;\n    let mut vowel_end = -1;\n    for &vowel in vowels.iter()\
    \ {\n        if word.contains(&vowel) {\n            vowel_found = true;\n   \
    \         vowel_start = word.rfind(&vowel);\n            vowel_end = word.rfind(vowel);\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4q6xufxn.rs:104:3\n\
    \    |\n7   | fn get_closest_vowel(word: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n82  |     for\
    \ &vowel in vowels.iter() {\n    |                                 - unclosed\
    \ delimiter\n83  |         if word.contains(&vowel) {\n    |                 \
    \                 - this delimiter might not be properly closed...\n...\n87  |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n104\
    \ | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4q6xufxn.rs:15:27\n\
    \   |\n10 |     let mut vowel_start = -1;\n   |                           -- expected\
    \ due to this value\n...\n15 |             vowel_start = word.rfind(vowel);\n\
    \   |                           ^^^^^^^^^^^^^^^^^ expected integer, found enum\
    \ `Option`\n   |\n   = note: expected type `{integer}`\n              found enum\
    \ `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4q6xufxn.rs:16:25\n\
    \   |\n11 |     let mut vowel_end = -1;\n   |                         -- expected\
    \ due to this value\n...\n16 |             vowel_end = word.rfind(&vowel);\n \
    \  |                         ^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4q6xufxn.rs:21:16\n   |\n7  |\
    \ fn get_closest_vowel(word: String) -> String {\n   |                       \
    \                ------ expected `String` because of return type\n...\n21 |  \
    \       return \"\";\n   |                ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4q6xufxn.rs:29:27\n\
    \   |\n24 |     let mut vowel_start = -1;\n   |                           -- expected\
    \ due to this value\n...\n29 |             vowel_start = word.rfind(&vowel);\n\
    \   |                           ^^^^^^^^^^^^^^^^^^ expected integer, found enum\
    \ `Option`\n   |\n   = note: expected type "
  stdout: ''
  timestamp: 1660053251
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowel_pos = word.rfind('a', -1);\n    let mut vowel_end\
    \ = word.rfind('a', word.len());\n    let mut vowel_before = word.rfind('e', -1);\n\
    \    let mut vowel_after = word.rfind('e', word.len());\n    let mut vowel_before_end\
    \ = word.rfind('i', -1);\n    let mut vowel_after_end = word.rfind('i', word.len());\n\
    \    let mut vowel_before_start = word.rfind('o', -1);\n    let mut vowel_after_start\
    \ = word.rfind('o', word.len());\n    let mut vowel_before_start_end = word.rfind('u',\
    \ -1);\n    let mut vowel_after_start_end = word.rfind('u', word.len());\n   \
    \ \n    if vowel_pos == -1 {\n        return \"\";\n    }\n    \n    if vowel_end\
    \ == -1 {\n        vowel_end = word.len();\n    }\n    \n    if vowel_before ==\
    \ -1 {\n        vowel_before = word.len();\n    }\n    \n    if vowel_after ==\
    \ -1 {\n        vowel_after = word.len();\n    }\n    \n    if vowel_before_end\
    \ == -1 {\n        vowel_before_end = word.len();\n    }\n    \n    if vowel_after_end\
    \ == -1 {\n        vowel_after_end = word.len();\n    }\n    \n    if vowel_before_start\
    \ == -1 {\n        vowel_before_start = word.len();\n    }\n    \n    if vowel_after_start\
    \ == -1 {\n        vowel_after_start = word.len();\n    }\n    \n    if vowel_before_start_end\
    \ == -1 {\n        vowel_before_start_end = word.len();\n    }\n    \n    if vowel_after_start_end\
    \ == -1 {\n        vowel_after_start_end = word.len();\n    }\n    \n    if vowel_pos\
    \ > vowel_end {\n        vowel_pos = word.len();\n    }\n    \n    if vowel_pos\
    \ < vowel_before {\n        vowel_before = word.len();\n    }\n    \n    if vowel_pos\
    \ < vowel_after {\n        vowel_after = word.len();\n    }\n    \n    if vowel_pos\
    \ < vowel_before_end {\n        vowel_before_end = word.len();\n    }\n    \n\
    \    if vowel_pos < vowel_after_end {\n        vowel_after_end = word.len();\n\
    \    }\n    \n    if vowel_pos < vowel_before_start {\n        vowel_before_start\
    \ = word.len();\n    }\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpotd483nx.rs:9:30\n     |\n9    |     let mut vowel_pos = word.rfind('a',\
    \ -1);\n     |                              ^^^^^ ---  -- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpotd483nx.rs:10:30\n\
    \     |\n10   |     let mut vowel_end = word.rfind('a', word.len());\n     | \
    \                             ^^^^^ ---  ---------- supplied 2 arguments\n   \
    \  |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpotd483nx.rs:11:33\n\
    \     |\n11   |     let mut vowel_before = word.rfind('e', -1);\n     |      \
    \                           ^^^^^ ---  -- supplied 2 arguments\n     |       \
    \                          |\n     |                                 expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpotd483nx.rs:12:32\n\
    \     |\n12   |     let mut vowel_after = word.rfind('e', word.len());\n     |\
    \                                ^^^^^ ---  ---------- supplied 2 arguments\n\
    \     |                                |\n     |                             \
    \   expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpotd483nx.rs:13:37\n\
    \     |\n13   |     let mut vowel_before_end = word.rfind('i', -1);\n     |  \
    \                                   ^^^^^ ---  -- supplied 2 arguments\n     |\
    \                                     |\n     |                              \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were sup"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowel_found = false;\n    let mut vowel_start = 0;\n\
    \    let mut vowel_end = 0;\n    let mut vowel_found = false;\n    for c in word.chars()\
    \ {\n        if vowels.contains(&c.to_lowercase()) {\n            vowel_found\
    \ = true;\n            vowel_start = word.len() - 1;\n            vowel_end =\
    \ word.len() - 1;\n            break;\n        }\n        if vowel_found {\n \
    \           if c.is_uppercase() {\n                vowel_end = word.len() - 1;\n\
    \            } else {\n                vowel_start = word.len() - 1;\n       \
    \     }\n        }\n    }\n    if vowel_found {\n        return word.chars().nth(vowel_end).unwrap().to_string();\n\
    \    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnixd04dx.rs:14:28\n   |\n\
    14 |         if vowels.contains(&c.to_lowercase()) {\n   |                   \
    \         ^^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnixd04dx.rs:31:16\n   |\n7  |\
    \ fn get_closest_vowel(word: String) -> String {\n   |                       \
    \                ------ expected `String` because of return type\n...\n31 |  \
    \       return \"\";\n   |                ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_idx: Vec<usize> = vec![0];\n    let mut vowels_len:\
    \ usize = 0;\n    let mut idx: usize = 0;\n    let mut len: usize = word.len();\n\
    \    while idx < len {\n        if word[idx] == 'a' || word[idx] == 'e' || word[idx]\
    \ == 'i' || word[idx] == 'o' || word[idx] == 'u' {\n            vowels_len +=\
    \ 1;\n            vowels_idx += 1;\n        }\n        idx += 1;\n    }\n    if\
    \ vowels_len == 0 {\n        return \"\";\n    }\n    let mut idx: usize = 0;\n\
    \    while idx < len {\n        if word[idx] == 'a' || word[idx] == 'e' || word[idx]\
    \ == 'i' || word[idx] == 'o' || word[idx] == 'u' {\n            if idx < vowels_len\
    \ {\n                return word[vowels_idx.iter().min().unwrap() + idx..vowels_idx.iter().max().unwrap()];\n\
    \            }\n        }\n        idx += 1;\n    }\n    return \"\";\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1yfu43a3.rs:14:12\n\
    \   |\n14 |         if word[idx] == 'a' || word[idx] == 'e' || word[idx] == 'i'\
    \ || word[idx] == 'o' || word[idx] == 'u' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1yfu43a3.rs:14:32\n   |\n14 |         if word[idx] == 'a' || word[idx]\
    \ == 'e' || word[idx] == 'i' || word[idx] == 'o' || word[idx] == 'u' {\n   | \
    \                               ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1yfu43a3.rs:14:52\n   |\n14 |         if word[idx] == 'a' || word[idx]\
    \ == 'e' || word[idx] == 'i' || word[idx] == 'o' || word[idx] == 'u' {\n   | \
    \                                                   ^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <Stri"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter\
    \ = vowels.iter();\n    let mut vowels_iter = \n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpsajw8pqb.rs:54:1\n\
    \   |\n54 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_idx = word.len();\n    let mut vowels_idx_end = word.len();\n\
    \    \n    while vowels_idx > 0 && vowels_idx_end > 0 {\n        if word[vowels_idx\
    \ - 1] == vowels[vowels_idx - 1] {\n            vowels_idx -= 1;\n        } else\
    \ {\n            vowels_idx_end -= 1;\n        }\n    }\n    \n    if vowels_idx\
    \ > 0 {\n        return word[vowels_idx - 1];\n    } else if vowels_idx_end >\
    \ 0 {\n        return word[vowels_idx_end - 1];\n    } else {\n        return\
    \ \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n   \
    \ assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"\
    most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n  \
    \  assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqzfkc1ru.rs:13:12\n\
    \   |\n13 |         if word[vowels_idx - 1] == vowels[vowels_idx - 1] {\n   |\
    \            ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqzfkc1ru.rs:21:16\n\
    \   |\n21 |         return word[vowels_idx - 1];\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqzfkc1ru.rs:23:16\n   |\n23 |         return word[vowels_idx_end\
    \ - 1];\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as In"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmps4ljauhk.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    let mut\
    \ vowel_pos = word.rfind('a', word.len() - 1);\n    if vowel_pos == word.len()\
    \ - 1 {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind('A',\
    \ word.len() - 1);\n    if vowel_pos == word.len() - 1 {\n        return \"\"\
    ;\n    }\n    let mut vowel_pos = word.rfind('e', word.len() - 1);\n    if vowel_pos\
    \ == word.len() - 1 {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind('E',\
    \ word.len() - 1);\n    if vowel_pos == word.len() - 1 {\n        return \"\"\
    ;\n    }\n    let mut vowel_pos = word.rfind('i', word.len() - 1);\n    if vowel_pos\
    \ == word.len() - 1 {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind('I',\
    \ word.len() - 1);\n    if vowel_pos == word.len() - 1 {\n        return \"\"\
    ;\n    }\n    let mut vowel_pos = word.rfind('o', word.len() - 1);\n    if vowel_pos\
    \ == word.len() - 1 {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind('O',\
    \ word.len() - 1);\n    if vowel_pos == word.len() - 1 {\n        return \"\"\
    ;\n    }\n    let mut vowel_pos = word.rfind('u', word.len() - 1);\n    if vowel_pos\
    \ == word.len() - 1 {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind('U',\
    \ word.len() - 1);\n    if vowel_pos == word.len() - 1 {\n        return \"\"\
    ;\n    }\n    let mut vowel_pos = word.rfind('a', 0);\n    if vowel_pos == 0 {\n\
    \        return \"\";\n    }\n    let mut vowel_pos = word.rfind('A', 0);\n  \
    \  if vowel_pos == 0 {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind('e',\
    \ 0);\n    if vowel_pos == 0 {\n        return \"\";\n    }\n    let mut vowel_pos\
    \ = word.rfind('E', 0);\n    if vowel_pos == 0 {\n        return \"\";\n    }\n\
    \    let mut vowel_pos = word.rfind('i', 0);\n    if vowel_pos == 0 {\n      \
    \  return \"\";\n    }\n    let mut vowel_pos = word.rfind('I', 0);\n    if vowel_pos\
    \ == 0 {\n        return \"\";\n    }\n    let mut vowel_pos = word.rfind('o',\
    \ 0);\n    if vowel_pos == 0 {\n        return \"\";\n    }\n    let mut vowel_pos\
    \ = word.rfind('O', 0);\n    if vowel_po\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpkl62oipn.rs:79:1\n   |\n\
    78 |     if vowel_po\n   |     -- this `if` expression has a condition, but no\
    \ block\n79 | }\n   | ^ expected `{`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmpkl62oipn.rs:9:30\n     |\n9 \
    \   |     let mut vowel_pos = word.rfind('a', word.len() - 1);\n     |       \
    \                       ^^^^^ ---  -------------- supplied 2 arguments\n     |\
    \                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkl62oipn.rs:10:21\n   |\n10 |     if vowel_pos\
    \ == word.len() - 1 {\n   |                     ^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n10 |\
    \     if vowel_pos == Some(word.len() - 1) {\n   |                     +++++ \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkl62oipn.rs:11:16\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    11 |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmpkl62oipn.rs:13:30\n     |\n13\
    \   |     let mut vowel_pos = word.rfind('A', word.len() - 1);\n     |       \
    \                       ^^^^^ ---  -------------- supplied 2 arguments\n     |\
    \                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkl62oipn.rs:14:21\n   |\n14 |     if vowel_pos\
    \ == word.len() - 1 {\n   |                     ^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found "
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_end = vec![0];\n    let mut vowels_count_start = vec![0];\n\
    \    let mut vowels_count_start_index = vec![0];\n    let mut vowels_count_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end = vec![0];\n    let mut vowels_count_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_end_index = vec![0];\n    let mut vowels_count_start_end_end_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start = vec![0];\n\
    \    let mut vowels_count_start_end_end_start_index_start_end = vec![0];\n   \
    \ let mut vowels_count_start_end_end_start_index_start_end_end = vec![0];\n  \
    \  let mut vowels_count_start_end_end_start_index_start_end_end_start = vec![0];\n\
    \    let mut vowels_count_start_end_end_start_index_start_end_end_start_end =\
    \ vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start_end\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start_end_start_end\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start_end_start_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start_end_start_end_end\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start_end_start_end_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start_end_start_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpygwbxds3.rs:35:92\n   |\n\
    35 |     let mut vowels_count_start_end_end_start_index_start_end_end_start_end_start_end_start_\n\
    \   |                                                                        \
    \                    ^ help: add `;` here\n36 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpygwbxds3.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n  \
    \  vowels.iter().for_each(|vowel| {\n        vowels_set.insert(vowel.to_string());\n\
    \    });\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    if vowels_set.len() == 0 {\n        return \"\";\n  \
    \  }\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    if vowels_set.len() == 0 {\n        return \"\";\n  \
    \  }\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    if vowels_set.len() == 0 {\n        return \"\";\n  \
    \  }\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    if vowels_set.len() == 0 {\n        return \"\";\n  \
    \  }\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    if vowels_set.len() == 0 {\n        return \"\";\n  \
    \  }\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    if vowels_set.len() == 0 {\n        return \"\";\n  \
    \  }\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_string()) {\n            \n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkf1qgz99.rs:88:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n68 |     word.chars().for_each(|c|\
    \ {\n   |                          -    - unclosed delimiter\n   |           \
    \               |\n   |                          unclosed delimiter\n69 |    \
    \     if vowels_set.contains(&c.to_string()) {\n   |                         \
    \                       - this delimiter might not be properly closed...\n70 |\
    \             \n71 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n88 | }\n   |   ^\n\nerror[E0412]: cannot find type `HashSet` in this scope\n\
    \ --> /tmp/tmpkf1qgz99.rs:9:25\n  |\n9 |     let mut vowels_set: HashSet<&str>\
    \ = HashSet::new();\n  |                         ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpkf1qgz99.rs:9:41\n  |\n9 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n\
    \  |                                         ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpkf1qgz99.rs:13:25\n\
    \   |\n13 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpkf1qgz99.rs:13:41\n\
    \   |\n13 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpkf1qgz99.rs:22:25\n\
    \   |\n22 |     let mut vowels_set: HashSet<&str> = HashSet::new();"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    let mut\
    \ vowel_pos = word.rfind('a').unwrap();\n    let mut vowel_end = word.rfind('e').unwrap();\n\
    \    let mut vowel_start = word.rfind('i').unwrap();\n    let mut vowel_mid =\
    \ word.rfind('o').unwrap();\n    let mut vowel_start = word.rfind('u').unwrap();\n\
    \    let mut vowel_end = word.rfind('A').unwrap();\n    let mut vowel_start =\
    \ word.rfind('E').unwrap();\n    let mut vowel_end = word.rfind('I').unwrap();\n\
    \    let mut vowel_start = word.rfind('O').unwrap();\n    let mut vowel_end =\
    \ word.rfind('U').unwrap();\n    let mut vowel_start = word.rfind('a').unwrap();\n\
    \    let mut vowel_end = word.rfind('e').unwrap();\n    let mut vowel_start =\
    \ word.rfind('i').unwrap();\n    let mut vowel_end = word.rfind('o').unwrap();\n\
    \    let mut vowel_start = word.rfind('u').unwrap();\n    let mut vowel_end =\
    \ word.rfind('A').unwrap();\n    let mut vowel_start = word.rfind('E').unwrap();\n\
    \    let mut vowel_end = word.rfind('I').unwrap();\n    let mut vowel_start =\
    \ word.rfind('O').unwrap();\n    let mut vowel_end = word.rfind('U').unwrap();\n\
    \    let mut vowel_start = word.rfind('a').unwrap();\n    let mut vowel_end =\
    \ word.rfind('e').unwrap();\n    let mut vowel_start = word.rfind('i').unwrap();\n\
    \    let mut vowel_end = word.rfind('o').unwrap();\n    let mut vowel_start =\
    \ word.rfind('u').unwrap();\n    let mut vowel_end = word.rfind('A').unwrap();\n\
    \    let mut vowel_start = word.rfind('E').unwrap();\n    let mut vowel_end =\
    \ word.rfind('I').unwrap();\n    let mut vowel_start = word.rfind('O').unwrap();\n\
    \    let mut vowel_end = word.rfind('U').unwrap();\n    let mut vowel_start =\
    \ word.rfind('a').unwrap();\n    let mut vowel_end = word.rfind('e').unwrap();\n\
    \    let mut vowel_start = word.rfind('i').unwrap();\n    let mut vowel_end =\
    \ word.rfind('o').unwrap();\n    let mut vowel_start = word.rfind('u').unwrap();\n\
    \    let mut vowel_end = word.rfind('\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpfoyya2d0.rs:44:36\n\
    \   |\n44 |     let mut vowel_end = word.rfind('\n   |                       \
    \             ^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index2 = vec![0];\n    let mut vowels_count_index3 =\
    \ vec![0];\n    let mut vowels_count_index4 = vec![0];\n    let mut vowels_count_index5\
    \ = vec![0];\n    let mut vowels_count_index6 = vec![0];\n    let mut vowels_count_index7\
    \ = vec![0];\n    let mut vowels_count_index8 = vec![0];\n    let mut vowels_count_index9\
    \ = vec![0];\n    let mut vowels_count_index10 = vec![0];\n    let mut vowels_count_index11\
    \ = vec![0];\n    let mut vowels_count_index12 = vec![0];\n    let mut vowels_count_index13\
    \ = vec![0];\n    let mut vowels_count_index14 = vec![0];\n    let mut vowels_count_index15\
    \ = vec![0];\n    let mut vowels_count_index16 = vec![0];\n    let mut vowels_count_index17\
    \ = vec![0];\n    let mut vowels_count_index18 = vec![0];\n    let mut vowels_count_index19\
    \ = vec![0];\n    let mut vowels_count_index20 = vec![0];\n    let mut vowels_count_index21\
    \ = vec![0];\n    let mut vowels_count_index22 = vec![0];\n    let mut vowels_count_index23\
    \ = vec![0];\n    let mut vowels_count_index24 = vec![0];\n    let mut vowels_count_index25\
    \ = vec![0];\n    let mut vowels_count_index26 = vec![0];\n    let mut vowels_count_index27\
    \ = vec![0];\n    let mut vowels_count_index28 = vec![0];\n    let mut vowels_count_index29\
    \ = vec![0];\n    let mut vowels_count_index30 = vec![0];\n    let mut vowels_count_index31\
    \ = vec![0];\n    let mut vowels_count_index32 = vec![0];\n    let mut vowels_count_index33\
    \ = vec![0];\n    let mut vowels_count_index34 = vec![0];\n    let mut vowels_count_index35\
    \ = vec![0];\n    let mut vowels_count_index36 = vec![0];\n    let mut vowels_count_index37\
    \ = vec![0];\n    let mut vowels_count_index38 = vec![0];\n    let mut \n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpbm22x8e7.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmprntrtm33.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_end = vec![0];\n    let mut vowels_count_start = vec![0];\n\
    \    let mut vowels_count_start_index = vec![0];\n    let mut vowels_count_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end = vec![0];\n    let mut vowels_count_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_end_index = vec![0];\n    let mut vowels_count_start_end_end_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_index = vec![0];\n\
    \    let mut vowels_count_start_end_end_start_end_end_index = vec![0];\n    let\
    \ mut vowels_count_start_end_end_start_end_end_start_index = vec![0];\n    let\
    \ mut vowels_count_start_end_end_start_end_end_start_end_index = vec![0];\n  \
    \  let mut vowels_count_start_end_end_start_end_end_start_end_end_index = vec![0];\n\
    \    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_end_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_end_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_end_end_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_end_end_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_end_end_end_end_end_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_end_end_start_end_end_end_end_end_end_end_end_end_index\
    \ = vec![0];\n    let mut vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7yszbu0z.rs:36:18\n   |\n\
    36 |     let mut vowel\n   |                  ^ help: add `;` here\n37 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7yszbu0z.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp91fpm9_h.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp91fpm9_h.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n\
    \    let mut vowels_start = vowels_iter.next();\n    let mut vowels_middle = vowels_iter.next();\n\
    \    let mut vowels_first_half = vowels_iter.next();\n    let mut vowels_second_half\
    \ = vowels_iter.next();\n    let mut vowels_first_half_iter = vowels_first_half.iter();\n\
    \    let mut vowels_second_half_iter = vowels_second_half.iter();\n    let mut\
    \ vowels_first_half_end = vowels_first_half_iter.next();\n    let mut vowels_second_half_end\
    \ = vowels_second_half_iter.next();\n    let mut vowels_first_half_start = vowels_first_half_iter.next();\n\
    \    let mut vowels_second_half_start = vowels_second_half_iter.next();\n    let\
    \ mut vowels_first_half_middle = vowels_first_half_iter.next();\n    let mut vowels_second_half_middle\
    \ = vowels_second_half_iter.next();\n    let mut vowels_first_half_middle_iter\
    \ = vowels_first_half_middle.iter();\n    let mut vowels_second_half_middle_iter\
    \ = vowels_second_half_middle.iter();\n    let mut vowels_first_half_middle_end\
    \ = vowels_first_half_middle_iter.next();\n    let mut vowels_second_half_middle_end\
    \ = vowels_second_half_middle_iter.next();\n    let mut vowels_first_half_middle_start\
    \ = vowels_first_half_middle_iter.next();\n    let mut vowels_second_half_middle_start\
    \ = vowels_second_half_middle_iter.next();\n    let mut vowels_first_half_middle_middle\
    \ = vowels_first_half_middle_iter.next();\n    let mut vowels_second_half_middle_middle\
    \ = vowels_second_half_middle_iter.next();\n    let mut vowels_first_half_middle_middle_iter\
    \ = vowels_first_half_middle_middle.iter();\n    let mut vowels_second_half_middle_middle_iter\
    \ = vowels_second_half_middle_middle.iter();\n    let mut vowels_first_half_middle_middle_end\
    \ = vowels_first_half_middle_middle_iter.next();\n    let mut vowels_second_half_middle_middle_end\
    \ = vowels_second_half_middle_middle_iter.next();\n    let mut vowels_first_half_middle_middle_start\
    \ = vowels_first_half_middle_middle_iter.next();\n    let mut vowels_second_half_middle_middle_start\
    \ = vowels_second_half_middle_middle_iter.next();\n    let mut vowels_first_half_middle_middle_middle\
    \ = vowels_first_half_middle_middle_iter.next();\n    let mut vowels_second_half_middle_middle_middle\
    \ = vowels_second_half_middle_middle_iter.next();\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpcau077_m.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_max = vec![0];\n\
    \    let mut vowels_count_min = vec![0];\n    let mut vowels_count_max_index =\
    \ vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6m5zkkwd.rs:50:26\n   |\n\
    50 |     let mut vowels_count_\n   |                          ^ help: add `;`\
    \ here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp6m5zkkwd.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) -> String\
    \ {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mut vowels_iter = vowels_iter.skip(1);\n    let mut vowels_iter = vowels_iter.skip(1);\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuptgtg54.rs:47:11\n   |\n\
    47 |     let mu\n   |           ^ help: add `;` here\n48 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpuptgtg54.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    let mut\
    \ vowel_pos = word.rfind('a').unwrap();\n    let mut vowel_end = word.rfind('e').unwrap();\n\
    \    let mut vowel_start = word.rfind('i').unwrap();\n    let mut vowel_mid =\
    \ word.rfind('o').unwrap();\n    let mut vowel_mid2 = word.rfind('u').unwrap();\n\
    \    \n    if vowel_pos == word.len() {\n        return \"\";\n    }\n    \n \
    \   while vowel_pos > 0 {\n        if vowels[vowel_pos] == word[vowel_pos] {\n\
    \            vowel_end = vowel_pos;\n        } else {\n            vowel_pos =\
    \ vowel_pos - 1;\n        }\n    }\n    \n    while vowel_end < word.len() {\n\
    \        if vowels[vowel_end] == word[vowel_end] {\n            vowel_start =\
    \ vowel_end;\n        } else {\n            vowel_end = vowel_end + 1;\n     \
    \   }\n    }\n    \n    while vowel_start < word.len() {\n        if vowels[vowel_start]\
    \ == word[vowel_start] {\n            vowel_mid = vowel_start;\n        } else\
    \ {\n            vowel_start = vowel_start + 1;\n        }\n    }\n    \n    while\
    \ vowel_mid < word.len() {\n        if vowels[vowel_mid] == word[vowel_mid] {\n\
    \            vowel_mid2 = vowel_mid;\n        } else {\n            vowel_mid\
    \ = vowel_mid + 1;\n        }\n    }\n    \n    if vowel_start == word.len() {\n\
    \        return \"\";\n    }\n    \n    if vowel_end == word.len() {\n       \
    \ return \"\";\n    }\n    \n    if vowel_mid == word.len() {\n        return\
    \ \"\";\n    }\n    \n    if vowel_mid2 == word.len() {\n        return \"\";\n\
    \    }\n    \n    if vowel_mid < vowel_start {\n        return \"\";\n    }\n\
    \    \n    if vowel_mid > vowel_end {\n        return \"\";\n    }\n    \n   \
    \ if vowel_mid < vowel_mid2 {\n        return \"\";\n    }\n    \n    if vowel_mid\
    \ > vowel_mid2 {\n        return \"\";\n    }\n    \n    if vowel_mid == vowel_mid2\
    \ {\n        return \"\";\n    }\n    \n    return word[vowel_mid..].to_string();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8oq74o89.rs:16:16\n   |\n\
    7  | fn get_closest_vowel(word: String) -> String {\n   |                    \
    \                   ------ expected `String` because of return type\n...\n16 |\
    \         return \"\";\n   |                ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8oq74o89.rs:20:12\n   |\n20 |         if vowels[vowel_pos] == word[vowel_pos]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8oq74o89.rs:20:33\n   |\n20 |         if vowels[vowel_pos] == word[vowel_pos]\
    \ {\n   |                                 ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8oq74o89.rs:28:12\n   |\n28 |         if vowels[vowel_end] == word[vowel_end]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n  "
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_count = word.chars().filter(|c| vowels.contains(&c.to_string())).count();\n\
    \    let mut vowel_found = false;\n    let mut vowel_found2 = false;\n    let\
    \ mut vowel_found3 = false;\n    let mut vowel_found4 = false;\n    let mut vowel_found5\
    \ = false;\n    let mut vowel_found6 = false;\n    let mut vowel_found7 = false;\n\
    \    let mut vowel_found8 = false;\n    let mut vowel_found9 = false;\n    let\
    \ mut vowel_found10 = false;\n    let mut vowel_found11 = false;\n    let mut\
    \ vowel_found12 = false;\n    let mut vowel_found13 = false;\n    let mut vowel_found14\
    \ = false;\n    let mut vowel_found15 = false;\n    let mut vowel_found16 = false;\n\
    \    let mut vowel_found17 = false;\n    let mut vowel_found18 = false;\n    let\
    \ mut vowel_found19 = false;\n    let mut vowel_found20 = false;\n    let mut\
    \ vowel_found21 = false;\n    let mut vowel_found22 = false;\n    let mut vowel_found23\
    \ = false;\n    let mut vowel_found24 = false;\n    let mut vowel_found25 = false;\n\
    \    let mut vowel_found26 = false;\n    let mut vowel_found27 = false;\n    let\
    \ mut vowel_found28 = false;\n    let mut vowel_found29 = false;\n    let mut\
    \ vowel_found30 = false;\n    let mut vowel_found31 = false;\n    let mut vowel_found32\
    \ = false;\n    let mut vowel_found33 = false;\n    let mut vowel_found34 = false;\n\
    \    let mut vowel_found35 = false;\n    let mut vowel_found36 = false;\n    let\
    \ mut vowel_found37 = false;\n    let mut vowel_found38 = false;\n    let mut\
    \ vowel_found39 = false;\n    let mut vowel_found40 = false;\n    let mut vowel_found41\
    \ = false;\n    let mut vowel_found42 = false;\n    let mut vowel_found43 = false;\n\
    \    let mut vowel_found44 = false;\n    let mut vowel_found45 = false;\n    let\
    \ mut vowel_found46 = false;\n    let mut vowel_found47 = false;\n    let mut\
    \ vowel_found48 = false;\n    let mut vowel_found49 = false;\n    let mut vowel_found50\
    \ = false;\n    let mut vowel_found51 = false;\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9qdhdv14.rs:9:68\n  |\n9 |\
    \     let mut vowels_count = word.chars().filter(|c| vowels.contains(&c.to_string())).count();\n\
    \  |                                                                    ^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n  |\n  = note: expected reference `&&str`\n\
    \             found reference `&String`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp9qdhdv14.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) -> String\
    \ {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_set = HashSet::new();\n    vowels.iter().for_each(|v|\
    \ vowels_set.insert(v));\n    let mut vowels_count = vowels_set.len();\n    let\
    \ mut vowels_index = 0;\n    let mut vowels_index2 = 0;\n    let mut vowels_index3\
    \ = 0;\n    let mut vowels_index4 = 0;\n    let mut vowels_index5 = 0;\n    let\
    \ mut vowels_index6 = 0;\n    let mut vowels_index7 = 0;\n    let mut vowels_index8\
    \ = 0;\n    let mut vowels_index9 = 0;\n    let mut vowels_index10 = 0;\n    let\
    \ mut vowels_index11 = 0;\n    let mut vowels_index12 = 0;\n    let mut vowels_index13\
    \ = 0;\n    let mut vowels_index14 = 0;\n    let mut vowels_index15 = 0;\n   \
    \ let mut vowels_index16 = 0;\n    let mut vowels_index17 = 0;\n    let mut vowels_index18\
    \ = 0;\n    let mut vowels_index19 = 0;\n    let mut vowels_index20 = 0;\n   \
    \ let mut vowels_index21 = 0;\n    let mut vowels_index22 = 0;\n    let mut vowels_index23\
    \ = 0;\n    let mut vowels_index24 = 0;\n    let mut vowels_index25 = 0;\n   \
    \ let mut vowels_index26 = 0;\n    let mut vowels_index27 = 0;\n    let mut vowels_index28\
    \ = 0;\n    let mut vowels_index29 = 0;\n    let mut vowels_index30 = 0;\n   \
    \ let mut vowels_index31 = 0;\n    let mut vowels_index32 = 0;\n    let mut vowels_index33\
    \ = 0;\n    let mut vowels_index34 = 0;\n    let mut vowels_index35 = 0;\n   \
    \ let mut vowels_index36 = 0;\n    let mut vowels_index37 = 0;\n    let mut vowels_index38\
    \ = 0;\n    let mut vowels_index39 = 0;\n    let mut vowels_index40 = 0;\n   \
    \ let mut vowels_index41 = 0;\n    let mut vowels_index42 = 0;\n    let mut vowels_index43\
    \ = 0;\n    let mut vowels_index44 = 0;\n    let mut vowels_index45 = 0;\n   \
    \ let mut vowels_index46 = 0;\n    let mut vowels_index47 = 0;\n    let mut vowels_index48\
    \ = 0;\n    let mut vowels_index49 = 0;\n    let mut vowels_index50 = 0;\n   \
    \ let mut vowels_index51 = 0;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp9_fac0ad.rs:9:26\n  |\n9 |     let mut vowels_set = HashSet::new();\n\
    \  |                          ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp9_fac0ad.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index2 = vec![0];\n    let mut vowels_count_index3 =\
    \ vec![0];\n    let mut vowels_count_index4 = vec![0];\n    let mut vowels_count_index5\
    \ = vec![0];\n    let mut vowels_count_index6 = vec![0];\n    let mut vowels_count_index7\
    \ = vec![0];\n    let mut vowels_count_index8 = vec![0];\n    let mut vowels_count_index9\
    \ = vec![0];\n    let mut vowels_count_index10 = vec![0];\n    let mut vowels_count_index11\
    \ = vec![0];\n    let mut vowels_count_index12 = vec![0];\n    let mut vowels_count_index13\
    \ = vec![0];\n    let mut vowels_count_index14 = vec![0];\n    let mut vowels_count_index15\
    \ = vec![0];\n    let mut vowels_count_index16 = vec![0];\n    let mut vowels_count_index17\
    \ = vec![0];\n    let mut vowels_count_index18 = vec![0];\n    let mut vowels_count_index19\
    \ = vec![0];\n    let mut vowels_count_index20 = vec![0];\n    let mut vowels_count_index21\
    \ = vec![0];\n    let mut vowels_count_index22 = vec![0];\n    let mut vowels_count_index23\
    \ = vec![0];\n    let mut vowels_count_index24 = vec![0];\n    let mut vowels_count_index25\
    \ = vec![0];\n    let mut vowels_count_index26 = vec![0];\n    let mut vowels_count_index27\
    \ = vec![0];\n    let mut vowels_count_index28 = vec![0];\n    let mut vowels_count_index29\
    \ = vec![0];\n    let mut vowels_count_index30 = vec![0];\n    let mut vowels_count_index31\
    \ = vec![0];\n    let mut vowels_count_index32 = vec![0];\n    let mut vowels_count_index33\
    \ = vec![0];\n    let mut vowels_count_index34 = vec![0];\n    let mut vowels_count_index35\
    \ = vec![0];\n    let mut vowels_count_index36 = vec![0];\n    let mut vowels_count_index37\
    \ = vec![0];\n    let mut vowels_count_index38 = vec![0];\n    let mut \n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpbm22x8e7.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index_max = vec![0];\n    let mut vowels_count_index_min\
    \ = vec![0];\n    let mut vowels_count_index_max_min = vec![0];\n    let mut vowels_count_index_max_min_index\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_max = vec![0];\n  \
    \  let mut vowels_count_index_max_min_index_min_index = vec![0];\n    let mut\
    \ vowels_count_index_max_min_index_min_index_max = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0ua0x9mx.rs:31:89\n   |\n\
    31 |     let mut vowels_count_index_max_min_index_min_index_min_index_min_index_min_index_min\n\
    \   |                                                                        \
    \                 ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp0ua0x9mx.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut vowel_pos = 0;\n    let mut consonant_pos = 0;\n    let mut consonant_len\
    \ = word.len();\n    let mut vowel_len = vowels.len();\n    let mut vowel_found\
    \ = false;\n    let mut consonant_found = false;\n    while vowel_pos < vowel_len\
    \ && consonant_pos < consonant_len {\n        if word[vowel_pos] == vowels[vowel_pos]\
    \ {\n            vowel_found = true;\n            vowel_pos++;\n        } else\
    \ {\n            vowel_found = false;\n        }\n        if word[consonant_pos]\
    \ == vowels[vowel_pos] {\n            consonant_found = true;\n            consonant_pos++;\n\
    \        } else {\n            consonant_found = false;\n        }\n        if\
    \ vowel_found && consonant_found {\n            break;\n        }\n    }\n   \
    \ if vowel_found && consonant_found {\n        return word.to_owned();\n    }\n\
    \    return String::new();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpfmzxjh_f.rs:18:22\n\
    \   |\n18 |             vowel_pos++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |             { let\
    \ tmp = vowel_pos; vowel_pos += 1; tmp };\n   |             +++++++++++      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~\n18 -             vowel_pos++;\n18 +            \
    \ vowel_pos += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  -->\
    \ /tmp/tmpfmzxjh_f.rs:24:26\n   |\n24 |             consonant_pos++;\n   |   \
    \                       ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n24 |             { let tmp = consonant_pos; consonant_pos +=\
    \ 1; tmp };\n   |             +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    24 -             consonant_pos++;\n24 +             consonant_pos += 1;\n   |\
    \ \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfmzxjh_f.rs:16:12\n\
    \   |\n16 |         if word[vowel_pos] == vowels[vowel_pos] {\n   |          \
    \  ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfmzxjh_f.rs:22:12\n   |\n22 |         if word[consonant_pos] ==\
    \ vowels[vowel_pos] {\n   |            ^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp91fpm9_h.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp91fpm9_h.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index2 = vec![0];\n    let mut vowels_count_index3 =\
    \ vec![0];\n    let mut vowels_count_index4 = vec![0];\n    let mut vowels_count_index5\
    \ = vec![0];\n    let mut vowels_count_index6 = vec![0];\n    let mut vowels_count_index7\
    \ = vec![0];\n    let mut vowels_count_index8 = vec![0];\n    let mut vowels_count_index9\
    \ = vec![0];\n    let mut vowels_count_index10 = vec![0];\n    let mut vowels_count_index11\
    \ = vec![0];\n    let mut vowels_count_index12 = vec![0];\n    let mut vowels_count_index13\
    \ = vec![0];\n    let mut vowels_count_index14 = vec![0];\n    let mut vowels_count_index15\
    \ = vec![0];\n    let mut vowels_count_index16 = vec![0];\n    let mut vowels_count_index17\
    \ = vec![0];\n    let mut vowels_count_index18 = vec![0];\n    let mut vowels_count_index19\
    \ = vec![0];\n    let mut vowels_count_index20 = vec![0];\n    let mut vowels_count_index21\
    \ = vec![0];\n    let mut vowels_count_index22 = vec![0];\n    let mut vowels_count_index23\
    \ = vec![0];\n    let mut vowels_count_index24 = vec![0];\n    let mut vowels_count_index25\
    \ = vec![0];\n    let mut vowels_count_index26 = vec![0];\n    let mut vowels_count_index27\
    \ = vec![0];\n    let mut vowels_count_index28 = vec![0];\n    let mut vowels_count_index29\
    \ = vec![0];\n    let mut vowels_count_index30 = vec![0];\n    let mut vowels_count_index31\
    \ = vec![0];\n    let mut vowels_count_index32 = vec![0];\n    let mut vowels_count_index33\
    \ = vec![0];\n    let mut vowels_count_index34 = vec![0];\n    let mut vowels_count_index35\
    \ = vec![0];\n    let mut vowels_count_index36 = vec![0];\n    let mut vowels_count_index37\
    \ = vec![0];\n    let mut vowels_count_index38 = vec![0];\n    let mut \n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpbm22x8e7.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_set = HashSet::new();\n    for vowel in vowels.iter()\
    \ {\n        vowels_set.insert(vowel);\n    }\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpevbwhjzj.rs:51:33\n   |\n\
    51 |     let mut vowels_set = HashSet\n   |                                 ^\
    \ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpevbwhjzj.rs:9:26\n\
    \  |\n9 |     let mut vowels_set = HashSet::new();\n  |                      \
    \    ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpevbwhjzj.rs:13:26\n   |\n13\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpevbwhjzj.rs:14:26\n   |\n14\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpevbwhjzj.rs:15:26\n   |\n15\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpevbwhjzj.rs:16:26\n   |\n16\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpevbwhjzj.rs:17:26\n   |\n17\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Hash"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_index2 = 0;\n    let mut vowels_count_index3 = 0;\n\
    \    let mut vowels_count_index4 = 0;\n    let mut vowels_count_index5 = 0;\n\
    \    let mut vowels_count_index6 = 0;\n    let mut vowels_count_index7 = 0;\n\
    \    let mut vowels_count_index8 = 0;\n    let mut vowels_count_index9 = 0;\n\
    \    let mut vowels_count_index10 = 0;\n    let mut vowels_count_index11 = 0;\n\
    \    let mut vowels_count_index12 = 0;\n    let mut vowels_count_index13 = 0;\n\
    \    let mut vowels_count_index14 = 0;\n    let mut vowels_count_index15 = 0;\n\
    \    let mut vowels_count_index16 = 0;\n    let mut vowels_count_index17 = 0;\n\
    \    let mut vowels_count_index18 = 0;\n    let mut vowels_count_index19 = 0;\n\
    \    let mut vowels_count_index20 = 0;\n    let mut vowels_count_index21 = 0;\n\
    \    let mut vowels_count_index22 = 0;\n    let mut vowels_count_index23 = 0;\n\
    \    let mut vowels_count_index24 = 0;\n    let mut vowels_count_index25 = 0;\n\
    \    let mut vowels_count_index26 = 0;\n    let mut vowels_count_index27 = 0;\n\
    \    let mut vowels_count_index28 = 0;\n    let mut vowels_count_index29 = 0;\n\
    \    let mut vowels_count_index30 = 0;\n    let mut vowels_count_index31 = 0;\n\
    \    let mut vowels_count_index32 = 0;\n    let mut vowels_count_index33 = 0;\n\
    \    let mut vowels_count_index34 = 0;\n    let mut vowels_count_index35 = 0;\n\
    \    let mut vowels_count_index36 = 0;\n    let mut vowels_count_index37 = 0;\n\
    \    let mut vowels_count_index38 = 0;\n    let mut vowels_count_index39 = 0;\n\
    \    let mut vowels_count_index40 = 0;\n    let mut vowels_count_index41 = 0;\n\
    \    let mut vowels_count_index42 = 0;\n    let mut vowels_count_index43 = 0;\n\
    \    let mut vowels_count_index44 = 0;\n    let mut vowels_count_index45 = 0;\n\
    \    let mut vowels_count_index46 = 0;\n    let mut vowels_count_index47 = 0;\n\
    \    let mut vowels_count_index48 = 0;\n    let mut vowels_count_index49 = 0;\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxmvutlve.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n  \
    \  vowels.iter().for_each(|v| vowels_set.insert(v));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c| vowels_set.insert(c));\n\
    \    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ vowels_set.insert(c));\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n\
    \    word.chars().for_each(|c| vowels_set.insert(c));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c| vowels_set.insert(c));\n\
    \    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ vowels_set.insert(c));\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n\
    \    word.chars().for_each(|c| vowels_set.insert(c));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c| vowels_set.insert(c));\n\
    \    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ vowels_set.insert(c));\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n\
    \    word.chars().for_each(|c| vowels_set.insert(c));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c| vowels_set.insert(c));\n\
    \    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ vowels_set.insert(c));\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n\
    \    word.chars().for_each(|c| vowels_set.insert(c));\n    let mut vowels_set:\
    \ HashSet<&str> = HashSet::new();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp7y14p3de.rs:9:25\n\
    \  |\n9 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n  |       \
    \                  ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmp7y14p3de.rs:9:41\n\
    \  |\n9 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n  |       \
    \                                  ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp7y14p3de.rs:11:25\n\
    \   |\n11 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp7y14p3de.rs:11:41\n\
    \   |\n11 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp7y14p3de.rs:13:25\n\
    \   |\n13 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp7y14p3de.rs:13:41\n\
    \   |\n13 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp7y14p3de.rs:15:25\n\
    \   |\n15 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \      "
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n\
    \    let mut vowels_start = vowels_iter.next();\n    let mut vowels_middle = vowels_iter.next();\n\
    \    let mut vowels_first_half = vowels_iter.next();\n    let mut vowels_second_half\
    \ = vowels_iter.next();\n    let mut vowels_first_half_end = vowels_iter.next();\n\
    \    let mut vowels_second_half_end = vowels_iter.next();\n    let mut vowels_first_half_start\
    \ = vowels_iter.next();\n    let mut vowels_second_half_start = vowels_iter.next();\n\
    \    let mut vowels_first_half_middle = vowels_iter.next();\n    let mut vowels_second_half_middle\
    \ = vowels_iter.next();\n    let mut vowels_first_half_middle_end = vowels_iter.next();\n\
    \    let mut vowels_second_half_middle_end = vowels_iter.next();\n    let mut\
    \ vowels_first_half_middle_start = vowels_iter.next();\n    let mut vowels_second_half_middle_start\
    \ = vowels_iter.next();\n    let mut vowels_first_half_middle_middle = vowels_iter.next();\n\
    \    let mut vowels_second_half_middle_middle = vowels_iter.next();\n    let mut\
    \ vowels_first_half_middle_middle_end = vowels_iter.next();\n    let mut vowels_second_half_middle_middle_end\
    \ = vowels_iter.next();\n    let mut vowels_first_half_middle_middle_start = vowels_iter.next();\n\
    \    let mut vowels_second_half_middle_middle_start = vowels_iter.next();\n  \
    \  let mut vowels_first_half_middle_middle_middle = vowels_iter.next();\n    let\
    \ mut vowels_second_half_middle_middle_middle = vowels_iter.next();\n    let mut\
    \ vowels_first_half_middle_middle_middle_end = vowels_iter.next();\n    let mut\
    \ vowels_second_half_middle_middle_middle_end = vowels_iter.next();\n    let mut\
    \ vowels_first_half_middle_middle_middle_start = vowels_iter.next();\n    let\
    \ mut vowels_second_half_middle_middle_middle_start = vowels_iter.next();\n  \
    \  let mut vowels_first_half_middle_middle_middle_middle = vowels_iter.next();\n\
    \    let mut vowels_second_half_middle_middle_middle_middle = vowels_iter.next();\n\
    \    let mut vowels_first_half_middle_middle_middle_middle_end = vowels_iter.next();\n\
    \    let mut vowels_second_half_middle_middle_middle_middle_end = vowels_iter.next();\n\
    \    let mut vowels_first_half_middle_middle_middle_middle_start = vowels_iter.next();\n\
    \    let mut vowels_second_half_middle_middle_middle_middle_start = vowels_iter.next();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpomehlf_y.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut vowel_pos\
    \ = word.rfind('a');\n    let mut vowel_end = word.rfind('e');\n    let mut vowel_start\
    \ = word.rfind('i');\n    let mut vowel_mid = word.rfind('o');\n    let mut vowel_len\
    \ = word.len();\n    let mut vowel_found = false;\n    while vowel_pos != word.len()\
    \ && vowel_end != word.len() && vowel_start != word.len() && vowel_mid != word.len()\
    \ && vowel_len != word.len() {\n        if vowels.contains(&word[vowel_pos]) {\n\
    \            vowel_found = true;\n            break;\n        }\n        vowel_pos--;\n\
    \        vowel_end++;\n        vowel_start++;\n        vowel_mid++;\n        vowel_len--;\n\
    \    }\n    if vowel_found == false {\n        return \"\";\n    }\n    let mut\
    \ vowel_start = word.rfind('a');\n    let mut vowel_end = word.rfind('e');\n \
    \   let mut vowel_mid = word.rfind('i');\n    let mut vowel_len = word.len();\n\
    \    while vowel_start != word.len() && vowel_end != word.len() && vowel_mid !=\
    \ word.len() && vowel_len != word.len() {\n        if vowels.contains(&word[vowel_start])\
    \ {\n            vowel_found = true;\n            break;\n        }\n        vowel_start++;\n\
    \        vowel_end++;\n        vowel_mid++;\n        vowel_len--;\n    }\n   \
    \ if vowel_found == false {\n        return \"\";\n    }\n    let mut vowel_mid\
    \ = word.rfind('o');\n    let mut vowel_len = word.len();\n    while vowel_mid\
    \ != word.len() && vowel_len != word.len() {\n        if vowels.contains(&word[vowel_mid])\
    \ {\n            vowel_found = true;\n            break;\n        }\n        vowel_mid++;\n\
    \        vowel_len--;\n    }\n    if vowel_found == false {\n        return \"\
    \";\n    }\n    let mut vowel_end = word.rfind('e');\n    let mut vowel_len =\
    \ word.len();\n    while vowel_end != word.len() && vowel_len != word.len() {\n\
    \        if vowels.contains(&word[vowel_end]) {\n            vowel_found = true;\n\
    \            break;\n        }\n        vowel_end++;\n        vowel_len--;\n \
    \   }\n    if vowel_found == false {\n        return \"\";\n    }\n    let mut\
    \ vowel_start = word.rfind('a');\n    let mut vowel_len = word.len();\n    while\
    \ vowel_start \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n   \
    \ assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"\
    most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n  \
    \  assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpw3d048vb.rs:20:20\n\
    \   |\n20 |         vowel_pos--;\n   |                    ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpw3d048vb.rs:38:20\n\
    \   |\n38 |         vowel_start++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n38 |         { let tmp = vowel_start;\
    \ vowel_start += 1; tmp };\n   |         +++++++++++            ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    38 -         vowel_start++;\n38 +         vowel_start += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpw3d048vb.rs:53:18\n   |\n53\
    \ |         vowel_mid++;\n   |                  ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n53 |         { let tmp = vowel_mid; vowel_mid\
    \ += 1; tmp };\n   |         +++++++++++          ~~~~~~~~~~~~~~~~~~~~~~~\n53\
    \ -         vowel_mid++;\n53 +         vowel_mid += 1;\n   | \n\nerror: Rust has\
    \ no postfix increment operator\n  --> /tmp/tmpw3d048vb.rs:66:18\n   |\n66 | \
    \        vowel_end++;\n   |                  ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n66 |         { let tmp = vowel_end; vowel_end\
    \ += 1; tmp };\n   |         +++++++++++          ~~~~~~~~~~~~~~~~~~~~~~~\n66\
    \ -         vowel_end++;\n66 +         vowel_end += 1;\n   | \n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmpw3d048vb.rs:75:1\n   |\n74 |     while vowel_start\
    \ \n   |     ----- ----------- this `while` condition successfully parsed\n  \
    \ |     |\n   |     while parsing the body of this `while` expression\n75 | }\n\
    \   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw3d048vb.rs:15:24\n\
    \   |\n15 |     while vowel_pos != word.len() && vowel_end != word.len() && vowel_start\
    \ != word.len() && vowel_mid != word.len() && vowel_len != word.le...\n   |  \
    \                      ^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n\
    \   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n15 |     while vowel_pos !=\
    \ Some(word.len()) && vowel_end != word.le"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_end = vowels_iter.next();\n\
    \    let mut vowels_start = vowels_iter.next();\n    let mut vowels_mid = vowels_iter.next();\n\
    \    let mut vowels_mid2 = vowels_iter.next();\n    let mut vowels_mid3 = vowels_iter.next();\n\
    \    let mut vowels_mid4 = vowels_iter.next();\n    let mut vowels_mid5 = vowels_iter.next();\n\
    \    let mut vowels_mid6 = vowels_iter.next();\n    let mut vowels_mid7 = vowels_iter.next();\n\
    \    let mut vowels_mid8 = vowels_iter.next();\n    let mut vowels_mid9 = vowels_iter.next();\n\
    \    let mut vowels_mid10 = vowels_iter.next();\n    let mut vowels_mid11 = vowels_iter.next();\n\
    \    let mut vowels_mid12 = vowels_iter.next();\n    let mut vowels_mid13 = vowels_iter.next();\n\
    \    let mut vowels_mid14 = vowels_iter.next();\n    let mut vowels_mid15 = vowels_iter.next();\n\
    \    let mut vowels_mid16 = vowels_iter.next();\n    let mut vowels_mid17 = vowels_iter.next();\n\
    \    let mut vowels_mid18 = vowels_iter.next();\n    let mut vowels_mid19 = vowels_iter.next();\n\
    \    let mut vowels_mid20 = vowels_iter.next();\n    let mut vowels_mid21 = vowels_iter.next();\n\
    \    let mut vowels_mid22 = vowels_iter.next();\n    let mut vowels_mid23 = vowels_iter.next();\n\
    \    let mut vowels_mid24 = vowels_iter.next();\n    let mut vowels_mid25 = vowels_iter.next();\n\
    \    let mut vowels_mid26 = vowels_iter.next();\n    let mut vowels_mid27 = vowels_iter.next();\n\
    \    let mut vowels_mid28 = vowels_iter.next();\n    let mut vowels_mid29 = vowels_iter.next();\n\
    \    let mut vowels_mid30 = vowels_iter.next();\n    let mut vowels_mid31 = vowels_iter.next();\n\
    \    let mut vowels_mid32 = vowels_iter.next();\n    let mut vowels_mid33 = vowels_iter.next();\n\
    \    let mut vowels_mid34 = vowels_iter.next();\n    let mut vowels_mid35 = vowels_iter.next();\n\
    \    let mut vowels_mid36 = vowels_iter.next();\n    let mut vowels_\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb7za378n.rs:48:20\n   |\n\
    48 |     let mut vowels_\n   |                    ^ help: add `;` here\n49 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpb7za378n.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_idx = word.len();\n    let mut vowels_idx_to_remove\
    \ = word.len();\n    let mut vowels_idx_to_add = word.len();\n    let mut vowels_idx_to_add2\
    \ = word.len();\n    let mut vowels_idx_to_add3 = word.len();\n    let mut vowels_idx_to_add4\
    \ = word.len();\n    let mut vowels_idx_to_add5 = word.len();\n    let mut vowels_idx_to_add6\
    \ = word.len();\n    let mut vowels_idx_to_add7 = word.len();\n    let mut vowels_idx_to_add8\
    \ = word.len();\n    let mut vowels_idx_to_add9 = word.len();\n    let mut vowels_idx_to_add10\
    \ = word.len();\n    let mut vowels_idx_to_add11 = word.len();\n    let mut vowels_idx_to_add12\
    \ = word.len();\n    let mut vowels_idx_to_add13 = word.len();\n    let mut vowels_idx_to_add14\
    \ = word.len();\n    let mut vowels_idx_to_add15 = word.len();\n    let mut vowels_idx_to_add16\
    \ = word.len();\n    let mut vowels_idx_to_add17 = word.len();\n    let mut vowels_idx_to_add18\
    \ = word.len();\n    let mut vowels_idx_to_add19 = word.len();\n    let mut vowels_idx_to_add20\
    \ = word.len();\n    let mut vowels_idx_to_add21 = word.len();\n    let mut vowels_idx_to_add22\
    \ = word.len();\n    let mut vowels_idx_to_add23 = word.len();\n    let mut vowels_idx_to_add24\
    \ = word.len();\n    let mut vowels_idx_to_add25 = word.len();\n    let mut vowels_idx_to_add26\
    \ = word.len();\n    let mut vowels_idx_to_add27 = word.len();\n    let mut vowels_idx_to_add28\
    \ = word.len();\n    let mut vowels_idx_to_add29 = word.len();\n    let mut vowels_idx_to_add30\
    \ = word.len();\n    let mut vowels_idx_to_add31 = word.len();\n    let mut vowels_idx_to_add32\
    \ = word.len();\n    let mut vowels_idx_to_add33 = word.len();\n    let mut vowels_idx_to_add34\
    \ = word.len();\n    let mut vowels_idx_to_\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpises146s.rs:45:27\n   |\n\
    45 |     let mut vowels_idx_to_\n   |                           ^ help: add `;`\
    \ here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpises146s.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) -> String\
    \ {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index2 = vec![0];\n    let mut vowels_count_index3 =\
    \ vec![0];\n    let mut vowels_count_index4 = vec![0];\n    let mut vowels_count_index5\
    \ = vec![0];\n    let mut vowels_count_index6 = vec![0];\n    let mut vowels_count_index7\
    \ = vec![0];\n    let mut vowels_count_index8 = vec![0];\n    let mut vowels_count_index9\
    \ = vec![0];\n    let mut vowels_count_index10 = vec![0];\n    let mut vowels_count_index11\
    \ = vec![0];\n    let mut vowels_count_index12 = vec![0];\n    let mut vowels_count_index13\
    \ = vec![0];\n    let mut vowels_count_index14 = vec![0];\n    let mut vowels_count_index15\
    \ = vec![0];\n    let mut vowels_count_index16 = vec![0];\n    let mut vowels_count_index17\
    \ = vec![0];\n    let mut vowels_count_index18 = vec![0];\n    let mut vowels_count_index19\
    \ = vec![0];\n    let mut vowels_count_index20 = vec![0];\n    let mut vowels_count_index21\
    \ = vec![0];\n    let mut vowels_count_index22 = vec![0];\n    let mut vowels_count_index23\
    \ = vec![0];\n    let mut vowels_count_index24 = vec![0];\n    let mut vowels_count_index25\
    \ = vec![0];\n    let mut vowels_count_index26 = vec![0];\n    let mut vowels_count_index27\
    \ = vec![0];\n    let mut vowels_count_index28 = vec![0];\n    let mut vowels_count_index29\
    \ = vec![0];\n    let mut vowels_count_index30 = vec![0];\n    let mut vowels_count_index31\
    \ = vec![0];\n    let mut vowels_count_index32 = vec![0];\n    let mut vowels_count_index33\
    \ = vec![0];\n    let mut vowels_count_index34 = vec![0];\n    let mut vowels_count_index35\
    \ = vec![0];\n    let mut vowels_count_index36 = vec![0];\n    let mut vowels_count_index37\
    \ = vec![0];\n    let mut vowels_count_index38 = vec![0];\n    let mut \n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpbm22x8e7.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index_max = vec![0];\n    let mut vowels_count_index_min\
    \ = vec![0];\n    let mut vowels_count_index_max_index = vec![0];\n    let mut\
    \ vowels_count_index_min_index = vec![0];\n    let mut vowels_count_index_max_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_index_max = vec![0];\n    let\
    \ mut vowels_count_index_min_index_min_index = vec![0];\n    let mut vowels_count_index_max_index_min_index\
    \ = vec![0];\n    let mut vowels_count_index_min_index_max_index_max = vec![0];\n\
    \    let mut vowels_count_index_min_index_min_index_max = vec![0];\n    let mut\
    \ vowels_count_index_max_index_min_index_min_index = vec![0];\n    let mut vowels_count_index_min_index_max_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_index_min_index_max_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_max_index_min_index_min_index_max_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_index_max_index_min_index_max_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_index_max_index_min_index_max_index_min_index_min_index_max_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_index_max_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_index_max_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_index_max_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_index_max_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_index_max_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_count_\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxn5vm2ri.rs:32:26\n   |\n\
    32 |     let mut vowels_count_\n   |                          ^ help: add `;`\
    \ here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpxn5vm2ri.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) -> String\
    \ {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_end = vec![0];\n    let mut vowels_count_start = vec![0];\n\
    \    let mut vowels_count_start_index = vec![0];\n    let mut vowels_count_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end = vec![0];\n    let mut vowels_count_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_index_end = vec![0];\n    let mut vowels_count_start_end_index_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index = vec![0];\n\
    \    let mut vowels_count_start_end_index_end_start_index_end = vec![0];\n   \
    \ let mut vowels_count_start_end_index_end_start_index_end_index = vec![0];\n\
    \    let mut vowels_count_start_end_index_end_start_index_end_index_start = vec![0];\n\
    \    let mut vowels_count_start_end_index_end_start_index_end_index_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end_index_start\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end_index_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end_index_start_index_end\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end_index_start_index_end_index_start\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end_index_start_index_end_index_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end_index_start_index_end_index_start_index_end\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end_index_start_index_end_index_start_index_end_index_start\
    \ = vec![0];\n    let mut vowels_count_start_end_index_end_start_index_end_index_start_index_end_index_start_index_end_index_start_index_end_index_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdxb78sz_.rs:35:36\n   |\n\
    35 |     let mut vowels_count_start_end_\n   |                               \
    \     ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpdxb78sz_.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String)\
    \ -> String {\n  |    -----------------                  ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n    let mut vowels_iter = vowels.iter();\n\
    \    let mut vowels_iter = vowels.iter();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppxdvyedb.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_set = HashSet::new();\n    vowels.iter().for_each(|vowel|\
    \ {\n        vowels_set.insert(vowel);\n    });\n    let mut vowels_count = vowels_set.len();\n\
    \    let mut vowels_index = vowels_set.len();\n    let mut vowels_index2 = vowels_set.len();\n\
    \    let mut vowels_index3 = vowels_set.len();\n    let mut vowels_index4 = vowels_set.len();\n\
    \    let mut vowels_index5 = vowels_set.len();\n    let mut vowels_index6 = vowels_set.len();\n\
    \    let mut vowels_index7 = vowels_set.len();\n    let mut vowels_index8 = vowels_set.len();\n\
    \    let mut vowels_index9 = vowels_set.len();\n    let mut vowels_index10 = vowels_set.len();\n\
    \    let mut vowels_index11 = vowels_set.len();\n    let mut vowels_index12 =\
    \ vowels_set.len();\n    let mut vowels_index13 = vowels_set.len();\n    let mut\
    \ vowels_index14 = vowels_set.len();\n    let mut vowels_index15 = vowels_set.len();\n\
    \    let mut vowels_index16 = vowels_set.len();\n    let mut vowels_index17 =\
    \ vowels_set.len();\n    let mut vowels_index18 = vowels_set.len();\n    let mut\
    \ vowels_index19 = vowels_set.len();\n    let mut vowels_index20 = vowels_set.len();\n\
    \    let mut vowels_index21 = vowels_set.len();\n    let mut vowels_index22 =\
    \ vowels_set.len();\n    let mut vowels_index23 = vowels_set.len();\n    let mut\
    \ vowels_index24 = vowels_set.len();\n    let mut vowels_index25 = vowels_set.len();\n\
    \    let mut vowels_index26 = vowels_set.len();\n    let mut vowels_index27 =\
    \ vowels_set.len();\n    let mut vowels_index28 = vowels_set.len();\n    let mut\
    \ vowels_index29 = vowels_set.len();\n    let mut vowels_index30 = vowels_set.len();\n\
    \    let mut vowels_index31 = vowels_set.len();\n    let mut vowels_index32 =\
    \ vowels_set.len();\n    let mut vowels_index33 = vowels_set.len();\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpf5on_non.rs:9:26\n  |\n9 |     let mut vowels_set = HashSet::new();\n\
    \  |                          ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpf5on_non.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_end = vec![0];\n    let mut vowels_count_start = vec![0];\n\
    \    let mut vowels_count_start_index = vec![0];\n    let mut vowels_count_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end = vec![0];\n    let mut vowels_count_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_end_index = vec![0];\n    let mut vowels_count_start_end_end_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index = vec![0];\n\
    \    let mut vowels_count_start_end_end_start_index_index_index = vec![0];\n \
    \   let mut vowels_count_start_end_end_start_index_index_index_index = vec![0];\n\
    \    let mut vowels_count_start_end_end_start_index_index_index_index_index =\
    \ vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = vec![0];\n    let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index_index_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw9663xq8.rs:35:106\n   |\n\
    35 |     let mut vowels_count_start_end_end_start_index_index_index_index_index_index_index_index_index_index_\n\
    \   |                                                                        \
    \                                  ^ help: add `;` here\n36 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpw9663xq8.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count = vec![0, 1, 2, 3, 4];\n\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmps4ljauhk.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmprntrtm33.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index2 = vec![0];\n    let mut vowels_count2 = vec![0];\n\
    \    let mut vowels_index3 = vec![0];\n    let mut vowels_count3 = vec![0];\n\
    \    let mut vowels_index4 = vec![0];\n    let mut vowels_count4 = vec![0];\n\
    \    let mut vowels_index5 = vec![0];\n    let mut vowels_count5 = vec![0];\n\
    \    let mut vowels_index6 = vec![0];\n    let mut vowels_count6 = vec![0];\n\
    \    let mut vowels_index7 = vec![0];\n    let mut vowels_count7 = vec![0];\n\
    \    let mut vowels_index8 = vec![0];\n    let mut vowels_count8 = vec![0];\n\
    \    let mut vowels_index9 = vec![0];\n    let mut vowels_count9 = vec![0];\n\
    \    let mut vowels_index10 = vec![0];\n    let mut vowels_count10 = vec![0];\n\
    \    let mut vowels_index11 = vec![0];\n    let mut vowels_count11 = vec![0];\n\
    \    let mut vowels_index12 = vec![0];\n    let mut vowels_count12 = vec![0];\n\
    \    let mut vowels_index13 = vec![0];\n    let mut vowels_count13 = vec![0];\n\
    \    let mut vowels_index14 = vec![0];\n    let mut vowels_count14 = vec![0];\n\
    \    let mut vowels_index15 = vec![0];\n    let mut vowels_count15 = vec![0];\n\
    \    let mut vowels_index16 = vec![0];\n    let mut vowels_count16 = vec![0];\n\
    \    let mut vowels_index17 = vec![0];\n    let mut vowels_count17 = vec![0];\n\
    \    let mut vowels_index18 = vec![0];\n    let mut vowels_count18 = vec![0];\n\
    \    let mut vowels_index19 = vec![0];\n    let mut vowels_count19 = vec![0];\n\
    \    let mut vowels_index20 = vec![0];\n    let mut vowels_count20 = vec![0];\n\
    \    let mut vowels_index21 = vec![0];\n    let mut vowels_count21 = vec![0];\n\
    \    let mut vowels_index22 = vec![0];\n    let mut vowels_count22 = vec![0];\n\
    \    let mut vowels_index23 = vec![0];\n    let \n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpv3a97jg1.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_idx: Vec<usize> = vec![0];\n    let mut vowels_len:\
    \ usize = 0;\n    for vowel in vowels.iter() {\n        if word.ends_with(vowel)\
    \ {\n            vowels_len += 1;\n            vowels_idx += 1;\n        }\n \
    \   }\n    if vowels_len == 0 {\n        return \"\";\n    }\n    let mut vowels_idx:\
    \ Vec<usize> = vec![0];\n    let mut vowels_len: usize = 0;\n    for vowel in\
    \ vowels.iter() {\n        if word.ends_with(vowel) {\n            vowels_len\
    \ += 1;\n            vowels_idx += 1;\n        }\n    }\n    if vowels_len ==\
    \ 0 {\n        return \"\";\n    }\n    let mut vowels_idx: Vec<usize> = vec![0];\n\
    \    let mut vowels_len: usize = 0;\n    for vowel in vowels.iter() {\n      \
    \  if word.ends_with(vowel) {\n            vowels_len += 1;\n            vowels_idx\
    \ += 1;\n        }\n    }\n    if vowels_len == 0 {\n        return \"\";\n  \
    \  }\n    let mut vowels_idx: Vec<usize> = vec![0];\n    let mut vowels_len: usize\
    \ = 0;\n    for vowel in vowels.iter() {\n        if word.ends_with(vowel) {\n\
    \            vowels_len += 1;\n            vowels_idx += 1;\n        }\n    }\n\
    \    if vowels_len == 0 {\n        return \"\";\n    }\n    let mut vowels_idx:\
    \ Vec<usize> = vec![0];\n    let mut vowels_len: usize = 0;\n    for vowel in\
    \ vowels.iter() {\n        if word.ends_with(vowel) {\n            vowels_len\
    \ += 1;\n            vowels_idx += 1;\n        }\n    }\n    if vowels_len ==\
    \ 0 {\n        return \"\";\n    }\n    let mut vowels_idx: Vec<usize> = vec![0];\n\
    \    let mut vowels_len: usize = 0;\n    for vowel in vowels.iter() {\n      \
    \  if word.ends_with(vowel) {\n            vowels_len += 1;\n            vowels_idx\
    \ += 1;\n        }\n    }\n    if vowels_len == 0 {\n        return \"\";\n  \
    \  }\n    let mut vowels_idx: Vec<usize> = vec![0];\n    let mut vowels_len: usize\
    \ = 0;\n    for vowel in vowels.iter() {\n        if word.ends_with(vowel) {\n\
    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnh_fdn9p.rs:97:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n77 |     for vowel\
    \ in vowels.iter() {\n   |                                - unclosed delimiter\n\
    78 |         if word.ends_with(vowel) {\n   |                                \
    \  - this delimiter might not be properly closed...\n79 | \n80 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n97 | }\n   |   ^\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<usize>`\n\
    \  --> /tmp/tmpnh_fdn9p.rs:14:13\n   |\n14 |             vowels_idx += 1;\n  \
    \ |             ----------^^^^^\n   |             |\n   |             cannot use\
    \ `+=` on type `Vec<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnh_fdn9p.rs:18:16\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    18 |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `Vec<usize>`\n  --> /tmp/tmpnh_fdn9p.rs:25:13\n  \
    \ |\n25 |             vowels_idx += 1;\n   |             ----------^^^^^\n   |\
    \             |\n   |             cannot use `+=` on type `Vec<usize>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<usize>`\n  -->\
    \ /tmp/tmpnh_fdn9p.rs:36:13\n   |\n36 |             vowels_idx += 1;\n   |   \
    \          ----------^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `Vec<usize>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `Vec<usize>`\n  --> /tmp/tmpnh_fdn9p.rs:47:13\n   |\n47 |\
    \             vowels_idx += 1;\n   |             ----------^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `Vec<usize>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied t"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowel_pos = word.rfind('a', word.len());\n    let mut\
    \ vowel_end = word.rfind('e', word.len());\n    let mut vowel_start = word.rfind('i',\
    \ word.len());\n    let mut vowel_middle = word.rfind('o', word.len());\n    let\
    \ mut vowel_first_half = word.rfind('u', word.len());\n    let mut vowel_second_half\
    \ = word.rfind('a', word.len());\n    \n    if vowel_pos == word.len() {\n   \
    \     return \"\";\n    }\n    \n    if vowel_end == word.len() {\n        vowel_end\
    \ = word.len();\n    }\n    \n    if vowel_start == word.len() {\n        vowel_start\
    \ = word.len();\n    }\n    \n    if vowel_middle == word.len() {\n        vowel_middle\
    \ = word.len();\n    }\n    \n    if vowel_first_half == word.len() {\n      \
    \  vowel_first_half = word.len();\n    }\n    \n    if vowel_second_half == word.len()\
    \ {\n        vowel_second_half = word.len();\n    }\n    \n    if vowel_pos >\
    \ vowel_end {\n        vowel_end = vowel_pos;\n    }\n    \n    if vowel_start\
    \ > vowel_end {\n        vowel_start = vowel_pos;\n    }\n    \n    if vowel_middle\
    \ > vowel_end {\n        vowel_middle = vowel_pos;\n    }\n    \n    if vowel_first_half\
    \ > vowel_end {\n        vowel_first_half = vowel_pos;\n    }\n    \n    if vowel_second_half\
    \ > vowel_end {\n        vowel_second_half = vowel_pos;\n    }\n    \n    if vowel_pos\
    \ < vowel_start {\n        vowel_start = vowel_pos;\n    }\n    \n    if vowel_end\
    \ < vowel_start {\n        vowel_end = vowel_pos;\n    }\n    \n    if vowel_start\
    \ < vowel_middle {\n        vowel_start = vowel_pos;\n    }\n    \n    if vowel_middle\
    \ < vowel_start {\n        vowel_middle = vowel_pos;\n    }\n    \n    if vowel_first_half\
    \ < vowel_middle {\n        vowel_first_half = vowel_pos;\n    }\n    \n    if\
    \ vowel_second_half < vowel_middle {\n        vowel_second_half = vowel_pos;\n\
    \    }\n    \n\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n   \
    \ assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"\
    most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n  \
    \  assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpdy10v8_z.rs:9:30\n     |\n9    |     let mut vowel_pos = word.rfind('a',\
    \ word.len());\n     |                              ^^^^^ ---  ---------- supplied\
    \ 2 arguments\n     |                              |\n     |                 \
    \             expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpdy10v8_z.rs:10:30\n     |\n10   |     let mut vowel_end = word.rfind('e',\
    \ word.len());\n     |                              ^^^^^ ---  ---------- supplied\
    \ 2 arguments\n     |                              |\n     |                 \
    \             expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpdy10v8_z.rs:11:32\n     |\n11   |     let mut vowel_start = word.rfind('i',\
    \ word.len());\n     |                                ^^^^^ ---  ---------- supplied\
    \ 2 arguments\n     |                                |\n     |               \
    \                 expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpdy10v8_z.rs:12:33\n     |\n12   |     let mut vowel_middle =\
    \ word.rfind('o', word.len());\n     |                                 ^^^^^ ---\
    \  ---------- supplied 2 arguments\n     |                                 |\n\
    \     |                                 expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 2\
    \ arguments were supplied\n    --> /tmp/tmpdy10v8_z.rs:13:37\n     |\n13   | \
    \    let mut vowel_first_half = word.rfind('u', word.len());\n     |         \
    \                            ^^^^^ ---  ---------- supplied 2 arguments\n    \
    \ |                                     |\n     |                            \
    \         expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0061]: this fu"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\".to_string();\n    let mut\
    \ vowel_iter = word.chars().enumerate().rev();\n    let mut vowel_iter = vowel_iter.filter(|&(_,\
    \ c)| vowels.contains(&c.to_string()));\n    let mut vowel_iter = vowel_iter.filter(|&(_,\
    \ c)| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n    let mut\
    \ vowel_iter = vowel_iter.filter(|&(_, c)| c != 'A' && c != 'E' && c != 'I' &&\
    \ c != 'O' && c != 'U');\n    let mut vowel_iter = vowel_iter.filter(|&(_, c)|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n    let mut vowel_iter\
    \ = vowel_iter.filter(|&(_, c)| c != 'A' && c != 'E' && c != 'I' && c != 'O' &&\
    \ c != 'U');\n    let mut vowel_iter = vowel_iter.filter(|&(_, c)| c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u');\n    let mut vowel_iter = vowel_iter.filter(|&(_,\
    \ c)| c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U');\n    let mut\
    \ vowel_iter = vowel_iter.filter(|&(_, c)| c != 'a' && c != 'e' && c != 'i' &&\
    \ c != 'o' && c != 'u');\n    let mut vowel_iter = vowel_iter.filter(|&(_, c)|\
    \ c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U');\n    let mut vowel_iter\
    \ = vowel_iter.filter(|&(_, c)| c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u');\n    let mut vowel_iter = vowel_iter.filter(|&(_, c)| c != 'A' &&\
    \ c != 'E' && c != 'I' && c != 'O' && c != 'U');\n    let mut vowel_iter = vowel_iter.filter(|&(_,\
    \ c)| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n    let mut\
    \ vowel_iter = vowel_iter.filter(|&(_, c)| c != 'A' && c != 'E' && c != 'I' &&\
    \ c != 'O' && c != 'U');\n    let mut vowel_iter = vowel_iter.filter(|&(_, c)|\
    \ c != '\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp6fk_0nku.rs:23:59\n\
    \   |\n23 |     let mut vowel_iter = vowel_iter.filter(|&(_, c)| c != '\n   |\
    \                                                           ^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp91fpm9_h.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp91fpm9_h.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut vowel_pos\
    \ = word.rfind('a');\n    let mut vowel_pos_2 = word.rfind('e');\n    let mut\
    \ vowel_pos_3 = word.rfind('i');\n    let mut vowel_pos_4 = word.rfind('o');\n\
    \    let mut vowel_pos_5 = word.rfind('u');\n    if vowel_pos == word.len() -\
    \ 1 {\n        return \"\".to_string();\n    }\n    if vowel_pos_2 == word.len()\
    \ - 1 {\n        return \"\".to_string();\n    }\n    if vowel_pos_3 == word.len()\
    \ - 1 {\n        return \"\".to_string();\n    }\n    if vowel_pos_4 == word.len()\
    \ - 1 {\n        return \"\".to_string();\n    }\n    if vowel_pos_5 == word.len()\
    \ - 1 {\n        return \"\".to_string();\n    }\n    if vowel_pos == 0 {\n  \
    \      return \"\".to_string();\n    }\n    if vowel_pos_2 == 0 {\n        return\
    \ \"\".to_string();\n    }\n    if vowel_pos_3 == 0 {\n        return \"\".to_string();\n\
    \    }\n    if vowel_pos_4 == 0 {\n        return \"\".to_string();\n    }\n \
    \   if vowel_pos_5 == 0 {\n        return \"\".to_string();\n    }\n    if vowel_pos\
    \ < vowel_pos_2 {\n        return \"\".to_string();\n    }\n    if vowel_pos_2\
    \ < vowel_pos_3 {\n        return \"\".to_string();\n    }\n    if vowel_pos_3\
    \ < vowel_pos_4 {\n        return \"\".to_string();\n    }\n    if vowel_pos_4\
    \ < vowel_pos_5 {\n        return \"\".to_string();\n    }\n    if vowel_pos_5\
    \ < vowel_pos {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_2 {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_3 {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_4 {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_5 {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_2 {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_3 {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_4 {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_5 {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_2 {\n        return \"\".to_string();\n    }\n    if vowel_pos ==\
    \ vowel_pos_3 {\n        return \"\"\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9j0ypitm.rs:105:3\n\
    \    |\n7   | fn get_closest_vowel(word: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n86  |     if vowel_pos\
    \ == vowel_pos_3 {\n    |                                 - this delimiter might\
    \ not be properly closed...\n87  |         return \"\"\n88  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n105 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9j0ypitm.rs:14:21\n   |\n14 |  \
    \   if vowel_pos == word.len() - 1 {\n   |                     ^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n14 |     if vowel_pos == Some(word.len() - 1) {\n   |                 \
    \    +++++              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9j0ypitm.rs:17:23\n\
    \   |\n17 |     if vowel_pos_2 == word.len() - 1 {\n   |                     \
    \  ^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found type `usize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n17 |     if vowel_pos_2 == Some(word.len() - 1)\
    \ {\n   |                       +++++              +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9j0ypitm.rs:20:23\n   |\n20 |     if vowel_pos_3 == word.len()\
    \ - 1 {\n   |                       ^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ `usize`\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n20 |     if\
    \ vowel_pos_3 == Some(word.len() - 1) {\n   |                       +++++    \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9j0ypitm.rs:23:23\n\
    \   |\n23 |     if vowel_pos_4 == word.len() - 1 {\n   |                     \
    \  ^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found type `usize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n23 |     if vowel_"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let vowels_count\
    \ = vowels.len();\n    let vowels_count = vowels_count.cmp(&word[word.len() -\
    \ 1]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n    let\
    \ vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \    let vowels_count = vowels_count + 1;\n    let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();\n    let vowels_count = vowels_count % vowels_count;\n\
    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplrdv80ar.rs:10:42\n\
    \   |\n10 |     let vowels_count = vowels_count.cmp(&word[word.len() - 1]).unwrap();\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmplrdv80ar.rs:10:64\n   |\n10 |     let vowels_count\
    \ = vowels_count.cmp(&word[word.len() - 1]).unwrap();\n   |                  \
    \                                              ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplrdv80ar.rs:13:42\n\
    \   |\n13 |     let vowels_count = vowels_count.cmp(&word[word.len() - vowels_count]).unwrap();\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplrdv80ar.rs:16:42\n   |\n16 |     let vowels_count = vowels_count.cmp(&word[word.len()\
    \ - vowels_count]).unwrap();"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count_max\
    \ = vec![0];\n    let mut vowels_index_count_min = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index_max = vec![0];\n    let mut vowels_index_count_min_index_max\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min = vec![0];\n    let\
    \ mut vowels_index_count_min_index_min = vec![0];\n    let mut vowels_index_count_max_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index = vec![0];\n\
    \    let mut vowels_index_count_max_index_min_index_max = vec![0];\n    let mut\
    \ vowels_index_count_min_index_min_index_max = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index = vec![0];\n\
    \    let mut vowels_index_count_max_index_min_index_min_index_max = vec![0];\n\
    \    let mut vowels_index_count_min_index_min_index_min_index_max = vec![0];\n\
    \    let mut vowels_index_count_max_index_min_index_min_index_min_index = vec![0];\n\
    \    let mut vowels_index_count_min_index_min_index_min_index_min_index = vec![0];\n\
    \    let mut vowels_index_count_max_index_min_index_min_index_min_index_max =\
    \ vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index_min_index_min_index_max\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index_min_index_min_index_min_index_min_index_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index_min_index_min_index_min_index_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpamy7_8xa.rs:38:72\n   |\n\
    38 |     let mut vowels_index_count_max_index_min_index_min_index_min_index_\n\
    \   |                                                                        ^\
    \ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpamy7_8xa.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String)\
    \ -> String {\n  |    -----------------                  ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_max = vec![0];\n\
    \    let mut vowels_count_min = vec![0];\n    let mut vowels_count_max_index =\
    \ vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_count\
    \ = vec![0];\n    let mut vowels_count_min_count = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_count\
    \ = vec![0];\n    let mut vowels_count_min_count = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_count\
    \ = vec![0];\n    let mut vowels_count_min_count = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_count\
    \ = vec![0];\n    let mut vowels_count_min_count = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_count\
    \ = vec![0];\n    let mut vowels_count_min_count = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_count\
    \ = vec![0];\n    let mut vowels_count_min_count = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_count\
    \ = vec![0];\n    let mut vowels_count_min_count = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_count\
    \ = vec![0];\n    let mut vowels_count_min_count = vec![0];\n    let mut vowels_count_max_index\
    \ = vec![0];\n    let mut vowels_count_min_index = vec![0];\n    let mut vowels_count_max_count\
    \ = vec![0];\n    let mut vowels_count_min_count = vec![0];\n    let mut vowels_count_max_index\
    \ = vec\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbmq4li2c.rs:50:41\n   |\n\
    50 |     let mut vowels_count_max_index = vec\n   |                          \
    \               ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0423]:\
    \ expected value, found macro `vec`\n  --> /tmp/tmpbmq4li2c.rs:50:38\n   |\n50\
    \ |     let mut vowels_count_max_index = vec\n   |                           \
    \           ^^^ not a value\n\nerror[E0308]: mismatched types\n --> /tmp/tmpbmq4li2c.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = 0;\n\
    \    let mut vowels_count_max = 0;\n    let mut vowels_count_min = 0;\n    let\
    \ mut vowels_count_min_index = 0;\n    let mut vowels_count_max_index = 0;\n \
    \   let mut vowels_count_min_max = 0;\n    let mut vowels_count_min_max_index\
    \ = 0;\n    let mut vowels_count_min_max_index = 0;\n    let mut vowels_count_min_max_index2\
    \ = 0;\n    let mut vowels_count_min_max_index2 = 0;\n    let mut vowels_count_min_max_index3\
    \ = 0;\n    let mut vowels_count_min_max_index4 = 0;\n    let mut vowels_count_min_max_index5\
    \ = 0;\n    let mut vowels_count_min_max_index6 = 0;\n    let mut vowels_count_min_max_index7\
    \ = 0;\n    let mut vowels_count_min_max_index8 = 0;\n    let mut vowels_count_min_max_index9\
    \ = 0;\n    let mut vowels_count_min_max_index10 = 0;\n    let mut vowels_count_min_max_index11\
    \ = 0;\n    let mut vowels_count_min_max_index12 = 0;\n    let mut vowels_count_min_max_index13\
    \ = 0;\n    let mut vowels_count_min_max_index14 = 0;\n    let mut vowels_count_min_max_index15\
    \ = 0;\n    let mut vowels_count_min_max_index16 = 0;\n    let mut vowels_count_min_max_index17\
    \ = 0;\n    let mut vowels_count_min_max_index18 = 0;\n    let mut vowels_count_min_max_index19\
    \ = 0;\n    let mut vowels_count_min_max_index20 = 0;\n    let mut vowels_count_min_max_index21\
    \ = 0;\n    let mut vowels_count_min_max_index22 = 0;\n    let mut vowels_count_min_max_index23\
    \ = 0;\n    let mut vowels_count_min_max_index24 = 0;\n    let mut vowels_count_min_max_index25\
    \ = 0;\n    let mut vowels_count_min_max_index26 = 0;\n    let mut vowels_count_min_max_index27\
    \ = 0;\n    let mut vowels_count_min_max_index28 = 0;\n    let mut vowels_count_min_max_index29\
    \ = 0;\n    let mut vowels_count_min_max_index30 = 0;\n    let mut vowels_count_min_max_index31\
    \ = 0;\n    let mut vowels_count_min_max_index32 = 0;\n    let mut vowels_count_min_max_index33\
    \ = 0;\n    let mut vowels_count_min_max_index34 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5mdhvk9r.rs:52:11\n   |\n\
    52 |     let mu\n   |           ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5mdhvk9r.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmprntrtm33.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_end = vec![0];\n    let mut vowels_count_start = vec![0];\n\
    \    let mut vowels_count_start_index = vec![0];\n    let mut vowels_count_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end = vec![0];\n    let mut vowels_count_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_index = vec![0];\n    let mut\
    \ vowels_count_start_end_start = vec![0];\n    let mut vowels_count_start_end_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end = vec![0];\n    let\
    \ mut vowels_count_start_end_start_end_index = vec![0];\n    let mut vowels_count_start_end_start_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_index = vec![0];\n\
    \    let mut vowels_count_start_end_start_end_start_end = vec![0];\n    let mut\
    \ vowels_count_start_end_start_end_start_end_index = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_start_end\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_start_end_start\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_start_end_start_index\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_start_end_start_end\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_start_end_start_end_index\
    \ = vec![0];\n    let mut vowels_count_start_end_start_end_start_end_start_end_start_end_start_end_start\
    \ = vec![0];\n    let mut vowels_count_start_\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl8jg96_q.rs:39:32\n   |\n\
    39 |     let mut vowels_count_start_\n   |                                ^ help:\
    \ add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpl8jg96_q.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) ->\
    \ String {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_iter = vowels.iter();\n    let mut vowels_end\
    \ = vowels_iter.next();\n    let mut vowels_start = vowels_iter.next();\n    let\
    \ mut vowels_mid = vowels_iter.next();\n    let mut vowels_mid_next = vowels_iter.next();\n\
    \    let mut vowels_mid_next_next = vowels_iter.next();\n    let mut vowels_mid_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next = vowels_iter.next();\n\
    \    let mut vowels_mid_next_next_next_next_next = vowels_iter.next();\n    let\
    \ mut vowels_mid_next_next_next_next_next_next = vowels_iter.next();\n    let\
    \ mut vowels_mid_next_next_next_next_next_next_next = vowels_iter.next();\n  \
    \  let mut vowels_mid_next_next_next_next_next_next_next_next = vowels_iter.next();\n\
    \    let mut vowels_mid_next_next_next_next_next_next_next_next_next = vowels_iter.next();\n\
    \    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next = vowels_iter.next();\n\
    \    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = vowels_iter.next();\n    let mut vowels_mid_next_next_\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnl_omg80.rs:34:34\n   |\n\
    34 |     let mut vowels_mid_next_next_\n   |                                 \
    \ ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpnl_omg80.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String)\
    \ -> String {\n  |    -----------------                  ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mu\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn0_7_anq.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpn0_7_anq.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n  \
    \  vowels.iter().for_each(|vowel| {\n        vowels_set.insert(vowel);\n    });\n\
    \    let mut vowels_set: HashSet<&str> = HashSet::new();\n    word.chars().for_each(|c|\
    \ {\n        if vowels_set.contains(&c.to_string()) {\n            vowels_set.insert(c.to_string());\n\
    \        }\n    });\n    vowels_set.iter().for_each(|vowel| {\n        if word.chars().any(|c|\
    \ {\n            vowel == c.to_string()\n        }) {\n            return vowel.to_string();\n\
    \        }\n    });\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp0km4yiwf.rs:9:25\n\
    \  |\n9 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n  |       \
    \                  ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmp0km4yiwf.rs:9:41\n\
    \  |\n9 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n  |       \
    \                                  ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp0km4yiwf.rs:13:25\n\
    \   |\n13 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp0km4yiwf.rs:13:41\n\
    \   |\n13 |     let mut vowels_set: HashSet<&str> = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowel_pos: usize = 0;\n    let mut vowel_end: usize\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_found2 = false;\n\
    \    let mut vowel_found3 = false;\n    let mut vowel_found4 = false;\n    let\
    \ mut vowel_found5 = false;\n    let mut vowel_found6 = false;\n    let mut vowel_found7\
    \ = false;\n    let mut vowel_found8 = false;\n    let mut vowel_found9 = false;\n\
    \    let mut vowel_found10 = false;\n    let mut vowel_found11 = false;\n    let\
    \ mut vowel_found12 = false;\n    let mut vowel_found13 = false;\n    let mut\
    \ vowel_found14 = false;\n    let mut vowel_found15 = false;\n    let mut vowel_found16\
    \ = false;\n    let mut vowel_found17 = false;\n    let mut vowel_found18 = false;\n\
    \    let mut vowel_found19 = false;\n    let mut vowel_found20 = false;\n    let\
    \ mut vowel_found21 = false;\n    let mut vowel_found22 = false;\n    let mut\
    \ vowel_found23 = false;\n    let mut vowel_found24 = false;\n    let mut vowel_found25\
    \ = false;\n    let mut vowel_found26 = false;\n    let mut vowel_found27 = false;\n\
    \    let mut vowel_found28 = false;\n    let mut vowel_found29 = false;\n    let\
    \ mut vowel_found30 = false;\n    let mut vowel_found31 = false;\n    let mut\
    \ vowel_found32 = false;\n    let mut vowel_found33 = false;\n    let mut vowel_found34\
    \ = false;\n    let mut vowel_found35 = false;\n    let mut vowel_found36 = false;\n\
    \    let mut vowel_found37 = false;\n    let mut vowel_found38 = false;\n    let\
    \ mut vowel_found39 = false;\n    let mut vowel_found40 = false;\n    let mut\
    \ vowel_found41 = false;\n    let mut vowel_found42 = false;\n    let mut vowel_found43\
    \ = false;\n    let mut vowel_found44 = false;\n    let mut vowel_found45 = false;\n\
    \    let mut vowel_found46 = false;\n    let mut vowel_found47 = false;\n    let\
    \ mut vowel_found48 = false;\n    let mut vowel_found49 = false;\n    let mut\
    \ vowel_found50 = false;\n    let mut vowel_found51 = false;\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp506f5uxs.rs:62:18\n   |\n\
    62 |     let mut vowel\n   |                  ^ help: add `;` here\n63 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp506f5uxs.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index_count_max\
    \ = vec![0];\n    let mut vowels_index_count_min = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec![0];\n    let mut vowels_index_count_max_index = vec![0];\n    let mut\
    \ vowels_index_count_min_index = vec![0];\n    let mut vowels_index_count_max_index\
    \ = vec![0];\n    let mut vowels_index_count_min_index = vec![0];\n    let mut\
    \ vowels_index_count_max_index = vec![0];\n    let mut vowels_index_count_min_index\
    \ = vec\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7y5opkg6.rs:47:47\n   |\n\
    47 |     let mut vowels_index_count_min_index = vec\n   |                    \
    \                           ^ help: add `;` here\n48 | }\n   | - unexpected token\n\
    \nerror[E0423]: expected value, found macro `vec`\n  --> /tmp/tmp7y5opkg6.rs:47:44\n\
    \   |\n47 |     let mut vowels_index_count_min_index = vec\n   |             \
    \                               ^^^ not a value\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp7y5opkg6.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) ->\
    \ String {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0423.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpm3o866ds.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_idx: Vec<usize> = vec![0];\n    let mut vowels_len:\
    \ usize = 0;\n    let mut idx: usize = 0;\n    let mut len: usize = 0;\n    let\
    \ mut vowel: &str;\n    let mut vowel_found = false;\n    let mut vowel_found2\
    \ = false;\n    let mut vowel_found3 = false;\n    let mut vowel_found4 = false;\n\
    \    let mut vowel_found5 = false;\n    let mut vowel_found6 = false;\n    let\
    \ mut vowel_found7 = false;\n    let mut vowel_found8 = false;\n    let mut vowel_found9\
    \ = false;\n    let mut vowel_found10 = false;\n    let mut vowel_found11 = false;\n\
    \    let mut vowel_found12 = false;\n    let mut vowel_found13 = false;\n    let\
    \ mut vowel_found14 = false;\n    let mut vowel_found15 = false;\n    let mut\
    \ vowel_found16 = false;\n    let mut vowel_found17 = false;\n    let mut vowel_found18\
    \ = false;\n    let mut vowel_found19 = false;\n    let mut vowel_found20 = false;\n\
    \    let mut vowel_found21 = false;\n    let mut vowel_found22 = false;\n    let\
    \ mut vowel_found23 = false;\n    let mut vowel_found24 = false;\n    let mut\
    \ vowel_found25 = false;\n    let mut vowel_found26 = false;\n    let mut vowel_found27\
    \ = false;\n    let mut vowel_found28 = false;\n    let mut vowel_found29 = false;\n\
    \    let mut vowel_found30 = false;\n    let mut vowel_found31 = false;\n    let\
    \ mut vowel_found32 = false;\n    let mut vowel_found33 = false;\n    let mut\
    \ vowel_found34 = false;\n    let mut vowel_found35 = false;\n    let mut vowel_found36\
    \ = false;\n    let mut vowel_found37 = false;\n    let mut vowel_found38 = false;\n\
    \    let mut vowel_found39 = false;\n    let mut vowel_found40 = false;\n    let\
    \ mut vowel_found41 = false;\n    let mut vowel_found42 = false;\n    let mut\
    \ vowel_found43 = false;\n    let mut vowel_found44 = false;\n    let mut vowel_found45\
    \ = false;\n    let mut vowel_found46 = false;\n    let mut vowel_found47 = false;\n\
    \    let mut vowel_found\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqodwvdb0.rs:61:24\n   |\n\
    61 |     let mut vowel_found\n   |                        ^ help: add `;` here\n\
    62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpqodwvdb0.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index_max = vec![0];\n    let mut vowels_count_index_min\
    \ = vec![0];\n    let mut vowels_count_index_min_max = vec![0];\n    let mut vowels_count_index_min_max_count\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_max = vec![0];\n  \
    \  let mut vowels_count_index_min_max_count_min = vec![0];\n    let mut vowels_count_index_min_max_count_min_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count = vec![0];\n\
    \    let mut vowels_count_index_min_max_count_min_max_count_max = vec![0];\n \
    \   let mut vowels_count_index_min_max_count_min_max_count_min = vec![0];\n  \
    \  let mut vowels_count_index_min_max_count_min_max_count_min_max = vec![0];\n\
    \    let mut vowels_count_index_min_max_count_min_max_count_min_max_count = vec![0];\n\
    \    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count_min_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max\
    \ = vec!\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmpzx91pt5o.rs:34:1\n\
    \   |\n33 |     let mut vowels_count_index_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max_count_min_max\
    \ = vec!\n   |                                                               \
    \                                                                   - expected\
    \ one of `(`, `[`, or `{`\n34 | }\n   | ^ unexpected token\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index2 = vec![0];\n    let mut vowels_index3 = vec![0];\n\
    \    let mut vowels_index4 = vec![0];\n    let mut vowels_index5 = vec![0];\n\
    \    let mut vowels_index6 = vec![0];\n    let mut vowels_index7 = vec![0];\n\
    \    let mut vowels_index8 = vec![0];\n    let mut vowels_index9 = vec![0];\n\
    \    let mut vowels_index10 = vec![0];\n    let mut vowels_index11 = vec![0];\n\
    \    let mut vowels_index12 = vec![0];\n    let mut vowels_index13 = vec![0];\n\
    \    let mut vowels_index14 = vec![0];\n    let mut vowels_index15 = vec![0];\n\
    \    let mut vowels_index16 = vec![0];\n    let mut vowels_index17 = vec![0];\n\
    \    let mut vowels_index18 = vec![0];\n    let mut vowels_index19 = vec![0];\n\
    \    let mut vowels_index20 = vec![0];\n    let mut vowels_index21 = vec![0];\n\
    \    let mut vowels_index22 = vec![0];\n    let mut vowels_index23 = vec![0];\n\
    \    let mut vowels_index24 = vec![0];\n    let mut vowels_index25 = vec![0];\n\
    \    let mut vowels_index26 = vec![0];\n    let mut vowels_index27 = vec![0];\n\
    \    let mut vowels_index28 = vec![0];\n    let mut vowels_index29 = vec![0];\n\
    \    let mut vowels_index30 = vec![0];\n    let mut vowels_index31 = vec![0];\n\
    \    let mut vowels_index32 = vec![0];\n    let mut vowels_index33 = vec![0];\n\
    \    let mut vowels_index34 = vec![0];\n    let mut vowels_index35 = vec![0];\n\
    \    let mut vowels_index36 = vec![0];\n    let mut vowels_index37 = vec![0];\n\
    \    let mut vowels_index38 = vec![0];\n    let mut vowels_index39 = vec![0];\n\
    \    let mut vowels_index40 = vec![0];\n    let mut vowels_index41 = vec![0];\n\
    \    let mut vowels_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps80nlfnp.rs:51:20\n   |\n\
    51 |     let mut vowels_\n   |                    ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmps80nlfnp.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec!\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmpgg62jy70.rs:58:1\n\
    \   |\n57 |     let mut vowels_index = vec!\n   |                            \
    \    - expected one of `(`, `[`, or `{`\n58 | }\n   | ^ unexpected token\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_count_\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwapz2pxz.rs:44:26\n   |\n\
    44 |     let mut vowels_count_\n   |                          ^ help: add `;`\
    \ here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpwapz2pxz.rs:7:39\n  |\n7 | fn get_closest_vowel(word: String) -> String\
    \ {\n  |    -----------------                  ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_count = vowels.len();\n    let mut vowels_index\
    \ = 0;\n    let mut vowels_index_count = 0;\n    let mut vowels_index_count_2\
    \ = 0;\n    let mut vowels_index_count_3 = 0;\n    let mut vowels_index_count_4\
    \ = 0;\n    let mut vowels_index_count_5 = 0;\n    let mut vowels_index_count_6\
    \ = 0;\n    let mut vowels_index_count_7 = 0;\n    let mut vowels_index_count_8\
    \ = 0;\n    let mut vowels_index_count_9 = 0;\n    let mut vowels_index_count_10\
    \ = 0;\n    let mut vowels_index_count_11 = 0;\n    let mut vowels_index_count_12\
    \ = 0;\n    let mut vowels_index_count_13 = 0;\n    let mut vowels_index_count_14\
    \ = 0;\n    let mut vowels_index_count_15 = 0;\n    let mut vowels_index_count_16\
    \ = 0;\n    let mut vowels_index_count_17 = 0;\n    let mut vowels_index_count_18\
    \ = 0;\n    let mut vowels_index_count_19 = 0;\n    let mut vowels_index_count_20\
    \ = 0;\n    let mut vowels_index_count_21 = 0;\n    let mut vowels_index_count_22\
    \ = 0;\n    let mut vowels_index_count_23 = 0;\n    let mut vowels_index_count_24\
    \ = 0;\n    let mut vowels_index_count_25 = 0;\n    let mut vowels_index_count_26\
    \ = 0;\n    let mut vowels_index_count_27 = 0;\n    let mut vowels_index_count_28\
    \ = 0;\n    let mut vowels_index_count_29 = 0;\n    let mut vowels_index_count_30\
    \ = 0;\n    let mut vowels_index_count_31 = 0;\n    let mut vowels_index_count_32\
    \ = 0;\n    let mut vowels_index_count_33 = 0;\n    let mut vowels_index_count_34\
    \ = 0;\n    let mut vowels_index_count_35 = 0;\n    let mut vowels_index_count_36\
    \ = 0;\n    let mut vowels_index_count_37 = 0;\n    let mut vowels_index_count_38\
    \ = 0;\n    let mut vowels_index_count_39 = 0;\n    let mut vowels_index_count_40\
    \ = 0;\n    let mut vowels_index_count_41 = 0;\n    let mut vowels_index_count_42\
    \ = 0;\n    let mut vowels_index_count_43 = 0;\n    let mut vowels_index_count_44\
    \ = 0;\n    let mut vowels_index_count_45 = 0;\n    let mut vowels_index_count_46\
    \ = 0;\n    let mut vowels_index_count_47 = 0;\n    let mut vowels_\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx3zva0er.rs:58:20\n   |\n\
    58 |     let mut vowels_\n   |                    ^ help: add `;` here\n59 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpx3zva0er.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp91fpm9_h.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp91fpm9_h.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index2 = vec![0];\n    let mut vowels_index3 = vec![0];\n\
    \    let mut vowels_index4 = vec![0];\n    let mut vowels_index5 = vec![0];\n\
    \    let mut vowels_index6 = vec![0];\n    let mut vowels_index7 = vec![0];\n\
    \    let mut vowels_index8 = vec![0];\n    let mut vowels_index9 = vec![0];\n\
    \    let mut vowels_index10 = vec![0];\n    let mut vowels_index11 = vec![0];\n\
    \    let mut vowels_index12 = vec![0];\n    let mut vowels_index13 = vec![0];\n\
    \    let mut vowels_index14 = vec![0];\n    let mut vowels_index15 = vec![0];\n\
    \    let mut vowels_index16 = vec![0];\n    let mut vowels_index17 = vec![0];\n\
    \    let mut vowels_index18 = vec![0];\n    let mut vowels_index19 = vec![0];\n\
    \    let mut vowels_index20 = vec![0];\n    let mut vowels_index21 = vec![0];\n\
    \    let mut vowels_index22 = vec![0];\n    let mut vowels_index23 = vec![0];\n\
    \    let mut vowels_index24 = vec![0];\n    let mut vowels_index25 = vec![0];\n\
    \    let mut vowels_index26 = vec![0];\n    let mut vowels_index27 = vec![0];\n\
    \    let mut vowels_index28 = vec![0];\n    let mut vowels_index29 = vec![0];\n\
    \    let mut vowels_index30 = vec![0];\n    let mut vowels_index31 = vec![0];\n\
    \    let mut vowels_index32 = vec![0];\n    let mut vowels_index33 = vec![0];\n\
    \    let mut vowels_index34 = vec![0];\n    let mut vowels_index35 = vec![0];\n\
    \    let mut vowels_index36 = vec![0];\n    let mut vowels_index37 = vec![0];\n\
    \    let mut vowels_index38 = vec![0];\n    let mut vowels_index39 = vec![0];\n\
    \    let mut vowels_index40 = vec![0];\n    let mut vowels_index41 = vec![0];\n\
    \    let mut vowels_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps80nlfnp.rs:51:20\n   |\n\
    51 |     let mut vowels_\n   |                    ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmps80nlfnp.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index_count = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfhwxmta5.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index_end = vec![0];\n    let mut vowels_count_index_start\
    \ = vec![0];\n    let mut vowels_count_index_start_end = vec![0];\n    let mut\
    \ vowels_count_index_start_end_end = vec![0];\n    let mut vowels_count_index_start_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end = vec![0];\n\
    \    let mut vowels_count_index_start_end_end_end_end_end = vec![0];\n    let\
    \ mut vowels_count_index_start_end_end_end_end_end_end = vec![0];\n    let mut\
    \ vowels_count_index_start_end_end_end_end_end_end_end = vec![0];\n    let mut\
    \ vowels_count_index_start_end_end_end_end_end_end_end_end = vec![0];\n    let\
    \ mut vowels_count_index_start_end_end_end_end_end_end_end_end_end = vec![0];\n\
    \    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = vec![0];\n    let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpavrx0qou.rs:33:94\n   |\n\
    33 |     let mut vowels_count_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_\n\
    \   |                                                                        \
    \                      ^ help: add `;` here\n34 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpavrx0qou.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index2 = vec![0];\n    let mut vowels_count_index3 =\
    \ vec![0];\n    let mut vowels_count_index4 = vec![0];\n    let mut vowels_count_index5\
    \ = vec![0];\n    let mut vowels_count_index6 = vec![0];\n    let mut vowels_count_index7\
    \ = vec![0];\n    let mut vowels_count_index8 = vec![0];\n    let mut vowels_count_index9\
    \ = vec![0];\n    let mut vowels_count_index10 = vec![0];\n    let mut vowels_count_index11\
    \ = vec![0];\n    let mut vowels_count_index12 = vec![0];\n    let mut vowels_count_index13\
    \ = vec![0];\n    let mut vowels_count_index14 = vec![0];\n    let mut vowels_count_index15\
    \ = vec![0];\n    let mut vowels_count_index16 = vec![0];\n    let mut vowels_count_index17\
    \ = vec![0];\n    let mut vowels_count_index18 = vec![0];\n    let mut vowels_count_index19\
    \ = vec![0];\n    let mut vowels_count_index20 = vec![0];\n    let mut vowels_count_index21\
    \ = vec![0];\n    let mut vowels_count_index22 = vec![0];\n    let mut vowels_count_index23\
    \ = vec![0];\n    let mut vowels_count_index24 = vec![0];\n    let mut vowels_count_index25\
    \ = vec![0];\n    let mut vowels_count_index26 = vec![0];\n    let mut vowels_count_index27\
    \ = vec![0];\n    let mut vowels_count_index28 = vec![0];\n    let mut vowels_count_index29\
    \ = vec![0];\n    let mut vowels_count_index30 = vec![0];\n    let mut vowels_count_index31\
    \ = vec![0];\n    let mut vowels_count_index32 = vec![0];\n    let mut vowels_count_index33\
    \ = vec![0];\n    let mut vowels_count_index34 = vec![0];\n    let mut vowels_count_index35\
    \ = vec![0];\n    let mut vowels_count_index36 = vec![0];\n    let mut vowels_count_index37\
    \ = vec![0];\n    let mut vowels_count_index38 = vec![0];\n    let mut \n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpbm22x8e7.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmparbecfcx.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_count = vowels.len();\n    let mut vowel_index\
    \ = 0;\n    let mut vowel_found = false;\n    let mut vowel_found2 = false;\n\
    \    let mut vowel_found3 = false;\n    let mut vowel_found4 = false;\n    let\
    \ mut vowel_found5 = false;\n    let mut vowel_found6 = false;\n    let mut vowel_found7\
    \ = false;\n    let mut vowel_found8 = false;\n    let mut vowel_found9 = false;\n\
    \    let mut vowel_found10 = false;\n    let mut vowel_found11 = false;\n    let\
    \ mut vowel_found12 = false;\n    let mut vowel_found13 = false;\n    let mut\
    \ vowel_found14 = false;\n    let mut vowel_found15 = false;\n    let mut vowel_found16\
    \ = false;\n    let mut vowel_found17 = false;\n    let mut vowel_found18 = false;\n\
    \    let mut vowel_found19 = false;\n    let mut vowel_found20 = false;\n    let\
    \ mut vowel_found21 = false;\n    let mut vowel_found22 = false;\n    let mut\
    \ vowel_found23 = false;\n    let mut vowel_found24 = false;\n    let mut vowel_found25\
    \ = false;\n    let mut vowel_found26 = false;\n    let mut vowel_found27 = false;\n\
    \    let mut vowel_found28 = false;\n    let mut vowel_found29 = false;\n    let\
    \ mut vowel_found30 = false;\n    let mut vowel_found31 = false;\n    let mut\
    \ vowel_found32 = false;\n    let mut vowel_found33 = false;\n    let mut vowel_found34\
    \ = false;\n    let mut vowel_found35 = false;\n    let mut vowel_found36 = false;\n\
    \    let mut vowel_found37 = false;\n    let mut vowel_found38 = false;\n    let\
    \ mut vowel_found39 = false;\n    let mut vowel_found40 = false;\n    let mut\
    \ vowel_found41 = false;\n    let mut vowel_found42 = false;\n    let mut vowel_found43\
    \ = false;\n    let mut vowel_found44 = false;\n    let mut vowel_found45 = false;\n\
    \    let mut vowel_found46 = false;\n    let mut vowel_found47 = false;\n    let\
    \ mut vowel_found48 = false;\n    let mut vowel_found49 = false;\n    let mut\
    \ vowel_found50 = false;\n    let mut vowel_found51 = false;\n    let mut vowel_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwa4c2i09.rs:62:19\n   |\n\
    62 |     let mut vowel_\n   |                   ^ help: add `;` here\n63 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwa4c2i09.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index2 = vec![0];\n    let mut vowels_count_index3 =\
    \ vec![0];\n    let mut vowels_count_index4 = vec![0];\n    let mut vowels_count_index5\
    \ = vec![0];\n    let mut vowels_count_index6 = vec![0];\n    let mut vowels_count_index7\
    \ = vec![0];\n    let mut vowels_count_index8 = vec![0];\n    let mut vowels_count_index9\
    \ = vec![0];\n    let mut vowels_count_index10 = vec![0];\n    let mut vowels_count_index11\
    \ = vec![0];\n    let mut vowels_count_index12 = vec![0];\n    let mut vowels_count_index13\
    \ = vec![0];\n    let mut vowels_count_index14 = vec![0];\n    let mut vowels_count_index15\
    \ = vec![0];\n    let mut vowels_count_index16 = vec![0];\n    let mut vowels_count_index17\
    \ = vec![0];\n    let mut vowels_count_index18 = vec![0];\n    let mut vowels_count_index19\
    \ = vec![0];\n    let mut vowels_count_index20 = vec![0];\n    let mut vowels_count_index21\
    \ = vec![0];\n    let mut vowels_count_index22 = vec![0];\n    let mut vowels_count_index23\
    \ = vec![0];\n    let mut vowels_count_index24 = vec![0];\n    let mut vowels_count_index25\
    \ = vec![0];\n    let mut vowels_count_index26 = vec![0];\n    let mut vowels_count_index27\
    \ = vec![0];\n    let mut vowels_count_index28 = vec![0];\n    let mut vowels_count_index29\
    \ = vec![0];\n    let mut vowels_count_index30 = vec![0];\n    let mut vowels_count_index31\
    \ = vec![0];\n    let mut vowels_count_index32 = vec![0];\n    let mut vowels_count_index33\
    \ = vec![0];\n    let mut vowels_count_index34 = vec![0];\n    let mut vowels_count_index35\
    \ = vec![0];\n    let mut vowels_count_index36 = vec![0];\n    let mut vowels_count_index37\
    \ = vec![0];\n    let mut vowels_count_index38 = vec![0];\n    let mut \n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpbm22x8e7.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index_max = vec![0];\n    let mut vowels_count_index_min\
    \ = vec![0];\n    let mut vowels_count_index_min_max = vec![0];\n    let mut vowels_count_index_min_max_index\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max = vec![0];\n  \
    \  let mut vowels_count_index_min_max_index_max_min = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max =\
    \ vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_min_index\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index_max_min_index_max\
    \ = vec![0];\n    let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcrjhwfrg.rs:31:92\n   |\n\
    31 |     let mut vowels_count_index_min_max_index_max_min_index_max_min_index_max_min_index_max_\n\
    \   |                                                                        \
    \                    ^ help: add `;` here\n32 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpcrjhwfrg.rs:7:39\n  |\n7 | fn get_closest_vowel(word:\
    \ String) -> String {\n  |    -----------------                  ^^^^^^ expected\
    \ struct `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_index = vec![0];\n    let mut vowels_count = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let mut vowels_count_index = vec![0];\n\
    \    let mut vowels_count_index = vec![0];\n    let \n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpm3o866ds.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_count = vowels.len();\n    let mut vowel_found\
    \ = false;\n    let mut vowel_found2 = false;\n    let mut vowel_found3 = false;\n\
    \    let mut vowel_found4 = false;\n    let mut vowel_found5 = false;\n    let\
    \ mut vowel_found6 = false;\n    let mut vowel_found7 = false;\n    let mut vowel_found8\
    \ = false;\n    let mut vowel_found9 = false;\n    let mut vowel_found10 = false;\n\
    \    let mut vowel_found11 = false;\n    let mut vowel_found12 = false;\n    let\
    \ mut vowel_found13 = false;\n    let mut vowel_found14 = false;\n    let mut\
    \ vowel_found15 = false;\n    let mut vowel_found16 = false;\n    let mut vowel_found17\
    \ = false;\n    let mut vowel_found18 = false;\n    let mut vowel_found19 = false;\n\
    \    let mut vowel_found20 = false;\n    let mut vowel_found21 = false;\n    let\
    \ mut vowel_found22 = false;\n    let mut vowel_found23 = false;\n    let mut\
    \ vowel_found24 = false;\n    let mut vowel_found25 = false;\n    let mut vowel_found26\
    \ = false;\n    let mut vowel_found27 = false;\n    let mut vowel_found28 = false;\n\
    \    let mut vowel_found29 = false;\n    let mut vowel_found30 = false;\n    let\
    \ mut vowel_found31 = false;\n    let mut vowel_found32 = false;\n    let mut\
    \ vowel_found33 = false;\n    let mut vowel_found34 = false;\n    let mut vowel_found35\
    \ = false;\n    let mut vowel_found36 = false;\n    let mut vowel_found37 = false;\n\
    \    let mut vowel_found38 = false;\n    let mut vowel_found39 = false;\n    let\
    \ mut vowel_found40 = false;\n    let mut vowel_found41 = false;\n    let mut\
    \ vowel_found42 = false;\n    let mut vowel_found43 = false;\n    let mut vowel_found44\
    \ = false;\n    let mut vowel_found45 = false;\n    let mut vowel_found46 = false;\n\
    \    let mut vowel_found47 = false;\n    let mut vowel_found48 = false;\n    let\
    \ mut vowel_found49 = false;\n    let mut vowel_found50 = false;\n    let mut\
    \ vowel_found51 = false;\n    let mut vowel_found52 = false;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmposkpiahk.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmposkpiahk.rs:7:39\n  |\n\
    7 | fn get_closest_vowel(word: String) -> String {\n  |    ----------------- \
    \                 ^^^^^^ expected struct `String`, found `()`\n  |    |\n  | \
    \   implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowel_pos = word.rfind('a').unwrap();\n    let mut vowel_end\
    \ = word.rfind('e').unwrap();\n    let mut vowel_start = word.rfind('i').unwrap();\n\
    \    let mut vowel_mid = word.rfind('o').unwrap();\n    let mut vowel_mid2 = word.rfind('u').unwrap();\n\
    \    let mut vowel_mid3 = word.rfind('A').unwrap();\n    let mut vowel_mid4 =\
    \ word.rfind('E').unwrap();\n    let mut vowel_mid5 = word.rfind('I').unwrap();\n\
    \    let mut vowel_mid6 = word.rfind('O').unwrap();\n    let mut vowel_mid7 =\
    \ word.rfind('U').unwrap();\n    let mut vowel_mid8 = word.rfind('a').unwrap();\n\
    \    let mut vowel_mid9 = word.rfind('e').unwrap();\n    let mut vowel_mid10 =\
    \ word.rfind('i').unwrap();\n    let mut vowel_mid11 = word.rfind('o').unwrap();\n\
    \    let mut vowel_mid12 = word.rfind('u').unwrap();\n    let mut vowel_mid13\
    \ = word.rfind('A').unwrap();\n    let mut vowel_mid14 = word.rfind('E').unwrap();\n\
    \    let mut vowel_mid15 = word.rfind('I').unwrap();\n    let mut vowel_mid16\
    \ = word.rfind('O').unwrap();\n    let mut vowel_mid17 = word.rfind('U').unwrap();\n\
    \    let mut vowel_mid18 = word.rfind('a').unwrap();\n    let mut vowel_mid19\
    \ = word.rfind('e').unwrap();\n    let mut vowel_mid20 = word.rfind('i').unwrap();\n\
    \    let mut vowel_mid21 = word.rfind('o').unwrap();\n    let mut vowel_mid22\
    \ = word.rfind('u').unwrap();\n    let mut vowel_mid23 = word.rfind('A').unwrap();\n\
    \    let mut vowel_mid24 = word.rfind('E').unwrap();\n    let mut vowel_mid25\
    \ = word.rfind('I').unwrap();\n    let mut vowel_mid26 = word.rfind('O').unwrap();\n\
    \    let mut vowel_mid27 = word.rfind('U').unwrap();\n    let mut vowel_mid28\
    \ = word.rfind('a').unwrap();\n    let mut vowel_mid29 = word.rfind('e\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp6okdwctr.rs:40:37\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n40 |     let mut vowel_mid29 = word.rfind('e\n   |                      \
    \               ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected `while`, `for`, `loop` or `{` after a label\n  --> /tmp/tmp6okdwctr.rs:41:1\n\
    \   |\n41 | }\n   | ^ expected `while`, `for`, `loop` or `{` after a label\n\n\
    error: expected expression, found `)`\n  --> /tmp/tmp6okdwctr.rs:41:1\n   |\n\
    41 | }\n   | ^ expected expression\n\nerror: aborting due to 3 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<&str> = vec![\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut vowels_index: Vec<usize> = vec![0];\n    let mut\
    \ vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize> =\
    \ vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index:\
    \ Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n   \
    \ let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize>\
    \ = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index:\
    \ Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n   \
    \ let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize>\
    \ = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index:\
    \ Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n   \
    \ let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize>\
    \ = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index:\
    \ Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n   \
    \ let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize>\
    \ = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index:\
    \ Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n   \
    \ let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index: Vec<usize>\
    \ = vec![0];\n    let mut vowels_index: Vec<usize> = vec![0];\n    let mut vowels_index:\
    \ Vec<usize> = vec![0];\n    let mut vowels_index: Vec<\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `>`, a const expression, lifetime, or type, found\
    \ `}`\n  --> /tmp/tmp44buth2b.rs:40:1\n   |\n39 |     let mut vowels_index: Vec<\n\
    \   |         ----------------      - expected one of `>`, a const expression,\
    \ lifetime, or type\n   |         |\n   |         while parsing the type for `mut\
    \ vowels_index`\n40 | }\n   | ^ unexpected token\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_set = HashSet::new();\n    for vowel in vowels {\n \
    \       vowels_set.insert(vowel);\n    }\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new();\n\
    \    let mut vowels_set = HashSet::new();\n    let mut vowels_set = HashSet::new\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5g7z1g7k.rs:51:38\n   |\n\
    51 |     let mut vowels_set = HashSet::new\n   |                             \
    \         ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp5g7z1g7k.rs:51:26\n\
    \   |\n51 |     let mut vowels_set = HashSet::new\n   |                      \
    \    ^^^^^^^ use of undeclared type `HashSet`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp5g7z1g7k.rs:9:26\n  |\n9 |  \
    \   let mut vowels_set = HashSet::new();\n  |                          ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmp5g7z1g7k.rs:13:26\n   |\n13 |  \
    \   let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp5g7z1g7k.rs:14:26\n   |\n14\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp5g7z1g7k.rs:15:26\n   |\n15\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp5g7z1g7k.rs:16:26\n   |\n16\
    \ |     let mut vowels_set = HashSet::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp5g7z1g7k.rs:17:26\n   |\n17\
    \ |     let mut vowels_set = "
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index2 = vec![0];\n    let mut vowels_index3 = vec![0];\n\
    \    let mut vowels_index4 = vec![0];\n    let mut vowels_index5 = vec![0];\n\
    \    let mut vowels_index6 = vec![0];\n    let mut vowels_index7 = vec![0];\n\
    \    let mut vowels_index8 = vec![0];\n    let mut vowels_index9 = vec![0];\n\
    \    let mut vowels_index10 = vec![0];\n    let mut vowels_index11 = vec![0];\n\
    \    let mut vowels_index12 = vec![0];\n    let mut vowels_index13 = vec![0];\n\
    \    let mut vowels_index14 = vec![0];\n    let mut vowels_index15 = vec![0];\n\
    \    let mut vowels_index16 = vec![0];\n    let mut vowels_index17 = vec![0];\n\
    \    let mut vowels_index18 = vec![0];\n    let mut vowels_index19 = vec![0];\n\
    \    let mut vowels_index20 = vec![0];\n    let mut vowels_index21 = vec![0];\n\
    \    let mut vowels_index22 = vec![0];\n    let mut vowels_index23 = vec![0];\n\
    \    let mut vowels_index24 = vec![0];\n    let mut vowels_index25 = vec![0];\n\
    \    let mut vowels_index26 = vec![0];\n    let mut vowels_index27 = vec![0];\n\
    \    let mut vowels_index28 = vec![0];\n    let mut vowels_index29 = vec![0];\n\
    \    let mut vowels_index30 = vec![0];\n    let mut vowels_index31 = vec![0];\n\
    \    let mut vowels_index32 = vec![0];\n    let mut vowels_index33 = vec![0];\n\
    \    let mut vowels_index34 = vec![0];\n    let mut vowels_index35 = vec![0];\n\
    \    let mut vowels_index36 = vec![0];\n    let mut vowels_index37 = vec![0];\n\
    \    let mut vowels_index38 = vec![0];\n    let mut vowels_index39 = vec![0];\n\
    \    let mut vowels_index40 = vec![0];\n    let mut vowels_index41 = vec![0];\n\
    \    let mut vowels_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps80nlfnp.rs:51:20\n   |\n\
    51 |     let mut vowels_\n   |                    ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmps80nlfnp.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index\
    \ = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index =\
    \ vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n  \
    \  let mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let\
    \ mut vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut\
    \ vowels_index = vec![0];\n    let mut vowels_index = vec![0];\n    let mut vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxcttppqg.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxcttppqg.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_count = vec![0];\n    let mut vowels_index = vec![0];\n\
    \    let mut vowels_index2 = vec![0];\n    let mut vowels_index3 = vec![0];\n\
    \    let mut vowels_index4 = vec![0];\n    let mut vowels_index5 = vec![0];\n\
    \    let mut vowels_index6 = vec![0];\n    let mut vowels_index7 = vec![0];\n\
    \    let mut vowels_index8 = vec![0];\n    let mut vowels_index9 = vec![0];\n\
    \    let mut vowels_index10 = vec![0];\n    let mut vowels_index11 = vec![0];\n\
    \    let mut vowels_index12 = vec![0];\n    let mut vowels_index13 = vec![0];\n\
    \    let mut vowels_index14 = vec![0];\n    let mut vowels_index15 = vec![0];\n\
    \    let mut vowels_index16 = vec![0];\n    let mut vowels_index17 = vec![0];\n\
    \    let mut vowels_index18 = vec![0];\n    let mut vowels_index19 = vec![0];\n\
    \    let mut vowels_index20 = vec![0];\n    let mut vowels_index21 = vec![0];\n\
    \    let mut vowels_index22 = vec![0];\n    let mut vowels_index23 = vec![0];\n\
    \    let mut vowels_index24 = vec![0];\n    let mut vowels_index25 = vec![0];\n\
    \    let mut vowels_index26 = vec![0];\n    let mut vowels_index27 = vec![0];\n\
    \    let mut vowels_index28 = vec![0];\n    let mut vowels_index29 = vec![0];\n\
    \    let mut vowels_index30 = vec![0];\n    let mut vowels_index31 = vec![0];\n\
    \    let mut vowels_index32 = vec![0];\n    let mut vowels_index33 = vec![0];\n\
    \    let mut vowels_index34 = vec![0];\n    let mut vowels_index35 = vec![0];\n\
    \    let mut vowels_index36 = vec![0];\n    let mut vowels_index37 = vec![0];\n\
    \    let mut vowels_index38 = vec![0];\n    let mut vowels_index39 = vec![0];\n\
    \    let mut vowels_index40 = vec![0];\n    let mut vowels_index41 = vec![0];\n\
    \    let mut vowels_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps80nlfnp.rs:51:20\n   |\n\
    51 |     let mut vowels_\n   |                    ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmps80nlfnp.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660053250
